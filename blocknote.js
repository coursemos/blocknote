/*! For license information please see main.30308063.js.LICENSE.txt */
function blocknote() {
    "use strict";
    var e = {
        2730: (e, t, n) => {
            var r = n(5043)
                , o = n(8853);
            function i(e) {
                for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
                    t += "&args[]=" + encodeURIComponent(arguments[n]);
                return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            var s = new Set
                , a = {};
            function l(e, t) {
                c(e, t),
                    c(e + "Capture", t)
            }
            function c(e, t) {
                for (a[e] = t,
                    e = 0; e < t.length; e++)
                    s.add(t[e])
            }
            var d = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement)
                , u = Object.prototype.hasOwnProperty
                , h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
                , p = {}
                , f = {};
            function m(e, t, n, r, o, i, s) {
                this.acceptsBooleans = 2 === t || 3 === t || 4 === t,
                    this.attributeName = r,
                    this.attributeNamespace = o,
                    this.mustUseProperty = n,
                    this.propertyName = e,
                    this.type = t,
                    this.sanitizeURL = i,
                    this.removeEmptyString = s
            }
            var g = {};
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) {
                g[e] = new m(e, 0, !1, e, null, !1, !1)
            }
            )),
                [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) {
                    var t = e[0];
                    g[t] = new m(t, 1, !1, e[1], null, !1, !1)
                }
                )),
                ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) {
                    g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1)
                }
                )),
                ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) {
                    g[e] = new m(e, 2, !1, e, null, !1, !1)
                }
                )),
                "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) {
                    g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1)
                }
                )),
                ["checked", "multiple", "muted", "selected"].forEach((function (e) {
                    g[e] = new m(e, 3, !0, e, null, !1, !1)
                }
                )),
                ["capture", "download"].forEach((function (e) {
                    g[e] = new m(e, 4, !1, e, null, !1, !1)
                }
                )),
                ["cols", "rows", "size", "span"].forEach((function (e) {
                    g[e] = new m(e, 6, !1, e, null, !1, !1)
                }
                )),
                ["rowSpan", "start"].forEach((function (e) {
                    g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1)
                }
                ));
            var b = /[\-:]([a-z])/g;
            function y(e) {
                return e[1].toUpperCase()
            }
            function v(e, t, n, r) {
                var o = g.hasOwnProperty(t) ? g[t] : null;
                (null !== o ? 0 !== o.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) {
                    if (null === t || "undefined" === typeof t || function (e, t, n, r) {
                        if (null !== n && 0 === n.type)
                            return !1;
                        switch (typeof t) {
                            case "function":
                            case "symbol":
                                return !0;
                            case "boolean":
                                return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                            default:
                                return !1
                        }
                    }(e, t, n, r))
                        return !0;
                    if (r)
                        return !1;
                    if (null !== n)
                        switch (n.type) {
                            case 3:
                                return !t;
                            case 4:
                                return !1 === t;
                            case 5:
                                return isNaN(t);
                            case 6:
                                return isNaN(t) || 1 > t
                        }
                    return !1
                }(t, n, o, r) && (n = null),
                    r || null === o ? function (e) {
                        return !!u.call(f, e) || !u.call(p, e) && (h.test(e) ? f[e] = !0 : (p[e] = !0,
                            !1))
                    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : o.mustUseProperty ? e[o.propertyName] = null === n ? 3 !== o.type && "" : n : (t = o.attributeName,
                        r = o.attributeNamespace,
                        null === n ? e.removeAttribute(t) : (n = 3 === (o = o.type) || 4 === o && !0 === n ? "" : "" + n,
                            r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
            }
            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) {
                var t = e.replace(b, y);
                g[t] = new m(t, 1, !1, e, null, !1, !1)
            }
            )),
                "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) {
                    var t = e.replace(b, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
                }
                )),
                ["xml:base", "xml:lang", "xml:space"].forEach((function (e) {
                    var t = e.replace(b, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
                }
                )),
                ["tabIndex", "crossOrigin"].forEach((function (e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1)
                }
                )),
                g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1),
                ["src", "href", "action", "formAction"].forEach((function (e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0)
                }
                ));
            var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
                , k = Symbol.for("react.element")
                , C = Symbol.for("react.portal")
                , S = Symbol.for("react.fragment")
                , x = Symbol.for("react.strict_mode")
                , E = Symbol.for("react.profiler")
                , M = Symbol.for("react.provider")
                , T = Symbol.for("react.context")
                , N = Symbol.for("react.forward_ref")
                , _ = Symbol.for("react.suspense")
                , O = Symbol.for("react.suspense_list")
                , A = Symbol.for("react.memo")
                , P = Symbol.for("react.lazy");
            Symbol.for("react.scope"),
                Symbol.for("react.debug_trace_mode");
            var L = Symbol.for("react.offscreen");
            Symbol.for("react.legacy_hidden"),
                Symbol.for("react.cache"),
                Symbol.for("react.tracing_marker");
            var R = Symbol.iterator;
            function D(e) {
                return null === e || "object" !== typeof e ? null : "function" === typeof (e = R && e[R] || e["@@iterator"]) ? e : null
            }
            var I, j = Object.assign;
            function H(e) {
                if (void 0 === I)
                    try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        I = t && t[1] || ""
                    }
                return "\n" + I + e
            }
            var z = !1;
            function $(e, t) {
                if (!e || z)
                    return "";
                z = !0;
                var n = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    if (t)
                        if (t = function () {
                            throw Error()
                        }
                            ,
                            Object.defineProperty(t.prototype, "props", {
                                set: function () {
                                    throw Error()
                                }
                            }),
                            "object" === typeof Reflect && Reflect.construct) {
                            try {
                                Reflect.construct(t, [])
                            } catch (c) {
                                var r = c
                            }
                            Reflect.construct(e, [], t)
                        } else {
                            try {
                                t.call()
                            } catch (c) {
                                r = c
                            }
                            e.call(t.prototype)
                        }
                    else {
                        try {
                            throw Error()
                        } catch (c) {
                            r = c
                        }
                        e()
                    }
                } catch (c) {
                    if (c && r && "string" === typeof c.stack) {
                        for (var o = c.stack.split("\n"), i = r.stack.split("\n"), s = o.length - 1, a = i.length - 1; 1 <= s && 0 <= a && o[s] !== i[a];)
                            a--;
                        for (; 1 <= s && 0 <= a; s--,
                            a--)
                            if (o[s] !== i[a]) {
                                if (1 !== s || 1 !== a)
                                    do {
                                        if (s--,
                                            0 > --a || o[s] !== i[a]) {
                                            var l = "\n" + o[s].replace(" at new ", " at ");
                                            return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                                l
                                        }
                                    } while (1 <= s && 0 <= a);
                                break
                            }
                    }
                } finally {
                    z = !1,
                        Error.prepareStackTrace = n
                }
                return (e = e ? e.displayName || e.name : "") ? H(e) : ""
            }
            function B(e) {
                switch (e.tag) {
                    case 5:
                        return H(e.type);
                    case 16:
                        return H("Lazy");
                    case 13:
                        return H("Suspense");
                    case 19:
                        return H("SuspenseList");
                    case 0:
                    case 2:
                    case 15:
                        return e = $(e.type, !1);
                    case 11:
                        return e = $(e.type.render, !1);
                    case 1:
                        return e = $(e.type, !0);
                    default:
                        return ""
                }
            }
            function V(e) {
                if (null == e)
                    return null;
                if ("function" === typeof e)
                    return e.displayName || e.name || null;
                if ("string" === typeof e)
                    return e;
                switch (e) {
                    case S:
                        return "Fragment";
                    case C:
                        return "Portal";
                    case E:
                        return "Profiler";
                    case x:
                        return "StrictMode";
                    case _:
                        return "Suspense";
                    case O:
                        return "SuspenseList"
                }
                if ("object" === typeof e)
                    switch (e.$$typeof) {
                        case T:
                            return (e.displayName || "Context") + ".Consumer";
                        case M:
                            return (e._context.displayName || "Context") + ".Provider";
                        case N:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"),
                                e;
                        case A:
                            return null !== (t = e.displayName || null) ? t : V(e.type) || "Memo";
                        case P:
                            t = e._payload,
                                e = e._init;
                            try {
                                return V(e(t))
                            } catch (n) { }
                    }
                return null
            }
            function F(e) {
                var t = e.type;
                switch (e.tag) {
                    case 24:
                        return "Cache";
                    case 9:
                        return (t.displayName || "Context") + ".Consumer";
                    case 10:
                        return (t._context.displayName || "Context") + ".Provider";
                    case 18:
                        return "DehydratedFragment";
                    case 11:
                        return e = (e = t.render).displayName || e.name || "",
                            t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                    case 7:
                        return "Fragment";
                    case 5:
                        return t;
                    case 4:
                        return "Portal";
                    case 3:
                        return "Root";
                    case 6:
                        return "Text";
                    case 16:
                        return V(t);
                    case 8:
                        return t === x ? "StrictMode" : "Mode";
                    case 22:
                        return "Offscreen";
                    case 12:
                        return "Profiler";
                    case 21:
                        return "Scope";
                    case 13:
                        return "Suspense";
                    case 19:
                        return "SuspenseList";
                    case 25:
                        return "TracingMarker";
                    case 1:
                    case 0:
                    case 17:
                    case 2:
                    case 14:
                    case 15:
                        if ("function" === typeof t)
                            return t.displayName || t.name || null;
                        if ("string" === typeof t)
                            return t
                }
                return null
            }
            function U(e) {
                switch (typeof e) {
                    case "boolean":
                    case "number":
                    case "string":
                    case "undefined":
                    case "object":
                        return e;
                    default:
                        return ""
                }
            }
            function W(e) {
                var t = e.type;
                return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
            }
            function q(e) {
                e._valueTracker || (e._valueTracker = function (e) {
                    var t = W(e) ? "checked" : "value"
                        , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
                        , r = "" + e[t];
                    if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                        var o = n.get
                            , i = n.set;
                        return Object.defineProperty(e, t, {
                            configurable: !0,
                            get: function () {
                                return o.call(this)
                            },
                            set: function (e) {
                                r = "" + e,
                                    i.call(this, e)
                            }
                        }),
                            Object.defineProperty(e, t, {
                                enumerable: n.enumerable
                            }),
                        {
                            getValue: function () {
                                return r
                            },
                            setValue: function (e) {
                                r = "" + e
                            },
                            stopTracking: function () {
                                e._valueTracker = null,
                                    delete e[t]
                            }
                        }
                    }
                }(e))
            }
            function G(e) {
                if (!e)
                    return !1;
                var t = e._valueTracker;
                if (!t)
                    return !0;
                var n = t.getValue()
                    , r = "";
                return e && (r = W(e) ? e.checked ? "true" : "false" : e.value),
                    (e = r) !== n && (t.setValue(e),
                        !0)
            }
            function K(e) {
                if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0)))
                    return null;
                try {
                    return e.activeElement || e.body
                } catch (kk) {
                    return e.body
                }
            }
            function J(e, t) {
                var n = t.checked;
                return j({}, t, {
                    defaultChecked: void 0,
                    defaultValue: void 0,
                    value: void 0,
                    checked: null != n ? n : e._wrapperState.initialChecked
                })
            }
            function Z(e, t) {
                var n = null == t.defaultValue ? "" : t.defaultValue
                    , r = null != t.checked ? t.checked : t.defaultChecked;
                n = U(null != t.value ? t.value : n),
                    e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
            }
            function X(e, t) {
                null != (t = t.checked) && v(e, "checked", t, !1)
            }
            function Q(e, t) {
                X(e, t);
                var n = U(t.value)
                    , r = t.type;
                if (null != n)
                    "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                else if ("submit" === r || "reset" === r)
                    return void e.removeAttribute("value");
                t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, U(t.defaultValue)),
                    null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
            }
            function Y(e, t, n) {
                if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                    var r = t.type;
                    if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value))
                        return;
                    t = "" + e._wrapperState.initialValue,
                        n || t === e.value || (e.value = t),
                        e.defaultValue = t
                }
                "" !== (n = e.name) && (e.name = ""),
                    e.defaultChecked = !!e._wrapperState.initialChecked,
                    "" !== n && (e.name = n)
            }
            function ee(e, t, n) {
                "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
            }
            var te = Array.isArray;
            function ne(e, t, n, r) {
                if (e = e.options,
                    t) {
                    t = {};
                    for (var o = 0; o < n.length; o++)
                        t["$" + n[o]] = !0;
                    for (n = 0; n < e.length; n++)
                        o = t.hasOwnProperty("$" + e[n].value),
                            e[n].selected !== o && (e[n].selected = o),
                            o && r && (e[n].defaultSelected = !0)
                } else {
                    for (n = "" + U(n),
                        t = null,
                        o = 0; o < e.length; o++) {
                        if (e[o].value === n)
                            return e[o].selected = !0,
                                void (r && (e[o].defaultSelected = !0));
                        null !== t || e[o].disabled || (t = e[o])
                    }
                    null !== t && (t.selected = !0)
                }
            }
            function re(e, t) {
                if (null != t.dangerouslySetInnerHTML)
                    throw Error(i(91));
                return j({}, t, {
                    value: void 0,
                    defaultValue: void 0,
                    children: "" + e._wrapperState.initialValue
                })
            }
            function oe(e, t) {
                var n = t.value;
                if (null == n) {
                    if (n = t.children,
                        t = t.defaultValue,
                        null != n) {
                        if (null != t)
                            throw Error(i(92));
                        if (te(n)) {
                            if (1 < n.length)
                                throw Error(i(93));
                            n = n[0]
                        }
                        t = n
                    }
                    null == t && (t = ""),
                        n = t
                }
                e._wrapperState = {
                    initialValue: U(n)
                }
            }
            function ie(e, t) {
                var n = U(t.value)
                    , r = U(t.defaultValue);
                null != n && ((n = "" + n) !== e.value && (e.value = n),
                    null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)),
                    null != r && (e.defaultValue = "" + r)
            }
            function se(e) {
                var t = e.textContent;
                t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
            }
            function ae(e) {
                switch (e) {
                    case "svg":
                        return "http://www.w3.org/2000/svg";
                    case "math":
                        return "http://www.w3.org/1998/Math/MathML";
                    default:
                        return "http://www.w3.org/1999/xhtml"
                }
            }
            function le(e, t) {
                return null == e || "http://www.w3.org/1999/xhtml" === e ? ae(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
            }
            var ce, de, ue = (de = function (e, t) {
                if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e)
                    e.innerHTML = t;
                else {
                    for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
                        t = ce.firstChild; e.firstChild;)
                        e.removeChild(e.firstChild);
                    for (; t.firstChild;)
                        e.appendChild(t.firstChild)
                }
            }
                ,
                "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) {
                    MSApp.execUnsafeLocalFunction((function () {
                        return de(e, t)
                    }
                    ))
                }
                    : de);
            function he(e, t) {
                if (t) {
                    var n = e.firstChild;
                    if (n && n === e.lastChild && 3 === n.nodeType)
                        return void (n.nodeValue = t)
                }
                e.textContent = t
            }
            var pe = {
                animationIterationCount: !0,
                aspectRatio: !0,
                borderImageOutset: !0,
                borderImageSlice: !0,
                borderImageWidth: !0,
                boxFlex: !0,
                boxFlexGroup: !0,
                boxOrdinalGroup: !0,
                columnCount: !0,
                columns: !0,
                flex: !0,
                flexGrow: !0,
                flexPositive: !0,
                flexShrink: !0,
                flexNegative: !0,
                flexOrder: !0,
                gridArea: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowSpan: !0,
                gridRowStart: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnSpan: !0,
                gridColumnStart: !0,
                fontWeight: !0,
                lineClamp: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                tabSize: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0,
                fillOpacity: !0,
                floodOpacity: !0,
                stopOpacity: !0,
                strokeDasharray: !0,
                strokeDashoffset: !0,
                strokeMiterlimit: !0,
                strokeOpacity: !0,
                strokeWidth: !0
            }
                , fe = ["Webkit", "ms", "Moz", "O"];
            function me(e, t, n) {
                return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || pe.hasOwnProperty(e) && pe[e] ? ("" + t).trim() : t + "px"
            }
            function ge(e, t) {
                for (var n in e = e.style,
                    t)
                    if (t.hasOwnProperty(n)) {
                        var r = 0 === n.indexOf("--")
                            , o = me(n, t[n], r);
                        "float" === n && (n = "cssFloat"),
                            r ? e.setProperty(n, o) : e[n] = o
                    }
            }
            Object.keys(pe).forEach((function (e) {
                fe.forEach((function (t) {
                    t = t + e.charAt(0).toUpperCase() + e.substring(1),
                        pe[t] = pe[e]
                }
                ))
            }
            ));
            var be = j({
                menuitem: !0
            }, {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                embed: !0,
                hr: !0,
                img: !0,
                input: !0,
                keygen: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0
            });
            function ye(e, t) {
                if (t) {
                    if (be[e] && (null != t.children || null != t.dangerouslySetInnerHTML))
                        throw Error(i(137, e));
                    if (null != t.dangerouslySetInnerHTML) {
                        if (null != t.children)
                            throw Error(i(60));
                        if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML))
                            throw Error(i(61))
                    }
                    if (null != t.style && "object" !== typeof t.style)
                        throw Error(i(62))
                }
            }
            function ve(e, t) {
                if (-1 === e.indexOf("-"))
                    return "string" === typeof t.is;
                switch (e) {
                    case "annotation-xml":
                    case "color-profile":
                    case "font-face":
                    case "font-face-src":
                    case "font-face-uri":
                    case "font-face-format":
                    case "font-face-name":
                    case "missing-glyph":
                        return !1;
                    default:
                        return !0
                }
            }
            var we = null;
            function ke(e) {
                return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement),
                    3 === e.nodeType ? e.parentNode : e
            }
            var Ce = null
                , Se = null
                , xe = null;
            function Ee(e) {
                if (e = wo(e)) {
                    if ("function" !== typeof Ce)
                        throw Error(i(280));
                    var t = e.stateNode;
                    t && (t = Co(t),
                        Ce(e.stateNode, e.type, t))
                }
            }
            function Me(e) {
                Se ? xe ? xe.push(e) : xe = [e] : Se = e
            }
            function Te() {
                if (Se) {
                    var e = Se
                        , t = xe;
                    if (xe = Se = null,
                        Ee(e),
                        t)
                        for (e = 0; e < t.length; e++)
                            Ee(t[e])
                }
            }
            function Ne(e, t) {
                return e(t)
            }
            function _e() { }
            var Oe = !1;
            function Ae(e, t, n) {
                if (Oe)
                    return e(t, n);
                Oe = !0;
                try {
                    return Ne(e, t, n)
                } finally {
                    Oe = !1,
                        (null !== Se || null !== xe) && (_e(),
                            Te())
                }
            }
            function Pe(e, t) {
                var n = e.stateNode;
                if (null === n)
                    return null;
                var r = Co(n);
                if (null === r)
                    return null;
                n = r[t];
                e: switch (t) {
                    case "onClick":
                    case "onClickCapture":
                    case "onDoubleClick":
                    case "onDoubleClickCapture":
                    case "onMouseDown":
                    case "onMouseDownCapture":
                    case "onMouseMove":
                    case "onMouseMoveCapture":
                    case "onMouseUp":
                    case "onMouseUpCapture":
                    case "onMouseEnter":
                        (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)),
                            e = !r;
                        break e;
                    default:
                        e = !1
                }
                if (e)
                    return null;
                if (n && "function" !== typeof n)
                    throw Error(i(231, t, typeof n));
                return n
            }
            var Le = !1;
            if (d)
                try {
                    var Re = {};
                    Object.defineProperty(Re, "passive", {
                        get: function () {
                            Le = !0
                        }
                    }),
                        window.addEventListener("test", Re, Re),
                        window.removeEventListener("test", Re, Re)
                } catch (de) {
                    Le = !1
                }
            function De(e, t, n, r, o, i, s, a, l) {
                var c = Array.prototype.slice.call(arguments, 3);
                try {
                    t.apply(n, c)
                } catch (d) {
                    this.onError(d)
                }
            }
            var Ie = !1
                , je = null
                , He = !1
                , ze = null
                , $e = {
                    onError: function (e) {
                        Ie = !0,
                            je = e
                    }
                };
            function Be(e, t, n, r, o, i, s, a, l) {
                Ie = !1,
                    je = null,
                    De.apply($e, arguments)
            }
            function Ve(e) {
                var t = e
                    , n = e;
                if (e.alternate)
                    for (; t.return;)
                        t = t.return;
                else {
                    e = t;
                    do {
                        0 !== (4098 & (t = e).flags) && (n = t.return),
                            e = t.return
                    } while (e)
                }
                return 3 === t.tag ? n : null
            }
            function Fe(e) {
                if (13 === e.tag) {
                    var t = e.memoizedState;
                    if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)),
                        null !== t)
                        return t.dehydrated
                }
                return null
            }
            function Ue(e) {
                if (Ve(e) !== e)
                    throw Error(i(188))
            }
            function We(e) {
                return e = function (e) {
                    var t = e.alternate;
                    if (!t) {
                        if (null === (t = Ve(e)))
                            throw Error(i(188));
                        return t !== e ? null : e
                    }
                    for (var n = e, r = t; ;) {
                        var o = n.return;
                        if (null === o)
                            break;
                        var s = o.alternate;
                        if (null === s) {
                            if (null !== (r = o.return)) {
                                n = r;
                                continue
                            }
                            break
                        }
                        if (o.child === s.child) {
                            for (s = o.child; s;) {
                                if (s === n)
                                    return Ue(o),
                                        e;
                                if (s === r)
                                    return Ue(o),
                                        t;
                                s = s.sibling
                            }
                            throw Error(i(188))
                        }
                        if (n.return !== r.return)
                            n = o,
                                r = s;
                        else {
                            for (var a = !1, l = o.child; l;) {
                                if (l === n) {
                                    a = !0,
                                        n = o,
                                        r = s;
                                    break
                                }
                                if (l === r) {
                                    a = !0,
                                        r = o,
                                        n = s;
                                    break
                                }
                                l = l.sibling
                            }
                            if (!a) {
                                for (l = s.child; l;) {
                                    if (l === n) {
                                        a = !0,
                                            n = s,
                                            r = o;
                                        break
                                    }
                                    if (l === r) {
                                        a = !0,
                                            r = s,
                                            n = o;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!a)
                                    throw Error(i(189))
                            }
                        }
                        if (n.alternate !== r)
                            throw Error(i(190))
                    }
                    if (3 !== n.tag)
                        throw Error(i(188));
                    return n.stateNode.current === n ? e : t
                }(e),
                    null !== e ? qe(e) : null
            }
            function qe(e) {
                if (5 === e.tag || 6 === e.tag)
                    return e;
                for (e = e.child; null !== e;) {
                    var t = qe(e);
                    if (null !== t)
                        return t;
                    e = e.sibling
                }
                return null
            }
            var Ge = o.unstable_scheduleCallback
                , Ke = o.unstable_cancelCallback
                , Je = o.unstable_shouldYield
                , Ze = o.unstable_requestPaint
                , Xe = o.unstable_now
                , Qe = o.unstable_getCurrentPriorityLevel
                , Ye = o.unstable_ImmediatePriority
                , et = o.unstable_UserBlockingPriority
                , tt = o.unstable_NormalPriority
                , nt = o.unstable_LowPriority
                , rt = o.unstable_IdlePriority
                , ot = null
                , it = null;
            var st = Math.clz32 ? Math.clz32 : function (e) {
                return e >>>= 0,
                    0 === e ? 32 : 31 - (at(e) / lt | 0) | 0
            }
                , at = Math.log
                , lt = Math.LN2;
            var ct = 64
                , dt = 4194304;
            function ut(e) {
                switch (e & -e) {
                    case 1:
                        return 1;
                    case 2:
                        return 2;
                    case 4:
                        return 4;
                    case 8:
                        return 8;
                    case 16:
                        return 16;
                    case 32:
                        return 32;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return 4194240 & e;
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        return 130023424 & e;
                    case 134217728:
                        return 134217728;
                    case 268435456:
                        return 268435456;
                    case 536870912:
                        return 536870912;
                    case 1073741824:
                        return 1073741824;
                    default:
                        return e
                }
            }
            function ht(e, t) {
                var n = e.pendingLanes;
                if (0 === n)
                    return 0;
                var r = 0
                    , o = e.suspendedLanes
                    , i = e.pingedLanes
                    , s = 268435455 & n;
                if (0 !== s) {
                    var a = s & ~o;
                    0 !== a ? r = ut(a) : 0 !== (i &= s) && (r = ut(i))
                } else
                    0 !== (s = n & ~o) ? r = ut(s) : 0 !== i && (r = ut(i));
                if (0 === r)
                    return 0;
                if (0 !== t && t !== r && 0 === (t & o) && ((o = r & -r) >= (i = t & -t) || 16 === o && 0 !== (4194240 & i)))
                    return t;
                if (0 !== (4 & r) && (r |= 16 & n),
                    0 !== (t = e.entangledLanes))
                    for (e = e.entanglements,
                        t &= r; 0 < t;)
                        o = 1 << (n = 31 - st(t)),
                            r |= e[n],
                            t &= ~o;
                return r
            }
            function pt(e, t) {
                switch (e) {
                    case 1:
                    case 2:
                    case 4:
                        return t + 250;
                    case 8:
                    case 16:
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return t + 5e3;
                    default:
                        return -1
                }
            }
            function ft(e) {
                return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
            }
            function mt() {
                var e = ct;
                return 0 === (4194240 & (ct <<= 1)) && (ct = 64),
                    e
            }
            function gt(e) {
                for (var t = [], n = 0; 31 > n; n++)
                    t.push(e);
                return t
            }
            function bt(e, t, n) {
                e.pendingLanes |= t,
                    536870912 !== t && (e.suspendedLanes = 0,
                        e.pingedLanes = 0),
                    (e = e.eventTimes)[t = 31 - st(t)] = n
            }
            function yt(e, t) {
                var n = e.entangledLanes |= t;
                for (e = e.entanglements; n;) {
                    var r = 31 - st(n)
                        , o = 1 << r;
                    o & t | e[r] & t && (e[r] |= t),
                        n &= ~o
                }
            }
            var vt = 0;
            function wt(e) {
                return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
            }
            var kt, Ct, St, xt, Et, Mt = !1, Tt = [], Nt = null, _t = null, Ot = null, At = new Map, Pt = new Map, Lt = [], Rt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
            function Dt(e, t) {
                switch (e) {
                    case "focusin":
                    case "focusout":
                        Nt = null;
                        break;
                    case "dragenter":
                    case "dragleave":
                        _t = null;
                        break;
                    case "mouseover":
                    case "mouseout":
                        Ot = null;
                        break;
                    case "pointerover":
                    case "pointerout":
                        At.delete(t.pointerId);
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                        Pt.delete(t.pointerId)
                }
            }
            function It(e, t, n, r, o, i) {
                return null === e || e.nativeEvent !== i ? (e = {
                    blockedOn: t,
                    domEventName: n,
                    eventSystemFlags: r,
                    nativeEvent: i,
                    targetContainers: [o]
                },
                    null !== t && (null !== (t = wo(t)) && Ct(t)),
                    e) : (e.eventSystemFlags |= r,
                        t = e.targetContainers,
                        null !== o && -1 === t.indexOf(o) && t.push(o),
                        e)
            }
            function jt(e) {
                var t = vo(e.target);
                if (null !== t) {
                    var n = Ve(t);
                    if (null !== n)
                        if (13 === (t = n.tag)) {
                            if (null !== (t = Fe(n)))
                                return e.blockedOn = t,
                                    void Et(e.priority, (function () {
                                        St(n)
                                    }
                                    ))
                        } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated)
                            return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                }
                e.blockedOn = null
            }
            function Ht(e) {
                if (null !== e.blockedOn)
                    return !1;
                for (var t = e.targetContainers; 0 < t.length;) {
                    var n = Jt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                    if (null !== n)
                        return null !== (t = wo(n)) && Ct(t),
                            e.blockedOn = n,
                            !1;
                    var r = new (n = e.nativeEvent).constructor(n.type, n);
                    we = r,
                        n.target.dispatchEvent(r),
                        we = null,
                        t.shift()
                }
                return !0
            }
            function zt(e, t, n) {
                Ht(e) && n.delete(t)
            }
            function $t() {
                Mt = !1,
                    null !== Nt && Ht(Nt) && (Nt = null),
                    null !== _t && Ht(_t) && (_t = null),
                    null !== Ot && Ht(Ot) && (Ot = null),
                    At.forEach(zt),
                    Pt.forEach(zt)
            }
            function Bt(e, t) {
                e.blockedOn === t && (e.blockedOn = null,
                    Mt || (Mt = !0,
                        o.unstable_scheduleCallback(o.unstable_NormalPriority, $t)))
            }
            function Vt(e) {
                function t(t) {
                    return Bt(t, e)
                }
                if (0 < Tt.length) {
                    Bt(Tt[0], e);
                    for (var n = 1; n < Tt.length; n++) {
                        var r = Tt[n];
                        r.blockedOn === e && (r.blockedOn = null)
                    }
                }
                for (null !== Nt && Bt(Nt, e),
                    null !== _t && Bt(_t, e),
                    null !== Ot && Bt(Ot, e),
                    At.forEach(t),
                    Pt.forEach(t),
                    n = 0; n < Lt.length; n++)
                    (r = Lt[n]).blockedOn === e && (r.blockedOn = null);
                for (; 0 < Lt.length && null === (n = Lt[0]).blockedOn;)
                    jt(n),
                        null === n.blockedOn && Lt.shift()
            }
            var Ft = w.ReactCurrentBatchConfig
                , Ut = !0;
            function Wt(e, t, n, r) {
                var o = vt
                    , i = Ft.transition;
                Ft.transition = null;
                try {
                    vt = 1,
                        Gt(e, t, n, r)
                } finally {
                    vt = o,
                        Ft.transition = i
                }
            }
            function qt(e, t, n, r) {
                var o = vt
                    , i = Ft.transition;
                Ft.transition = null;
                try {
                    vt = 4,
                        Gt(e, t, n, r)
                } finally {
                    vt = o,
                        Ft.transition = i
                }
            }
            function Gt(e, t, n, r) {
                if (Ut) {
                    var o = Jt(e, t, n, r);
                    if (null === o)
                        Ur(e, t, r, Kt, n),
                            Dt(e, r);
                    else if (function (e, t, n, r, o) {
                        switch (t) {
                            case "focusin":
                                return Nt = It(Nt, e, t, n, r, o),
                                    !0;
                            case "dragenter":
                                return _t = It(_t, e, t, n, r, o),
                                    !0;
                            case "mouseover":
                                return Ot = It(Ot, e, t, n, r, o),
                                    !0;
                            case "pointerover":
                                var i = o.pointerId;
                                return At.set(i, It(At.get(i) || null, e, t, n, r, o)),
                                    !0;
                            case "gotpointercapture":
                                return i = o.pointerId,
                                    Pt.set(i, It(Pt.get(i) || null, e, t, n, r, o)),
                                    !0
                        }
                        return !1
                    }(o, e, t, n, r))
                        r.stopPropagation();
                    else if (Dt(e, r),
                        4 & t && -1 < Rt.indexOf(e)) {
                        for (; null !== o;) {
                            var i = wo(o);
                            if (null !== i && kt(i),
                                null === (i = Jt(e, t, n, r)) && Ur(e, t, r, Kt, n),
                                i === o)
                                break;
                            o = i
                        }
                        null !== o && r.stopPropagation()
                    } else
                        Ur(e, t, r, null, n)
                }
            }
            var Kt = null;
            function Jt(e, t, n, r) {
                if (Kt = null,
                    null !== (e = vo(e = ke(r))))
                    if (null === (t = Ve(e)))
                        e = null;
                    else if (13 === (n = t.tag)) {
                        if (null !== (e = Fe(t)))
                            return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated)
                            return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else
                        t !== e && (e = null);
                return Kt = e,
                    null
            }
            function Zt(e) {
                switch (e) {
                    case "cancel":
                    case "click":
                    case "close":
                    case "contextmenu":
                    case "copy":
                    case "cut":
                    case "auxclick":
                    case "dblclick":
                    case "dragend":
                    case "dragstart":
                    case "drop":
                    case "focusin":
                    case "focusout":
                    case "input":
                    case "invalid":
                    case "keydown":
                    case "keypress":
                    case "keyup":
                    case "mousedown":
                    case "mouseup":
                    case "paste":
                    case "pause":
                    case "play":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointerup":
                    case "ratechange":
                    case "reset":
                    case "resize":
                    case "seeked":
                    case "submit":
                    case "touchcancel":
                    case "touchend":
                    case "touchstart":
                    case "volumechange":
                    case "change":
                    case "selectionchange":
                    case "textInput":
                    case "compositionstart":
                    case "compositionend":
                    case "compositionupdate":
                    case "beforeblur":
                    case "afterblur":
                    case "beforeinput":
                    case "blur":
                    case "fullscreenchange":
                    case "focus":
                    case "hashchange":
                    case "popstate":
                    case "select":
                    case "selectstart":
                        return 1;
                    case "drag":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "mousemove":
                    case "mouseout":
                    case "mouseover":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "scroll":
                    case "toggle":
                    case "touchmove":
                    case "wheel":
                    case "mouseenter":
                    case "mouseleave":
                    case "pointerenter":
                    case "pointerleave":
                        return 4;
                    case "message":
                        switch (Qe()) {
                            case Ye:
                                return 1;
                            case et:
                                return 4;
                            case tt:
                            case nt:
                                return 16;
                            case rt:
                                return 536870912;
                            default:
                                return 16
                        }
                    default:
                        return 16
                }
            }
            var Xt = null
                , Qt = null
                , Yt = null;
            function en() {
                if (Yt)
                    return Yt;
                var e, t, n = Qt, r = n.length, o = "value" in Xt ? Xt.value : Xt.textContent, i = o.length;
                for (e = 0; e < r && n[e] === o[e]; e++)
                    ;
                var s = r - e;
                for (t = 1; t <= s && n[r - t] === o[i - t]; t++)
                    ;
                return Yt = o.slice(e, 1 < t ? 1 - t : void 0)
            }
            function tn(e) {
                var t = e.keyCode;
                return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t,
                    10 === e && (e = 13),
                    32 <= e || 13 === e ? e : 0
            }
            function nn() {
                return !0
            }
            function rn() {
                return !1
            }
            function on(e) {
                function t(t, n, r, o, i) {
                    for (var s in this._reactName = t,
                        this._targetInst = r,
                        this.type = n,
                        this.nativeEvent = o,
                        this.target = i,
                        this.currentTarget = null,
                        e)
                        e.hasOwnProperty(s) && (t = e[s],
                            this[s] = t ? t(o) : o[s]);
                    return this.isDefaultPrevented = (null != o.defaultPrevented ? o.defaultPrevented : !1 === o.returnValue) ? nn : rn,
                        this.isPropagationStopped = rn,
                        this
                }
                return j(t.prototype, {
                    preventDefault: function () {
                        this.defaultPrevented = !0;
                        var e = this.nativeEvent;
                        e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1),
                            this.isDefaultPrevented = nn)
                    },
                    stopPropagation: function () {
                        var e = this.nativeEvent;
                        e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0),
                            this.isPropagationStopped = nn)
                    },
                    persist: function () { },
                    isPersistent: nn
                }),
                    t
            }
            var sn, an, ln, cn = {
                eventPhase: 0,
                bubbles: 0,
                cancelable: 0,
                timeStamp: function (e) {
                    return e.timeStamp || Date.now()
                },
                defaultPrevented: 0,
                isTrusted: 0
            }, dn = on(cn), un = j({}, cn, {
                view: 0,
                detail: 0
            }), hn = on(un), pn = j({}, un, {
                screenX: 0,
                screenY: 0,
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                getModifierState: En,
                button: 0,
                buttons: 0,
                relatedTarget: function (e) {
                    return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                },
                movementX: function (e) {
                    return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (sn = e.screenX - ln.screenX,
                        an = e.screenY - ln.screenY) : an = sn = 0,
                        ln = e),
                        sn)
                },
                movementY: function (e) {
                    return "movementY" in e ? e.movementY : an
                }
            }), fn = on(pn), mn = on(j({}, pn, {
                dataTransfer: 0
            })), gn = on(j({}, un, {
                relatedTarget: 0
            })), bn = on(j({}, cn, {
                animationName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            })), yn = j({}, cn, {
                clipboardData: function (e) {
                    return "clipboardData" in e ? e.clipboardData : window.clipboardData
                }
            }), vn = on(yn), wn = on(j({}, cn, {
                data: 0
            })), kn = {
                Esc: "Escape",
                Spacebar: " ",
                Left: "ArrowLeft",
                Up: "ArrowUp",
                Right: "ArrowRight",
                Down: "ArrowDown",
                Del: "Delete",
                Win: "OS",
                Menu: "ContextMenu",
                Apps: "ContextMenu",
                Scroll: "ScrollLock",
                MozPrintableKey: "Unidentified"
            }, Cn = {
                8: "Backspace",
                9: "Tab",
                12: "Clear",
                13: "Enter",
                16: "Shift",
                17: "Control",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Escape",
                32: " ",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "ArrowLeft",
                38: "ArrowUp",
                39: "ArrowRight",
                40: "ArrowDown",
                45: "Insert",
                46: "Delete",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "NumLock",
                145: "ScrollLock",
                224: "Meta"
            }, Sn = {
                Alt: "altKey",
                Control: "ctrlKey",
                Meta: "metaKey",
                Shift: "shiftKey"
            };
            function xn(e) {
                var t = this.nativeEvent;
                return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e]
            }
            function En() {
                return xn
            }
            var Mn = j({}, un, {
                key: function (e) {
                    if (e.key) {
                        var t = kn[e.key] || e.key;
                        if ("Unidentified" !== t)
                            return t
                    }
                    return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Cn[e.keyCode] || "Unidentified" : ""
                },
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: En,
                charCode: function (e) {
                    return "keypress" === e.type ? tn(e) : 0
                },
                keyCode: function (e) {
                    return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                },
                which: function (e) {
                    return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                }
            })
                , Tn = on(Mn)
                , Nn = on(j({}, pn, {
                    pointerId: 0,
                    width: 0,
                    height: 0,
                    pressure: 0,
                    tangentialPressure: 0,
                    tiltX: 0,
                    tiltY: 0,
                    twist: 0,
                    pointerType: 0,
                    isPrimary: 0
                }))
                , _n = on(j({}, un, {
                    touches: 0,
                    targetTouches: 0,
                    changedTouches: 0,
                    altKey: 0,
                    metaKey: 0,
                    ctrlKey: 0,
                    shiftKey: 0,
                    getModifierState: En
                }))
                , On = on(j({}, cn, {
                    propertyName: 0,
                    elapsedTime: 0,
                    pseudoElement: 0
                }))
                , An = j({}, pn, {
                    deltaX: function (e) {
                        return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                    },
                    deltaY: function (e) {
                        return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                    },
                    deltaZ: 0,
                    deltaMode: 0
                })
                , Pn = on(An)
                , Ln = [9, 13, 27, 32]
                , Rn = d && "CompositionEvent" in window
                , Dn = null;
            d && "documentMode" in document && (Dn = document.documentMode);
            var In = d && "TextEvent" in window && !Dn
                , jn = d && (!Rn || Dn && 8 < Dn && 11 >= Dn)
                , Hn = String.fromCharCode(32)
                , zn = !1;
            function $n(e, t) {
                switch (e) {
                    case "keyup":
                        return -1 !== Ln.indexOf(t.keyCode);
                    case "keydown":
                        return 229 !== t.keyCode;
                    case "keypress":
                    case "mousedown":
                    case "focusout":
                        return !0;
                    default:
                        return !1
                }
            }
            function Bn(e) {
                return "object" === typeof (e = e.detail) && "data" in e ? e.data : null
            }
            var Vn = !1;
            var Fn = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };
            function Un(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return "input" === t ? !!Fn[e.type] : "textarea" === t
            }
            function Wn(e, t, n, r) {
                Me(r),
                    0 < (t = qr(t, "onChange")).length && (n = new dn("onChange", "change", null, n, r),
                        e.push({
                            event: n,
                            listeners: t
                        }))
            }
            var qn = null
                , Gn = null;
            function Kn(e) {
                Hr(e, 0)
            }
            function Jn(e) {
                if (G(ko(e)))
                    return e
            }
            function Zn(e, t) {
                if ("change" === e)
                    return t
            }
            var Xn = !1;
            if (d) {
                var Qn;
                if (d) {
                    var Yn = "oninput" in document;
                    if (!Yn) {
                        var er = document.createElement("div");
                        er.setAttribute("oninput", "return;"),
                            Yn = "function" === typeof er.oninput
                    }
                    Qn = Yn
                } else
                    Qn = !1;
                Xn = Qn && (!document.documentMode || 9 < document.documentMode)
            }
            function tr() {
                qn && (qn.detachEvent("onpropertychange", nr),
                    Gn = qn = null)
            }
            function nr(e) {
                if ("value" === e.propertyName && Jn(Gn)) {
                    var t = [];
                    Wn(t, Gn, e, ke(e)),
                        Ae(Kn, t)
                }
            }
            function rr(e, t, n) {
                "focusin" === e ? (tr(),
                    Gn = n,
                    (qn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
            }
            function or(e) {
                if ("selectionchange" === e || "keyup" === e || "keydown" === e)
                    return Jn(Gn)
            }
            function ir(e, t) {
                if ("click" === e)
                    return Jn(t)
            }
            function sr(e, t) {
                if ("input" === e || "change" === e)
                    return Jn(t)
            }
            var ar = "function" === typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
                ;
            function lr(e, t) {
                if (ar(e, t))
                    return !0;
                if ("object" !== typeof e || null === e || "object" !== typeof t || null === t)
                    return !1;
                var n = Object.keys(e)
                    , r = Object.keys(t);
                if (n.length !== r.length)
                    return !1;
                for (r = 0; r < n.length; r++) {
                    var o = n[r];
                    if (!u.call(t, o) || !ar(e[o], t[o]))
                        return !1
                }
                return !0
            }
            function cr(e) {
                for (; e && e.firstChild;)
                    e = e.firstChild;
                return e
            }
            function dr(e, t) {
                var n, r = cr(e);
                for (e = 0; r;) {
                    if (3 === r.nodeType) {
                        if (n = e + r.textContent.length,
                            e <= t && n >= t)
                            return {
                                node: r,
                                offset: t - e
                            };
                        e = n
                    }
                    e: {
                        for (; r;) {
                            if (r.nextSibling) {
                                r = r.nextSibling;
                                break e
                            }
                            r = r.parentNode
                        }
                        r = void 0
                    }
                    r = cr(r)
                }
            }
            function ur(e, t) {
                return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? ur(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
            }
            function hr() {
                for (var e = window, t = K(); t instanceof e.HTMLIFrameElement;) {
                    try {
                        var n = "string" === typeof t.contentWindow.location.href
                    } catch (r) {
                        n = !1
                    }
                    if (!n)
                        break;
                    t = K((e = t.contentWindow).document)
                }
                return t
            }
            function pr(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
            }
            function fr(e) {
                var t = hr()
                    , n = e.focusedElem
                    , r = e.selectionRange;
                if (t !== n && n && n.ownerDocument && ur(n.ownerDocument.documentElement, n)) {
                    if (null !== r && pr(n))
                        if (t = r.start,
                            void 0 === (e = r.end) && (e = t),
                            "selectionStart" in n)
                            n.selectionStart = t,
                                n.selectionEnd = Math.min(e, n.value.length);
                        else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var o = n.textContent.length
                                , i = Math.min(r.start, o);
                            r = void 0 === r.end ? i : Math.min(r.end, o),
                                !e.extend && i > r && (o = r,
                                    r = i,
                                    i = o),
                                o = dr(n, i);
                            var s = dr(n, r);
                            o && s && (1 !== e.rangeCount || e.anchorNode !== o.node || e.anchorOffset !== o.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && ((t = t.createRange()).setStart(o.node, o.offset),
                                e.removeAllRanges(),
                                i > r ? (e.addRange(t),
                                    e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset),
                                        e.addRange(t)))
                        }
                    for (t = [],
                        e = n; e = e.parentNode;)
                        1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                    for ("function" === typeof n.focus && n.focus(),
                        n = 0; n < t.length; n++)
                        (e = t[n]).element.scrollLeft = e.left,
                            e.element.scrollTop = e.top
                }
            }
            var mr = d && "documentMode" in document && 11 >= document.documentMode
                , gr = null
                , br = null
                , yr = null
                , vr = !1;
            function wr(e, t, n) {
                var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                vr || null == gr || gr !== K(r) || ("selectionStart" in (r = gr) && pr(r) ? r = {
                    start: r.selectionStart,
                    end: r.selectionEnd
                } : r = {
                    anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                    anchorOffset: r.anchorOffset,
                    focusNode: r.focusNode,
                    focusOffset: r.focusOffset
                },
                    yr && lr(yr, r) || (yr = r,
                        0 < (r = qr(br, "onSelect")).length && (t = new dn("onSelect", "select", null, t, n),
                            e.push({
                                event: t,
                                listeners: r
                            }),
                            t.target = gr)))
            }
            function kr(e, t) {
                var n = {};
                return n[e.toLowerCase()] = t.toLowerCase(),
                    n["Webkit" + e] = "webkit" + t,
                    n["Moz" + e] = "moz" + t,
                    n
            }
            var Cr = {
                animationend: kr("Animation", "AnimationEnd"),
                animationiteration: kr("Animation", "AnimationIteration"),
                animationstart: kr("Animation", "AnimationStart"),
                transitionend: kr("Transition", "TransitionEnd")
            }
                , Sr = {}
                , xr = {};
            function Er(e) {
                if (Sr[e])
                    return Sr[e];
                if (!Cr[e])
                    return e;
                var t, n = Cr[e];
                for (t in n)
                    if (n.hasOwnProperty(t) && t in xr)
                        return Sr[e] = n[t];
                return e
            }
            d && (xr = document.createElement("div").style,
                "AnimationEvent" in window || (delete Cr.animationend.animation,
                    delete Cr.animationiteration.animation,
                    delete Cr.animationstart.animation),
                "TransitionEvent" in window || delete Cr.transitionend.transition);
            var Mr = Er("animationend")
                , Tr = Er("animationiteration")
                , Nr = Er("animationstart")
                , _r = Er("transitionend")
                , Or = new Map
                , Ar = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
            function Pr(e, t) {
                Or.set(e, t),
                    l(t, [e])
            }
            for (var Lr = 0; Lr < Ar.length; Lr++) {
                var Rr = Ar[Lr];
                Pr(Rr.toLowerCase(), "on" + (Rr[0].toUpperCase() + Rr.slice(1)))
            }
            Pr(Mr, "onAnimationEnd"),
                Pr(Tr, "onAnimationIteration"),
                Pr(Nr, "onAnimationStart"),
                Pr("dblclick", "onDoubleClick"),
                Pr("focusin", "onFocus"),
                Pr("focusout", "onBlur"),
                Pr(_r, "onTransitionEnd"),
                c("onMouseEnter", ["mouseout", "mouseover"]),
                c("onMouseLeave", ["mouseout", "mouseover"]),
                c("onPointerEnter", ["pointerout", "pointerover"]),
                c("onPointerLeave", ["pointerout", "pointerover"]),
                l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
                l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
                l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
                l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
                l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
                l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
                , Ir = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr));
            function jr(e, t, n) {
                var r = e.type || "unknown-event";
                e.currentTarget = n,
                    function (e, t, n, r, o, s, a, l, c) {
                        if (Be.apply(this, arguments),
                            Ie) {
                            if (!Ie)
                                throw Error(i(198));
                            var d = je;
                            Ie = !1,
                                je = null,
                                He || (He = !0,
                                    ze = d)
                        }
                    }(r, t, void 0, e),
                    e.currentTarget = null
            }
            function Hr(e, t) {
                t = 0 !== (4 & t);
                for (var n = 0; n < e.length; n++) {
                    var r = e[n]
                        , o = r.event;
                    r = r.listeners;
                    e: {
                        var i = void 0;
                        if (t)
                            for (var s = r.length - 1; 0 <= s; s--) {
                                var a = r[s]
                                    , l = a.instance
                                    , c = a.currentTarget;
                                if (a = a.listener,
                                    l !== i && o.isPropagationStopped())
                                    break e;
                                jr(o, a, c),
                                    i = l
                            }
                        else
                            for (s = 0; s < r.length; s++) {
                                if (l = (a = r[s]).instance,
                                    c = a.currentTarget,
                                    a = a.listener,
                                    l !== i && o.isPropagationStopped())
                                    break e;
                                jr(o, a, c),
                                    i = l
                            }
                    }
                }
                if (He)
                    throw e = ze,
                    He = !1,
                    ze = null,
                    e
            }
            function zr(e, t) {
                var n = t[go];
                void 0 === n && (n = t[go] = new Set);
                var r = e + "__bubble";
                n.has(r) || (Fr(t, e, 2, !1),
                    n.add(r))
            }
            function $r(e, t, n) {
                var r = 0;
                t && (r |= 4),
                    Fr(n, e, r, t)
            }
            var Br = "_reactListening" + Math.random().toString(36).slice(2);
            function Vr(e) {
                if (!e[Br]) {
                    e[Br] = !0,
                        s.forEach((function (t) {
                            "selectionchange" !== t && (Ir.has(t) || $r(t, !1, e),
                                $r(t, !0, e))
                        }
                        ));
                    var t = 9 === e.nodeType ? e : e.ownerDocument;
                    null === t || t[Br] || (t[Br] = !0,
                        $r("selectionchange", !1, t))
                }
            }
            function Fr(e, t, n, r) {
                switch (Zt(t)) {
                    case 1:
                        var o = Wt;
                        break;
                    case 4:
                        o = qt;
                        break;
                    default:
                        o = Gt
                }
                n = o.bind(null, t, n, e),
                    o = void 0,
                    !Le || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (o = !0),
                    r ? void 0 !== o ? e.addEventListener(t, n, {
                        capture: !0,
                        passive: o
                    }) : e.addEventListener(t, n, !0) : void 0 !== o ? e.addEventListener(t, n, {
                        passive: o
                    }) : e.addEventListener(t, n, !1)
            }
            function Ur(e, t, n, r, o) {
                var i = r;
                if (0 === (1 & t) && 0 === (2 & t) && null !== r)
                    e: for (; ;) {
                        if (null === r)
                            return;
                        var s = r.tag;
                        if (3 === s || 4 === s) {
                            var a = r.stateNode.containerInfo;
                            if (a === o || 8 === a.nodeType && a.parentNode === o)
                                break;
                            if (4 === s)
                                for (s = r.return; null !== s;) {
                                    var l = s.tag;
                                    if ((3 === l || 4 === l) && ((l = s.stateNode.containerInfo) === o || 8 === l.nodeType && l.parentNode === o))
                                        return;
                                    s = s.return
                                }
                            for (; null !== a;) {
                                if (null === (s = vo(a)))
                                    return;
                                if (5 === (l = s.tag) || 6 === l) {
                                    r = i = s;
                                    continue e
                                }
                                a = a.parentNode
                            }
                        }
                        r = r.return
                    }
                Ae((function () {
                    var r = i
                        , o = ke(n)
                        , s = [];
                    e: {
                        var a = Or.get(e);
                        if (void 0 !== a) {
                            var l = dn
                                , c = e;
                            switch (e) {
                                case "keypress":
                                    if (0 === tn(n))
                                        break e;
                                case "keydown":
                                case "keyup":
                                    l = Tn;
                                    break;
                                case "focusin":
                                    c = "focus",
                                        l = gn;
                                    break;
                                case "focusout":
                                    c = "blur",
                                        l = gn;
                                    break;
                                case "beforeblur":
                                case "afterblur":
                                    l = gn;
                                    break;
                                case "click":
                                    if (2 === n.button)
                                        break e;
                                case "auxclick":
                                case "dblclick":
                                case "mousedown":
                                case "mousemove":
                                case "mouseup":
                                case "mouseout":
                                case "mouseover":
                                case "contextmenu":
                                    l = fn;
                                    break;
                                case "drag":
                                case "dragend":
                                case "dragenter":
                                case "dragexit":
                                case "dragleave":
                                case "dragover":
                                case "dragstart":
                                case "drop":
                                    l = mn;
                                    break;
                                case "touchcancel":
                                case "touchend":
                                case "touchmove":
                                case "touchstart":
                                    l = _n;
                                    break;
                                case Mr:
                                case Tr:
                                case Nr:
                                    l = bn;
                                    break;
                                case _r:
                                    l = On;
                                    break;
                                case "scroll":
                                    l = hn;
                                    break;
                                case "wheel":
                                    l = Pn;
                                    break;
                                case "copy":
                                case "cut":
                                case "paste":
                                    l = vn;
                                    break;
                                case "gotpointercapture":
                                case "lostpointercapture":
                                case "pointercancel":
                                case "pointerdown":
                                case "pointermove":
                                case "pointerout":
                                case "pointerover":
                                case "pointerup":
                                    l = Nn
                            }
                            var d = 0 !== (4 & t)
                                , u = !d && "scroll" === e
                                , h = d ? null !== a ? a + "Capture" : null : a;
                            d = [];
                            for (var p, f = r; null !== f;) {
                                var m = (p = f).stateNode;
                                if (5 === p.tag && null !== m && (p = m,
                                    null !== h && (null != (m = Pe(f, h)) && d.push(Wr(f, m, p)))),
                                    u)
                                    break;
                                f = f.return
                            }
                            0 < d.length && (a = new l(a, c, null, n, o),
                                s.push({
                                    event: a,
                                    listeners: d
                                }))
                        }
                    }
                    if (0 === (7 & t)) {
                        if (l = "mouseout" === e || "pointerout" === e,
                            (!(a = "mouseover" === e || "pointerover" === e) || n === we || !(c = n.relatedTarget || n.fromElement) || !vo(c) && !c[mo]) && (l || a) && (a = o.window === o ? o : (a = o.ownerDocument) ? a.defaultView || a.parentWindow : window,
                                l ? (l = r,
                                    null !== (c = (c = n.relatedTarget || n.toElement) ? vo(c) : null) && (c !== (u = Ve(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null,
                                        c = r),
                                l !== c)) {
                            if (d = fn,
                                m = "onMouseLeave",
                                h = "onMouseEnter",
                                f = "mouse",
                                "pointerout" !== e && "pointerover" !== e || (d = Nn,
                                    m = "onPointerLeave",
                                    h = "onPointerEnter",
                                    f = "pointer"),
                                u = null == l ? a : ko(l),
                                p = null == c ? a : ko(c),
                                (a = new d(m, f + "leave", l, n, o)).target = u,
                                a.relatedTarget = p,
                                m = null,
                                vo(o) === r && ((d = new d(h, f + "enter", c, n, o)).target = p,
                                    d.relatedTarget = u,
                                    m = d),
                                u = m,
                                l && c)
                                e: {
                                    for (h = c,
                                        f = 0,
                                        p = d = l; p; p = Gr(p))
                                        f++;
                                    for (p = 0,
                                        m = h; m; m = Gr(m))
                                        p++;
                                    for (; 0 < f - p;)
                                        d = Gr(d),
                                            f--;
                                    for (; 0 < p - f;)
                                        h = Gr(h),
                                            p--;
                                    for (; f--;) {
                                        if (d === h || null !== h && d === h.alternate)
                                            break e;
                                        d = Gr(d),
                                            h = Gr(h)
                                    }
                                    d = null
                                }
                            else
                                d = null;
                            null !== l && Kr(s, a, l, d, !1),
                                null !== c && null !== u && Kr(s, u, c, d, !0)
                        }
                        if ("select" === (l = (a = r ? ko(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type)
                            var g = Zn;
                        else if (Un(a))
                            if (Xn)
                                g = sr;
                            else {
                                g = or;
                                var b = rr
                            }
                        else
                            (l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = ir);
                        switch (g && (g = g(e, r)) ? Wn(s, g, n, o) : (b && b(e, a, r),
                            "focusout" === e && (b = a._wrapperState) && b.controlled && "number" === a.type && ee(a, "number", a.value)),
                        b = r ? ko(r) : window,
                        e) {
                            case "focusin":
                                (Un(b) || "true" === b.contentEditable) && (gr = b,
                                    br = r,
                                    yr = null);
                                break;
                            case "focusout":
                                yr = br = gr = null;
                                break;
                            case "mousedown":
                                vr = !0;
                                break;
                            case "contextmenu":
                            case "mouseup":
                            case "dragend":
                                vr = !1,
                                    wr(s, n, o);
                                break;
                            case "selectionchange":
                                if (mr)
                                    break;
                            case "keydown":
                            case "keyup":
                                wr(s, n, o)
                        }
                        var y;
                        if (Rn)
                            e: {
                                switch (e) {
                                    case "compositionstart":
                                        var v = "onCompositionStart";
                                        break e;
                                    case "compositionend":
                                        v = "onCompositionEnd";
                                        break e;
                                    case "compositionupdate":
                                        v = "onCompositionUpdate";
                                        break e
                                }
                                v = void 0
                            }
                        else
                            Vn ? $n(e, n) && (v = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (v = "onCompositionStart");
                        v && (jn && "ko" !== n.locale && (Vn || "onCompositionStart" !== v ? "onCompositionEnd" === v && Vn && (y = en()) : (Qt = "value" in (Xt = o) ? Xt.value : Xt.textContent,
                            Vn = !0)),
                            0 < (b = qr(r, v)).length && (v = new wn(v, e, null, n, o),
                                s.push({
                                    event: v,
                                    listeners: b
                                }),
                                y ? v.data = y : null !== (y = Bn(n)) && (v.data = y))),
                            (y = In ? function (e, t) {
                                switch (e) {
                                    case "compositionend":
                                        return Bn(t);
                                    case "keypress":
                                        return 32 !== t.which ? null : (zn = !0,
                                            Hn);
                                    case "textInput":
                                        return (e = t.data) === Hn && zn ? null : e;
                                    default:
                                        return null
                                }
                            }(e, n) : function (e, t) {
                                if (Vn)
                                    return "compositionend" === e || !Rn && $n(e, t) ? (e = en(),
                                        Yt = Qt = Xt = null,
                                        Vn = !1,
                                        e) : null;
                                switch (e) {
                                    case "paste":
                                    default:
                                        return null;
                                    case "keypress":
                                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                            if (t.char && 1 < t.char.length)
                                                return t.char;
                                            if (t.which)
                                                return String.fromCharCode(t.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return jn && "ko" !== t.locale ? null : t.data
                                }
                            }(e, n)) && (0 < (r = qr(r, "onBeforeInput")).length && (o = new wn("onBeforeInput", "beforeinput", null, n, o),
                                s.push({
                                    event: o,
                                    listeners: r
                                }),
                                o.data = y))
                    }
                    Hr(s, t)
                }
                ))
            }
            function Wr(e, t, n) {
                return {
                    instance: e,
                    listener: t,
                    currentTarget: n
                }
            }
            function qr(e, t) {
                for (var n = t + "Capture", r = []; null !== e;) {
                    var o = e
                        , i = o.stateNode;
                    5 === o.tag && null !== i && (o = i,
                        null != (i = Pe(e, n)) && r.unshift(Wr(e, i, o)),
                        null != (i = Pe(e, t)) && r.push(Wr(e, i, o))),
                        e = e.return
                }
                return r
            }
            function Gr(e) {
                if (null === e)
                    return null;
                do {
                    e = e.return
                } while (e && 5 !== e.tag);
                return e || null
            }
            function Kr(e, t, n, r, o) {
                for (var i = t._reactName, s = []; null !== n && n !== r;) {
                    var a = n
                        , l = a.alternate
                        , c = a.stateNode;
                    if (null !== l && l === r)
                        break;
                    5 === a.tag && null !== c && (a = c,
                        o ? null != (l = Pe(n, i)) && s.unshift(Wr(n, l, a)) : o || null != (l = Pe(n, i)) && s.push(Wr(n, l, a))),
                        n = n.return
                }
                0 !== s.length && e.push({
                    event: t,
                    listeners: s
                })
            }
            var Jr = /\r\n?/g
                , Zr = /\u0000|\uFFFD/g;
            function Xr(e) {
                return ("string" === typeof e ? e : "" + e).replace(Jr, "\n").replace(Zr, "")
            }
            function Qr(e, t, n) {
                if (t = Xr(t),
                    Xr(e) !== t && n)
                    throw Error(i(425))
            }
            function Yr() { }
            var eo = null
                , to = null;
            function no(e, t) {
                return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
            }
            var ro = "function" === typeof setTimeout ? setTimeout : void 0
                , oo = "function" === typeof clearTimeout ? clearTimeout : void 0
                , io = "function" === typeof Promise ? Promise : void 0
                , so = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof io ? function (e) {
                    return io.resolve(null).then(e).catch(ao)
                }
                    : ro;
            function ao(e) {
                setTimeout((function () {
                    throw e
                }
                ))
            }
            function lo(e, t) {
                var n = t
                    , r = 0;
                do {
                    var o = n.nextSibling;
                    if (e.removeChild(n),
                        o && 8 === o.nodeType)
                        if ("/$" === (n = o.data)) {
                            if (0 === r)
                                return e.removeChild(o),
                                    void Vt(t);
                            r--
                        } else
                            "$" !== n && "$?" !== n && "$!" !== n || r++;
                    n = o
                } while (n);
                Vt(t)
            }
            function co(e) {
                for (; null != e; e = e.nextSibling) {
                    var t = e.nodeType;
                    if (1 === t || 3 === t)
                        break;
                    if (8 === t) {
                        if ("$" === (t = e.data) || "$!" === t || "$?" === t)
                            break;
                        if ("/$" === t)
                            return null
                    }
                }
                return e
            }
            function uo(e) {
                e = e.previousSibling;
                for (var t = 0; e;) {
                    if (8 === e.nodeType) {
                        var n = e.data;
                        if ("$" === n || "$!" === n || "$?" === n) {
                            if (0 === t)
                                return e;
                            t--
                        } else
                            "/$" === n && t++
                    }
                    e = e.previousSibling
                }
                return null
            }
            var ho = Math.random().toString(36).slice(2)
                , po = "__reactFiber$" + ho
                , fo = "__reactProps$" + ho
                , mo = "__reactContainer$" + ho
                , go = "__reactEvents$" + ho
                , bo = "__reactListeners$" + ho
                , yo = "__reactHandles$" + ho;
            function vo(e) {
                var t = e[po];
                if (t)
                    return t;
                for (var n = e.parentNode; n;) {
                    if (t = n[mo] || n[po]) {
                        if (n = t.alternate,
                            null !== t.child || null !== n && null !== n.child)
                            for (e = uo(e); null !== e;) {
                                if (n = e[po])
                                    return n;
                                e = uo(e)
                            }
                        return t
                    }
                    n = (e = n).parentNode
                }
                return null
            }
            function wo(e) {
                return !(e = e[po] || e[mo]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
            }
            function ko(e) {
                if (5 === e.tag || 6 === e.tag)
                    return e.stateNode;
                throw Error(i(33))
            }
            function Co(e) {
                return e[fo] || null
            }
            var So = []
                , xo = -1;
            function Eo(e) {
                return {
                    current: e
                }
            }
            function Mo(e) {
                0 > xo || (e.current = So[xo],
                    So[xo] = null,
                    xo--)
            }
            function To(e, t) {
                xo++,
                    So[xo] = e.current,
                    e.current = t
            }
            var No = {}
                , _o = Eo(No)
                , Oo = Eo(!1)
                , Ao = No;
            function Po(e, t) {
                var n = e.type.contextTypes;
                if (!n)
                    return No;
                var r = e.stateNode;
                if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
                    return r.__reactInternalMemoizedMaskedChildContext;
                var o, i = {};
                for (o in n)
                    i[o] = t[o];
                return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t,
                    e.__reactInternalMemoizedMaskedChildContext = i),
                    i
            }
            function Lo(e) {
                return null !== (e = e.childContextTypes) && void 0 !== e
            }
            function Ro() {
                Mo(Oo),
                    Mo(_o)
            }
            function Do(e, t, n) {
                if (_o.current !== No)
                    throw Error(i(168));
                To(_o, t),
                    To(Oo, n)
            }
            function Io(e, t, n) {
                var r = e.stateNode;
                if (t = t.childContextTypes,
                    "function" !== typeof r.getChildContext)
                    return n;
                for (var o in r = r.getChildContext())
                    if (!(o in t))
                        throw Error(i(108, F(e) || "Unknown", o));
                return j({}, n, r)
            }
            function jo(e) {
                return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || No,
                    Ao = _o.current,
                    To(_o, e),
                    To(Oo, Oo.current),
                    !0
            }
            function Ho(e, t, n) {
                var r = e.stateNode;
                if (!r)
                    throw Error(i(169));
                n ? (e = Io(e, t, Ao),
                    r.__reactInternalMemoizedMergedChildContext = e,
                    Mo(Oo),
                    Mo(_o),
                    To(_o, e)) : Mo(Oo),
                    To(Oo, n)
            }
            var zo = null
                , $o = !1
                , Bo = !1;
            function Vo(e) {
                null === zo ? zo = [e] : zo.push(e)
            }
            function Fo() {
                if (!Bo && null !== zo) {
                    Bo = !0;
                    var e = 0
                        , t = vt;
                    try {
                        var n = zo;
                        for (vt = 1; e < n.length; e++) {
                            var r = n[e];
                            do {
                                r = r(!0)
                            } while (null !== r)
                        }
                        zo = null,
                            $o = !1
                    } catch (o) {
                        throw null !== zo && (zo = zo.slice(e + 1)),
                        Ge(Ye, Fo),
                        o
                    } finally {
                        vt = t,
                            Bo = !1
                    }
                }
                return null
            }
            var Uo = []
                , Wo = 0
                , qo = null
                , Go = 0
                , Ko = []
                , Jo = 0
                , Zo = null
                , Xo = 1
                , Qo = "";
            function Yo(e, t) {
                Uo[Wo++] = Go,
                    Uo[Wo++] = qo,
                    qo = e,
                    Go = t
            }
            function ei(e, t, n) {
                Ko[Jo++] = Xo,
                    Ko[Jo++] = Qo,
                    Ko[Jo++] = Zo,
                    Zo = e;
                var r = Xo;
                e = Qo;
                var o = 32 - st(r) - 1;
                r &= ~(1 << o),
                    n += 1;
                var i = 32 - st(t) + o;
                if (30 < i) {
                    var s = o - o % 5;
                    i = (r & (1 << s) - 1).toString(32),
                        r >>= s,
                        o -= s,
                        Xo = 1 << 32 - st(t) + o | n << o | r,
                        Qo = i + e
                } else
                    Xo = 1 << i | n << o | r,
                        Qo = e
            }
            function ti(e) {
                null !== e.return && (Yo(e, 1),
                    ei(e, 1, 0))
            }
            function ni(e) {
                for (; e === qo;)
                    qo = Uo[--Wo],
                        Uo[Wo] = null,
                        Go = Uo[--Wo],
                        Uo[Wo] = null;
                for (; e === Zo;)
                    Zo = Ko[--Jo],
                        Ko[Jo] = null,
                        Qo = Ko[--Jo],
                        Ko[Jo] = null,
                        Xo = Ko[--Jo],
                        Ko[Jo] = null
            }
            var ri = null
                , oi = null
                , ii = !1
                , si = null;
            function ai(e, t) {
                var n = Ac(5, null, null, 0);
                n.elementType = "DELETED",
                    n.stateNode = t,
                    n.return = e,
                    null === (t = e.deletions) ? (e.deletions = [n],
                        e.flags |= 16) : t.push(n)
            }
            function li(e, t) {
                switch (e.tag) {
                    case 5:
                        var n = e.type;
                        return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t,
                            ri = e,
                            oi = co(t.firstChild),
                            !0);
                    case 6:
                        return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t,
                            ri = e,
                            oi = null,
                            !0);
                    case 13:
                        return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Zo ? {
                            id: Xo,
                            overflow: Qo
                        } : null,
                            e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            },
                            (n = Ac(18, null, null, 0)).stateNode = t,
                            n.return = e,
                            e.child = n,
                            ri = e,
                            oi = null,
                            !0);
                    default:
                        return !1
                }
            }
            function ci(e) {
                return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
            }
            function di(e) {
                if (ii) {
                    var t = oi;
                    if (t) {
                        var n = t;
                        if (!li(e, t)) {
                            if (ci(e))
                                throw Error(i(418));
                            t = co(n.nextSibling);
                            var r = ri;
                            t && li(e, t) ? ai(r, n) : (e.flags = -4097 & e.flags | 2,
                                ii = !1,
                                ri = e)
                        }
                    } else {
                        if (ci(e))
                            throw Error(i(418));
                        e.flags = -4097 & e.flags | 2,
                            ii = !1,
                            ri = e
                    }
                }
            }
            function ui(e) {
                for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)
                    e = e.return;
                ri = e
            }
            function hi(e) {
                if (e !== ri)
                    return !1;
                if (!ii)
                    return ui(e),
                        ii = !0,
                        !1;
                var t;
                if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !no(e.type, e.memoizedProps)),
                    t && (t = oi)) {
                    if (ci(e))
                        throw pi(),
                        Error(i(418));
                    for (; t;)
                        ai(e, t),
                            t = co(t.nextSibling)
                }
                if (ui(e),
                    13 === e.tag) {
                    if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
                        throw Error(i(317));
                    e: {
                        for (e = e.nextSibling,
                            t = 0; e;) {
                            if (8 === e.nodeType) {
                                var n = e.data;
                                if ("/$" === n) {
                                    if (0 === t) {
                                        oi = co(e.nextSibling);
                                        break e
                                    }
                                    t--
                                } else
                                    "$" !== n && "$!" !== n && "$?" !== n || t++
                            }
                            e = e.nextSibling
                        }
                        oi = null
                    }
                } else
                    oi = ri ? co(e.stateNode.nextSibling) : null;
                return !0
            }
            function pi() {
                for (var e = oi; e;)
                    e = co(e.nextSibling)
            }
            function fi() {
                oi = ri = null,
                    ii = !1
            }
            function mi(e) {
                null === si ? si = [e] : si.push(e)
            }
            var gi = w.ReactCurrentBatchConfig;
            function bi(e, t, n) {
                if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                    if (n._owner) {
                        if (n = n._owner) {
                            if (1 !== n.tag)
                                throw Error(i(309));
                            var r = n.stateNode
                        }
                        if (!r)
                            throw Error(i(147, e));
                        var o = r
                            , s = "" + e;
                        return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === s ? t.ref : (t = function (e) {
                            var t = o.refs;
                            null === e ? delete t[s] : t[s] = e
                        }
                            ,
                            t._stringRef = s,
                            t)
                    }
                    if ("string" !== typeof e)
                        throw Error(i(284));
                    if (!n._owner)
                        throw Error(i(290, e))
                }
                return e
            }
            function yi(e, t) {
                throw e = Object.prototype.toString.call(t),
                Error(i(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
            }
            function vi(e) {
                return (0,
                    e._init)(e._payload)
            }
            function wi(e) {
                function t(t, n) {
                    if (e) {
                        var r = t.deletions;
                        null === r ? (t.deletions = [n],
                            t.flags |= 16) : r.push(n)
                    }
                }
                function n(n, r) {
                    if (!e)
                        return null;
                    for (; null !== r;)
                        t(n, r),
                            r = r.sibling;
                    return null
                }
                function r(e, t) {
                    for (e = new Map; null !== t;)
                        null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                            t = t.sibling;
                    return e
                }
                function o(e, t) {
                    return (e = Lc(e, t)).index = 0,
                        e.sibling = null,
                        e
                }
                function s(t, n, r) {
                    return t.index = r,
                        e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2,
                            n) : r : (t.flags |= 2,
                                n) : (t.flags |= 1048576,
                                    n)
                }
                function a(t) {
                    return e && null === t.alternate && (t.flags |= 2),
                        t
                }
                function l(e, t, n, r) {
                    return null === t || 6 !== t.tag ? ((t = jc(n, e.mode, r)).return = e,
                        t) : ((t = o(t, n)).return = e,
                            t)
                }
                function c(e, t, n, r) {
                    var i = n.type;
                    return i === S ? u(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === i || "object" === typeof i && null !== i && i.$$typeof === P && vi(i) === t.type) ? ((r = o(t, n.props)).ref = bi(e, t, n),
                        r.return = e,
                        r) : ((r = Rc(n.type, n.key, n.props, null, e.mode, r)).ref = bi(e, t, n),
                            r.return = e,
                            r)
                }
                function d(e, t, n, r) {
                    return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Hc(n, e.mode, r)).return = e,
                        t) : ((t = o(t, n.children || [])).return = e,
                            t)
                }
                function u(e, t, n, r, i) {
                    return null === t || 7 !== t.tag ? ((t = Dc(n, e.mode, r, i)).return = e,
                        t) : ((t = o(t, n)).return = e,
                            t)
                }
                function h(e, t, n) {
                    if ("string" === typeof t && "" !== t || "number" === typeof t)
                        return (t = jc("" + t, e.mode, n)).return = e,
                            t;
                    if ("object" === typeof t && null !== t) {
                        switch (t.$$typeof) {
                            case k:
                                return (n = Rc(t.type, t.key, t.props, null, e.mode, n)).ref = bi(e, null, t),
                                    n.return = e,
                                    n;
                            case C:
                                return (t = Hc(t, e.mode, n)).return = e,
                                    t;
                            case P:
                                return h(e, (0,
                                    t._init)(t._payload), n)
                        }
                        if (te(t) || D(t))
                            return (t = Dc(t, e.mode, n, null)).return = e,
                                t;
                        yi(e, t)
                    }
                    return null
                }
                function p(e, t, n, r) {
                    var o = null !== t ? t.key : null;
                    if ("string" === typeof n && "" !== n || "number" === typeof n)
                        return null !== o ? null : l(e, t, "" + n, r);
                    if ("object" === typeof n && null !== n) {
                        switch (n.$$typeof) {
                            case k:
                                return n.key === o ? c(e, t, n, r) : null;
                            case C:
                                return n.key === o ? d(e, t, n, r) : null;
                            case P:
                                return p(e, t, (o = n._init)(n._payload), r)
                        }
                        if (te(n) || D(n))
                            return null !== o ? null : u(e, t, n, r, null);
                        yi(e, n)
                    }
                    return null
                }
                function f(e, t, n, r, o) {
                    if ("string" === typeof r && "" !== r || "number" === typeof r)
                        return l(t, e = e.get(n) || null, "" + r, o);
                    if ("object" === typeof r && null !== r) {
                        switch (r.$$typeof) {
                            case k:
                                return c(t, e = e.get(null === r.key ? n : r.key) || null, r, o);
                            case C:
                                return d(t, e = e.get(null === r.key ? n : r.key) || null, r, o);
                            case P:
                                return f(e, t, n, (0,
                                    r._init)(r._payload), o)
                        }
                        if (te(r) || D(r))
                            return u(t, e = e.get(n) || null, r, o, null);
                        yi(t, r)
                    }
                    return null
                }
                function m(o, i, a, l) {
                    for (var c = null, d = null, u = i, m = i = 0, g = null; null !== u && m < a.length; m++) {
                        u.index > m ? (g = u,
                            u = null) : g = u.sibling;
                        var b = p(o, u, a[m], l);
                        if (null === b) {
                            null === u && (u = g);
                            break
                        }
                        e && u && null === b.alternate && t(o, u),
                            i = s(b, i, m),
                            null === d ? c = b : d.sibling = b,
                            d = b,
                            u = g
                    }
                    if (m === a.length)
                        return n(o, u),
                            ii && Yo(o, m),
                            c;
                    if (null === u) {
                        for (; m < a.length; m++)
                            null !== (u = h(o, a[m], l)) && (i = s(u, i, m),
                                null === d ? c = u : d.sibling = u,
                                d = u);
                        return ii && Yo(o, m),
                            c
                    }
                    for (u = r(o, u); m < a.length; m++)
                        null !== (g = f(u, o, m, a[m], l)) && (e && null !== g.alternate && u.delete(null === g.key ? m : g.key),
                            i = s(g, i, m),
                            null === d ? c = g : d.sibling = g,
                            d = g);
                    return e && u.forEach((function (e) {
                        return t(o, e)
                    }
                    )),
                        ii && Yo(o, m),
                        c
                }
                function g(o, a, l, c) {
                    var d = D(l);
                    if ("function" !== typeof d)
                        throw Error(i(150));
                    if (null == (l = d.call(l)))
                        throw Error(i(151));
                    for (var u = d = null, m = a, g = a = 0, b = null, y = l.next(); null !== m && !y.done; g++,
                        y = l.next()) {
                        m.index > g ? (b = m,
                            m = null) : b = m.sibling;
                        var v = p(o, m, y.value, c);
                        if (null === v) {
                            null === m && (m = b);
                            break
                        }
                        e && m && null === v.alternate && t(o, m),
                            a = s(v, a, g),
                            null === u ? d = v : u.sibling = v,
                            u = v,
                            m = b
                    }
                    if (y.done)
                        return n(o, m),
                            ii && Yo(o, g),
                            d;
                    if (null === m) {
                        for (; !y.done; g++,
                            y = l.next())
                            null !== (y = h(o, y.value, c)) && (a = s(y, a, g),
                                null === u ? d = y : u.sibling = y,
                                u = y);
                        return ii && Yo(o, g),
                            d
                    }
                    for (m = r(o, m); !y.done; g++,
                        y = l.next())
                        null !== (y = f(m, o, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key),
                            a = s(y, a, g),
                            null === u ? d = y : u.sibling = y,
                            u = y);
                    return e && m.forEach((function (e) {
                        return t(o, e)
                    }
                    )),
                        ii && Yo(o, g),
                        d
                }
                return function e(r, i, s, l) {
                    if ("object" === typeof s && null !== s && s.type === S && null === s.key && (s = s.props.children),
                        "object" === typeof s && null !== s) {
                        switch (s.$$typeof) {
                            case k:
                                e: {
                                    for (var c = s.key, d = i; null !== d;) {
                                        if (d.key === c) {
                                            if ((c = s.type) === S) {
                                                if (7 === d.tag) {
                                                    n(r, d.sibling),
                                                        (i = o(d, s.props.children)).return = r,
                                                        r = i;
                                                    break e
                                                }
                                            } else if (d.elementType === c || "object" === typeof c && null !== c && c.$$typeof === P && vi(c) === d.type) {
                                                n(r, d.sibling),
                                                    (i = o(d, s.props)).ref = bi(r, d, s),
                                                    i.return = r,
                                                    r = i;
                                                break e
                                            }
                                            n(r, d);
                                            break
                                        }
                                        t(r, d),
                                            d = d.sibling
                                    }
                                    s.type === S ? ((i = Dc(s.props.children, r.mode, l, s.key)).return = r,
                                        r = i) : ((l = Rc(s.type, s.key, s.props, null, r.mode, l)).ref = bi(r, i, s),
                                            l.return = r,
                                            r = l)
                                }
                                return a(r);
                            case C:
                                e: {
                                    for (d = s.key; null !== i;) {
                                        if (i.key === d) {
                                            if (4 === i.tag && i.stateNode.containerInfo === s.containerInfo && i.stateNode.implementation === s.implementation) {
                                                n(r, i.sibling),
                                                    (i = o(i, s.children || [])).return = r,
                                                    r = i;
                                                break e
                                            }
                                            n(r, i);
                                            break
                                        }
                                        t(r, i),
                                            i = i.sibling
                                    }
                                    (i = Hc(s, r.mode, l)).return = r,
                                        r = i
                                }
                                return a(r);
                            case P:
                                return e(r, i, (d = s._init)(s._payload), l)
                        }
                        if (te(s))
                            return m(r, i, s, l);
                        if (D(s))
                            return g(r, i, s, l);
                        yi(r, s)
                    }
                    return "string" === typeof s && "" !== s || "number" === typeof s ? (s = "" + s,
                        null !== i && 6 === i.tag ? (n(r, i.sibling),
                            (i = o(i, s)).return = r,
                            r = i) : (n(r, i),
                                (i = jc(s, r.mode, l)).return = r,
                                r = i),
                        a(r)) : n(r, i)
                }
            }
            var ki = wi(!0)
                , Ci = wi(!1)
                , Si = Eo(null)
                , xi = null
                , Ei = null
                , Mi = null;
            function Ti() {
                Mi = Ei = xi = null
            }
            function Ni(e) {
                var t = Si.current;
                Mo(Si),
                    e._currentValue = t
            }
            function _i(e, t, n) {
                for (; null !== e;) {
                    var r = e.alternate;
                    if ((e.childLanes & t) !== t ? (e.childLanes |= t,
                        null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t),
                        e === n)
                        break;
                    e = e.return
                }
            }
            function Oi(e, t) {
                xi = e,
                    Mi = Ei = null,
                    null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (va = !0),
                        e.firstContext = null)
            }
            function Ai(e) {
                var t = e._currentValue;
                if (Mi !== e)
                    if (e = {
                        context: e,
                        memoizedValue: t,
                        next: null
                    },
                        null === Ei) {
                        if (null === xi)
                            throw Error(i(308));
                        Ei = e,
                            xi.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                    } else
                        Ei = Ei.next = e;
                return t
            }
            var Pi = null;
            function Li(e) {
                null === Pi ? Pi = [e] : Pi.push(e)
            }
            function Ri(e, t, n, r) {
                var o = t.interleaved;
                return null === o ? (n.next = n,
                    Li(t)) : (n.next = o.next,
                        o.next = n),
                    t.interleaved = n,
                    Di(e, r)
            }
            function Di(e, t) {
                e.lanes |= t;
                var n = e.alternate;
                for (null !== n && (n.lanes |= t),
                    n = e,
                    e = e.return; null !== e;)
                    e.childLanes |= t,
                        null !== (n = e.alternate) && (n.childLanes |= t),
                        n = e,
                        e = e.return;
                return 3 === n.tag ? n.stateNode : null
            }
            var Ii = !1;
            function ji(e) {
                e.updateQueue = {
                    baseState: e.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        interleaved: null,
                        lanes: 0
                    },
                    effects: null
                }
            }
            function Hi(e, t) {
                e = e.updateQueue,
                    t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
            }
            function zi(e, t) {
                return {
                    eventTime: e,
                    lane: t,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                }
            }
            function $i(e, t, n) {
                var r = e.updateQueue;
                if (null === r)
                    return null;
                if (r = r.shared,
                    0 !== (2 & Nl)) {
                    var o = r.pending;
                    return null === o ? t.next = t : (t.next = o.next,
                        o.next = t),
                        r.pending = t,
                        Di(e, n)
                }
                return null === (o = r.interleaved) ? (t.next = t,
                    Li(r)) : (t.next = o.next,
                        o.next = t),
                    r.interleaved = t,
                    Di(e, n)
            }
            function Bi(e, t, n) {
                if (null !== (t = t.updateQueue) && (t = t.shared,
                    0 !== (4194240 & n))) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes,
                        t.lanes = n,
                        yt(e, n)
                }
            }
            function Vi(e, t) {
                var n = e.updateQueue
                    , r = e.alternate;
                if (null !== r && n === (r = r.updateQueue)) {
                    var o = null
                        , i = null;
                    if (null !== (n = n.firstBaseUpdate)) {
                        do {
                            var s = {
                                eventTime: n.eventTime,
                                lane: n.lane,
                                tag: n.tag,
                                payload: n.payload,
                                callback: n.callback,
                                next: null
                            };
                            null === i ? o = i = s : i = i.next = s,
                                n = n.next
                        } while (null !== n);
                        null === i ? o = i = t : i = i.next = t
                    } else
                        o = i = t;
                    return n = {
                        baseState: r.baseState,
                        firstBaseUpdate: o,
                        lastBaseUpdate: i,
                        shared: r.shared,
                        effects: r.effects
                    },
                        void (e.updateQueue = n)
                }
                null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t,
                    n.lastBaseUpdate = t
            }
            function Fi(e, t, n, r) {
                var o = e.updateQueue;
                Ii = !1;
                var i = o.firstBaseUpdate
                    , s = o.lastBaseUpdate
                    , a = o.shared.pending;
                if (null !== a) {
                    o.shared.pending = null;
                    var l = a
                        , c = l.next;
                    l.next = null,
                        null === s ? i = c : s.next = c,
                        s = l;
                    var d = e.alternate;
                    null !== d && ((a = (d = d.updateQueue).lastBaseUpdate) !== s && (null === a ? d.firstBaseUpdate = c : a.next = c,
                        d.lastBaseUpdate = l))
                }
                if (null !== i) {
                    var u = o.baseState;
                    for (s = 0,
                        d = c = l = null,
                        a = i; ;) {
                        var h = a.lane
                            , p = a.eventTime;
                        if ((r & h) === h) {
                            null !== d && (d = d.next = {
                                eventTime: p,
                                lane: 0,
                                tag: a.tag,
                                payload: a.payload,
                                callback: a.callback,
                                next: null
                            });
                            e: {
                                var f = e
                                    , m = a;
                                switch (h = t,
                                p = n,
                                m.tag) {
                                    case 1:
                                        if ("function" === typeof (f = m.payload)) {
                                            u = f.call(p, u, h);
                                            break e
                                        }
                                        u = f;
                                        break e;
                                    case 3:
                                        f.flags = -65537 & f.flags | 128;
                                    case 0:
                                        if (null === (h = "function" === typeof (f = m.payload) ? f.call(p, u, h) : f) || void 0 === h)
                                            break e;
                                        u = j({}, u, h);
                                        break e;
                                    case 2:
                                        Ii = !0
                                }
                            }
                            null !== a.callback && 0 !== a.lane && (e.flags |= 64,
                                null === (h = o.effects) ? o.effects = [a] : h.push(a))
                        } else
                            p = {
                                eventTime: p,
                                lane: h,
                                tag: a.tag,
                                payload: a.payload,
                                callback: a.callback,
                                next: null
                            },
                                null === d ? (c = d = p,
                                    l = u) : d = d.next = p,
                                s |= h;
                        if (null === (a = a.next)) {
                            if (null === (a = o.shared.pending))
                                break;
                            a = (h = a).next,
                                h.next = null,
                                o.lastBaseUpdate = h,
                                o.shared.pending = null
                        }
                    }
                    if (null === d && (l = u),
                        o.baseState = l,
                        o.firstBaseUpdate = c,
                        o.lastBaseUpdate = d,
                        null !== (t = o.shared.interleaved)) {
                        o = t;
                        do {
                            s |= o.lane,
                                o = o.next
                        } while (o !== t)
                    } else
                        null === i && (o.shared.lanes = 0);
                    Il |= s,
                        e.lanes = s,
                        e.memoizedState = u
                }
            }
            function Ui(e, t, n) {
                if (e = t.effects,
                    t.effects = null,
                    null !== e)
                    for (t = 0; t < e.length; t++) {
                        var r = e[t]
                            , o = r.callback;
                        if (null !== o) {
                            if (r.callback = null,
                                r = n,
                                "function" !== typeof o)
                                throw Error(i(191, o));
                            o.call(r)
                        }
                    }
            }
            var Wi = {}
                , qi = Eo(Wi)
                , Gi = Eo(Wi)
                , Ki = Eo(Wi);
            function Ji(e) {
                if (e === Wi)
                    throw Error(i(174));
                return e
            }
            function Zi(e, t) {
                switch (To(Ki, t),
                To(Gi, e),
                To(qi, Wi),
                e = t.nodeType) {
                    case 9:
                    case 11:
                        t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
                        break;
                    default:
                        t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                }
                Mo(qi),
                    To(qi, t)
            }
            function Xi() {
                Mo(qi),
                    Mo(Gi),
                    Mo(Ki)
            }
            function Qi(e) {
                Ji(Ki.current);
                var t = Ji(qi.current)
                    , n = le(t, e.type);
                t !== n && (To(Gi, e),
                    To(qi, n))
            }
            function Yi(e) {
                Gi.current === e && (Mo(qi),
                    Mo(Gi))
            }
            var es = Eo(0);
            function ts(e) {
                for (var t = e; null !== t;) {
                    if (13 === t.tag) {
                        var n = t.memoizedState;
                        if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data))
                            return t
                    } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                        if (0 !== (128 & t.flags))
                            return t
                    } else if (null !== t.child) {
                        t.child.return = t,
                            t = t.child;
                        continue
                    }
                    if (t === e)
                        break;
                    for (; null === t.sibling;) {
                        if (null === t.return || t.return === e)
                            return null;
                        t = t.return
                    }
                    t.sibling.return = t.return,
                        t = t.sibling
                }
                return null
            }
            var ns = [];
            function rs() {
                for (var e = 0; e < ns.length; e++)
                    ns[e]._workInProgressVersionPrimary = null;
                ns.length = 0
            }
            var os = w.ReactCurrentDispatcher
                , is = w.ReactCurrentBatchConfig
                , ss = 0
                , as = null
                , ls = null
                , cs = null
                , ds = !1
                , us = !1
                , hs = 0
                , ps = 0;
            function fs() {
                throw Error(i(321))
            }
            function ms(e, t) {
                if (null === t)
                    return !1;
                for (var n = 0; n < t.length && n < e.length; n++)
                    if (!ar(e[n], t[n]))
                        return !1;
                return !0
            }
            function gs(e, t, n, r, o, s) {
                if (ss = s,
                    as = t,
                    t.memoizedState = null,
                    t.updateQueue = null,
                    t.lanes = 0,
                    os.current = null === e || null === e.memoizedState ? Ys : ea,
                    e = n(r, o),
                    us) {
                    s = 0;
                    do {
                        if (us = !1,
                            hs = 0,
                            25 <= s)
                            throw Error(i(301));
                        s += 1,
                            cs = ls = null,
                            t.updateQueue = null,
                            os.current = ta,
                            e = n(r, o)
                    } while (us)
                }
                if (os.current = Qs,
                    t = null !== ls && null !== ls.next,
                    ss = 0,
                    cs = ls = as = null,
                    ds = !1,
                    t)
                    throw Error(i(300));
                return e
            }
            function bs() {
                var e = 0 !== hs;
                return hs = 0,
                    e
            }
            function ys() {
                var e = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                return null === cs ? as.memoizedState = cs = e : cs = cs.next = e,
                    cs
            }
            function vs() {
                if (null === ls) {
                    var e = as.alternate;
                    e = null !== e ? e.memoizedState : null
                } else
                    e = ls.next;
                var t = null === cs ? as.memoizedState : cs.next;
                if (null !== t)
                    cs = t,
                        ls = e;
                else {
                    if (null === e)
                        throw Error(i(310));
                    e = {
                        memoizedState: (ls = e).memoizedState,
                        baseState: ls.baseState,
                        baseQueue: ls.baseQueue,
                        queue: ls.queue,
                        next: null
                    },
                        null === cs ? as.memoizedState = cs = e : cs = cs.next = e
                }
                return cs
            }
            function ws(e, t) {
                return "function" === typeof t ? t(e) : t
            }
            function ks(e) {
                var t = vs()
                    , n = t.queue;
                if (null === n)
                    throw Error(i(311));
                n.lastRenderedReducer = e;
                var r = ls
                    , o = r.baseQueue
                    , s = n.pending;
                if (null !== s) {
                    if (null !== o) {
                        var a = o.next;
                        o.next = s.next,
                            s.next = a
                    }
                    r.baseQueue = o = s,
                        n.pending = null
                }
                if (null !== o) {
                    s = o.next,
                        r = r.baseState;
                    var l = a = null
                        , c = null
                        , d = s;
                    do {
                        var u = d.lane;
                        if ((ss & u) === u)
                            null !== c && (c = c.next = {
                                lane: 0,
                                action: d.action,
                                hasEagerState: d.hasEagerState,
                                eagerState: d.eagerState,
                                next: null
                            }),
                                r = d.hasEagerState ? d.eagerState : e(r, d.action);
                        else {
                            var h = {
                                lane: u,
                                action: d.action,
                                hasEagerState: d.hasEagerState,
                                eagerState: d.eagerState,
                                next: null
                            };
                            null === c ? (l = c = h,
                                a = r) : c = c.next = h,
                                as.lanes |= u,
                                Il |= u
                        }
                        d = d.next
                    } while (null !== d && d !== s);
                    null === c ? a = r : c.next = l,
                        ar(r, t.memoizedState) || (va = !0),
                        t.memoizedState = r,
                        t.baseState = a,
                        t.baseQueue = c,
                        n.lastRenderedState = r
                }
                if (null !== (e = n.interleaved)) {
                    o = e;
                    do {
                        s = o.lane,
                            as.lanes |= s,
                            Il |= s,
                            o = o.next
                    } while (o !== e)
                } else
                    null === o && (n.lanes = 0);
                return [t.memoizedState, n.dispatch]
            }
            function Cs(e) {
                var t = vs()
                    , n = t.queue;
                if (null === n)
                    throw Error(i(311));
                n.lastRenderedReducer = e;
                var r = n.dispatch
                    , o = n.pending
                    , s = t.memoizedState;
                if (null !== o) {
                    n.pending = null;
                    var a = o = o.next;
                    do {
                        s = e(s, a.action),
                            a = a.next
                    } while (a !== o);
                    ar(s, t.memoizedState) || (va = !0),
                        t.memoizedState = s,
                        null === t.baseQueue && (t.baseState = s),
                        n.lastRenderedState = s
                }
                return [s, r]
            }
            function Ss() { }
            function xs(e, t) {
                var n = as
                    , r = vs()
                    , o = t()
                    , s = !ar(r.memoizedState, o);
                if (s && (r.memoizedState = o,
                    va = !0),
                    r = r.queue,
                    Is(Ts.bind(null, n, r, e), [e]),
                    r.getSnapshot !== t || s || null !== cs && 1 & cs.memoizedState.tag) {
                    if (n.flags |= 2048,
                        As(9, Ms.bind(null, n, r, o, t), void 0, null),
                        null === _l)
                        throw Error(i(349));
                    0 !== (30 & ss) || Es(n, t, o)
                }
                return o
            }
            function Es(e, t, n) {
                e.flags |= 16384,
                    e = {
                        getSnapshot: t,
                        value: n
                    },
                    null === (t = as.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    },
                        as.updateQueue = t,
                        t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
            }
            function Ms(e, t, n, r) {
                t.value = n,
                    t.getSnapshot = r,
                    Ns(t) && _s(e)
            }
            function Ts(e, t, n) {
                return n((function () {
                    Ns(t) && _s(e)
                }
                ))
            }
            function Ns(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var n = t();
                    return !ar(e, n)
                } catch (r) {
                    return !0
                }
            }
            function _s(e) {
                var t = Di(e, 1);
                null !== t && nc(t, e, 1, -1)
            }
            function Os(e) {
                var t = ys();
                return "function" === typeof e && (e = e()),
                    t.memoizedState = t.baseState = e,
                    e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: ws,
                        lastRenderedState: e
                    },
                    t.queue = e,
                    e = e.dispatch = Ks.bind(null, as, e),
                    [t.memoizedState, e]
            }
            function As(e, t, n, r) {
                return e = {
                    tag: e,
                    create: t,
                    destroy: n,
                    deps: r,
                    next: null
                },
                    null === (t = as.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    },
                        as.updateQueue = t,
                        t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next,
                            n.next = e,
                            e.next = r,
                            t.lastEffect = e),
                    e
            }
            function Ps() {
                return vs().memoizedState
            }
            function Ls(e, t, n, r) {
                var o = ys();
                as.flags |= e,
                    o.memoizedState = As(1 | t, n, void 0, void 0 === r ? null : r)
            }
            function Rs(e, t, n, r) {
                var o = vs();
                r = void 0 === r ? null : r;
                var i = void 0;
                if (null !== ls) {
                    var s = ls.memoizedState;
                    if (i = s.destroy,
                        null !== r && ms(r, s.deps))
                        return void (o.memoizedState = As(t, n, i, r))
                }
                as.flags |= e,
                    o.memoizedState = As(1 | t, n, i, r)
            }
            function Ds(e, t) {
                return Ls(8390656, 8, e, t)
            }
            function Is(e, t) {
                return Rs(2048, 8, e, t)
            }
            function js(e, t) {
                return Rs(4, 2, e, t)
            }
            function Hs(e, t) {
                return Rs(4, 4, e, t)
            }
            function zs(e, t) {
                return "function" === typeof t ? (e = e(),
                    t(e),
                    function () {
                        t(null)
                    }
                ) : null !== t && void 0 !== t ? (e = e(),
                    t.current = e,
                    function () {
                        t.current = null
                    }
                ) : void 0
            }
            function $s(e, t, n) {
                return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                    Rs(4, 4, zs.bind(null, t, e), n)
            }
            function Bs() { }
            function Vs(e, t) {
                var n = vs();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && ms(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
                    e)
            }
            function Fs(e, t) {
                var n = vs();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && ms(t, r[1]) ? r[0] : (e = e(),
                    n.memoizedState = [e, t],
                    e)
            }
            function Us(e, t, n) {
                return 0 === (21 & ss) ? (e.baseState && (e.baseState = !1,
                    va = !0),
                    e.memoizedState = n) : (ar(n, t) || (n = mt(),
                        as.lanes |= n,
                        Il |= n,
                        e.baseState = !0),
                        t)
            }
            function Ws(e, t) {
                var n = vt;
                vt = 0 !== n && 4 > n ? n : 4,
                    e(!0);
                var r = is.transition;
                is.transition = {};
                try {
                    e(!1),
                        t()
                } finally {
                    vt = n,
                        is.transition = r
                }
            }
            function qs() {
                return vs().memoizedState
            }
            function Gs(e, t, n) {
                var r = tc(e);
                if (n = {
                    lane: r,
                    action: n,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                    Js(e))
                    Zs(t, n);
                else if (null !== (n = Ri(e, t, n, r))) {
                    nc(n, e, r, ec()),
                        Xs(n, t, r)
                }
            }
            function Ks(e, t, n) {
                var r = tc(e)
                    , o = {
                        lane: r,
                        action: n,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    };
                if (Js(e))
                    Zs(t, o);
                else {
                    var i = e.alternate;
                    if (0 === e.lanes && (null === i || 0 === i.lanes) && null !== (i = t.lastRenderedReducer))
                        try {
                            var s = t.lastRenderedState
                                , a = i(s, n);
                            if (o.hasEagerState = !0,
                                o.eagerState = a,
                                ar(a, s)) {
                                var l = t.interleaved;
                                return null === l ? (o.next = o,
                                    Li(t)) : (o.next = l.next,
                                        l.next = o),
                                    void (t.interleaved = o)
                            }
                        } catch (c) { }
                    null !== (n = Ri(e, t, o, r)) && (nc(n, e, r, o = ec()),
                        Xs(n, t, r))
                }
            }
            function Js(e) {
                var t = e.alternate;
                return e === as || null !== t && t === as
            }
            function Zs(e, t) {
                us = ds = !0;
                var n = e.pending;
                null === n ? t.next = t : (t.next = n.next,
                    n.next = t),
                    e.pending = t
            }
            function Xs(e, t, n) {
                if (0 !== (4194240 & n)) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes,
                        t.lanes = n,
                        yt(e, n)
                }
            }
            var Qs = {
                readContext: Ai,
                useCallback: fs,
                useContext: fs,
                useEffect: fs,
                useImperativeHandle: fs,
                useInsertionEffect: fs,
                useLayoutEffect: fs,
                useMemo: fs,
                useReducer: fs,
                useRef: fs,
                useState: fs,
                useDebugValue: fs,
                useDeferredValue: fs,
                useTransition: fs,
                useMutableSource: fs,
                useSyncExternalStore: fs,
                useId: fs,
                unstable_isNewReconciler: !1
            }
                , Ys = {
                    readContext: Ai,
                    useCallback: function (e, t) {
                        return ys().memoizedState = [e, void 0 === t ? null : t],
                            e
                    },
                    useContext: Ai,
                    useEffect: Ds,
                    useImperativeHandle: function (e, t, n) {
                        return n = null !== n && void 0 !== n ? n.concat([e]) : null,
                            Ls(4194308, 4, zs.bind(null, t, e), n)
                    },
                    useLayoutEffect: function (e, t) {
                        return Ls(4194308, 4, e, t)
                    },
                    useInsertionEffect: function (e, t) {
                        return Ls(4, 2, e, t)
                    },
                    useMemo: function (e, t) {
                        var n = ys();
                        return t = void 0 === t ? null : t,
                            e = e(),
                            n.memoizedState = [e, t],
                            e
                    },
                    useReducer: function (e, t, n) {
                        var r = ys();
                        return t = void 0 !== n ? n(t) : t,
                            r.memoizedState = r.baseState = t,
                            e = {
                                pending: null,
                                interleaved: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: e,
                                lastRenderedState: t
                            },
                            r.queue = e,
                            e = e.dispatch = Gs.bind(null, as, e),
                            [r.memoizedState, e]
                    },
                    useRef: function (e) {
                        return e = {
                            current: e
                        },
                            ys().memoizedState = e
                    },
                    useState: Os,
                    useDebugValue: Bs,
                    useDeferredValue: function (e) {
                        return ys().memoizedState = e
                    },
                    useTransition: function () {
                        var e = Os(!1)
                            , t = e[0];
                        return e = Ws.bind(null, e[1]),
                            ys().memoizedState = e,
                            [t, e]
                    },
                    useMutableSource: function () { },
                    useSyncExternalStore: function (e, t, n) {
                        var r = as
                            , o = ys();
                        if (ii) {
                            if (void 0 === n)
                                throw Error(i(407));
                            n = n()
                        } else {
                            if (n = t(),
                                null === _l)
                                throw Error(i(349));
                            0 !== (30 & ss) || Es(r, t, n)
                        }
                        o.memoizedState = n;
                        var s = {
                            value: n,
                            getSnapshot: t
                        };
                        return o.queue = s,
                            Ds(Ts.bind(null, r, s, e), [e]),
                            r.flags |= 2048,
                            As(9, Ms.bind(null, r, s, n, t), void 0, null),
                            n
                    },
                    useId: function () {
                        var e = ys()
                            , t = _l.identifierPrefix;
                        if (ii) {
                            var n = Qo;
                            t = ":" + t + "R" + (n = (Xo & ~(1 << 32 - st(Xo) - 1)).toString(32) + n),
                                0 < (n = hs++) && (t += "H" + n.toString(32)),
                                t += ":"
                        } else
                            t = ":" + t + "r" + (n = ps++).toString(32) + ":";
                        return e.memoizedState = t
                    },
                    unstable_isNewReconciler: !1
                }
                , ea = {
                    readContext: Ai,
                    useCallback: Vs,
                    useContext: Ai,
                    useEffect: Is,
                    useImperativeHandle: $s,
                    useInsertionEffect: js,
                    useLayoutEffect: Hs,
                    useMemo: Fs,
                    useReducer: ks,
                    useRef: Ps,
                    useState: function () {
                        return ks(ws)
                    },
                    useDebugValue: Bs,
                    useDeferredValue: function (e) {
                        return Us(vs(), ls.memoizedState, e)
                    },
                    useTransition: function () {
                        return [ks(ws)[0], vs().memoizedState]
                    },
                    useMutableSource: Ss,
                    useSyncExternalStore: xs,
                    useId: qs,
                    unstable_isNewReconciler: !1
                }
                , ta = {
                    readContext: Ai,
                    useCallback: Vs,
                    useContext: Ai,
                    useEffect: Is,
                    useImperativeHandle: $s,
                    useInsertionEffect: js,
                    useLayoutEffect: Hs,
                    useMemo: Fs,
                    useReducer: Cs,
                    useRef: Ps,
                    useState: function () {
                        return Cs(ws)
                    },
                    useDebugValue: Bs,
                    useDeferredValue: function (e) {
                        var t = vs();
                        return null === ls ? t.memoizedState = e : Us(t, ls.memoizedState, e)
                    },
                    useTransition: function () {
                        return [Cs(ws)[0], vs().memoizedState]
                    },
                    useMutableSource: Ss,
                    useSyncExternalStore: xs,
                    useId: qs,
                    unstable_isNewReconciler: !1
                };
            function na(e, t) {
                if (e && e.defaultProps) {
                    for (var n in t = j({}, t),
                        e = e.defaultProps)
                        void 0 === t[n] && (t[n] = e[n]);
                    return t
                }
                return t
            }
            function ra(e, t, n, r) {
                n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : j({}, t, n),
                    e.memoizedState = n,
                    0 === e.lanes && (e.updateQueue.baseState = n)
            }
            var oa = {
                isMounted: function (e) {
                    return !!(e = e._reactInternals) && Ve(e) === e
                },
                enqueueSetState: function (e, t, n) {
                    e = e._reactInternals;
                    var r = ec()
                        , o = tc(e)
                        , i = zi(r, o);
                    i.payload = t,
                        void 0 !== n && null !== n && (i.callback = n),
                        null !== (t = $i(e, i, o)) && (nc(t, e, o, r),
                            Bi(t, e, o))
                },
                enqueueReplaceState: function (e, t, n) {
                    e = e._reactInternals;
                    var r = ec()
                        , o = tc(e)
                        , i = zi(r, o);
                    i.tag = 1,
                        i.payload = t,
                        void 0 !== n && null !== n && (i.callback = n),
                        null !== (t = $i(e, i, o)) && (nc(t, e, o, r),
                            Bi(t, e, o))
                },
                enqueueForceUpdate: function (e, t) {
                    e = e._reactInternals;
                    var n = ec()
                        , r = tc(e)
                        , o = zi(n, r);
                    o.tag = 2,
                        void 0 !== t && null !== t && (o.callback = t),
                        null !== (t = $i(e, o, r)) && (nc(t, e, r, n),
                            Bi(t, e, r))
                }
            };
            function ia(e, t, n, r, o, i, s) {
                return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, i, s) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(o, i))
            }
            function sa(e, t, n) {
                var r = !1
                    , o = No
                    , i = t.contextType;
                return "object" === typeof i && null !== i ? i = Ai(i) : (o = Lo(t) ? Ao : _o.current,
                    i = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Po(e, o) : No),
                    t = new t(n, i),
                    e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null,
                    t.updater = oa,
                    e.stateNode = t,
                    t._reactInternals = e,
                    r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = o,
                        e.__reactInternalMemoizedMaskedChildContext = i),
                    t
            }
            function aa(e, t, n, r) {
                e = t.state,
                    "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r),
                    "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r),
                    t.state !== e && oa.enqueueReplaceState(t, t.state, null)
            }
            function la(e, t, n, r) {
                var o = e.stateNode;
                o.props = n,
                    o.state = e.memoizedState,
                    o.refs = {},
                    ji(e);
                var i = t.contextType;
                "object" === typeof i && null !== i ? o.context = Ai(i) : (i = Lo(t) ? Ao : _o.current,
                    o.context = Po(e, i)),
                    o.state = e.memoizedState,
                    "function" === typeof (i = t.getDerivedStateFromProps) && (ra(e, t, i, n),
                        o.state = e.memoizedState),
                    "function" === typeof t.getDerivedStateFromProps || "function" === typeof o.getSnapshotBeforeUpdate || "function" !== typeof o.UNSAFE_componentWillMount && "function" !== typeof o.componentWillMount || (t = o.state,
                        "function" === typeof o.componentWillMount && o.componentWillMount(),
                        "function" === typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount(),
                        t !== o.state && oa.enqueueReplaceState(o, o.state, null),
                        Fi(e, n, o, r),
                        o.state = e.memoizedState),
                    "function" === typeof o.componentDidMount && (e.flags |= 4194308)
            }
            function ca(e, t) {
                try {
                    var n = ""
                        , r = t;
                    do {
                        n += B(r),
                            r = r.return
                    } while (r);
                    var o = n
                } catch (i) {
                    o = "\nError generating stack: " + i.message + "\n" + i.stack
                }
                return {
                    value: e,
                    source: t,
                    stack: o,
                    digest: null
                }
            }
            function da(e, t, n) {
                return {
                    value: e,
                    source: null,
                    stack: null != n ? n : null,
                    digest: null != t ? t : null
                }
            }
            function ua(e, t) {
                try {
                    console.error(t.value)
                } catch (n) {
                    setTimeout((function () {
                        throw n
                    }
                    ))
                }
            }
            var ha = "function" === typeof WeakMap ? WeakMap : Map;
            function pa(e, t, n) {
                (n = zi(-1, n)).tag = 3,
                    n.payload = {
                        element: null
                    };
                var r = t.value;
                return n.callback = function () {
                    Ul || (Ul = !0,
                        Wl = r),
                        ua(0, t)
                }
                    ,
                    n
            }
            function fa(e, t, n) {
                (n = zi(-1, n)).tag = 3;
                var r = e.type.getDerivedStateFromError;
                if ("function" === typeof r) {
                    var o = t.value;
                    n.payload = function () {
                        return r(o)
                    }
                        ,
                        n.callback = function () {
                            ua(0, t)
                        }
                }
                var i = e.stateNode;
                return null !== i && "function" === typeof i.componentDidCatch && (n.callback = function () {
                    ua(0, t),
                        "function" !== typeof r && (null === ql ? ql = new Set([this]) : ql.add(this));
                    var e = t.stack;
                    this.componentDidCatch(t.value, {
                        componentStack: null !== e ? e : ""
                    })
                }
                ),
                    n
            }
            function ma(e, t, n) {
                var r = e.pingCache;
                if (null === r) {
                    r = e.pingCache = new ha;
                    var o = new Set;
                    r.set(t, o)
                } else
                    void 0 === (o = r.get(t)) && (o = new Set,
                        r.set(t, o));
                o.has(n) || (o.add(n),
                    e = Ec.bind(null, e, t, n),
                    t.then(e, e))
            }
            function ga(e) {
                do {
                    var t;
                    if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated),
                        t)
                        return e;
                    e = e.return
                } while (null !== e);
                return null
            }
            function ba(e, t, n, r, o) {
                return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128,
                    n.flags |= 131072,
                    n.flags &= -52805,
                    1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = zi(-1, 1)).tag = 2,
                        $i(n, t, 1))),
                    n.lanes |= 1),
                    e) : (e.flags |= 65536,
                        e.lanes = o,
                        e)
            }
            var ya = w.ReactCurrentOwner
                , va = !1;
            function wa(e, t, n, r) {
                t.child = null === e ? Ci(t, null, n, r) : ki(t, e.child, n, r)
            }
            function ka(e, t, n, r, o) {
                n = n.render;
                var i = t.ref;
                return Oi(t, o),
                    r = gs(e, t, n, r, i, o),
                    n = bs(),
                    null === e || va ? (ii && n && ti(t),
                        t.flags |= 1,
                        wa(e, t, r, o),
                        t.child) : (t.updateQueue = e.updateQueue,
                            t.flags &= -2053,
                            e.lanes &= ~o,
                            Ua(e, t, o))
            }
            function Ca(e, t, n, r, o) {
                if (null === e) {
                    var i = n.type;
                    return "function" !== typeof i || Pc(i) || void 0 !== i.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Rc(n.type, null, r, t, t.mode, o)).ref = t.ref,
                        e.return = t,
                        t.child = e) : (t.tag = 15,
                            t.type = i,
                            Sa(e, t, i, r, o))
                }
                if (i = e.child,
                    0 === (e.lanes & o)) {
                    var s = i.memoizedProps;
                    if ((n = null !== (n = n.compare) ? n : lr)(s, r) && e.ref === t.ref)
                        return Ua(e, t, o)
                }
                return t.flags |= 1,
                    (e = Lc(i, r)).ref = t.ref,
                    e.return = t,
                    t.child = e
            }
            function Sa(e, t, n, r, o) {
                if (null !== e) {
                    var i = e.memoizedProps;
                    if (lr(i, r) && e.ref === t.ref) {
                        if (va = !1,
                            t.pendingProps = r = i,
                            0 === (e.lanes & o))
                            return t.lanes = e.lanes,
                                Ua(e, t, o);
                        0 !== (131072 & e.flags) && (va = !0)
                    }
                }
                return Ma(e, t, n, r, o)
            }
            function xa(e, t, n) {
                var r = t.pendingProps
                    , o = r.children
                    , i = null !== e ? e.memoizedState : null;
                if ("hidden" === r.mode)
                    if (0 === (1 & t.mode))
                        t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        },
                            To(Ll, Pl),
                            Pl |= n;
                    else {
                        if (0 === (1073741824 & n))
                            return e = null !== i ? i.baseLanes | n : n,
                                t.lanes = t.childLanes = 1073741824,
                                t.memoizedState = {
                                    baseLanes: e,
                                    cachePool: null,
                                    transitions: null
                                },
                                t.updateQueue = null,
                                To(Ll, Pl),
                                Pl |= e,
                                null;
                        t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        },
                            r = null !== i ? i.baseLanes : n,
                            To(Ll, Pl),
                            Pl |= r
                    }
                else
                    null !== i ? (r = i.baseLanes | n,
                        t.memoizedState = null) : r = n,
                        To(Ll, Pl),
                        Pl |= r;
                return wa(e, t, o, n),
                    t.child
            }
            function Ea(e, t) {
                var n = t.ref;
                (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512,
                    t.flags |= 2097152)
            }
            function Ma(e, t, n, r, o) {
                var i = Lo(n) ? Ao : _o.current;
                return i = Po(t, i),
                    Oi(t, o),
                    n = gs(e, t, n, r, i, o),
                    r = bs(),
                    null === e || va ? (ii && r && ti(t),
                        t.flags |= 1,
                        wa(e, t, n, o),
                        t.child) : (t.updateQueue = e.updateQueue,
                            t.flags &= -2053,
                            e.lanes &= ~o,
                            Ua(e, t, o))
            }
            function Ta(e, t, n, r, o) {
                if (Lo(n)) {
                    var i = !0;
                    jo(t)
                } else
                    i = !1;
                if (Oi(t, o),
                    null === t.stateNode)
                    Fa(e, t),
                        sa(t, n, r),
                        la(t, n, r, o),
                        r = !0;
                else if (null === e) {
                    var s = t.stateNode
                        , a = t.memoizedProps;
                    s.props = a;
                    var l = s.context
                        , c = n.contextType;
                    "object" === typeof c && null !== c ? c = Ai(c) : c = Po(t, c = Lo(n) ? Ao : _o.current);
                    var d = n.getDerivedStateFromProps
                        , u = "function" === typeof d || "function" === typeof s.getSnapshotBeforeUpdate;
                    u || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== r || l !== c) && aa(t, s, r, c),
                        Ii = !1;
                    var h = t.memoizedState;
                    s.state = h,
                        Fi(t, r, s, o),
                        l = t.memoizedState,
                        a !== r || h !== l || Oo.current || Ii ? ("function" === typeof d && (ra(t, n, d, r),
                            l = t.memoizedState),
                            (a = Ii || ia(t, n, a, r, h, l, c)) ? (u || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(),
                                "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()),
                                "function" === typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308),
                                    t.memoizedProps = r,
                                    t.memoizedState = l),
                            s.props = r,
                            s.state = l,
                            s.context = c,
                            r = a) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308),
                                r = !1)
                } else {
                    s = t.stateNode,
                        Hi(e, t),
                        a = t.memoizedProps,
                        c = t.type === t.elementType ? a : na(t.type, a),
                        s.props = c,
                        u = t.pendingProps,
                        h = s.context,
                        "object" === typeof (l = n.contextType) && null !== l ? l = Ai(l) : l = Po(t, l = Lo(n) ? Ao : _o.current);
                    var p = n.getDerivedStateFromProps;
                    (d = "function" === typeof p || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== u || h !== l) && aa(t, s, r, l),
                        Ii = !1,
                        h = t.memoizedState,
                        s.state = h,
                        Fi(t, r, s, o);
                    var f = t.memoizedState;
                    a !== u || h !== f || Oo.current || Ii ? ("function" === typeof p && (ra(t, n, p, r),
                        f = t.memoizedState),
                        (c = Ii || ia(t, n, c, r, h, f, l) || !1) ? (d || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, f, l),
                            "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, f, l)),
                            "function" === typeof s.componentDidUpdate && (t.flags |= 4),
                            "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                                "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                                t.memoizedProps = r,
                                t.memoizedState = f),
                        s.props = r,
                        s.state = f,
                        s.context = l,
                        r = c) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                            "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                            r = !1)
                }
                return Na(e, t, n, r, i, o)
            }
            function Na(e, t, n, r, o, i) {
                Ea(e, t);
                var s = 0 !== (128 & t.flags);
                if (!r && !s)
                    return o && Ho(t, n, !1),
                        Ua(e, t, i);
                r = t.stateNode,
                    ya.current = t;
                var a = s && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                return t.flags |= 1,
                    null !== e && s ? (t.child = ki(t, e.child, null, i),
                        t.child = ki(t, null, a, i)) : wa(e, t, a, i),
                    t.memoizedState = r.state,
                    o && Ho(t, n, !0),
                    t.child
            }
            function _a(e) {
                var t = e.stateNode;
                t.pendingContext ? Do(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Do(0, t.context, !1),
                    Zi(e, t.containerInfo)
            }
            function Oa(e, t, n, r, o) {
                return fi(),
                    mi(o),
                    t.flags |= 256,
                    wa(e, t, n, r),
                    t.child
            }
            var Aa, Pa, La, Ra, Da = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0
            };
            function Ia(e) {
                return {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                }
            }
            function ja(e, t, n) {
                var r, o = t.pendingProps, s = es.current, a = !1, l = 0 !== (128 & t.flags);
                if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)),
                    r ? (a = !0,
                        t.flags &= -129) : null !== e && null === e.memoizedState || (s |= 1),
                    To(es, 1 & s),
                    null === e)
                    return di(t),
                        null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824,
                            null) : (l = o.children,
                                e = o.fallback,
                                a ? (o = t.mode,
                                    a = t.child,
                                    l = {
                                        mode: "hidden",
                                        children: l
                                    },
                                    0 === (1 & o) && null !== a ? (a.childLanes = 0,
                                        a.pendingProps = l) : a = Ic(l, o, 0, null),
                                    e = Dc(e, o, n, null),
                                    a.return = t,
                                    e.return = t,
                                    a.sibling = e,
                                    t.child = a,
                                    t.child.memoizedState = Ia(n),
                                    t.memoizedState = Da,
                                    e) : Ha(t, l));
                if (null !== (s = e.memoizedState) && null !== (r = s.dehydrated))
                    return function (e, t, n, r, o, s, a) {
                        if (n)
                            return 256 & t.flags ? (t.flags &= -257,
                                za(e, t, a, r = da(Error(i(422))))) : null !== t.memoizedState ? (t.child = e.child,
                                    t.flags |= 128,
                                    null) : (s = r.fallback,
                                        o = t.mode,
                                        r = Ic({
                                            mode: "visible",
                                            children: r.children
                                        }, o, 0, null),
                                        (s = Dc(s, o, a, null)).flags |= 2,
                                        r.return = t,
                                        s.return = t,
                                        r.sibling = s,
                                        t.child = r,
                                        0 !== (1 & t.mode) && ki(t, e.child, null, a),
                                        t.child.memoizedState = Ia(a),
                                        t.memoizedState = Da,
                                        s);
                        if (0 === (1 & t.mode))
                            return za(e, t, a, null);
                        if ("$!" === o.data) {
                            if (r = o.nextSibling && o.nextSibling.dataset)
                                var l = r.dgst;
                            return r = l,
                                za(e, t, a, r = da(s = Error(i(419)), r, void 0))
                        }
                        if (l = 0 !== (a & e.childLanes),
                            va || l) {
                            if (null !== (r = _l)) {
                                switch (a & -a) {
                                    case 4:
                                        o = 2;
                                        break;
                                    case 16:
                                        o = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        o = 32;
                                        break;
                                    case 536870912:
                                        o = 268435456;
                                        break;
                                    default:
                                        o = 0
                                }
                                0 !== (o = 0 !== (o & (r.suspendedLanes | a)) ? 0 : o) && o !== s.retryLane && (s.retryLane = o,
                                    Di(e, o),
                                    nc(r, e, o, -1))
                            }
                            return mc(),
                                za(e, t, a, r = da(Error(i(421))))
                        }
                        return "$?" === o.data ? (t.flags |= 128,
                            t.child = e.child,
                            t = Tc.bind(null, e),
                            o._reactRetry = t,
                            null) : (e = s.treeContext,
                                oi = co(o.nextSibling),
                                ri = t,
                                ii = !0,
                                si = null,
                                null !== e && (Ko[Jo++] = Xo,
                                    Ko[Jo++] = Qo,
                                    Ko[Jo++] = Zo,
                                    Xo = e.id,
                                    Qo = e.overflow,
                                    Zo = t),
                                t = Ha(t, r.children),
                                t.flags |= 4096,
                                t)
                    }(e, t, l, o, r, s, n);
                if (a) {
                    a = o.fallback,
                        l = t.mode,
                        r = (s = e.child).sibling;
                    var c = {
                        mode: "hidden",
                        children: o.children
                    };
                    return 0 === (1 & l) && t.child !== s ? ((o = t.child).childLanes = 0,
                        o.pendingProps = c,
                        t.deletions = null) : (o = Lc(s, c)).subtreeFlags = 14680064 & s.subtreeFlags,
                        null !== r ? a = Lc(r, a) : (a = Dc(a, l, n, null)).flags |= 2,
                        a.return = t,
                        o.return = t,
                        o.sibling = a,
                        t.child = o,
                        o = a,
                        a = t.child,
                        l = null === (l = e.child.memoizedState) ? Ia(n) : {
                            baseLanes: l.baseLanes | n,
                            cachePool: null,
                            transitions: l.transitions
                        },
                        a.memoizedState = l,
                        a.childLanes = e.childLanes & ~n,
                        t.memoizedState = Da,
                        o
                }
                return e = (a = e.child).sibling,
                    o = Lc(a, {
                        mode: "visible",
                        children: o.children
                    }),
                    0 === (1 & t.mode) && (o.lanes = n),
                    o.return = t,
                    o.sibling = null,
                    null !== e && (null === (n = t.deletions) ? (t.deletions = [e],
                        t.flags |= 16) : n.push(e)),
                    t.child = o,
                    t.memoizedState = null,
                    o
            }
            function Ha(e, t) {
                return (t = Ic({
                    mode: "visible",
                    children: t
                }, e.mode, 0, null)).return = e,
                    e.child = t
            }
            function za(e, t, n, r) {
                return null !== r && mi(r),
                    ki(t, e.child, null, n),
                    (e = Ha(t, t.pendingProps.children)).flags |= 2,
                    t.memoizedState = null,
                    e
            }
            function $a(e, t, n) {
                e.lanes |= t;
                var r = e.alternate;
                null !== r && (r.lanes |= t),
                    _i(e.return, t, n)
            }
            function Ba(e, t, n, r, o) {
                var i = e.memoizedState;
                null === i ? e.memoizedState = {
                    isBackwards: t,
                    rendering: null,
                    renderingStartTime: 0,
                    last: r,
                    tail: n,
                    tailMode: o
                } : (i.isBackwards = t,
                    i.rendering = null,
                    i.renderingStartTime = 0,
                    i.last = r,
                    i.tail = n,
                    i.tailMode = o)
            }
            function Va(e, t, n) {
                var r = t.pendingProps
                    , o = r.revealOrder
                    , i = r.tail;
                if (wa(e, t, r.children, n),
                    0 !== (2 & (r = es.current)))
                    r = 1 & r | 2,
                        t.flags |= 128;
                else {
                    if (null !== e && 0 !== (128 & e.flags))
                        e: for (e = t.child; null !== e;) {
                            if (13 === e.tag)
                                null !== e.memoizedState && $a(e, n, t);
                            else if (19 === e.tag)
                                $a(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e,
                                    e = e.child;
                                continue
                            }
                            if (e === t)
                                break e;
                            for (; null === e.sibling;) {
                                if (null === e.return || e.return === t)
                                    break e;
                                e = e.return
                            }
                            e.sibling.return = e.return,
                                e = e.sibling
                        }
                    r &= 1
                }
                if (To(es, r),
                    0 === (1 & t.mode))
                    t.memoizedState = null;
                else
                    switch (o) {
                        case "forwards":
                            for (n = t.child,
                                o = null; null !== n;)
                                null !== (e = n.alternate) && null === ts(e) && (o = n),
                                    n = n.sibling;
                            null === (n = o) ? (o = t.child,
                                t.child = null) : (o = n.sibling,
                                    n.sibling = null),
                                Ba(t, !1, o, n, i);
                            break;
                        case "backwards":
                            for (n = null,
                                o = t.child,
                                t.child = null; null !== o;) {
                                if (null !== (e = o.alternate) && null === ts(e)) {
                                    t.child = o;
                                    break
                                }
                                e = o.sibling,
                                    o.sibling = n,
                                    n = o,
                                    o = e
                            }
                            Ba(t, !0, n, null, i);
                            break;
                        case "together":
                            Ba(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                    }
                return t.child
            }
            function Fa(e, t) {
                0 === (1 & t.mode) && null !== e && (e.alternate = null,
                    t.alternate = null,
                    t.flags |= 2)
            }
            function Ua(e, t, n) {
                if (null !== e && (t.dependencies = e.dependencies),
                    Il |= t.lanes,
                    0 === (n & t.childLanes))
                    return null;
                if (null !== e && t.child !== e.child)
                    throw Error(i(153));
                if (null !== t.child) {
                    for (n = Lc(e = t.child, e.pendingProps),
                        t.child = n,
                        n.return = t; null !== e.sibling;)
                        e = e.sibling,
                            (n = n.sibling = Lc(e, e.pendingProps)).return = t;
                    n.sibling = null
                }
                return t.child
            }
            function Wa(e, t) {
                if (!ii)
                    switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t;)
                                null !== t.alternate && (n = t),
                                    t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n;)
                                null !== n.alternate && (r = n),
                                    n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
            }
            function qa(e) {
                var t = null !== e.alternate && e.alternate.child === e.child
                    , n = 0
                    , r = 0;
                if (t)
                    for (var o = e.child; null !== o;)
                        n |= o.lanes | o.childLanes,
                            r |= 14680064 & o.subtreeFlags,
                            r |= 14680064 & o.flags,
                            o.return = e,
                            o = o.sibling;
                else
                    for (o = e.child; null !== o;)
                        n |= o.lanes | o.childLanes,
                            r |= o.subtreeFlags,
                            r |= o.flags,
                            o.return = e,
                            o = o.sibling;
                return e.subtreeFlags |= r,
                    e.childLanes = n,
                    t
            }
            function Ga(e, t, n) {
                var r = t.pendingProps;
                switch (ni(t),
                t.tag) {
                    case 2:
                    case 16:
                    case 15:
                    case 0:
                    case 11:
                    case 7:
                    case 8:
                    case 12:
                    case 9:
                    case 14:
                        return qa(t),
                            null;
                    case 1:
                    case 17:
                        return Lo(t.type) && Ro(),
                            qa(t),
                            null;
                    case 3:
                        return r = t.stateNode,
                            Xi(),
                            Mo(Oo),
                            Mo(_o),
                            rs(),
                            r.pendingContext && (r.context = r.pendingContext,
                                r.pendingContext = null),
                            null !== e && null !== e.child || (hi(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024,
                                null !== si && (sc(si),
                                    si = null))),
                            Pa(e, t),
                            qa(t),
                            null;
                    case 5:
                        Yi(t);
                        var o = Ji(Ki.current);
                        if (n = t.type,
                            null !== e && null != t.stateNode)
                            La(e, t, n, r, o),
                                e.ref !== t.ref && (t.flags |= 512,
                                    t.flags |= 2097152);
                        else {
                            if (!r) {
                                if (null === t.stateNode)
                                    throw Error(i(166));
                                return qa(t),
                                    null
                            }
                            if (e = Ji(qi.current),
                                hi(t)) {
                                r = t.stateNode,
                                    n = t.type;
                                var s = t.memoizedProps;
                                switch (r[po] = t,
                                r[fo] = s,
                                e = 0 !== (1 & t.mode),
                                n) {
                                    case "dialog":
                                        zr("cancel", r),
                                            zr("close", r);
                                        break;
                                    case "iframe":
                                    case "object":
                                    case "embed":
                                        zr("load", r);
                                        break;
                                    case "video":
                                    case "audio":
                                        for (o = 0; o < Dr.length; o++)
                                            zr(Dr[o], r);
                                        break;
                                    case "source":
                                        zr("error", r);
                                        break;
                                    case "img":
                                    case "image":
                                    case "link":
                                        zr("error", r),
                                            zr("load", r);
                                        break;
                                    case "details":
                                        zr("toggle", r);
                                        break;
                                    case "input":
                                        Z(r, s),
                                            zr("invalid", r);
                                        break;
                                    case "select":
                                        r._wrapperState = {
                                            wasMultiple: !!s.multiple
                                        },
                                            zr("invalid", r);
                                        break;
                                    case "textarea":
                                        oe(r, s),
                                            zr("invalid", r)
                                }
                                for (var l in ye(n, s),
                                    o = null,
                                    s)
                                    if (s.hasOwnProperty(l)) {
                                        var c = s[l];
                                        "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== s.suppressHydrationWarning && Qr(r.textContent, c, e),
                                            o = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== s.suppressHydrationWarning && Qr(r.textContent, c, e),
                                                o = ["children", "" + c]) : a.hasOwnProperty(l) && null != c && "onScroll" === l && zr("scroll", r)
                                    }
                                switch (n) {
                                    case "input":
                                        q(r),
                                            Y(r, s, !0);
                                        break;
                                    case "textarea":
                                        q(r),
                                            se(r);
                                        break;
                                    case "select":
                                    case "option":
                                        break;
                                    default:
                                        "function" === typeof s.onClick && (r.onclick = Yr)
                                }
                                r = o,
                                    t.updateQueue = r,
                                    null !== r && (t.flags |= 4)
                            } else {
                                l = 9 === o.nodeType ? o : o.ownerDocument,
                                    "http://www.w3.org/1999/xhtml" === e && (e = ae(n)),
                                    "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>",
                                        e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, {
                                            is: r.is
                                        }) : (e = l.createElement(n),
                                            "select" === n && (l = e,
                                                r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n),
                                    e[po] = t,
                                    e[fo] = r,
                                    Aa(e, t, !1, !1),
                                    t.stateNode = e;
                                e: {
                                    switch (l = ve(n, r),
                                    n) {
                                        case "dialog":
                                            zr("cancel", e),
                                                zr("close", e),
                                                o = r;
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            zr("load", e),
                                                o = r;
                                            break;
                                        case "video":
                                        case "audio":
                                            for (o = 0; o < Dr.length; o++)
                                                zr(Dr[o], e);
                                            o = r;
                                            break;
                                        case "source":
                                            zr("error", e),
                                                o = r;
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            zr("error", e),
                                                zr("load", e),
                                                o = r;
                                            break;
                                        case "details":
                                            zr("toggle", e),
                                                o = r;
                                            break;
                                        case "input":
                                            Z(e, r),
                                                o = J(e, r),
                                                zr("invalid", e);
                                            break;
                                        case "option":
                                        default:
                                            o = r;
                                            break;
                                        case "select":
                                            e._wrapperState = {
                                                wasMultiple: !!r.multiple
                                            },
                                                o = j({}, r, {
                                                    value: void 0
                                                }),
                                                zr("invalid", e);
                                            break;
                                        case "textarea":
                                            oe(e, r),
                                                o = re(e, r),
                                                zr("invalid", e)
                                    }
                                    for (s in ye(n, o),
                                        c = o)
                                        if (c.hasOwnProperty(s)) {
                                            var d = c[s];
                                            "style" === s ? ge(e, d) : "dangerouslySetInnerHTML" === s ? null != (d = d ? d.__html : void 0) && ue(e, d) : "children" === s ? "string" === typeof d ? ("textarea" !== n || "" !== d) && he(e, d) : "number" === typeof d && he(e, "" + d) : "suppressContentEditableWarning" !== s && "suppressHydrationWarning" !== s && "autoFocus" !== s && (a.hasOwnProperty(s) ? null != d && "onScroll" === s && zr("scroll", e) : null != d && v(e, s, d, l))
                                        }
                                    switch (n) {
                                        case "input":
                                            q(e),
                                                Y(e, r, !1);
                                            break;
                                        case "textarea":
                                            q(e),
                                                se(e);
                                            break;
                                        case "option":
                                            null != r.value && e.setAttribute("value", "" + U(r.value));
                                            break;
                                        case "select":
                                            e.multiple = !!r.multiple,
                                                null != (s = r.value) ? ne(e, !!r.multiple, s, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                            break;
                                        default:
                                            "function" === typeof o.onClick && (e.onclick = Yr)
                                    }
                                    switch (n) {
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            r = !!r.autoFocus;
                                            break e;
                                        case "img":
                                            r = !0;
                                            break e;
                                        default:
                                            r = !1
                                    }
                                }
                                r && (t.flags |= 4)
                            }
                            null !== t.ref && (t.flags |= 512,
                                t.flags |= 2097152)
                        }
                        return qa(t),
                            null;
                    case 6:
                        if (e && null != t.stateNode)
                            Ra(e, t, e.memoizedProps, r);
                        else {
                            if ("string" !== typeof r && null === t.stateNode)
                                throw Error(i(166));
                            if (n = Ji(Ki.current),
                                Ji(qi.current),
                                hi(t)) {
                                if (r = t.stateNode,
                                    n = t.memoizedProps,
                                    r[po] = t,
                                    (s = r.nodeValue !== n) && null !== (e = ri))
                                    switch (e.tag) {
                                        case 3:
                                            Qr(r.nodeValue, n, 0 !== (1 & e.mode));
                                            break;
                                        case 5:
                                            !0 !== e.memoizedProps.suppressHydrationWarning && Qr(r.nodeValue, n, 0 !== (1 & e.mode))
                                    }
                                s && (t.flags |= 4)
                            } else
                                (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[po] = t,
                                    t.stateNode = r
                        }
                        return qa(t),
                            null;
                    case 13:
                        if (Mo(es),
                            r = t.memoizedState,
                            null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                            if (ii && null !== oi && 0 !== (1 & t.mode) && 0 === (128 & t.flags))
                                pi(),
                                    fi(),
                                    t.flags |= 98560,
                                    s = !1;
                            else if (s = hi(t),
                                null !== r && null !== r.dehydrated) {
                                if (null === e) {
                                    if (!s)
                                        throw Error(i(318));
                                    if (!(s = null !== (s = t.memoizedState) ? s.dehydrated : null))
                                        throw Error(i(317));
                                    s[po] = t
                                } else
                                    fi(),
                                        0 === (128 & t.flags) && (t.memoizedState = null),
                                        t.flags |= 4;
                                qa(t),
                                    s = !1
                            } else
                                null !== si && (sc(si),
                                    si = null),
                                    s = !0;
                            if (!s)
                                return 65536 & t.flags ? t : null
                        }
                        return 0 !== (128 & t.flags) ? (t.lanes = n,
                            t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192,
                                0 !== (1 & t.mode) && (null === e || 0 !== (1 & es.current) ? 0 === Rl && (Rl = 3) : mc())),
                                null !== t.updateQueue && (t.flags |= 4),
                                qa(t),
                                null);
                    case 4:
                        return Xi(),
                            Pa(e, t),
                            null === e && Vr(t.stateNode.containerInfo),
                            qa(t),
                            null;
                    case 10:
                        return Ni(t.type._context),
                            qa(t),
                            null;
                    case 19:
                        if (Mo(es),
                            null === (s = t.memoizedState))
                            return qa(t),
                                null;
                        if (r = 0 !== (128 & t.flags),
                            null === (l = s.rendering))
                            if (r)
                                Wa(s, !1);
                            else {
                                if (0 !== Rl || null !== e && 0 !== (128 & e.flags))
                                    for (e = t.child; null !== e;) {
                                        if (null !== (l = ts(e))) {
                                            for (t.flags |= 128,
                                                Wa(s, !1),
                                                null !== (r = l.updateQueue) && (t.updateQueue = r,
                                                    t.flags |= 4),
                                                t.subtreeFlags = 0,
                                                r = n,
                                                n = t.child; null !== n;)
                                                e = r,
                                                    (s = n).flags &= 14680066,
                                                    null === (l = s.alternate) ? (s.childLanes = 0,
                                                        s.lanes = e,
                                                        s.child = null,
                                                        s.subtreeFlags = 0,
                                                        s.memoizedProps = null,
                                                        s.memoizedState = null,
                                                        s.updateQueue = null,
                                                        s.dependencies = null,
                                                        s.stateNode = null) : (s.childLanes = l.childLanes,
                                                            s.lanes = l.lanes,
                                                            s.child = l.child,
                                                            s.subtreeFlags = 0,
                                                            s.deletions = null,
                                                            s.memoizedProps = l.memoizedProps,
                                                            s.memoizedState = l.memoizedState,
                                                            s.updateQueue = l.updateQueue,
                                                            s.type = l.type,
                                                            e = l.dependencies,
                                                            s.dependencies = null === e ? null : {
                                                                lanes: e.lanes,
                                                                firstContext: e.firstContext
                                                            }),
                                                    n = n.sibling;
                                            return To(es, 1 & es.current | 2),
                                                t.child
                                        }
                                        e = e.sibling
                                    }
                                null !== s.tail && Xe() > Vl && (t.flags |= 128,
                                    r = !0,
                                    Wa(s, !1),
                                    t.lanes = 4194304)
                            }
                        else {
                            if (!r)
                                if (null !== (e = ts(l))) {
                                    if (t.flags |= 128,
                                        r = !0,
                                        null !== (n = e.updateQueue) && (t.updateQueue = n,
                                            t.flags |= 4),
                                        Wa(s, !0),
                                        null === s.tail && "hidden" === s.tailMode && !l.alternate && !ii)
                                        return qa(t),
                                            null
                                } else
                                    2 * Xe() - s.renderingStartTime > Vl && 1073741824 !== n && (t.flags |= 128,
                                        r = !0,
                                        Wa(s, !1),
                                        t.lanes = 4194304);
                            s.isBackwards ? (l.sibling = t.child,
                                t.child = l) : (null !== (n = s.last) ? n.sibling = l : t.child = l,
                                    s.last = l)
                        }
                        return null !== s.tail ? (t = s.tail,
                            s.rendering = t,
                            s.tail = t.sibling,
                            s.renderingStartTime = Xe(),
                            t.sibling = null,
                            n = es.current,
                            To(es, r ? 1 & n | 2 : 1 & n),
                            t) : (qa(t),
                                null);
                    case 22:
                    case 23:
                        return uc(),
                            r = null !== t.memoizedState,
                            null !== e && null !== e.memoizedState !== r && (t.flags |= 8192),
                            r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Pl) && (qa(t),
                                6 & t.subtreeFlags && (t.flags |= 8192)) : qa(t),
                            null;
                    case 24:
                    case 25:
                        return null
                }
                throw Error(i(156, t.tag))
            }
            function Ka(e, t) {
                switch (ni(t),
                t.tag) {
                    case 1:
                        return Lo(t.type) && Ro(),
                            65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                                t) : null;
                    case 3:
                        return Xi(),
                            Mo(Oo),
                            Mo(_o),
                            rs(),
                            0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128,
                                t) : null;
                    case 5:
                        return Yi(t),
                            null;
                    case 13:
                        if (Mo(es),
                            null !== (e = t.memoizedState) && null !== e.dehydrated) {
                            if (null === t.alternate)
                                throw Error(i(340));
                            fi()
                        }
                        return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                            t) : null;
                    case 19:
                        return Mo(es),
                            null;
                    case 4:
                        return Xi(),
                            null;
                    case 10:
                        return Ni(t.type._context),
                            null;
                    case 22:
                    case 23:
                        return uc(),
                            null;
                    default:
                        return null
                }
            }
            Aa = function (e, t) {
                for (var n = t.child; null !== n;) {
                    if (5 === n.tag || 6 === n.tag)
                        e.appendChild(n.stateNode);
                    else if (4 !== n.tag && null !== n.child) {
                        n.child.return = n,
                            n = n.child;
                        continue
                    }
                    if (n === t)
                        break;
                    for (; null === n.sibling;) {
                        if (null === n.return || n.return === t)
                            return;
                        n = n.return
                    }
                    n.sibling.return = n.return,
                        n = n.sibling
                }
            }
                ,
                Pa = function () { }
                ,
                La = function (e, t, n, r) {
                    var o = e.memoizedProps;
                    if (o !== r) {
                        e = t.stateNode,
                            Ji(qi.current);
                        var i, s = null;
                        switch (n) {
                            case "input":
                                o = J(e, o),
                                    r = J(e, r),
                                    s = [];
                                break;
                            case "select":
                                o = j({}, o, {
                                    value: void 0
                                }),
                                    r = j({}, r, {
                                        value: void 0
                                    }),
                                    s = [];
                                break;
                            case "textarea":
                                o = re(e, o),
                                    r = re(e, r),
                                    s = [];
                                break;
                            default:
                                "function" !== typeof o.onClick && "function" === typeof r.onClick && (e.onclick = Yr)
                        }
                        for (d in ye(n, r),
                            n = null,
                            o)
                            if (!r.hasOwnProperty(d) && o.hasOwnProperty(d) && null != o[d])
                                if ("style" === d) {
                                    var l = o[d];
                                    for (i in l)
                                        l.hasOwnProperty(i) && (n || (n = {}),
                                            n[i] = "")
                                } else
                                    "dangerouslySetInnerHTML" !== d && "children" !== d && "suppressContentEditableWarning" !== d && "suppressHydrationWarning" !== d && "autoFocus" !== d && (a.hasOwnProperty(d) ? s || (s = []) : (s = s || []).push(d, null));
                        for (d in r) {
                            var c = r[d];
                            if (l = null != o ? o[d] : void 0,
                                r.hasOwnProperty(d) && c !== l && (null != c || null != l))
                                if ("style" === d)
                                    if (l) {
                                        for (i in l)
                                            !l.hasOwnProperty(i) || c && c.hasOwnProperty(i) || (n || (n = {}),
                                                n[i] = "");
                                        for (i in c)
                                            c.hasOwnProperty(i) && l[i] !== c[i] && (n || (n = {}),
                                                n[i] = c[i])
                                    } else
                                        n || (s || (s = []),
                                            s.push(d, n)),
                                            n = c;
                                else
                                    "dangerouslySetInnerHTML" === d ? (c = c ? c.__html : void 0,
                                        l = l ? l.__html : void 0,
                                        null != c && l !== c && (s = s || []).push(d, c)) : "children" === d ? "string" !== typeof c && "number" !== typeof c || (s = s || []).push(d, "" + c) : "suppressContentEditableWarning" !== d && "suppressHydrationWarning" !== d && (a.hasOwnProperty(d) ? (null != c && "onScroll" === d && zr("scroll", e),
                                            s || l === c || (s = [])) : (s = s || []).push(d, c))
                        }
                        n && (s = s || []).push("style", n);
                        var d = s;
                        (t.updateQueue = d) && (t.flags |= 4)
                    }
                }
                ,
                Ra = function (e, t, n, r) {
                    n !== r && (t.flags |= 4)
                }
                ;
            var Ja = !1
                , Za = !1
                , Xa = "function" === typeof WeakSet ? WeakSet : Set
                , Qa = null;
            function Ya(e, t) {
                var n = e.ref;
                if (null !== n)
                    if ("function" === typeof n)
                        try {
                            n(null)
                        } catch (r) {
                            xc(e, t, r)
                        }
                    else
                        n.current = null
            }
            function el(e, t, n) {
                try {
                    n()
                } catch (r) {
                    xc(e, t, r)
                }
            }
            var tl = !1;
            function nl(e, t, n) {
                var r = t.updateQueue;
                if (null !== (r = null !== r ? r.lastEffect : null)) {
                    var o = r = r.next;
                    do {
                        if ((o.tag & e) === e) {
                            var i = o.destroy;
                            o.destroy = void 0,
                                void 0 !== i && el(t, n, i)
                        }
                        o = o.next
                    } while (o !== r)
                }
            }
            function rl(e, t) {
                if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                    var n = t = t.next;
                    do {
                        if ((n.tag & e) === e) {
                            var r = n.create;
                            n.destroy = r()
                        }
                        n = n.next
                    } while (n !== t)
                }
            }
            function ol(e) {
                var t = e.ref;
                if (null !== t) {
                    var n = e.stateNode;
                    e.tag,
                        e = n,
                        "function" === typeof t ? t(e) : t.current = e
                }
            }
            function il(e) {
                var t = e.alternate;
                null !== t && (e.alternate = null,
                    il(t)),
                    e.child = null,
                    e.deletions = null,
                    e.sibling = null,
                    5 === e.tag && (null !== (t = e.stateNode) && (delete t[po],
                        delete t[fo],
                        delete t[go],
                        delete t[bo],
                        delete t[yo])),
                    e.stateNode = null,
                    e.return = null,
                    e.dependencies = null,
                    e.memoizedProps = null,
                    e.memoizedState = null,
                    e.pendingProps = null,
                    e.stateNode = null,
                    e.updateQueue = null
            }
            function sl(e) {
                return 5 === e.tag || 3 === e.tag || 4 === e.tag
            }
            function al(e) {
                e: for (; ;) {
                    for (; null === e.sibling;) {
                        if (null === e.return || sl(e.return))
                            return null;
                        e = e.return
                    }
                    for (e.sibling.return = e.return,
                        e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                        if (2 & e.flags)
                            continue e;
                        if (null === e.child || 4 === e.tag)
                            continue e;
                        e.child.return = e,
                            e = e.child
                    }
                    if (!(2 & e.flags))
                        return e.stateNode
                }
            }
            function ll(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r)
                    e = e.stateNode,
                        t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e),
                            null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Yr));
                else if (4 !== r && null !== (e = e.child))
                    for (ll(e, t, n),
                        e = e.sibling; null !== e;)
                        ll(e, t, n),
                            e = e.sibling
            }
            function cl(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r)
                    e = e.stateNode,
                        t ? n.insertBefore(e, t) : n.appendChild(e);
                else if (4 !== r && null !== (e = e.child))
                    for (cl(e, t, n),
                        e = e.sibling; null !== e;)
                        cl(e, t, n),
                            e = e.sibling
            }
            var dl = null
                , ul = !1;
            function hl(e, t, n) {
                for (n = n.child; null !== n;)
                    pl(e, t, n),
                        n = n.sibling
            }
            function pl(e, t, n) {
                if (it && "function" === typeof it.onCommitFiberUnmount)
                    try {
                        it.onCommitFiberUnmount(ot, n)
                    } catch (a) { }
                switch (n.tag) {
                    case 5:
                        Za || Ya(n, t);
                    case 6:
                        var r = dl
                            , o = ul;
                        dl = null,
                            hl(e, t, n),
                            ul = o,
                            null !== (dl = r) && (ul ? (e = dl,
                                n = n.stateNode,
                                8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode));
                        break;
                    case 18:
                        null !== dl && (ul ? (e = dl,
                            n = n.stateNode,
                            8 === e.nodeType ? lo(e.parentNode, n) : 1 === e.nodeType && lo(e, n),
                            Vt(e)) : lo(dl, n.stateNode));
                        break;
                    case 4:
                        r = dl,
                            o = ul,
                            dl = n.stateNode.containerInfo,
                            ul = !0,
                            hl(e, t, n),
                            dl = r,
                            ul = o;
                        break;
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (!Za && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                            o = r = r.next;
                            do {
                                var i = o
                                    , s = i.destroy;
                                i = i.tag,
                                    void 0 !== s && (0 !== (2 & i) || 0 !== (4 & i)) && el(n, t, s),
                                    o = o.next
                            } while (o !== r)
                        }
                        hl(e, t, n);
                        break;
                    case 1:
                        if (!Za && (Ya(n, t),
                            "function" === typeof (r = n.stateNode).componentWillUnmount))
                            try {
                                r.props = n.memoizedProps,
                                    r.state = n.memoizedState,
                                    r.componentWillUnmount()
                            } catch (a) {
                                xc(n, t, a)
                            }
                        hl(e, t, n);
                        break;
                    case 21:
                        hl(e, t, n);
                        break;
                    case 22:
                        1 & n.mode ? (Za = (r = Za) || null !== n.memoizedState,
                            hl(e, t, n),
                            Za = r) : hl(e, t, n);
                        break;
                    default:
                        hl(e, t, n)
                }
            }
            function fl(e) {
                var t = e.updateQueue;
                if (null !== t) {
                    e.updateQueue = null;
                    var n = e.stateNode;
                    null === n && (n = e.stateNode = new Xa),
                        t.forEach((function (t) {
                            var r = Nc.bind(null, e, t);
                            n.has(t) || (n.add(t),
                                t.then(r, r))
                        }
                        ))
                }
            }
            function ml(e, t) {
                var n = t.deletions;
                if (null !== n)
                    for (var r = 0; r < n.length; r++) {
                        var o = n[r];
                        try {
                            var s = e
                                , a = t
                                , l = a;
                            e: for (; null !== l;) {
                                switch (l.tag) {
                                    case 5:
                                        dl = l.stateNode,
                                            ul = !1;
                                        break e;
                                    case 3:
                                    case 4:
                                        dl = l.stateNode.containerInfo,
                                            ul = !0;
                                        break e
                                }
                                l = l.return
                            }
                            if (null === dl)
                                throw Error(i(160));
                            pl(s, a, o),
                                dl = null,
                                ul = !1;
                            var c = o.alternate;
                            null !== c && (c.return = null),
                                o.return = null
                        } catch (d) {
                            xc(o, t, d)
                        }
                    }
                if (12854 & t.subtreeFlags)
                    for (t = t.child; null !== t;)
                        gl(t, e),
                            t = t.sibling
            }
            function gl(e, t) {
                var n = e.alternate
                    , r = e.flags;
                switch (e.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (ml(t, e),
                            bl(e),
                            4 & r) {
                            try {
                                nl(3, e, e.return),
                                    rl(3, e)
                            } catch (g) {
                                xc(e, e.return, g)
                            }
                            try {
                                nl(5, e, e.return)
                            } catch (g) {
                                xc(e, e.return, g)
                            }
                        }
                        break;
                    case 1:
                        ml(t, e),
                            bl(e),
                            512 & r && null !== n && Ya(n, n.return);
                        break;
                    case 5:
                        if (ml(t, e),
                            bl(e),
                            512 & r && null !== n && Ya(n, n.return),
                            32 & e.flags) {
                            var o = e.stateNode;
                            try {
                                he(o, "")
                            } catch (g) {
                                xc(e, e.return, g)
                            }
                        }
                        if (4 & r && null != (o = e.stateNode)) {
                            var s = e.memoizedProps
                                , a = null !== n ? n.memoizedProps : s
                                , l = e.type
                                , c = e.updateQueue;
                            if (e.updateQueue = null,
                                null !== c)
                                try {
                                    "input" === l && "radio" === s.type && null != s.name && X(o, s),
                                        ve(l, a);
                                    var d = ve(l, s);
                                    for (a = 0; a < c.length; a += 2) {
                                        var u = c[a]
                                            , h = c[a + 1];
                                        "style" === u ? ge(o, h) : "dangerouslySetInnerHTML" === u ? ue(o, h) : "children" === u ? he(o, h) : v(o, u, h, d)
                                    }
                                    switch (l) {
                                        case "input":
                                            Q(o, s);
                                            break;
                                        case "textarea":
                                            ie(o, s);
                                            break;
                                        case "select":
                                            var p = o._wrapperState.wasMultiple;
                                            o._wrapperState.wasMultiple = !!s.multiple;
                                            var f = s.value;
                                            null != f ? ne(o, !!s.multiple, f, !1) : p !== !!s.multiple && (null != s.defaultValue ? ne(o, !!s.multiple, s.defaultValue, !0) : ne(o, !!s.multiple, s.multiple ? [] : "", !1))
                                    }
                                    o[fo] = s
                                } catch (g) {
                                    xc(e, e.return, g)
                                }
                        }
                        break;
                    case 6:
                        if (ml(t, e),
                            bl(e),
                            4 & r) {
                            if (null === e.stateNode)
                                throw Error(i(162));
                            o = e.stateNode,
                                s = e.memoizedProps;
                            try {
                                o.nodeValue = s
                            } catch (g) {
                                xc(e, e.return, g)
                            }
                        }
                        break;
                    case 3:
                        if (ml(t, e),
                            bl(e),
                            4 & r && null !== n && n.memoizedState.isDehydrated)
                            try {
                                Vt(t.containerInfo)
                            } catch (g) {
                                xc(e, e.return, g)
                            }
                        break;
                    case 4:
                    default:
                        ml(t, e),
                            bl(e);
                        break;
                    case 13:
                        ml(t, e),
                            bl(e),
                            8192 & (o = e.child).flags && (s = null !== o.memoizedState,
                                o.stateNode.isHidden = s,
                                !s || null !== o.alternate && null !== o.alternate.memoizedState || (Bl = Xe())),
                            4 & r && fl(e);
                        break;
                    case 22:
                        if (u = null !== n && null !== n.memoizedState,
                            1 & e.mode ? (Za = (d = Za) || u,
                                ml(t, e),
                                Za = d) : ml(t, e),
                            bl(e),
                            8192 & r) {
                            if (d = null !== e.memoizedState,
                                (e.stateNode.isHidden = d) && !u && 0 !== (1 & e.mode))
                                for (Qa = e,
                                    u = e.child; null !== u;) {
                                    for (h = Qa = u; null !== Qa;) {
                                        switch (f = (p = Qa).child,
                                        p.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                nl(4, p, p.return);
                                                break;
                                            case 1:
                                                Ya(p, p.return);
                                                var m = p.stateNode;
                                                if ("function" === typeof m.componentWillUnmount) {
                                                    r = p,
                                                        n = p.return;
                                                    try {
                                                        t = r,
                                                            m.props = t.memoizedProps,
                                                            m.state = t.memoizedState,
                                                            m.componentWillUnmount()
                                                    } catch (g) {
                                                        xc(r, n, g)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                Ya(p, p.return);
                                                break;
                                            case 22:
                                                if (null !== p.memoizedState) {
                                                    kl(h);
                                                    continue
                                                }
                                        }
                                        null !== f ? (f.return = p,
                                            Qa = f) : kl(h)
                                    }
                                    u = u.sibling
                                }
                            e: for (u = null,
                                h = e; ;) {
                                if (5 === h.tag) {
                                    if (null === u) {
                                        u = h;
                                        try {
                                            o = h.stateNode,
                                                d ? "function" === typeof (s = o.style).setProperty ? s.setProperty("display", "none", "important") : s.display = "none" : (l = h.stateNode,
                                                    a = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null,
                                                    l.style.display = me("display", a))
                                        } catch (g) {
                                            xc(e, e.return, g)
                                        }
                                    }
                                } else if (6 === h.tag) {
                                    if (null === u)
                                        try {
                                            h.stateNode.nodeValue = d ? "" : h.memoizedProps
                                        } catch (g) {
                                            xc(e, e.return, g)
                                        }
                                } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                    h.child.return = h,
                                        h = h.child;
                                    continue
                                }
                                if (h === e)
                                    break e;
                                for (; null === h.sibling;) {
                                    if (null === h.return || h.return === e)
                                        break e;
                                    u === h && (u = null),
                                        h = h.return
                                }
                                u === h && (u = null),
                                    h.sibling.return = h.return,
                                    h = h.sibling
                            }
                        }
                        break;
                    case 19:
                        ml(t, e),
                            bl(e),
                            4 & r && fl(e);
                    case 21:
                }
            }
            function bl(e) {
                var t = e.flags;
                if (2 & t) {
                    try {
                        e: {
                            for (var n = e.return; null !== n;) {
                                if (sl(n)) {
                                    var r = n;
                                    break e
                                }
                                n = n.return
                            }
                            throw Error(i(160))
                        }
                        switch (r.tag) {
                            case 5:
                                var o = r.stateNode;
                                32 & r.flags && (he(o, ""),
                                    r.flags &= -33),
                                    cl(e, al(e), o);
                                break;
                            case 3:
                            case 4:
                                var s = r.stateNode.containerInfo;
                                ll(e, al(e), s);
                                break;
                            default:
                                throw Error(i(161))
                        }
                    } catch (a) {
                        xc(e, e.return, a)
                    }
                    e.flags &= -3
                }
                4096 & t && (e.flags &= -4097)
            }
            function yl(e, t, n) {
                Qa = e,
                    vl(e, t, n)
            }
            function vl(e, t, n) {
                for (var r = 0 !== (1 & e.mode); null !== Qa;) {
                    var o = Qa
                        , i = o.child;
                    if (22 === o.tag && r) {
                        var s = null !== o.memoizedState || Ja;
                        if (!s) {
                            var a = o.alternate
                                , l = null !== a && null !== a.memoizedState || Za;
                            a = Ja;
                            var c = Za;
                            if (Ja = s,
                                (Za = l) && !c)
                                for (Qa = o; null !== Qa;)
                                    l = (s = Qa).child,
                                        22 === s.tag && null !== s.memoizedState ? Cl(o) : null !== l ? (l.return = s,
                                            Qa = l) : Cl(o);
                            for (; null !== i;)
                                Qa = i,
                                    vl(i, t, n),
                                    i = i.sibling;
                            Qa = o,
                                Ja = a,
                                Za = c
                        }
                        wl(e)
                    } else
                        0 !== (8772 & o.subtreeFlags) && null !== i ? (i.return = o,
                            Qa = i) : wl(e)
                }
            }
            function wl(e) {
                for (; null !== Qa;) {
                    var t = Qa;
                    if (0 !== (8772 & t.flags)) {
                        var n = t.alternate;
                        try {
                            if (0 !== (8772 & t.flags))
                                switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Za || rl(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !Za)
                                            if (null === n)
                                                r.componentDidMount();
                                            else {
                                                var o = t.elementType === t.type ? n.memoizedProps : na(t.type, n.memoizedProps);
                                                r.componentDidUpdate(o, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var s = t.updateQueue;
                                        null !== s && Ui(t, s, r);
                                        break;
                                    case 3:
                                        var a = t.updateQueue;
                                        if (null !== a) {
                                            if (n = null,
                                                null !== t.child)
                                                switch (t.child.tag) {
                                                    case 5:
                                                    case 1:
                                                        n = t.child.stateNode
                                                }
                                            Ui(t, a, n)
                                        }
                                        break;
                                    case 5:
                                        var l = t.stateNode;
                                        if (null === n && 4 & t.flags) {
                                            n = l;
                                            var c = t.memoizedProps;
                                            switch (t.type) {
                                                case "button":
                                                case "input":
                                                case "select":
                                                case "textarea":
                                                    c.autoFocus && n.focus();
                                                    break;
                                                case "img":
                                                    c.src && (n.src = c.src)
                                            }
                                        }
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                    case 25:
                                        break;
                                    case 13:
                                        if (null === t.memoizedState) {
                                            var d = t.alternate;
                                            if (null !== d) {
                                                var u = d.memoizedState;
                                                if (null !== u) {
                                                    var h = u.dehydrated;
                                                    null !== h && Vt(h)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(i(163))
                                }
                            Za || 512 & t.flags && ol(t)
                        } catch (OA) {
                            xc(t, t.return, OA)
                        }
                    }
                    if (t === e) {
                        Qa = null;
                        break
                    }
                    if (null !== (n = t.sibling)) {
                        n.return = t.return,
                            Qa = n;
                        break
                    }
                    Qa = t.return
                }
            }
            function kl(e) {
                for (; null !== Qa;) {
                    var t = Qa;
                    if (t === e) {
                        Qa = null;
                        break
                    }
                    var n = t.sibling;
                    if (null !== n) {
                        n.return = t.return,
                            Qa = n;
                        break
                    }
                    Qa = t.return
                }
            }
            function Cl(e) {
                for (; null !== Qa;) {
                    var t = Qa;
                    try {
                        switch (t.tag) {
                            case 0:
                            case 11:
                            case 15:
                                var n = t.return;
                                try {
                                    rl(4, t)
                                } catch (l) {
                                    xc(t, n, l)
                                }
                                break;
                            case 1:
                                var r = t.stateNode;
                                if ("function" === typeof r.componentDidMount) {
                                    var o = t.return;
                                    try {
                                        r.componentDidMount()
                                    } catch (l) {
                                        xc(t, o, l)
                                    }
                                }
                                var i = t.return;
                                try {
                                    ol(t)
                                } catch (l) {
                                    xc(t, i, l)
                                }
                                break;
                            case 5:
                                var s = t.return;
                                try {
                                    ol(t)
                                } catch (l) {
                                    xc(t, s, l)
                                }
                        }
                    } catch (l) {
                        xc(t, t.return, l)
                    }
                    if (t === e) {
                        Qa = null;
                        break
                    }
                    var a = t.sibling;
                    if (null !== a) {
                        a.return = t.return,
                            Qa = a;
                        break
                    }
                    Qa = t.return
                }
            }
            var Sl, xl = Math.ceil, El = w.ReactCurrentDispatcher, Ml = w.ReactCurrentOwner, Tl = w.ReactCurrentBatchConfig, Nl = 0, _l = null, Ol = null, Al = 0, Pl = 0, Ll = Eo(0), Rl = 0, Dl = null, Il = 0, jl = 0, Hl = 0, zl = null, $l = null, Bl = 0, Vl = 1 / 0, Fl = null, Ul = !1, Wl = null, ql = null, Gl = !1, Kl = null, Jl = 0, Zl = 0, Xl = null, Ql = -1, Yl = 0;
            function ec() {
                return 0 !== (6 & Nl) ? Xe() : -1 !== Ql ? Ql : Ql = Xe()
            }
            function tc(e) {
                return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Nl) && 0 !== Al ? Al & -Al : null !== gi.transition ? (0 === Yl && (Yl = mt()),
                    Yl) : 0 !== (e = vt) ? e : e = void 0 === (e = window.event) ? 16 : Zt(e.type)
            }
            function nc(e, t, n, r) {
                if (50 < Zl)
                    throw Zl = 0,
                    Xl = null,
                    Error(i(185));
                bt(e, n, r),
                    0 !== (2 & Nl) && e === _l || (e === _l && (0 === (2 & Nl) && (jl |= n),
                        4 === Rl && ac(e, Al)),
                        rc(e, r),
                        1 === n && 0 === Nl && 0 === (1 & t.mode) && (Vl = Xe() + 500,
                            $o && Fo()))
            }
            function rc(e, t) {
                var n = e.callbackNode;
                !function (e, t) {
                    for (var n = e.suspendedLanes, r = e.pingedLanes, o = e.expirationTimes, i = e.pendingLanes; 0 < i;) {
                        var s = 31 - st(i)
                            , a = 1 << s
                            , l = o[s];
                        -1 === l ? 0 !== (a & n) && 0 === (a & r) || (o[s] = pt(a, t)) : l <= t && (e.expiredLanes |= a),
                            i &= ~a
                    }
                }(e, t);
                var r = ht(e, e === _l ? Al : 0);
                if (0 === r)
                    null !== n && Ke(n),
                        e.callbackNode = null,
                        e.callbackPriority = 0;
                else if (t = r & -r,
                    e.callbackPriority !== t) {
                    if (null != n && Ke(n),
                        1 === t)
                        0 === e.tag ? function (e) {
                            $o = !0,
                                Vo(e)
                        }(lc.bind(null, e)) : Vo(lc.bind(null, e)),
                            so((function () {
                                0 === (6 & Nl) && Fo()
                            }
                            )),
                            n = null;
                    else {
                        switch (wt(r)) {
                            case 1:
                                n = Ye;
                                break;
                            case 4:
                                n = et;
                                break;
                            case 16:
                            default:
                                n = tt;
                                break;
                            case 536870912:
                                n = rt
                        }
                        n = _c(n, oc.bind(null, e))
                    }
                    e.callbackPriority = t,
                        e.callbackNode = n
                }
            }
            function oc(e, t) {
                if (Ql = -1,
                    Yl = 0,
                    0 !== (6 & Nl))
                    throw Error(i(327));
                var n = e.callbackNode;
                if (Cc() && e.callbackNode !== n)
                    return null;
                var r = ht(e, e === _l ? Al : 0);
                if (0 === r)
                    return null;
                if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t)
                    t = gc(e, r);
                else {
                    t = r;
                    var o = Nl;
                    Nl |= 2;
                    var s = fc();
                    for (_l === e && Al === t || (Fl = null,
                        Vl = Xe() + 500,
                        hc(e, t)); ;)
                        try {
                            yc();
                            break
                        } catch (l) {
                            pc(e, l)
                        }
                    Ti(),
                        El.current = s,
                        Nl = o,
                        null !== Ol ? t = 0 : (_l = null,
                            Al = 0,
                            t = Rl)
                }
                if (0 !== t) {
                    if (2 === t && (0 !== (o = ft(e)) && (r = o,
                        t = ic(e, o))),
                        1 === t)
                        throw n = Dl,
                        hc(e, 0),
                        ac(e, r),
                        rc(e, Xe()),
                        n;
                    if (6 === t)
                        ac(e, r);
                    else {
                        if (o = e.current.alternate,
                            0 === (30 & r) && !function (e) {
                                for (var t = e; ;) {
                                    if (16384 & t.flags) {
                                        var n = t.updateQueue;
                                        if (null !== n && null !== (n = n.stores))
                                            for (var r = 0; r < n.length; r++) {
                                                var o = n[r]
                                                    , i = o.getSnapshot;
                                                o = o.value;
                                                try {
                                                    if (!ar(i(), o))
                                                        return !1
                                                } catch (a) {
                                                    return !1
                                                }
                                            }
                                    }
                                    if (n = t.child,
                                        16384 & t.subtreeFlags && null !== n)
                                        n.return = t,
                                            t = n;
                                    else {
                                        if (t === e)
                                            break;
                                        for (; null === t.sibling;) {
                                            if (null === t.return || t.return === e)
                                                return !0;
                                            t = t.return
                                        }
                                        t.sibling.return = t.return,
                                            t = t.sibling
                                    }
                                }
                                return !0
                            }(o) && (2 === (t = gc(e, r)) && (0 !== (s = ft(e)) && (r = s,
                                t = ic(e, s))),
                                1 === t))
                            throw n = Dl,
                            hc(e, 0),
                            ac(e, r),
                            rc(e, Xe()),
                            n;
                        switch (e.finishedWork = o,
                        e.finishedLanes = r,
                        t) {
                            case 0:
                            case 1:
                                throw Error(i(345));
                            case 2:
                            case 5:
                                kc(e, $l, Fl);
                                break;
                            case 3:
                                if (ac(e, r),
                                    (130023424 & r) === r && 10 < (t = Bl + 500 - Xe())) {
                                    if (0 !== ht(e, 0))
                                        break;
                                    if (((o = e.suspendedLanes) & r) !== r) {
                                        ec(),
                                            e.pingedLanes |= e.suspendedLanes & o;
                                        break
                                    }
                                    e.timeoutHandle = ro(kc.bind(null, e, $l, Fl), t);
                                    break
                                }
                                kc(e, $l, Fl);
                                break;
                            case 4:
                                if (ac(e, r),
                                    (4194240 & r) === r)
                                    break;
                                for (t = e.eventTimes,
                                    o = -1; 0 < r;) {
                                    var a = 31 - st(r);
                                    s = 1 << a,
                                        (a = t[a]) > o && (o = a),
                                        r &= ~s
                                }
                                if (r = o,
                                    10 < (r = (120 > (r = Xe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * xl(r / 1960)) - r)) {
                                    e.timeoutHandle = ro(kc.bind(null, e, $l, Fl), r);
                                    break
                                }
                                kc(e, $l, Fl);
                                break;
                            default:
                                throw Error(i(329))
                        }
                    }
                }
                return rc(e, Xe()),
                    e.callbackNode === n ? oc.bind(null, e) : null
            }
            function ic(e, t) {
                var n = zl;
                return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256),
                    2 !== (e = gc(e, t)) && (t = $l,
                        $l = n,
                        null !== t && sc(t)),
                    e
            }
            function sc(e) {
                null === $l ? $l = e : $l.push.apply($l, e)
            }
            function ac(e, t) {
                for (t &= ~Hl,
                    t &= ~jl,
                    e.suspendedLanes |= t,
                    e.pingedLanes &= ~t,
                    e = e.expirationTimes; 0 < t;) {
                    var n = 31 - st(t)
                        , r = 1 << n;
                    e[n] = -1,
                        t &= ~r
                }
            }
            function lc(e) {
                if (0 !== (6 & Nl))
                    throw Error(i(327));
                Cc();
                var t = ht(e, 0);
                if (0 === (1 & t))
                    return rc(e, Xe()),
                        null;
                var n = gc(e, t);
                if (0 !== e.tag && 2 === n) {
                    var r = ft(e);
                    0 !== r && (t = r,
                        n = ic(e, r))
                }
                if (1 === n)
                    throw n = Dl,
                    hc(e, 0),
                    ac(e, t),
                    rc(e, Xe()),
                    n;
                if (6 === n)
                    throw Error(i(345));
                return e.finishedWork = e.current.alternate,
                    e.finishedLanes = t,
                    kc(e, $l, Fl),
                    rc(e, Xe()),
                    null
            }
            function cc(e, t) {
                var n = Nl;
                Nl |= 1;
                try {
                    return e(t)
                } finally {
                    0 === (Nl = n) && (Vl = Xe() + 500,
                        $o && Fo())
                }
            }
            function dc(e) {
                null !== Kl && 0 === Kl.tag && 0 === (6 & Nl) && Cc();
                var t = Nl;
                Nl |= 1;
                var n = Tl.transition
                    , r = vt;
                try {
                    if (Tl.transition = null,
                        vt = 1,
                        e)
                        return e()
                } finally {
                    vt = r,
                        Tl.transition = n,
                        0 === (6 & (Nl = t)) && Fo()
                }
            }
            function uc() {
                Pl = Ll.current,
                    Mo(Ll)
            }
            function hc(e, t) {
                e.finishedWork = null,
                    e.finishedLanes = 0;
                var n = e.timeoutHandle;
                if (-1 !== n && (e.timeoutHandle = -1,
                    oo(n)),
                    null !== Ol)
                    for (n = Ol.return; null !== n;) {
                        var r = n;
                        switch (ni(r),
                        r.tag) {
                            case 1:
                                null !== (r = r.type.childContextTypes) && void 0 !== r && Ro();
                                break;
                            case 3:
                                Xi(),
                                    Mo(Oo),
                                    Mo(_o),
                                    rs();
                                break;
                            case 5:
                                Yi(r);
                                break;
                            case 4:
                                Xi();
                                break;
                            case 13:
                            case 19:
                                Mo(es);
                                break;
                            case 10:
                                Ni(r.type._context);
                                break;
                            case 22:
                            case 23:
                                uc()
                        }
                        n = n.return
                    }
                if (_l = e,
                    Ol = e = Lc(e.current, null),
                    Al = Pl = t,
                    Rl = 0,
                    Dl = null,
                    Hl = jl = Il = 0,
                    $l = zl = null,
                    null !== Pi) {
                    for (t = 0; t < Pi.length; t++)
                        if (null !== (r = (n = Pi[t]).interleaved)) {
                            n.interleaved = null;
                            var o = r.next
                                , i = n.pending;
                            if (null !== i) {
                                var s = i.next;
                                i.next = o,
                                    r.next = s
                            }
                            n.pending = r
                        }
                    Pi = null
                }
                return e
            }
            function pc(e, t) {
                for (; ;) {
                    var n = Ol;
                    try {
                        if (Ti(),
                            os.current = Qs,
                            ds) {
                            for (var r = as.memoizedState; null !== r;) {
                                var o = r.queue;
                                null !== o && (o.pending = null),
                                    r = r.next
                            }
                            ds = !1
                        }
                        if (ss = 0,
                            cs = ls = as = null,
                            us = !1,
                            hs = 0,
                            Ml.current = null,
                            null === n || null === n.return) {
                            Rl = 1,
                                Dl = t,
                                Ol = null;
                            break
                        }
                        e: {
                            var s = e
                                , a = n.return
                                , l = n
                                , c = t;
                            if (t = Al,
                                l.flags |= 32768,
                                null !== c && "object" === typeof c && "function" === typeof c.then) {
                                var d = c
                                    , u = l
                                    , h = u.tag;
                                if (0 === (1 & u.mode) && (0 === h || 11 === h || 15 === h)) {
                                    var p = u.alternate;
                                    p ? (u.updateQueue = p.updateQueue,
                                        u.memoizedState = p.memoizedState,
                                        u.lanes = p.lanes) : (u.updateQueue = null,
                                            u.memoizedState = null)
                                }
                                var f = ga(a);
                                if (null !== f) {
                                    f.flags &= -257,
                                        ba(f, a, l, 0, t),
                                        1 & f.mode && ma(s, d, t),
                                        c = d;
                                    var m = (t = f).updateQueue;
                                    if (null === m) {
                                        var g = new Set;
                                        g.add(c),
                                            t.updateQueue = g
                                    } else
                                        m.add(c);
                                    break e
                                }
                                if (0 === (1 & t)) {
                                    ma(s, d, t),
                                        mc();
                                    break e
                                }
                                c = Error(i(426))
                            } else if (ii && 1 & l.mode) {
                                var b = ga(a);
                                if (null !== b) {
                                    0 === (65536 & b.flags) && (b.flags |= 256),
                                        ba(b, a, l, 0, t),
                                        mi(ca(c, l));
                                    break e
                                }
                            }
                            s = c = ca(c, l),
                                4 !== Rl && (Rl = 2),
                                null === zl ? zl = [s] : zl.push(s),
                                s = a;
                            do {
                                switch (s.tag) {
                                    case 3:
                                        s.flags |= 65536,
                                            t &= -t,
                                            s.lanes |= t,
                                            Vi(s, pa(0, c, t));
                                        break e;
                                    case 1:
                                        l = c;
                                        var y = s.type
                                            , v = s.stateNode;
                                        if (0 === (128 & s.flags) && ("function" === typeof y.getDerivedStateFromError || null !== v && "function" === typeof v.componentDidCatch && (null === ql || !ql.has(v)))) {
                                            s.flags |= 65536,
                                                t &= -t,
                                                s.lanes |= t,
                                                Vi(s, fa(s, l, t));
                                            break e
                                        }
                                }
                                s = s.return
                            } while (null !== s)
                        }
                        wc(n)
                    } catch (w) {
                        t = w,
                            Ol === n && null !== n && (Ol = n = n.return);
                        continue
                    }
                    break
                }
            }
            function fc() {
                var e = El.current;
                return El.current = Qs,
                    null === e ? Qs : e
            }
            function mc() {
                0 !== Rl && 3 !== Rl && 2 !== Rl || (Rl = 4),
                    null === _l || 0 === (268435455 & Il) && 0 === (268435455 & jl) || ac(_l, Al)
            }
            function gc(e, t) {
                var n = Nl;
                Nl |= 2;
                var r = fc();
                for (_l === e && Al === t || (Fl = null,
                    hc(e, t)); ;)
                    try {
                        bc();
                        break
                    } catch (o) {
                        pc(e, o)
                    }
                if (Ti(),
                    Nl = n,
                    El.current = r,
                    null !== Ol)
                    throw Error(i(261));
                return _l = null,
                    Al = 0,
                    Rl
            }
            function bc() {
                for (; null !== Ol;)
                    vc(Ol)
            }
            function yc() {
                for (; null !== Ol && !Je();)
                    vc(Ol)
            }
            function vc(e) {
                var t = Sl(e.alternate, e, Pl);
                e.memoizedProps = e.pendingProps,
                    null === t ? wc(e) : Ol = t,
                    Ml.current = null
            }
            function wc(e) {
                var t = e;
                do {
                    var n = t.alternate;
                    if (e = t.return,
                        0 === (32768 & t.flags)) {
                        if (null !== (n = Ga(n, t, Pl)))
                            return void (Ol = n)
                    } else {
                        if (null !== (n = Ka(n, t)))
                            return n.flags &= 32767,
                                void (Ol = n);
                        if (null === e)
                            return Rl = 6,
                                void (Ol = null);
                        e.flags |= 32768,
                            e.subtreeFlags = 0,
                            e.deletions = null
                    }
                    if (null !== (t = t.sibling))
                        return void (Ol = t);
                    Ol = t = e
                } while (null !== t);
                0 === Rl && (Rl = 5)
            }
            function kc(e, t, n) {
                var r = vt
                    , o = Tl.transition;
                try {
                    Tl.transition = null,
                        vt = 1,
                        function (e, t, n, r) {
                            do {
                                Cc()
                            } while (null !== Kl);
                            if (0 !== (6 & Nl))
                                throw Error(i(327));
                            n = e.finishedWork;
                            var o = e.finishedLanes;
                            if (null === n)
                                return null;
                            if (e.finishedWork = null,
                                e.finishedLanes = 0,
                                n === e.current)
                                throw Error(i(177));
                            e.callbackNode = null,
                                e.callbackPriority = 0;
                            var s = n.lanes | n.childLanes;
                            if (function (e, t) {
                                var n = e.pendingLanes & ~t;
                                e.pendingLanes = t,
                                    e.suspendedLanes = 0,
                                    e.pingedLanes = 0,
                                    e.expiredLanes &= t,
                                    e.mutableReadLanes &= t,
                                    e.entangledLanes &= t,
                                    t = e.entanglements;
                                var r = e.eventTimes;
                                for (e = e.expirationTimes; 0 < n;) {
                                    var o = 31 - st(n)
                                        , i = 1 << o;
                                    t[o] = 0,
                                        r[o] = -1,
                                        e[o] = -1,
                                        n &= ~i
                                }
                            }(e, s),
                                e === _l && (Ol = _l = null,
                                    Al = 0),
                                0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Gl || (Gl = !0,
                                    _c(tt, (function () {
                                        return Cc(),
                                            null
                                    }
                                    ))),
                                s = 0 !== (15990 & n.flags),
                                0 !== (15990 & n.subtreeFlags) || s) {
                                s = Tl.transition,
                                    Tl.transition = null;
                                var a = vt;
                                vt = 1;
                                var l = Nl;
                                Nl |= 4,
                                    Ml.current = null,
                                    function (e, t) {
                                        if (eo = Ut,
                                            pr(e = hr())) {
                                            if ("selectionStart" in e)
                                                var n = {
                                                    start: e.selectionStart,
                                                    end: e.selectionEnd
                                                };
                                            else
                                                e: {
                                                    var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                                    if (r && 0 !== r.rangeCount) {
                                                        n = r.anchorNode;
                                                        var o = r.anchorOffset
                                                            , s = r.focusNode;
                                                        r = r.focusOffset;
                                                        try {
                                                            n.nodeType,
                                                                s.nodeType
                                                        } catch (Ik) {
                                                            n = null;
                                                            break e
                                                        }
                                                        var a = 0
                                                            , l = -1
                                                            , c = -1
                                                            , d = 0
                                                            , u = 0
                                                            , h = e
                                                            , p = null;
                                                        t: for (; ;) {
                                                            for (var f; h !== n || 0 !== o && 3 !== h.nodeType || (l = a + o),
                                                                h !== s || 0 !== r && 3 !== h.nodeType || (c = a + r),
                                                                3 === h.nodeType && (a += h.nodeValue.length),
                                                                null !== (f = h.firstChild);)
                                                                p = h,
                                                                    h = f;
                                                            for (; ;) {
                                                                if (h === e)
                                                                    break t;
                                                                if (p === n && ++d === o && (l = a),
                                                                    p === s && ++u === r && (c = a),
                                                                    null !== (f = h.nextSibling))
                                                                    break;
                                                                p = (h = p).parentNode
                                                            }
                                                            h = f
                                                        }
                                                        n = -1 === l || -1 === c ? null : {
                                                            start: l,
                                                            end: c
                                                        }
                                                    } else
                                                        n = null
                                                }
                                            n = n || {
                                                start: 0,
                                                end: 0
                                            }
                                        } else
                                            n = null;
                                        for (to = {
                                            focusedElem: e,
                                            selectionRange: n
                                        },
                                            Ut = !1,
                                            Qa = t; null !== Qa;)
                                            if (e = (t = Qa).child,
                                                0 !== (1028 & t.subtreeFlags) && null !== e)
                                                e.return = t,
                                                    Qa = e;
                                            else
                                                for (; null !== Qa;) {
                                                    t = Qa;
                                                    try {
                                                        var m = t.alternate;
                                                        if (0 !== (1024 & t.flags))
                                                            switch (t.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 15:
                                                                case 5:
                                                                case 6:
                                                                case 4:
                                                                case 17:
                                                                    break;
                                                                case 1:
                                                                    if (null !== m) {
                                                                        var g = m.memoizedProps
                                                                            , b = m.memoizedState
                                                                            , y = t.stateNode
                                                                            , v = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : na(t.type, g), b);
                                                                        y.__reactInternalSnapshotBeforeUpdate = v
                                                                    }
                                                                    break;
                                                                case 3:
                                                                    var w = t.stateNode.containerInfo;
                                                                    1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement);
                                                                    break;
                                                                default:
                                                                    throw Error(i(163))
                                                            }
                                                    } catch (Ik) {
                                                        xc(t, t.return, Ik)
                                                    }
                                                    if (null !== (e = t.sibling)) {
                                                        e.return = t.return,
                                                            Qa = e;
                                                        break
                                                    }
                                                    Qa = t.return
                                                }
                                        m = tl,
                                            tl = !1
                                    }(e, n),
                                    gl(n, e),
                                    fr(to),
                                    Ut = !!eo,
                                    to = eo = null,
                                    e.current = n,
                                    yl(n, e, o),
                                    Ze(),
                                    Nl = l,
                                    vt = a,
                                    Tl.transition = s
                            } else
                                e.current = n;
                            if (Gl && (Gl = !1,
                                Kl = e,
                                Jl = o),
                                s = e.pendingLanes,
                                0 === s && (ql = null),
                                function (e) {
                                    if (it && "function" === typeof it.onCommitFiberRoot)
                                        try {
                                            it.onCommitFiberRoot(ot, e, void 0, 128 === (128 & e.current.flags))
                                        } catch (t) { }
                                }(n.stateNode),
                                rc(e, Xe()),
                                null !== t)
                                for (r = e.onRecoverableError,
                                    n = 0; n < t.length; n++)
                                    o = t[n],
                                        r(o.value, {
                                            componentStack: o.stack,
                                            digest: o.digest
                                        });
                            if (Ul)
                                throw Ul = !1,
                                e = Wl,
                                Wl = null,
                                e;
                            0 !== (1 & Jl) && 0 !== e.tag && Cc(),
                                s = e.pendingLanes,
                                0 !== (1 & s) ? e === Xl ? Zl++ : (Zl = 0,
                                    Xl = e) : Zl = 0,
                                Fo()
                        }(e, t, n, r)
                } finally {
                    Tl.transition = o,
                        vt = r
                }
                return null
            }
            function Cc() {
                if (null !== Kl) {
                    var e = wt(Jl)
                        , t = Tl.transition
                        , n = vt;
                    try {
                        if (Tl.transition = null,
                            vt = 16 > e ? 16 : e,
                            null === Kl)
                            var r = !1;
                        else {
                            if (e = Kl,
                                Kl = null,
                                Jl = 0,
                                0 !== (6 & Nl))
                                throw Error(i(331));
                            var o = Nl;
                            for (Nl |= 4,
                                Qa = e.current; null !== Qa;) {
                                var s = Qa
                                    , a = s.child;
                                if (0 !== (16 & Qa.flags)) {
                                    var l = s.deletions;
                                    if (null !== l) {
                                        for (var c = 0; c < l.length; c++) {
                                            var d = l[c];
                                            for (Qa = d; null !== Qa;) {
                                                var u = Qa;
                                                switch (u.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        nl(8, u, s)
                                                }
                                                var h = u.child;
                                                if (null !== h)
                                                    h.return = u,
                                                        Qa = h;
                                                else
                                                    for (; null !== Qa;) {
                                                        var p = (u = Qa).sibling
                                                            , f = u.return;
                                                        if (il(u),
                                                            u === d) {
                                                            Qa = null;
                                                            break
                                                        }
                                                        if (null !== p) {
                                                            p.return = f,
                                                                Qa = p;
                                                            break
                                                        }
                                                        Qa = f
                                                    }
                                            }
                                        }
                                        var m = s.alternate;
                                        if (null !== m) {
                                            var g = m.child;
                                            if (null !== g) {
                                                m.child = null;
                                                do {
                                                    var b = g.sibling;
                                                    g.sibling = null,
                                                        g = b
                                                } while (null !== g)
                                            }
                                        }
                                        Qa = s
                                    }
                                }
                                if (0 !== (2064 & s.subtreeFlags) && null !== a)
                                    a.return = s,
                                        Qa = a;
                                else
                                    e: for (; null !== Qa;) {
                                        if (0 !== (2048 & (s = Qa).flags))
                                            switch (s.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    nl(9, s, s.return)
                                            }
                                        var y = s.sibling;
                                        if (null !== y) {
                                            y.return = s.return,
                                                Qa = y;
                                            break e
                                        }
                                        Qa = s.return
                                    }
                            }
                            var v = e.current;
                            for (Qa = v; null !== Qa;) {
                                var w = (a = Qa).child;
                                if (0 !== (2064 & a.subtreeFlags) && null !== w)
                                    w.return = a,
                                        Qa = w;
                                else
                                    e: for (a = v; null !== Qa;) {
                                        if (0 !== (2048 & (l = Qa).flags))
                                            try {
                                                switch (l.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        rl(9, l)
                                                }
                                            } catch (C) {
                                                xc(l, l.return, C)
                                            }
                                        if (l === a) {
                                            Qa = null;
                                            break e
                                        }
                                        var k = l.sibling;
                                        if (null !== k) {
                                            k.return = l.return,
                                                Qa = k;
                                            break e
                                        }
                                        Qa = l.return
                                    }
                            }
                            if (Nl = o,
                                Fo(),
                                it && "function" === typeof it.onPostCommitFiberRoot)
                                try {
                                    it.onPostCommitFiberRoot(ot, e)
                                } catch (C) { }
                            r = !0
                        }
                        return r
                    } finally {
                        vt = n,
                            Tl.transition = t
                    }
                }
                return !1
            }
            function Sc(e, t, n) {
                e = $i(e, t = pa(0, t = ca(n, t), 1), 1),
                    t = ec(),
                    null !== e && (bt(e, 1, t),
                        rc(e, t))
            }
            function xc(e, t, n) {
                if (3 === e.tag)
                    Sc(e, e, n);
                else
                    for (; null !== t;) {
                        if (3 === t.tag) {
                            Sc(t, e, n);
                            break
                        }
                        if (1 === t.tag) {
                            var r = t.stateNode;
                            if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === ql || !ql.has(r))) {
                                t = $i(t, e = fa(t, e = ca(n, e), 1), 1),
                                    e = ec(),
                                    null !== t && (bt(t, 1, e),
                                        rc(t, e));
                                break
                            }
                        }
                        t = t.return
                    }
            }
            function Ec(e, t, n) {
                var r = e.pingCache;
                null !== r && r.delete(t),
                    t = ec(),
                    e.pingedLanes |= e.suspendedLanes & n,
                    _l === e && (Al & n) === n && (4 === Rl || 3 === Rl && (130023424 & Al) === Al && 500 > Xe() - Bl ? hc(e, 0) : Hl |= n),
                    rc(e, t)
            }
            function Mc(e, t) {
                0 === t && (0 === (1 & e.mode) ? t = 1 : (t = dt,
                    0 === (130023424 & (dt <<= 1)) && (dt = 4194304)));
                var n = ec();
                null !== (e = Di(e, t)) && (bt(e, t, n),
                    rc(e, n))
            }
            function Tc(e) {
                var t = e.memoizedState
                    , n = 0;
                null !== t && (n = t.retryLane),
                    Mc(e, n)
            }
            function Nc(e, t) {
                var n = 0;
                switch (e.tag) {
                    case 13:
                        var r = e.stateNode
                            , o = e.memoizedState;
                        null !== o && (n = o.retryLane);
                        break;
                    case 19:
                        r = e.stateNode;
                        break;
                    default:
                        throw Error(i(314))
                }
                null !== r && r.delete(t),
                    Mc(e, n)
            }
            function _c(e, t) {
                return Ge(e, t)
            }
            function Oc(e, t, n, r) {
                this.tag = e,
                    this.key = n,
                    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                    this.index = 0,
                    this.ref = null,
                    this.pendingProps = t,
                    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                    this.mode = r,
                    this.subtreeFlags = this.flags = 0,
                    this.deletions = null,
                    this.childLanes = this.lanes = 0,
                    this.alternate = null
            }
            function Ac(e, t, n, r) {
                return new Oc(e, t, n, r)
            }
            function Pc(e) {
                return !(!(e = e.prototype) || !e.isReactComponent)
            }
            function Lc(e, t) {
                var n = e.alternate;
                return null === n ? ((n = Ac(e.tag, t, e.key, e.mode)).elementType = e.elementType,
                    n.type = e.type,
                    n.stateNode = e.stateNode,
                    n.alternate = e,
                    e.alternate = n) : (n.pendingProps = t,
                        n.type = e.type,
                        n.flags = 0,
                        n.subtreeFlags = 0,
                        n.deletions = null),
                    n.flags = 14680064 & e.flags,
                    n.childLanes = e.childLanes,
                    n.lanes = e.lanes,
                    n.child = e.child,
                    n.memoizedProps = e.memoizedProps,
                    n.memoizedState = e.memoizedState,
                    n.updateQueue = e.updateQueue,
                    t = e.dependencies,
                    n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    },
                    n.sibling = e.sibling,
                    n.index = e.index,
                    n.ref = e.ref,
                    n
            }
            function Rc(e, t, n, r, o, s) {
                var a = 2;
                if (r = e,
                    "function" === typeof e)
                    Pc(e) && (a = 1);
                else if ("string" === typeof e)
                    a = 5;
                else
                    e: switch (e) {
                        case S:
                            return Dc(n.children, o, s, t);
                        case x:
                            a = 8,
                                o |= 8;
                            break;
                        case E:
                            return (e = Ac(12, n, t, 2 | o)).elementType = E,
                                e.lanes = s,
                                e;
                        case _:
                            return (e = Ac(13, n, t, o)).elementType = _,
                                e.lanes = s,
                                e;
                        case O:
                            return (e = Ac(19, n, t, o)).elementType = O,
                                e.lanes = s,
                                e;
                        case L:
                            return Ic(n, o, s, t);
                        default:
                            if ("object" === typeof e && null !== e)
                                switch (e.$$typeof) {
                                    case M:
                                        a = 10;
                                        break e;
                                    case T:
                                        a = 9;
                                        break e;
                                    case N:
                                        a = 11;
                                        break e;
                                    case A:
                                        a = 14;
                                        break e;
                                    case P:
                                        a = 16,
                                            r = null;
                                        break e
                                }
                            throw Error(i(130, null == e ? e : typeof e, ""))
                    }
                return (t = Ac(a, n, t, o)).elementType = e,
                    t.type = r,
                    t.lanes = s,
                    t
            }
            function Dc(e, t, n, r) {
                return (e = Ac(7, e, r, t)).lanes = n,
                    e
            }
            function Ic(e, t, n, r) {
                return (e = Ac(22, e, r, t)).elementType = L,
                    e.lanes = n,
                    e.stateNode = {
                        isHidden: !1
                    },
                    e
            }
            function jc(e, t, n) {
                return (e = Ac(6, e, null, t)).lanes = n,
                    e
            }
            function Hc(e, t, n) {
                return (t = Ac(4, null !== e.children ? e.children : [], e.key, t)).lanes = n,
                    t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    },
                    t
            }
            function zc(e, t, n, r, o) {
                this.tag = t,
                    this.containerInfo = e,
                    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                    this.timeoutHandle = -1,
                    this.callbackNode = this.pendingContext = this.context = null,
                    this.callbackPriority = 0,
                    this.eventTimes = gt(0),
                    this.expirationTimes = gt(-1),
                    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                    this.entanglements = gt(0),
                    this.identifierPrefix = r,
                    this.onRecoverableError = o,
                    this.mutableSourceEagerHydrationData = null
            }
            function $c(e, t, n, r, o, i, s, a, l) {
                return e = new zc(e, t, n, a, l),
                    1 === t ? (t = 1,
                        !0 === i && (t |= 8)) : t = 0,
                    i = Ac(3, null, null, t),
                    e.current = i,
                    i.stateNode = e,
                    i.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    },
                    ji(i),
                    e
            }
            function Bc(e) {
                if (!e)
                    return No;
                e: {
                    if (Ve(e = e._reactInternals) !== e || 1 !== e.tag)
                        throw Error(i(170));
                    var t = e;
                    do {
                        switch (t.tag) {
                            case 3:
                                t = t.stateNode.context;
                                break e;
                            case 1:
                                if (Lo(t.type)) {
                                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                    break e
                                }
                        }
                        t = t.return
                    } while (null !== t);
                    throw Error(i(171))
                }
                if (1 === e.tag) {
                    var n = e.type;
                    if (Lo(n))
                        return Io(e, n, t)
                }
                return t
            }
            function Vc(e, t, n, r, o, i, s, a, l) {
                return (e = $c(n, r, !0, e, 0, i, 0, a, l)).context = Bc(null),
                    n = e.current,
                    (i = zi(r = ec(), o = tc(n))).callback = void 0 !== t && null !== t ? t : null,
                    $i(n, i, o),
                    e.current.lanes = o,
                    bt(e, o, r),
                    rc(e, r),
                    e
            }
            function Fc(e, t, n, r) {
                var o = t.current
                    , i = ec()
                    , s = tc(o);
                return n = Bc(n),
                    null === t.context ? t.context = n : t.pendingContext = n,
                    (t = zi(i, s)).payload = {
                        element: e
                    },
                    null !== (r = void 0 === r ? null : r) && (t.callback = r),
                    null !== (e = $i(o, t, s)) && (nc(e, o, s, i),
                        Bi(e, o, s)),
                    s
            }
            function Uc(e) {
                return (e = e.current).child ? (e.child.tag,
                    e.child.stateNode) : null
            }
            function Wc(e, t) {
                if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                    var n = e.retryLane;
                    e.retryLane = 0 !== n && n < t ? n : t
                }
            }
            function qc(e, t) {
                Wc(e, t),
                    (e = e.alternate) && Wc(e, t)
            }
            Sl = function (e, t, n) {
                if (null !== e)
                    if (e.memoizedProps !== t.pendingProps || Oo.current)
                        va = !0;
                    else {
                        if (0 === (e.lanes & n) && 0 === (128 & t.flags))
                            return va = !1,
                                function (e, t, n) {
                                    switch (t.tag) {
                                        case 3:
                                            _a(t),
                                                fi();
                                            break;
                                        case 5:
                                            Qi(t);
                                            break;
                                        case 1:
                                            Lo(t.type) && jo(t);
                                            break;
                                        case 4:
                                            Zi(t, t.stateNode.containerInfo);
                                            break;
                                        case 10:
                                            var r = t.type._context
                                                , o = t.memoizedProps.value;
                                            To(Si, r._currentValue),
                                                r._currentValue = o;
                                            break;
                                        case 13:
                                            if (null !== (r = t.memoizedState))
                                                return null !== r.dehydrated ? (To(es, 1 & es.current),
                                                    t.flags |= 128,
                                                    null) : 0 !== (n & t.child.childLanes) ? ja(e, t, n) : (To(es, 1 & es.current),
                                                        null !== (e = Ua(e, t, n)) ? e.sibling : null);
                                            To(es, 1 & es.current);
                                            break;
                                        case 19:
                                            if (r = 0 !== (n & t.childLanes),
                                                0 !== (128 & e.flags)) {
                                                if (r)
                                                    return Va(e, t, n);
                                                t.flags |= 128
                                            }
                                            if (null !== (o = t.memoizedState) && (o.rendering = null,
                                                o.tail = null,
                                                o.lastEffect = null),
                                                To(es, es.current),
                                                r)
                                                break;
                                            return null;
                                        case 22:
                                        case 23:
                                            return t.lanes = 0,
                                                xa(e, t, n)
                                    }
                                    return Ua(e, t, n)
                                }(e, t, n);
                        va = 0 !== (131072 & e.flags)
                    }
                else
                    va = !1,
                        ii && 0 !== (1048576 & t.flags) && ei(t, Go, t.index);
                switch (t.lanes = 0,
                t.tag) {
                    case 2:
                        var r = t.type;
                        Fa(e, t),
                            e = t.pendingProps;
                        var o = Po(t, _o.current);
                        Oi(t, n),
                            o = gs(null, t, r, e, o, n);
                        var s = bs();
                        return t.flags |= 1,
                            "object" === typeof o && null !== o && "function" === typeof o.render && void 0 === o.$$typeof ? (t.tag = 1,
                                t.memoizedState = null,
                                t.updateQueue = null,
                                Lo(r) ? (s = !0,
                                    jo(t)) : s = !1,
                                t.memoizedState = null !== o.state && void 0 !== o.state ? o.state : null,
                                ji(t),
                                o.updater = oa,
                                t.stateNode = o,
                                o._reactInternals = t,
                                la(t, r, e, n),
                                t = Na(null, t, r, !0, s, n)) : (t.tag = 0,
                                    ii && s && ti(t),
                                    wa(null, t, o, n),
                                    t = t.child),
                            t;
                    case 16:
                        r = t.elementType;
                        e: {
                            switch (Fa(e, t),
                            e = t.pendingProps,
                            r = (o = r._init)(r._payload),
                            t.type = r,
                            o = t.tag = function (e) {
                                if ("function" === typeof e)
                                    return Pc(e) ? 1 : 0;
                                if (void 0 !== e && null !== e) {
                                    if ((e = e.$$typeof) === N)
                                        return 11;
                                    if (e === A)
                                        return 14
                                }
                                return 2
                            }(r),
                            e = na(r, e),
                            o) {
                                case 0:
                                    t = Ma(null, t, r, e, n);
                                    break e;
                                case 1:
                                    t = Ta(null, t, r, e, n);
                                    break e;
                                case 11:
                                    t = ka(null, t, r, e, n);
                                    break e;
                                case 14:
                                    t = Ca(null, t, r, na(r.type, e), n);
                                    break e
                            }
                            throw Error(i(306, r, ""))
                        }
                        return t;
                    case 0:
                        return r = t.type,
                            o = t.pendingProps,
                            Ma(e, t, r, o = t.elementType === r ? o : na(r, o), n);
                    case 1:
                        return r = t.type,
                            o = t.pendingProps,
                            Ta(e, t, r, o = t.elementType === r ? o : na(r, o), n);
                    case 3:
                        e: {
                            if (_a(t),
                                null === e)
                                throw Error(i(387));
                            r = t.pendingProps,
                                o = (s = t.memoizedState).element,
                                Hi(e, t),
                                Fi(t, r, null, n);
                            var a = t.memoizedState;
                            if (r = a.element,
                                s.isDehydrated) {
                                if (s = {
                                    element: r,
                                    isDehydrated: !1,
                                    cache: a.cache,
                                    pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                                    transitions: a.transitions
                                },
                                    t.updateQueue.baseState = s,
                                    t.memoizedState = s,
                                    256 & t.flags) {
                                    t = Oa(e, t, r, n, o = ca(Error(i(423)), t));
                                    break e
                                }
                                if (r !== o) {
                                    t = Oa(e, t, r, n, o = ca(Error(i(424)), t));
                                    break e
                                }
                                for (oi = co(t.stateNode.containerInfo.firstChild),
                                    ri = t,
                                    ii = !0,
                                    si = null,
                                    n = Ci(t, null, r, n),
                                    t.child = n; n;)
                                    n.flags = -3 & n.flags | 4096,
                                        n = n.sibling
                            } else {
                                if (fi(),
                                    r === o) {
                                    t = Ua(e, t, n);
                                    break e
                                }
                                wa(e, t, r, n)
                            }
                            t = t.child
                        }
                        return t;
                    case 5:
                        return Qi(t),
                            null === e && di(t),
                            r = t.type,
                            o = t.pendingProps,
                            s = null !== e ? e.memoizedProps : null,
                            a = o.children,
                            no(r, o) ? a = null : null !== s && no(r, s) && (t.flags |= 32),
                            Ea(e, t),
                            wa(e, t, a, n),
                            t.child;
                    case 6:
                        return null === e && di(t),
                            null;
                    case 13:
                        return ja(e, t, n);
                    case 4:
                        return Zi(t, t.stateNode.containerInfo),
                            r = t.pendingProps,
                            null === e ? t.child = ki(t, null, r, n) : wa(e, t, r, n),
                            t.child;
                    case 11:
                        return r = t.type,
                            o = t.pendingProps,
                            ka(e, t, r, o = t.elementType === r ? o : na(r, o), n);
                    case 7:
                        return wa(e, t, t.pendingProps, n),
                            t.child;
                    case 8:
                    case 12:
                        return wa(e, t, t.pendingProps.children, n),
                            t.child;
                    case 10:
                        e: {
                            if (r = t.type._context,
                                o = t.pendingProps,
                                s = t.memoizedProps,
                                a = o.value,
                                To(Si, r._currentValue),
                                r._currentValue = a,
                                null !== s)
                                if (ar(s.value, a)) {
                                    if (s.children === o.children && !Oo.current) {
                                        t = Ua(e, t, n);
                                        break e
                                    }
                                } else
                                    for (null !== (s = t.child) && (s.return = t); null !== s;) {
                                        var l = s.dependencies;
                                        if (null !== l) {
                                            a = s.child;
                                            for (var c = l.firstContext; null !== c;) {
                                                if (c.context === r) {
                                                    if (1 === s.tag) {
                                                        (c = zi(-1, n & -n)).tag = 2;
                                                        var d = s.updateQueue;
                                                        if (null !== d) {
                                                            var u = (d = d.shared).pending;
                                                            null === u ? c.next = c : (c.next = u.next,
                                                                u.next = c),
                                                                d.pending = c
                                                        }
                                                    }
                                                    s.lanes |= n,
                                                        null !== (c = s.alternate) && (c.lanes |= n),
                                                        _i(s.return, n, t),
                                                        l.lanes |= n;
                                                    break
                                                }
                                                c = c.next
                                            }
                                        } else if (10 === s.tag)
                                            a = s.type === t.type ? null : s.child;
                                        else if (18 === s.tag) {
                                            if (null === (a = s.return))
                                                throw Error(i(341));
                                            a.lanes |= n,
                                                null !== (l = a.alternate) && (l.lanes |= n),
                                                _i(a, n, t),
                                                a = s.sibling
                                        } else
                                            a = s.child;
                                        if (null !== a)
                                            a.return = s;
                                        else
                                            for (a = s; null !== a;) {
                                                if (a === t) {
                                                    a = null;
                                                    break
                                                }
                                                if (null !== (s = a.sibling)) {
                                                    s.return = a.return,
                                                        a = s;
                                                    break
                                                }
                                                a = a.return
                                            }
                                        s = a
                                    }
                            wa(e, t, o.children, n),
                                t = t.child
                        }
                        return t;
                    case 9:
                        return o = t.type,
                            r = t.pendingProps.children,
                            Oi(t, n),
                            r = r(o = Ai(o)),
                            t.flags |= 1,
                            wa(e, t, r, n),
                            t.child;
                    case 14:
                        return o = na(r = t.type, t.pendingProps),
                            Ca(e, t, r, o = na(r.type, o), n);
                    case 15:
                        return Sa(e, t, t.type, t.pendingProps, n);
                    case 17:
                        return r = t.type,
                            o = t.pendingProps,
                            o = t.elementType === r ? o : na(r, o),
                            Fa(e, t),
                            t.tag = 1,
                            Lo(r) ? (e = !0,
                                jo(t)) : e = !1,
                            Oi(t, n),
                            sa(t, r, o),
                            la(t, r, o, n),
                            Na(null, t, r, !0, e, n);
                    case 19:
                        return Va(e, t, n);
                    case 22:
                        return xa(e, t, n)
                }
                throw Error(i(156, t.tag))
            }
                ;
            var Gc = "function" === typeof reportError ? reportError : function (e) {
                console.error(e)
            }
                ;
            function Kc(e) {
                this._internalRoot = e
            }
            function Jc(e) {
                this._internalRoot = e
            }
            function Zc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
            }
            function Xc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
            }
            function Qc() { }
            function Yc(e, t, n, r, o) {
                var i = n._reactRootContainer;
                if (i) {
                    var s = i;
                    if ("function" === typeof o) {
                        var a = o;
                        o = function () {
                            var e = Uc(s);
                            a.call(e)
                        }
                    }
                    Fc(t, s, e, o)
                } else
                    s = function (e, t, n, r, o) {
                        if (o) {
                            if ("function" === typeof r) {
                                var i = r;
                                r = function () {
                                    var e = Uc(s);
                                    i.call(e)
                                }
                            }
                            var s = Vc(t, r, e, 0, null, !1, 0, "", Qc);
                            return e._reactRootContainer = s,
                                e[mo] = s.current,
                                Vr(8 === e.nodeType ? e.parentNode : e),
                                dc(),
                                s
                        }
                        for (; o = e.lastChild;)
                            e.removeChild(o);
                        if ("function" === typeof r) {
                            var a = r;
                            r = function () {
                                var e = Uc(l);
                                a.call(e)
                            }
                        }
                        var l = $c(e, 0, !1, null, 0, !1, 0, "", Qc);
                        return e._reactRootContainer = l,
                            e[mo] = l.current,
                            Vr(8 === e.nodeType ? e.parentNode : e),
                            dc((function () {
                                Fc(t, l, n, r)
                            }
                            )),
                            l
                    }(n, t, e, o, r);
                return Uc(s)
            }
            Jc.prototype.render = Kc.prototype.render = function (e) {
                var t = this._internalRoot;
                if (null === t)
                    throw Error(i(409));
                Fc(e, t, null, null)
            }
                ,
                Jc.prototype.unmount = Kc.prototype.unmount = function () {
                    var e = this._internalRoot;
                    if (null !== e) {
                        this._internalRoot = null;
                        var t = e.containerInfo;
                        dc((function () {
                            Fc(null, e, null, null)
                        }
                        )),
                            t[mo] = null
                    }
                }
                ,
                Jc.prototype.unstable_scheduleHydration = function (e) {
                    if (e) {
                        var t = xt();
                        e = {
                            blockedOn: null,
                            target: e,
                            priority: t
                        };
                        for (var n = 0; n < Lt.length && 0 !== t && t < Lt[n].priority; n++)
                            ;
                        Lt.splice(n, 0, e),
                            0 === n && jt(e)
                    }
                }
                ,
                kt = function (e) {
                    switch (e.tag) {
                        case 3:
                            var t = e.stateNode;
                            if (t.current.memoizedState.isDehydrated) {
                                var n = ut(t.pendingLanes);
                                0 !== n && (yt(t, 1 | n),
                                    rc(t, Xe()),
                                    0 === (6 & Nl) && (Vl = Xe() + 500,
                                        Fo()))
                            }
                            break;
                        case 13:
                            dc((function () {
                                var t = Di(e, 1);
                                if (null !== t) {
                                    var n = ec();
                                    nc(t, e, 1, n)
                                }
                            }
                            )),
                                qc(e, 1)
                    }
                }
                ,
                Ct = function (e) {
                    if (13 === e.tag) {
                        var t = Di(e, 134217728);
                        if (null !== t)
                            nc(t, e, 134217728, ec());
                        qc(e, 134217728)
                    }
                }
                ,
                St = function (e) {
                    if (13 === e.tag) {
                        var t = tc(e)
                            , n = Di(e, t);
                        if (null !== n)
                            nc(n, e, t, ec());
                        qc(e, t)
                    }
                }
                ,
                xt = function () {
                    return vt
                }
                ,
                Et = function (e, t) {
                    var n = vt;
                    try {
                        return vt = e,
                            t()
                    } finally {
                        vt = n
                    }
                }
                ,
                Ce = function (e, t, n) {
                    switch (t) {
                        case "input":
                            if (Q(e, n),
                                t = n.name,
                                "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;)
                                    n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
                                    t = 0; t < n.length; t++) {
                                    var r = n[t];
                                    if (r !== e && r.form === e.form) {
                                        var o = Co(r);
                                        if (!o)
                                            throw Error(i(90));
                                        G(r),
                                            Q(r, o)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            ie(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                    }
                }
                ,
                Ne = cc,
                _e = dc;
            var ed = {
                usingClientEntryPoint: !1,
                Events: [wo, ko, Co, Me, Te, cc]
            }
                , td = {
                    findFiberByHostInstance: vo,
                    bundleType: 0,
                    version: "18.3.1",
                    rendererPackageName: "react-dom"
                }
                , nd = {
                    bundleType: td.bundleType,
                    version: td.version,
                    rendererPackageName: td.rendererPackageName,
                    rendererConfig: td.rendererConfig,
                    overrideHookState: null,
                    overrideHookStateDeletePath: null,
                    overrideHookStateRenamePath: null,
                    overrideProps: null,
                    overridePropsDeletePath: null,
                    overridePropsRenamePath: null,
                    setErrorHandler: null,
                    setSuspenseHandler: null,
                    scheduleUpdate: null,
                    currentDispatcherRef: w.ReactCurrentDispatcher,
                    findHostInstanceByFiber: function (e) {
                        return null === (e = We(e)) ? null : e.stateNode
                    },
                    findFiberByHostInstance: td.findFiberByHostInstance || function () {
                        return null
                    }
                    ,
                    findHostInstancesForRefresh: null,
                    scheduleRefresh: null,
                    scheduleRoot: null,
                    setRefreshHandler: null,
                    getCurrentFiber: null,
                    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
                };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var rd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!rd.isDisabled && rd.supportsFiber)
                    try {
                        ot = rd.inject(nd),
                            it = rd
                    } catch (de) { }
            }
            t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ed,
                t.createPortal = function (e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!Zc(t))
                        throw Error(i(200));
                    return function (e, t, n) {
                        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                        return {
                            $$typeof: C,
                            key: null == r ? null : "" + r,
                            children: e,
                            containerInfo: t,
                            implementation: n
                        }
                    }(e, t, null, n)
                }
                ,
                t.createRoot = function (e, t) {
                    if (!Zc(e))
                        throw Error(i(299));
                    var n = !1
                        , r = ""
                        , o = Gc;
                    return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0),
                        void 0 !== t.identifierPrefix && (r = t.identifierPrefix),
                        void 0 !== t.onRecoverableError && (o = t.onRecoverableError)),
                        t = $c(e, 1, !1, null, 0, n, 0, r, o),
                        e[mo] = t.current,
                        Vr(8 === e.nodeType ? e.parentNode : e),
                        new Kc(t)
                }
                ,
                t.findDOMNode = function (e) {
                    if (null == e)
                        return null;
                    if (1 === e.nodeType)
                        return e;
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render)
                            throw Error(i(188));
                        throw e = Object.keys(e).join(","),
                        Error(i(268, e))
                    }
                    return e = null === (e = We(t)) ? null : e.stateNode
                }
                ,
                t.flushSync = function (e) {
                    return dc(e)
                }
                ,
                t.hydrate = function (e, t, n) {
                    if (!Xc(t))
                        throw Error(i(200));
                    return Yc(null, e, t, !0, n)
                }
                ,
                t.hydrateRoot = function (e, t, n) {
                    if (!Zc(e))
                        throw Error(i(405));
                    var r = null != n && n.hydratedSources || null
                        , o = !1
                        , s = ""
                        , a = Gc;
                    if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (o = !0),
                        void 0 !== n.identifierPrefix && (s = n.identifierPrefix),
                        void 0 !== n.onRecoverableError && (a = n.onRecoverableError)),
                        t = Vc(t, null, e, 1, null != n ? n : null, o, 0, s, a),
                        e[mo] = t.current,
                        Vr(e),
                        r)
                        for (e = 0; e < r.length; e++)
                            o = (o = (n = r[e])._getVersion)(n._source),
                                null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, o] : t.mutableSourceEagerHydrationData.push(n, o);
                    return new Jc(t)
                }
                ,
                t.render = function (e, t, n) {
                    if (!Xc(t))
                        throw Error(i(200));
                    return Yc(null, e, t, !1, n)
                }
                ,
                t.unmountComponentAtNode = function (e) {
                    if (!Xc(e))
                        throw Error(i(40));
                    return !!e._reactRootContainer && (dc((function () {
                        Yc(null, null, e, !1, (function () {
                            e._reactRootContainer = null,
                                e[mo] = null
                        }
                        ))
                    }
                    )),
                        !0)
                }
                ,
                t.unstable_batchedUpdates = cc,
                t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
                    if (!Xc(n))
                        throw Error(i(200));
                    if (null == e || void 0 === e._reactInternals)
                        throw Error(i(38));
                    return Yc(e, t, n, !1, r)
                }
                ,
                t.version = "18.3.1-next-f1338f8080-20240426"
        }
        ,
        4391: (e, t, n) => {
            var r = n(7950);
            t.createRoot = r.createRoot,
                t.hydrateRoot = r.hydrateRoot
        }
        ,
        7950: (e, t, n) => {
            !function e() {
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
                    try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
            }(),
                e.exports = n(2730)
        }
        ,
        1153: (e, t, n) => {
            var r = n(5043)
                , o = Symbol.for("react.element")
                , i = Symbol.for("react.fragment")
                , s = Object.prototype.hasOwnProperty
                , a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
                , l = {
                    key: !0,
                    ref: !0,
                    __self: !0,
                    __source: !0
                };
            function c(e, t, n) {
                var r, i = {}, c = null, d = null;
                for (r in void 0 !== n && (c = "" + n),
                    void 0 !== t.key && (c = "" + t.key),
                    void 0 !== t.ref && (d = t.ref),
                    t)
                    s.call(t, r) && !l.hasOwnProperty(r) && (i[r] = t[r]);
                if (e && e.defaultProps)
                    for (r in t = e.defaultProps)
                        void 0 === i[r] && (i[r] = t[r]);
                return {
                    $$typeof: o,
                    type: e,
                    key: c,
                    ref: d,
                    props: i,
                    _owner: a.current
                }
            }
            t.Fragment = i,
                t.jsx = c,
                t.jsxs = c
        }
        ,
        4202: (e, t) => {
            var n = Symbol.for("react.element")
                , r = Symbol.for("react.portal")
                , o = Symbol.for("react.fragment")
                , i = Symbol.for("react.strict_mode")
                , s = Symbol.for("react.profiler")
                , a = Symbol.for("react.provider")
                , l = Symbol.for("react.context")
                , c = Symbol.for("react.forward_ref")
                , d = Symbol.for("react.suspense")
                , u = Symbol.for("react.memo")
                , h = Symbol.for("react.lazy")
                , p = Symbol.iterator;
            var f = {
                isMounted: function () {
                    return !1
                },
                enqueueForceUpdate: function () { },
                enqueueReplaceState: function () { },
                enqueueSetState: function () { }
            }
                , m = Object.assign
                , g = {};
            function b(e, t, n) {
                this.props = e,
                    this.context = t,
                    this.refs = g,
                    this.updater = n || f
            }
            function y() { }
            function v(e, t, n) {
                this.props = e,
                    this.context = t,
                    this.refs = g,
                    this.updater = n || f
            }
            b.prototype.isReactComponent = {},
                b.prototype.setState = function (e, t) {
                    if ("object" !== typeof e && "function" !== typeof e && null != e)
                        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, e, t, "setState")
                }
                ,
                b.prototype.forceUpdate = function (e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }
                ,
                y.prototype = b.prototype;
            var w = v.prototype = new y;
            w.constructor = v,
                m(w, b.prototype),
                w.isPureReactComponent = !0;
            var k = Array.isArray
                , C = Object.prototype.hasOwnProperty
                , S = {
                    current: null
                }
                , x = {
                    key: !0,
                    ref: !0,
                    __self: !0,
                    __source: !0
                };
            function E(e, t, r) {
                var o, i = {}, s = null, a = null;
                if (null != t)
                    for (o in void 0 !== t.ref && (a = t.ref),
                        void 0 !== t.key && (s = "" + t.key),
                        t)
                        C.call(t, o) && !x.hasOwnProperty(o) && (i[o] = t[o]);
                var l = arguments.length - 2;
                if (1 === l)
                    i.children = r;
                else if (1 < l) {
                    for (var c = Array(l), d = 0; d < l; d++)
                        c[d] = arguments[d + 2];
                    i.children = c
                }
                if (e && e.defaultProps)
                    for (o in l = e.defaultProps)
                        void 0 === i[o] && (i[o] = l[o]);
                return {
                    $$typeof: n,
                    type: e,
                    key: s,
                    ref: a,
                    props: i,
                    _owner: S.current
                }
            }
            function M(e) {
                return "object" === typeof e && null !== e && e.$$typeof === n
            }
            var T = /\/+/g;
            function N(e, t) {
                return "object" === typeof e && null !== e && null != e.key ? function (e) {
                    var t = {
                        "=": "=0",
                        ":": "=2"
                    };
                    return "$" + e.replace(/[=:]/g, (function (e) {
                        return t[e]
                    }
                    ))
                }("" + e.key) : t.toString(36)
            }
            function _(e, t, o, i, s) {
                var a = typeof e;
                "undefined" !== a && "boolean" !== a || (e = null);
                var l = !1;
                if (null === e)
                    l = !0;
                else
                    switch (a) {
                        case "string":
                        case "number":
                            l = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case n:
                                case r:
                                    l = !0
                            }
                    }
                if (l)
                    return s = s(l = e),
                        e = "" === i ? "." + N(l, 0) : i,
                        k(s) ? (o = "",
                            null != e && (o = e.replace(T, "$&/") + "/"),
                            _(s, t, o, "", (function (e) {
                                return e
                            }
                            ))) : null != s && (M(s) && (s = function (e, t) {
                                return {
                                    $$typeof: n,
                                    type: e.type,
                                    key: t,
                                    ref: e.ref,
                                    props: e.props,
                                    _owner: e._owner
                                }
                            }(s, o + (!s.key || l && l.key === s.key ? "" : ("" + s.key).replace(T, "$&/") + "/") + e)),
                                t.push(s)),
                        1;
                if (l = 0,
                    i = "" === i ? "." : i + ":",
                    k(e))
                    for (var c = 0; c < e.length; c++) {
                        var d = i + N(a = e[c], c);
                        l += _(a, t, o, d, s)
                    }
                else if (d = function (e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof (e = p && e[p] || e["@@iterator"]) ? e : null
                }(e),
                    "function" === typeof d)
                    for (e = d.call(e),
                        c = 0; !(a = e.next()).done;)
                        l += _(a = a.value, t, o, d = i + N(a, c++), s);
                else if ("object" === a)
                    throw t = String(e),
                    Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                return l
            }
            function O(e, t, n) {
                if (null == e)
                    return e;
                var r = []
                    , o = 0;
                return _(e, r, "", "", (function (e) {
                    return t.call(n, e, o++)
                }
                )),
                    r
            }
            function A(e) {
                if (-1 === e._status) {
                    var t = e._result;
                    (t = t()).then((function (t) {
                        0 !== e._status && -1 !== e._status || (e._status = 1,
                            e._result = t)
                    }
                    ), (function (t) {
                        0 !== e._status && -1 !== e._status || (e._status = 2,
                            e._result = t)
                    }
                    )),
                        -1 === e._status && (e._status = 0,
                            e._result = t)
                }
                if (1 === e._status)
                    return e._result.default;
                throw e._result
            }
            var P = {
                current: null
            }
                , L = {
                    transition: null
                }
                , R = {
                    ReactCurrentDispatcher: P,
                    ReactCurrentBatchConfig: L,
                    ReactCurrentOwner: S
                };
            function D() {
                throw Error("act(...) is not supported in production builds of React.")
            }
            t.Children = {
                map: O,
                forEach: function (e, t, n) {
                    O(e, (function () {
                        t.apply(this, arguments)
                    }
                    ), n)
                },
                count: function (e) {
                    var t = 0;
                    return O(e, (function () {
                        t++
                    }
                    )),
                        t
                },
                toArray: function (e) {
                    return O(e, (function (e) {
                        return e
                    }
                    )) || []
                },
                only: function (e) {
                    if (!M(e))
                        throw Error("React.Children.only expected to receive a single React element child.");
                    return e
                }
            },
                t.Component = b,
                t.Fragment = o,
                t.Profiler = s,
                t.PureComponent = v,
                t.StrictMode = i,
                t.Suspense = d,
                t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R,
                t.act = D,
                t.cloneElement = function (e, t, r) {
                    if (null === e || void 0 === e)
                        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                    var o = m({}, e.props)
                        , i = e.key
                        , s = e.ref
                        , a = e._owner;
                    if (null != t) {
                        if (void 0 !== t.ref && (s = t.ref,
                            a = S.current),
                            void 0 !== t.key && (i = "" + t.key),
                            e.type && e.type.defaultProps)
                            var l = e.type.defaultProps;
                        for (c in t)
                            C.call(t, c) && !x.hasOwnProperty(c) && (o[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c])
                    }
                    var c = arguments.length - 2;
                    if (1 === c)
                        o.children = r;
                    else if (1 < c) {
                        l = Array(c);
                        for (var d = 0; d < c; d++)
                            l[d] = arguments[d + 2];
                        o.children = l
                    }
                    return {
                        $$typeof: n,
                        type: e.type,
                        key: i,
                        ref: s,
                        props: o,
                        _owner: a
                    }
                }
                ,
                t.createContext = function (e) {
                    return (e = {
                        $$typeof: l,
                        _currentValue: e,
                        _currentValue2: e,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: a,
                        _context: e
                    },
                        e.Consumer = e
                }
                ,
                t.createElement = E,
                t.createFactory = function (e) {
                    var t = E.bind(null, e);
                    return t.type = e,
                        t
                }
                ,
                t.createRef = function () {
                    return {
                        current: null
                    }
                }
                ,
                t.forwardRef = function (e) {
                    return {
                        $$typeof: c,
                        render: e
                    }
                }
                ,
                t.isValidElement = M,
                t.lazy = function (e) {
                    return {
                        $$typeof: h,
                        _payload: {
                            _status: -1,
                            _result: e
                        },
                        _init: A
                    }
                }
                ,
                t.memo = function (e, t) {
                    return {
                        $$typeof: u,
                        type: e,
                        compare: void 0 === t ? null : t
                    }
                }
                ,
                t.startTransition = function (e) {
                    var t = L.transition;
                    L.transition = {};
                    try {
                        e()
                    } finally {
                        L.transition = t
                    }
                }
                ,
                t.unstable_act = D,
                t.useCallback = function (e, t) {
                    return P.current.useCallback(e, t)
                }
                ,
                t.useContext = function (e) {
                    return P.current.useContext(e)
                }
                ,
                t.useDebugValue = function () { }
                ,
                t.useDeferredValue = function (e) {
                    return P.current.useDeferredValue(e)
                }
                ,
                t.useEffect = function (e, t) {
                    return P.current.useEffect(e, t)
                }
                ,
                t.useId = function () {
                    return P.current.useId()
                }
                ,
                t.useImperativeHandle = function (e, t, n) {
                    return P.current.useImperativeHandle(e, t, n)
                }
                ,
                t.useInsertionEffect = function (e, t) {
                    return P.current.useInsertionEffect(e, t)
                }
                ,
                t.useLayoutEffect = function (e, t) {
                    return P.current.useLayoutEffect(e, t)
                }
                ,
                t.useMemo = function (e, t) {
                    return P.current.useMemo(e, t)
                }
                ,
                t.useReducer = function (e, t, n) {
                    return P.current.useReducer(e, t, n)
                }
                ,
                t.useRef = function (e) {
                    return P.current.useRef(e)
                }
                ,
                t.useState = function (e) {
                    return P.current.useState(e)
                }
                ,
                t.useSyncExternalStore = function (e, t, n) {
                    return P.current.useSyncExternalStore(e, t, n)
                }
                ,
                t.useTransition = function () {
                    return P.current.useTransition()
                }
                ,
                t.version = "18.3.1"
        }
        ,
        5043: (e, t, n) => {
            e.exports = n(4202)
        }
        ,
        579: (e, t, n) => {
            e.exports = n(1153)
        }
        ,
        7234: (e, t) => {
            function n(e, t) {
                var n = e.length;
                e.push(t);
                e: for (; 0 < n;) {
                    var r = n - 1 >>> 1
                        , o = e[r];
                    if (!(0 < i(o, t)))
                        break e;
                    e[r] = t,
                        e[n] = o,
                        n = r
                }
            }
            function r(e) {
                return 0 === e.length ? null : e[0]
            }
            function o(e) {
                if (0 === e.length)
                    return null;
                var t = e[0]
                    , n = e.pop();
                if (n !== t) {
                    e[0] = n;
                    e: for (var r = 0, o = e.length, s = o >>> 1; r < s;) {
                        var a = 2 * (r + 1) - 1
                            , l = e[a]
                            , c = a + 1
                            , d = e[c];
                        if (0 > i(l, n))
                            c < o && 0 > i(d, l) ? (e[r] = d,
                                e[c] = n,
                                r = c) : (e[r] = l,
                                    e[a] = n,
                                    r = a);
                        else {
                            if (!(c < o && 0 > i(d, n)))
                                break e;
                            e[r] = d,
                                e[c] = n,
                                r = c
                        }
                    }
                }
                return t
            }
            function i(e, t) {
                var n = e.sortIndex - t.sortIndex;
                return 0 !== n ? n : e.id - t.id
            }
            if ("object" === typeof performance && "function" === typeof performance.now) {
                var s = performance;
                t.unstable_now = function () {
                    return s.now()
                }
            } else {
                var a = Date
                    , l = a.now();
                t.unstable_now = function () {
                    return a.now() - l
                }
            }
            var c = []
                , d = []
                , u = 1
                , h = null
                , p = 3
                , f = !1
                , m = !1
                , g = !1
                , b = "function" === typeof setTimeout ? setTimeout : null
                , y = "function" === typeof clearTimeout ? clearTimeout : null
                , v = "undefined" !== typeof setImmediate ? setImmediate : null;
            function w(e) {
                for (var t = r(d); null !== t;) {
                    if (null === t.callback)
                        o(d);
                    else {
                        if (!(t.startTime <= e))
                            break;
                        o(d),
                            t.sortIndex = t.expirationTime,
                            n(c, t)
                    }
                    t = r(d)
                }
            }
            function k(e) {
                if (g = !1,
                    w(e),
                    !m)
                    if (null !== r(c))
                        m = !0,
                            L(C);
                    else {
                        var t = r(d);
                        null !== t && R(k, t.startTime - e)
                    }
            }
            function C(e, n) {
                m = !1,
                    g && (g = !1,
                        y(M),
                        M = -1),
                    f = !0;
                var i = p;
                try {
                    for (w(n),
                        h = r(c); null !== h && (!(h.expirationTime > n) || e && !_());) {
                        var s = h.callback;
                        if ("function" === typeof s) {
                            h.callback = null,
                                p = h.priorityLevel;
                            var a = s(h.expirationTime <= n);
                            n = t.unstable_now(),
                                "function" === typeof a ? h.callback = a : h === r(c) && o(c),
                                w(n)
                        } else
                            o(c);
                        h = r(c)
                    }
                    if (null !== h)
                        var l = !0;
                    else {
                        var u = r(d);
                        null !== u && R(k, u.startTime - n),
                            l = !1
                    }
                    return l
                } finally {
                    h = null,
                        p = i,
                        f = !1
                }
            }
            "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            var S, x = !1, E = null, M = -1, T = 5, N = -1;
            function _() {
                return !(t.unstable_now() - N < T)
            }
            function O() {
                if (null !== E) {
                    var e = t.unstable_now();
                    N = e;
                    var n = !0;
                    try {
                        n = E(!0, e)
                    } finally {
                        n ? S() : (x = !1,
                            E = null)
                    }
                } else
                    x = !1
            }
            if ("function" === typeof v)
                S = function () {
                    v(O)
                }
                    ;
            else if ("undefined" !== typeof MessageChannel) {
                var A = new MessageChannel
                    , P = A.port2;
                A.port1.onmessage = O,
                    S = function () {
                        P.postMessage(null)
                    }
            } else
                S = function () {
                    b(O, 0)
                }
                    ;
            function L(e) {
                E = e,
                    x || (x = !0,
                        S())
            }
            function R(e, n) {
                M = b((function () {
                    e(t.unstable_now())
                }
                ), n)
            }
            t.unstable_IdlePriority = 5,
                t.unstable_ImmediatePriority = 1,
                t.unstable_LowPriority = 4,
                t.unstable_NormalPriority = 3,
                t.unstable_Profiling = null,
                t.unstable_UserBlockingPriority = 2,
                t.unstable_cancelCallback = function (e) {
                    e.callback = null
                }
                ,
                t.unstable_continueExecution = function () {
                    m || f || (m = !0,
                        L(C))
                }
                ,
                t.unstable_forceFrameRate = function (e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < e ? Math.floor(1e3 / e) : 5
                }
                ,
                t.unstable_getCurrentPriorityLevel = function () {
                    return p
                }
                ,
                t.unstable_getFirstCallbackNode = function () {
                    return r(c)
                }
                ,
                t.unstable_next = function (e) {
                    switch (p) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = p
                    }
                    var n = p;
                    p = t;
                    try {
                        return e()
                    } finally {
                        p = n
                    }
                }
                ,
                t.unstable_pauseExecution = function () { }
                ,
                t.unstable_requestPaint = function () { }
                ,
                t.unstable_runWithPriority = function (e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = p;
                    p = e;
                    try {
                        return t()
                    } finally {
                        p = n
                    }
                }
                ,
                t.unstable_scheduleCallback = function (e, o, i) {
                    var s = t.unstable_now();
                    switch ("object" === typeof i && null !== i ? i = "number" === typeof (i = i.delay) && 0 < i ? s + i : s : i = s,
                    e) {
                        case 1:
                            var a = -1;
                            break;
                        case 2:
                            a = 250;
                            break;
                        case 5:
                            a = 1073741823;
                            break;
                        case 4:
                            a = 1e4;
                            break;
                        default:
                            a = 5e3
                    }
                    return e = {
                        id: u++,
                        callback: o,
                        priorityLevel: e,
                        startTime: i,
                        expirationTime: a = i + a,
                        sortIndex: -1
                    },
                        i > s ? (e.sortIndex = i,
                            n(d, e),
                            null === r(c) && e === r(d) && (g ? (y(M),
                                M = -1) : g = !0,
                                R(k, i - s))) : (e.sortIndex = a,
                                    n(c, e),
                                    m || f || (m = !0,
                                        L(C))),
                        e
                }
                ,
                t.unstable_shouldYield = _,
                t.unstable_wrapCallback = function (e) {
                    var t = p;
                    return function () {
                        var n = p;
                        p = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            p = n
                        }
                    }
                }
        }
        ,
        8853: (e, t, n) => {
            e.exports = n(7234)
        }
        ,
        3781: (e, t, n) => {
            function r(e, t) {
                const n = String(e);
                if ("string" !== typeof t)
                    throw new TypeError("Expected character");
                let r = 0
                    , o = n.indexOf(t);
                for (; -1 !== o;)
                    r++,
                        o = n.indexOf(t, o + t.length);
                return r
            }
            n.d(t, {
                D: () => r
            })
        }
        ,
        2259: (e, t, n) => {
            function r(e) {
                const t = []
                    , n = String(e || "");
                let r = n.indexOf(",")
                    , o = 0
                    , i = !1;
                for (; !i;) {
                    -1 === r && (r = n.length,
                        i = !0);
                    const e = n.slice(o, r).trim();
                    !e && i || t.push(e),
                        o = r + 1,
                        r = n.indexOf(",", o)
                }
                return t
            }
            function o(e, t) {
                const n = t || {};
                return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim()
            }
            n.d(t, {
                A: () => o,
                q: () => r
            })
        }
        ,
        478: (e, t, n) => {
            n.d(t, {
                m: () => o
            });
            const r = /[ \t\n\f\r]/g;
            function o(e) {
                return "object" === typeof e ? "text" === e.type && i(e.value) : i(e)
            }
            function i(e) {
                return "" === e.replace(r, "")
            }
        }
        ,
        3573: (e, t, n) => {
            n.d(t, {
                qy: () => y,
                JW: () => v
            });
            class r {
                constructor(e, t, n) {
                    this.property = e,
                        this.normal = t,
                        n && (this.space = n)
                }
            }
            function o(e, t) {
                const n = {}
                    , o = {};
                let i = -1;
                for (; ++i < e.length;)
                    Object.assign(n, e[i].property),
                        Object.assign(o, e[i].normal);
                return new r(n, o, t)
            }
            r.prototype.property = {},
                r.prototype.normal = {},
                r.prototype.space = null;
            var i = n(7312)
                , s = n(8306);
            const a = {}.hasOwnProperty;
            function l(e) {
                const t = {}
                    , n = {};
                let o;
                for (o in e.properties)
                    if (a.call(e.properties, o)) {
                        const r = e.properties[o]
                            , a = new s.E(o, e.transform(e.attributes || {}, o), r, e.space);
                        e.mustUseProperty && e.mustUseProperty.includes(o) && (a.mustUseProperty = !0),
                            t[o] = a,
                            n[(0,
                                i.S)(o)] = o,
                            n[(0,
                                i.S)(a.attribute)] = o
                    }
                return new r(t, n, e.space)
            }
            const c = l({
                space: "xlink",
                transform: (e, t) => "xlink:" + t.slice(5).toLowerCase(),
                properties: {
                    xLinkActuate: null,
                    xLinkArcRole: null,
                    xLinkHref: null,
                    xLinkRole: null,
                    xLinkShow: null,
                    xLinkTitle: null,
                    xLinkType: null
                }
            })
                , d = l({
                    space: "xml",
                    transform: (e, t) => "xml:" + t.slice(3).toLowerCase(),
                    properties: {
                        xmlLang: null,
                        xmlBase: null,
                        xmlSpace: null
                    }
                });
            function u(e, t) {
                return t in e ? e[t] : t
            }
            function h(e, t) {
                return u(e, t.toLowerCase())
            }
            const p = l({
                space: "xmlns",
                attributes: {
                    xmlnsxlink: "xmlns:xlink"
                },
                transform: h,
                properties: {
                    xmlns: null,
                    xmlnsXLink: null
                }
            });
            var f = n(161);
            const m = l({
                transform: (e, t) => "role" === t ? t : "aria-" + t.slice(4).toLowerCase(),
                properties: {
                    ariaActiveDescendant: null,
                    ariaAtomic: f.booleanish,
                    ariaAutoComplete: null,
                    ariaBusy: f.booleanish,
                    ariaChecked: f.booleanish,
                    ariaColCount: f.number,
                    ariaColIndex: f.number,
                    ariaColSpan: f.number,
                    ariaControls: f.spaceSeparated,
                    ariaCurrent: null,
                    ariaDescribedBy: f.spaceSeparated,
                    ariaDetails: null,
                    ariaDisabled: f.booleanish,
                    ariaDropEffect: f.spaceSeparated,
                    ariaErrorMessage: null,
                    ariaExpanded: f.booleanish,
                    ariaFlowTo: f.spaceSeparated,
                    ariaGrabbed: f.booleanish,
                    ariaHasPopup: null,
                    ariaHidden: f.booleanish,
                    ariaInvalid: null,
                    ariaKeyShortcuts: null,
                    ariaLabel: null,
                    ariaLabelledBy: f.spaceSeparated,
                    ariaLevel: f.number,
                    ariaLive: null,
                    ariaModal: f.booleanish,
                    ariaMultiLine: f.booleanish,
                    ariaMultiSelectable: f.booleanish,
                    ariaOrientation: null,
                    ariaOwns: f.spaceSeparated,
                    ariaPlaceholder: null,
                    ariaPosInSet: f.number,
                    ariaPressed: f.booleanish,
                    ariaReadOnly: f.booleanish,
                    ariaRelevant: null,
                    ariaRequired: f.booleanish,
                    ariaRoleDescription: f.spaceSeparated,
                    ariaRowCount: f.number,
                    ariaRowIndex: f.number,
                    ariaRowSpan: f.number,
                    ariaSelected: f.booleanish,
                    ariaSetSize: f.number,
                    ariaSort: null,
                    ariaValueMax: f.number,
                    ariaValueMin: f.number,
                    ariaValueNow: f.number,
                    ariaValueText: null,
                    role: null
                }
            })
                , g = l({
                    space: "html",
                    attributes: {
                        acceptcharset: "accept-charset",
                        classname: "class",
                        htmlfor: "for",
                        httpequiv: "http-equiv"
                    },
                    transform: h,
                    mustUseProperty: ["checked", "multiple", "muted", "selected"],
                    properties: {
                        abbr: null,
                        accept: f.commaSeparated,
                        acceptCharset: f.spaceSeparated,
                        accessKey: f.spaceSeparated,
                        action: null,
                        allow: null,
                        allowFullScreen: f.boolean,
                        allowPaymentRequest: f.boolean,
                        allowUserMedia: f.boolean,
                        alt: null,
                        as: null,
                        async: f.boolean,
                        autoCapitalize: null,
                        autoComplete: f.spaceSeparated,
                        autoFocus: f.boolean,
                        autoPlay: f.boolean,
                        blocking: f.spaceSeparated,
                        capture: null,
                        charSet: null,
                        checked: f.boolean,
                        cite: null,
                        className: f.spaceSeparated,
                        cols: f.number,
                        colSpan: null,
                        content: null,
                        contentEditable: f.booleanish,
                        controls: f.boolean,
                        controlsList: f.spaceSeparated,
                        coords: f.number | f.commaSeparated,
                        crossOrigin: null,
                        data: null,
                        dateTime: null,
                        decoding: null,
                        default: f.boolean,
                        defer: f.boolean,
                        dir: null,
                        dirName: null,
                        disabled: f.boolean,
                        download: f.overloadedBoolean,
                        draggable: f.booleanish,
                        encType: null,
                        enterKeyHint: null,
                        fetchPriority: null,
                        form: null,
                        formAction: null,
                        formEncType: null,
                        formMethod: null,
                        formNoValidate: f.boolean,
                        formTarget: null,
                        headers: f.spaceSeparated,
                        height: f.number,
                        hidden: f.boolean,
                        high: f.number,
                        href: null,
                        hrefLang: null,
                        htmlFor: f.spaceSeparated,
                        httpEquiv: f.spaceSeparated,
                        id: null,
                        imageSizes: null,
                        imageSrcSet: null,
                        inert: f.boolean,
                        inputMode: null,
                        integrity: null,
                        is: null,
                        isMap: f.boolean,
                        itemId: null,
                        itemProp: f.spaceSeparated,
                        itemRef: f.spaceSeparated,
                        itemScope: f.boolean,
                        itemType: f.spaceSeparated,
                        kind: null,
                        label: null,
                        lang: null,
                        language: null,
                        list: null,
                        loading: null,
                        loop: f.boolean,
                        low: f.number,
                        manifest: null,
                        max: null,
                        maxLength: f.number,
                        media: null,
                        method: null,
                        min: null,
                        minLength: f.number,
                        multiple: f.boolean,
                        muted: f.boolean,
                        name: null,
                        nonce: null,
                        noModule: f.boolean,
                        noValidate: f.boolean,
                        onAbort: null,
                        onAfterPrint: null,
                        onAuxClick: null,
                        onBeforeMatch: null,
                        onBeforePrint: null,
                        onBeforeToggle: null,
                        onBeforeUnload: null,
                        onBlur: null,
                        onCancel: null,
                        onCanPlay: null,
                        onCanPlayThrough: null,
                        onChange: null,
                        onClick: null,
                        onClose: null,
                        onContextLost: null,
                        onContextMenu: null,
                        onContextRestored: null,
                        onCopy: null,
                        onCueChange: null,
                        onCut: null,
                        onDblClick: null,
                        onDrag: null,
                        onDragEnd: null,
                        onDragEnter: null,
                        onDragExit: null,
                        onDragLeave: null,
                        onDragOver: null,
                        onDragStart: null,
                        onDrop: null,
                        onDurationChange: null,
                        onEmptied: null,
                        onEnded: null,
                        onError: null,
                        onFocus: null,
                        onFormData: null,
                        onHashChange: null,
                        onInput: null,
                        onInvalid: null,
                        onKeyDown: null,
                        onKeyPress: null,
                        onKeyUp: null,
                        onLanguageChange: null,
                        onLoad: null,
                        onLoadedData: null,
                        onLoadedMetadata: null,
                        onLoadEnd: null,
                        onLoadStart: null,
                        onMessage: null,
                        onMessageError: null,
                        onMouseDown: null,
                        onMouseEnter: null,
                        onMouseLeave: null,
                        onMouseMove: null,
                        onMouseOut: null,
                        onMouseOver: null,
                        onMouseUp: null,
                        onOffline: null,
                        onOnline: null,
                        onPageHide: null,
                        onPageShow: null,
                        onPaste: null,
                        onPause: null,
                        onPlay: null,
                        onPlaying: null,
                        onPopState: null,
                        onProgress: null,
                        onRateChange: null,
                        onRejectionHandled: null,
                        onReset: null,
                        onResize: null,
                        onScroll: null,
                        onScrollEnd: null,
                        onSecurityPolicyViolation: null,
                        onSeeked: null,
                        onSeeking: null,
                        onSelect: null,
                        onSlotChange: null,
                        onStalled: null,
                        onStorage: null,
                        onSubmit: null,
                        onSuspend: null,
                        onTimeUpdate: null,
                        onToggle: null,
                        onUnhandledRejection: null,
                        onUnload: null,
                        onVolumeChange: null,
                        onWaiting: null,
                        onWheel: null,
                        open: f.boolean,
                        optimum: f.number,
                        pattern: null,
                        ping: f.spaceSeparated,
                        placeholder: null,
                        playsInline: f.boolean,
                        popover: null,
                        popoverTarget: null,
                        popoverTargetAction: null,
                        poster: null,
                        preload: null,
                        readOnly: f.boolean,
                        referrerPolicy: null,
                        rel: f.spaceSeparated,
                        required: f.boolean,
                        reversed: f.boolean,
                        rows: f.number,
                        rowSpan: f.number,
                        sandbox: f.spaceSeparated,
                        scope: null,
                        scoped: f.boolean,
                        seamless: f.boolean,
                        selected: f.boolean,
                        shadowRootClonable: f.boolean,
                        shadowRootDelegatesFocus: f.boolean,
                        shadowRootMode: null,
                        shape: null,
                        size: f.number,
                        sizes: null,
                        slot: null,
                        span: f.number,
                        spellCheck: f.booleanish,
                        src: null,
                        srcDoc: null,
                        srcLang: null,
                        srcSet: null,
                        start: f.number,
                        step: null,
                        style: null,
                        tabIndex: f.number,
                        target: null,
                        title: null,
                        translate: null,
                        type: null,
                        typeMustMatch: f.boolean,
                        useMap: null,
                        value: f.booleanish,
                        width: f.number,
                        wrap: null,
                        writingSuggestions: null,
                        align: null,
                        aLink: null,
                        archive: f.spaceSeparated,
                        axis: null,
                        background: null,
                        bgColor: null,
                        border: f.number,
                        borderColor: null,
                        bottomMargin: f.number,
                        cellPadding: null,
                        cellSpacing: null,
                        char: null,
                        charOff: null,
                        classId: null,
                        clear: null,
                        code: null,
                        codeBase: null,
                        codeType: null,
                        color: null,
                        compact: f.boolean,
                        declare: f.boolean,
                        event: null,
                        face: null,
                        frame: null,
                        frameBorder: null,
                        hSpace: f.number,
                        leftMargin: f.number,
                        link: null,
                        longDesc: null,
                        lowSrc: null,
                        marginHeight: f.number,
                        marginWidth: f.number,
                        noResize: f.boolean,
                        noHref: f.boolean,
                        noShade: f.boolean,
                        noWrap: f.boolean,
                        object: null,
                        profile: null,
                        prompt: null,
                        rev: null,
                        rightMargin: f.number,
                        rules: null,
                        scheme: null,
                        scrolling: f.booleanish,
                        standby: null,
                        summary: null,
                        text: null,
                        topMargin: f.number,
                        valueType: null,
                        version: null,
                        vAlign: null,
                        vLink: null,
                        vSpace: f.number,
                        allowTransparency: null,
                        autoCorrect: null,
                        autoSave: null,
                        disablePictureInPicture: f.boolean,
                        disableRemotePlayback: f.boolean,
                        prefix: null,
                        property: null,
                        results: f.number,
                        security: null,
                        unselectable: null
                    }
                })
                , b = l({
                    space: "svg",
                    attributes: {
                        accentHeight: "accent-height",
                        alignmentBaseline: "alignment-baseline",
                        arabicForm: "arabic-form",
                        baselineShift: "baseline-shift",
                        capHeight: "cap-height",
                        className: "class",
                        clipPath: "clip-path",
                        clipRule: "clip-rule",
                        colorInterpolation: "color-interpolation",
                        colorInterpolationFilters: "color-interpolation-filters",
                        colorProfile: "color-profile",
                        colorRendering: "color-rendering",
                        crossOrigin: "crossorigin",
                        dataType: "datatype",
                        dominantBaseline: "dominant-baseline",
                        enableBackground: "enable-background",
                        fillOpacity: "fill-opacity",
                        fillRule: "fill-rule",
                        floodColor: "flood-color",
                        floodOpacity: "flood-opacity",
                        fontFamily: "font-family",
                        fontSize: "font-size",
                        fontSizeAdjust: "font-size-adjust",
                        fontStretch: "font-stretch",
                        fontStyle: "font-style",
                        fontVariant: "font-variant",
                        fontWeight: "font-weight",
                        glyphName: "glyph-name",
                        glyphOrientationHorizontal: "glyph-orientation-horizontal",
                        glyphOrientationVertical: "glyph-orientation-vertical",
                        hrefLang: "hreflang",
                        horizAdvX: "horiz-adv-x",
                        horizOriginX: "horiz-origin-x",
                        horizOriginY: "horiz-origin-y",
                        imageRendering: "image-rendering",
                        letterSpacing: "letter-spacing",
                        lightingColor: "lighting-color",
                        markerEnd: "marker-end",
                        markerMid: "marker-mid",
                        markerStart: "marker-start",
                        navDown: "nav-down",
                        navDownLeft: "nav-down-left",
                        navDownRight: "nav-down-right",
                        navLeft: "nav-left",
                        navNext: "nav-next",
                        navPrev: "nav-prev",
                        navRight: "nav-right",
                        navUp: "nav-up",
                        navUpLeft: "nav-up-left",
                        navUpRight: "nav-up-right",
                        onAbort: "onabort",
                        onActivate: "onactivate",
                        onAfterPrint: "onafterprint",
                        onBeforePrint: "onbeforeprint",
                        onBegin: "onbegin",
                        onCancel: "oncancel",
                        onCanPlay: "oncanplay",
                        onCanPlayThrough: "oncanplaythrough",
                        onChange: "onchange",
                        onClick: "onclick",
                        onClose: "onclose",
                        onCopy: "oncopy",
                        onCueChange: "oncuechange",
                        onCut: "oncut",
                        onDblClick: "ondblclick",
                        onDrag: "ondrag",
                        onDragEnd: "ondragend",
                        onDragEnter: "ondragenter",
                        onDragExit: "ondragexit",
                        onDragLeave: "ondragleave",
                        onDragOver: "ondragover",
                        onDragStart: "ondragstart",
                        onDrop: "ondrop",
                        onDurationChange: "ondurationchange",
                        onEmptied: "onemptied",
                        onEnd: "onend",
                        onEnded: "onended",
                        onError: "onerror",
                        onFocus: "onfocus",
                        onFocusIn: "onfocusin",
                        onFocusOut: "onfocusout",
                        onHashChange: "onhashchange",
                        onInput: "oninput",
                        onInvalid: "oninvalid",
                        onKeyDown: "onkeydown",
                        onKeyPress: "onkeypress",
                        onKeyUp: "onkeyup",
                        onLoad: "onload",
                        onLoadedData: "onloadeddata",
                        onLoadedMetadata: "onloadedmetadata",
                        onLoadStart: "onloadstart",
                        onMessage: "onmessage",
                        onMouseDown: "onmousedown",
                        onMouseEnter: "onmouseenter",
                        onMouseLeave: "onmouseleave",
                        onMouseMove: "onmousemove",
                        onMouseOut: "onmouseout",
                        onMouseOver: "onmouseover",
                        onMouseUp: "onmouseup",
                        onMouseWheel: "onmousewheel",
                        onOffline: "onoffline",
                        onOnline: "ononline",
                        onPageHide: "onpagehide",
                        onPageShow: "onpageshow",
                        onPaste: "onpaste",
                        onPause: "onpause",
                        onPlay: "onplay",
                        onPlaying: "onplaying",
                        onPopState: "onpopstate",
                        onProgress: "onprogress",
                        onRateChange: "onratechange",
                        onRepeat: "onrepeat",
                        onReset: "onreset",
                        onResize: "onresize",
                        onScroll: "onscroll",
                        onSeeked: "onseeked",
                        onSeeking: "onseeking",
                        onSelect: "onselect",
                        onShow: "onshow",
                        onStalled: "onstalled",
                        onStorage: "onstorage",
                        onSubmit: "onsubmit",
                        onSuspend: "onsuspend",
                        onTimeUpdate: "ontimeupdate",
                        onToggle: "ontoggle",
                        onUnload: "onunload",
                        onVolumeChange: "onvolumechange",
                        onWaiting: "onwaiting",
                        onZoom: "onzoom",
                        overlinePosition: "overline-position",
                        overlineThickness: "overline-thickness",
                        paintOrder: "paint-order",
                        panose1: "panose-1",
                        pointerEvents: "pointer-events",
                        referrerPolicy: "referrerpolicy",
                        renderingIntent: "rendering-intent",
                        shapeRendering: "shape-rendering",
                        stopColor: "stop-color",
                        stopOpacity: "stop-opacity",
                        strikethroughPosition: "strikethrough-position",
                        strikethroughThickness: "strikethrough-thickness",
                        strokeDashArray: "stroke-dasharray",
                        strokeDashOffset: "stroke-dashoffset",
                        strokeLineCap: "stroke-linecap",
                        strokeLineJoin: "stroke-linejoin",
                        strokeMiterLimit: "stroke-miterlimit",
                        strokeOpacity: "stroke-opacity",
                        strokeWidth: "stroke-width",
                        tabIndex: "tabindex",
                        textAnchor: "text-anchor",
                        textDecoration: "text-decoration",
                        textRendering: "text-rendering",
                        transformOrigin: "transform-origin",
                        typeOf: "typeof",
                        underlinePosition: "underline-position",
                        underlineThickness: "underline-thickness",
                        unicodeBidi: "unicode-bidi",
                        unicodeRange: "unicode-range",
                        unitsPerEm: "units-per-em",
                        vAlphabetic: "v-alphabetic",
                        vHanging: "v-hanging",
                        vIdeographic: "v-ideographic",
                        vMathematical: "v-mathematical",
                        vectorEffect: "vector-effect",
                        vertAdvY: "vert-adv-y",
                        vertOriginX: "vert-origin-x",
                        vertOriginY: "vert-origin-y",
                        wordSpacing: "word-spacing",
                        writingMode: "writing-mode",
                        xHeight: "x-height",
                        playbackOrder: "playbackorder",
                        timelineBegin: "timelinebegin"
                    },
                    transform: u,
                    properties: {
                        about: f.commaOrSpaceSeparated,
                        accentHeight: f.number,
                        accumulate: null,
                        additive: null,
                        alignmentBaseline: null,
                        alphabetic: f.number,
                        amplitude: f.number,
                        arabicForm: null,
                        ascent: f.number,
                        attributeName: null,
                        attributeType: null,
                        azimuth: f.number,
                        bandwidth: null,
                        baselineShift: null,
                        baseFrequency: null,
                        baseProfile: null,
                        bbox: null,
                        begin: null,
                        bias: f.number,
                        by: null,
                        calcMode: null,
                        capHeight: f.number,
                        className: f.spaceSeparated,
                        clip: null,
                        clipPath: null,
                        clipPathUnits: null,
                        clipRule: null,
                        color: null,
                        colorInterpolation: null,
                        colorInterpolationFilters: null,
                        colorProfile: null,
                        colorRendering: null,
                        content: null,
                        contentScriptType: null,
                        contentStyleType: null,
                        crossOrigin: null,
                        cursor: null,
                        cx: null,
                        cy: null,
                        d: null,
                        dataType: null,
                        defaultAction: null,
                        descent: f.number,
                        diffuseConstant: f.number,
                        direction: null,
                        display: null,
                        dur: null,
                        divisor: f.number,
                        dominantBaseline: null,
                        download: f.boolean,
                        dx: null,
                        dy: null,
                        edgeMode: null,
                        editable: null,
                        elevation: f.number,
                        enableBackground: null,
                        end: null,
                        event: null,
                        exponent: f.number,
                        externalResourcesRequired: null,
                        fill: null,
                        fillOpacity: f.number,
                        fillRule: null,
                        filter: null,
                        filterRes: null,
                        filterUnits: null,
                        floodColor: null,
                        floodOpacity: null,
                        focusable: null,
                        focusHighlight: null,
                        fontFamily: null,
                        fontSize: null,
                        fontSizeAdjust: null,
                        fontStretch: null,
                        fontStyle: null,
                        fontVariant: null,
                        fontWeight: null,
                        format: null,
                        fr: null,
                        from: null,
                        fx: null,
                        fy: null,
                        g1: f.commaSeparated,
                        g2: f.commaSeparated,
                        glyphName: f.commaSeparated,
                        glyphOrientationHorizontal: null,
                        glyphOrientationVertical: null,
                        glyphRef: null,
                        gradientTransform: null,
                        gradientUnits: null,
                        handler: null,
                        hanging: f.number,
                        hatchContentUnits: null,
                        hatchUnits: null,
                        height: null,
                        href: null,
                        hrefLang: null,
                        horizAdvX: f.number,
                        horizOriginX: f.number,
                        horizOriginY: f.number,
                        id: null,
                        ideographic: f.number,
                        imageRendering: null,
                        initialVisibility: null,
                        in: null,
                        in2: null,
                        intercept: f.number,
                        k: f.number,
                        k1: f.number,
                        k2: f.number,
                        k3: f.number,
                        k4: f.number,
                        kernelMatrix: f.commaOrSpaceSeparated,
                        kernelUnitLength: null,
                        keyPoints: null,
                        keySplines: null,
                        keyTimes: null,
                        kerning: null,
                        lang: null,
                        lengthAdjust: null,
                        letterSpacing: null,
                        lightingColor: null,
                        limitingConeAngle: f.number,
                        local: null,
                        markerEnd: null,
                        markerMid: null,
                        markerStart: null,
                        markerHeight: null,
                        markerUnits: null,
                        markerWidth: null,
                        mask: null,
                        maskContentUnits: null,
                        maskUnits: null,
                        mathematical: null,
                        max: null,
                        media: null,
                        mediaCharacterEncoding: null,
                        mediaContentEncodings: null,
                        mediaSize: f.number,
                        mediaTime: null,
                        method: null,
                        min: null,
                        mode: null,
                        name: null,
                        navDown: null,
                        navDownLeft: null,
                        navDownRight: null,
                        navLeft: null,
                        navNext: null,
                        navPrev: null,
                        navRight: null,
                        navUp: null,
                        navUpLeft: null,
                        navUpRight: null,
                        numOctaves: null,
                        observer: null,
                        offset: null,
                        onAbort: null,
                        onActivate: null,
                        onAfterPrint: null,
                        onBeforePrint: null,
                        onBegin: null,
                        onCancel: null,
                        onCanPlay: null,
                        onCanPlayThrough: null,
                        onChange: null,
                        onClick: null,
                        onClose: null,
                        onCopy: null,
                        onCueChange: null,
                        onCut: null,
                        onDblClick: null,
                        onDrag: null,
                        onDragEnd: null,
                        onDragEnter: null,
                        onDragExit: null,
                        onDragLeave: null,
                        onDragOver: null,
                        onDragStart: null,
                        onDrop: null,
                        onDurationChange: null,
                        onEmptied: null,
                        onEnd: null,
                        onEnded: null,
                        onError: null,
                        onFocus: null,
                        onFocusIn: null,
                        onFocusOut: null,
                        onHashChange: null,
                        onInput: null,
                        onInvalid: null,
                        onKeyDown: null,
                        onKeyPress: null,
                        onKeyUp: null,
                        onLoad: null,
                        onLoadedData: null,
                        onLoadedMetadata: null,
                        onLoadStart: null,
                        onMessage: null,
                        onMouseDown: null,
                        onMouseEnter: null,
                        onMouseLeave: null,
                        onMouseMove: null,
                        onMouseOut: null,
                        onMouseOver: null,
                        onMouseUp: null,
                        onMouseWheel: null,
                        onOffline: null,
                        onOnline: null,
                        onPageHide: null,
                        onPageShow: null,
                        onPaste: null,
                        onPause: null,
                        onPlay: null,
                        onPlaying: null,
                        onPopState: null,
                        onProgress: null,
                        onRateChange: null,
                        onRepeat: null,
                        onReset: null,
                        onResize: null,
                        onScroll: null,
                        onSeeked: null,
                        onSeeking: null,
                        onSelect: null,
                        onShow: null,
                        onStalled: null,
                        onStorage: null,
                        onSubmit: null,
                        onSuspend: null,
                        onTimeUpdate: null,
                        onToggle: null,
                        onUnload: null,
                        onVolumeChange: null,
                        onWaiting: null,
                        onZoom: null,
                        opacity: null,
                        operator: null,
                        order: null,
                        orient: null,
                        orientation: null,
                        origin: null,
                        overflow: null,
                        overlay: null,
                        overlinePosition: f.number,
                        overlineThickness: f.number,
                        paintOrder: null,
                        panose1: null,
                        path: null,
                        pathLength: f.number,
                        patternContentUnits: null,
                        patternTransform: null,
                        patternUnits: null,
                        phase: null,
                        ping: f.spaceSeparated,
                        pitch: null,
                        playbackOrder: null,
                        pointerEvents: null,
                        points: null,
                        pointsAtX: f.number,
                        pointsAtY: f.number,
                        pointsAtZ: f.number,
                        preserveAlpha: null,
                        preserveAspectRatio: null,
                        primitiveUnits: null,
                        propagate: null,
                        property: f.commaOrSpaceSeparated,
                        r: null,
                        radius: null,
                        referrerPolicy: null,
                        refX: null,
                        refY: null,
                        rel: f.commaOrSpaceSeparated,
                        rev: f.commaOrSpaceSeparated,
                        renderingIntent: null,
                        repeatCount: null,
                        repeatDur: null,
                        requiredExtensions: f.commaOrSpaceSeparated,
                        requiredFeatures: f.commaOrSpaceSeparated,
                        requiredFonts: f.commaOrSpaceSeparated,
                        requiredFormats: f.commaOrSpaceSeparated,
                        resource: null,
                        restart: null,
                        result: null,
                        rotate: null,
                        rx: null,
                        ry: null,
                        scale: null,
                        seed: null,
                        shapeRendering: null,
                        side: null,
                        slope: null,
                        snapshotTime: null,
                        specularConstant: f.number,
                        specularExponent: f.number,
                        spreadMethod: null,
                        spacing: null,
                        startOffset: null,
                        stdDeviation: null,
                        stemh: null,
                        stemv: null,
                        stitchTiles: null,
                        stopColor: null,
                        stopOpacity: null,
                        strikethroughPosition: f.number,
                        strikethroughThickness: f.number,
                        string: null,
                        stroke: null,
                        strokeDashArray: f.commaOrSpaceSeparated,
                        strokeDashOffset: null,
                        strokeLineCap: null,
                        strokeLineJoin: null,
                        strokeMiterLimit: f.number,
                        strokeOpacity: f.number,
                        strokeWidth: null,
                        style: null,
                        surfaceScale: f.number,
                        syncBehavior: null,
                        syncBehaviorDefault: null,
                        syncMaster: null,
                        syncTolerance: null,
                        syncToleranceDefault: null,
                        systemLanguage: f.commaOrSpaceSeparated,
                        tabIndex: f.number,
                        tableValues: null,
                        target: null,
                        targetX: f.number,
                        targetY: f.number,
                        textAnchor: null,
                        textDecoration: null,
                        textRendering: null,
                        textLength: null,
                        timelineBegin: null,
                        title: null,
                        transformBehavior: null,
                        type: null,
                        typeOf: f.commaOrSpaceSeparated,
                        to: null,
                        transform: null,
                        transformOrigin: null,
                        u1: null,
                        u2: null,
                        underlinePosition: f.number,
                        underlineThickness: f.number,
                        unicode: null,
                        unicodeBidi: null,
                        unicodeRange: null,
                        unitsPerEm: f.number,
                        values: null,
                        vAlphabetic: f.number,
                        vMathematical: f.number,
                        vectorEffect: null,
                        vHanging: f.number,
                        vIdeographic: f.number,
                        version: null,
                        vertAdvY: f.number,
                        vertOriginX: f.number,
                        vertOriginY: f.number,
                        viewBox: null,
                        viewTarget: null,
                        visibility: null,
                        width: null,
                        widths: null,
                        wordSpacing: null,
                        writingMode: null,
                        x: null,
                        x1: null,
                        x2: null,
                        xChannelSelector: null,
                        xHeight: f.number,
                        y: null,
                        y1: null,
                        y2: null,
                        yChannelSelector: null,
                        z: null,
                        zoomAndPan: null
                    }
                })
                , y = o([d, c, p, m, g], "html")
                , v = o([d, c, p, m, b], "svg")
        }
        ,
        3944: (e, t, n) => {
            n.d(t, {
                I: () => c
            });
            var r = n(7312)
                , o = n(8306)
                , i = n(5210);
            const s = /^data[-\w.:]+$/i
                , a = /-[a-z]/g
                , l = /[A-Z]/g;
            function c(e, t) {
                const n = (0,
                    r.S)(t);
                let c = t
                    , h = i.R;
                if (n in e.normal)
                    return e.property[e.normal[n]];
                if (n.length > 4 && "data" === n.slice(0, 4) && s.test(t)) {
                    if ("-" === t.charAt(4)) {
                        const e = t.slice(5).replace(a, u);
                        c = "data" + e.charAt(0).toUpperCase() + e.slice(1)
                    } else {
                        const e = t.slice(4);
                        if (!a.test(e)) {
                            let n = e.replace(l, d);
                            "-" !== n.charAt(0) && (n = "-" + n),
                                t = "data" + n
                        }
                    }
                    h = o.E
                }
                return new h(c, t)
            }
            function d(e) {
                return "-" + e.toLowerCase()
            }
            function u(e) {
                return e.charAt(1).toUpperCase()
            }
        }
        ,
        7312: (e, t, n) => {
            function r(e) {
                return e.toLowerCase()
            }
            n.d(t, {
                S: () => r
            })
        }
        ,
        8306: (e, t, n) => {
            n.d(t, {
                E: () => s
            });
            var r = n(5210)
                , o = n(161);
            const i = Object.keys(o);
            class s extends r.R {
                constructor(e, t, n, r) {
                    let s = -1;
                    if (super(e, t),
                        a(this, "space", r),
                        "number" === typeof n)
                        for (; ++s < i.length;) {
                            const e = i[s];
                            a(this, i[s], (n & o[e]) === o[e])
                        }
                }
            }
            function a(e, t, n) {
                n && (e[t] = n)
            }
            s.prototype.defined = !0
        }
        ,
        5210: (e, t, n) => {
            n.d(t, {
                R: () => r
            });
            class r {
                constructor(e, t) {
                    this.property = e,
                        this.attribute = t
                }
            }
            r.prototype.space = null,
                r.prototype.boolean = !1,
                r.prototype.booleanish = !1,
                r.prototype.overloadedBoolean = !1,
                r.prototype.number = !1,
                r.prototype.commaSeparated = !1,
                r.prototype.spaceSeparated = !1,
                r.prototype.commaOrSpaceSeparated = !1,
                r.prototype.mustUseProperty = !1,
                r.prototype.defined = !1
        }
        ,
        161: (e, t, n) => {
            n.r(t),
                n.d(t, {
                    boolean: () => o,
                    booleanish: () => i,
                    commaOrSpaceSeparated: () => d,
                    commaSeparated: () => c,
                    number: () => a,
                    overloadedBoolean: () => s,
                    spaceSeparated: () => l
                });
            let r = 0;
            const o = u()
                , i = u()
                , s = u()
                , a = u()
                , l = u()
                , c = u()
                , d = u();
            function u() {
                return 2 ** ++r
            }
        }
        ,
        4168: (e, t, n) => {
            function r(e) {
                const t = String(e || "").trim();
                return t ? t.split(/[ \t\n\r\f]+/g) : []
            }
            function o(e) {
                return e.join(" ").trim()
            }
            n.d(t, {
                A: () => o,
                q: () => r
            })
        }
        ,
        9917: (e, t, n) => {
            n.d(t, {
                l: () => v
            });
            const r = /["&'<>`]/g
                , o = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
                , i = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
                , s = /[|\\{}()[\]^$+*?.]/g
                , a = new WeakMap;
            function l(e, t) {
                return e = e.replace(t.subset ? function (e) {
                    let t = a.get(e);
                    t || (t = function (e) {
                        const t = [];
                        let n = -1;
                        for (; ++n < e.length;)
                            t.push(e[n].replace(s, "\\$&"));
                        return new RegExp("(?:" + t.join("|") + ")", "g")
                    }(e),
                        a.set(e, t));
                    return t
                }(t.subset) : r, n),
                    t.subset || t.escapeOnly ? e : e.replace(o, (function (e, n, r) {
                        return t.format(1024 * (e.charCodeAt(0) - 55296) + e.charCodeAt(1) - 56320 + 65536, r.charCodeAt(n + 2), t)
                    }
                    )).replace(i, n);
                function n(e, n, r) {
                    return t.format(e.charCodeAt(0), r.charCodeAt(n + 1), t)
                }
            }
            const c = /[\dA-Fa-f]/;
            const d = /\d/;
            const u = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"]
                , h = {
                    nbsp: "\xa0",
                    iexcl: "\xa1",
                    cent: "\xa2",
                    pound: "\xa3",
                    curren: "\xa4",
                    yen: "\xa5",
                    brvbar: "\xa6",
                    sect: "\xa7",
                    uml: "\xa8",
                    copy: "\xa9",
                    ordf: "\xaa",
                    laquo: "\xab",
                    not: "\xac",
                    shy: "\xad",
                    reg: "\xae",
                    macr: "\xaf",
                    deg: "\xb0",
                    plusmn: "\xb1",
                    sup2: "\xb2",
                    sup3: "\xb3",
                    acute: "\xb4",
                    micro: "\xb5",
                    para: "\xb6",
                    middot: "\xb7",
                    cedil: "\xb8",
                    sup1: "\xb9",
                    ordm: "\xba",
                    raquo: "\xbb",
                    frac14: "\xbc",
                    frac12: "\xbd",
                    frac34: "\xbe",
                    iquest: "\xbf",
                    Agrave: "\xc0",
                    Aacute: "\xc1",
                    Acirc: "\xc2",
                    Atilde: "\xc3",
                    Auml: "\xc4",
                    Aring: "\xc5",
                    AElig: "\xc6",
                    Ccedil: "\xc7",
                    Egrave: "\xc8",
                    Eacute: "\xc9",
                    Ecirc: "\xca",
                    Euml: "\xcb",
                    Igrave: "\xcc",
                    Iacute: "\xcd",
                    Icirc: "\xce",
                    Iuml: "\xcf",
                    ETH: "\xd0",
                    Ntilde: "\xd1",
                    Ograve: "\xd2",
                    Oacute: "\xd3",
                    Ocirc: "\xd4",
                    Otilde: "\xd5",
                    Ouml: "\xd6",
                    times: "\xd7",
                    Oslash: "\xd8",
                    Ugrave: "\xd9",
                    Uacute: "\xda",
                    Ucirc: "\xdb",
                    Uuml: "\xdc",
                    Yacute: "\xdd",
                    THORN: "\xde",
                    szlig: "\xdf",
                    agrave: "\xe0",
                    aacute: "\xe1",
                    acirc: "\xe2",
                    atilde: "\xe3",
                    auml: "\xe4",
                    aring: "\xe5",
                    aelig: "\xe6",
                    ccedil: "\xe7",
                    egrave: "\xe8",
                    eacute: "\xe9",
                    ecirc: "\xea",
                    euml: "\xeb",
                    igrave: "\xec",
                    iacute: "\xed",
                    icirc: "\xee",
                    iuml: "\xef",
                    eth: "\xf0",
                    ntilde: "\xf1",
                    ograve: "\xf2",
                    oacute: "\xf3",
                    ocirc: "\xf4",
                    otilde: "\xf5",
                    ouml: "\xf6",
                    divide: "\xf7",
                    oslash: "\xf8",
                    ugrave: "\xf9",
                    uacute: "\xfa",
                    ucirc: "\xfb",
                    uuml: "\xfc",
                    yacute: "\xfd",
                    thorn: "\xfe",
                    yuml: "\xff",
                    fnof: "\u0192",
                    Alpha: "\u0391",
                    Beta: "\u0392",
                    Gamma: "\u0393",
                    Delta: "\u0394",
                    Epsilon: "\u0395",
                    Zeta: "\u0396",
                    Eta: "\u0397",
                    Theta: "\u0398",
                    Iota: "\u0399",
                    Kappa: "\u039a",
                    Lambda: "\u039b",
                    Mu: "\u039c",
                    Nu: "\u039d",
                    Xi: "\u039e",
                    Omicron: "\u039f",
                    Pi: "\u03a0",
                    Rho: "\u03a1",
                    Sigma: "\u03a3",
                    Tau: "\u03a4",
                    Upsilon: "\u03a5",
                    Phi: "\u03a6",
                    Chi: "\u03a7",
                    Psi: "\u03a8",
                    Omega: "\u03a9",
                    alpha: "\u03b1",
                    beta: "\u03b2",
                    gamma: "\u03b3",
                    delta: "\u03b4",
                    epsilon: "\u03b5",
                    zeta: "\u03b6",
                    eta: "\u03b7",
                    theta: "\u03b8",
                    iota: "\u03b9",
                    kappa: "\u03ba",
                    lambda: "\u03bb",
                    mu: "\u03bc",
                    nu: "\u03bd",
                    xi: "\u03be",
                    omicron: "\u03bf",
                    pi: "\u03c0",
                    rho: "\u03c1",
                    sigmaf: "\u03c2",
                    sigma: "\u03c3",
                    tau: "\u03c4",
                    upsilon: "\u03c5",
                    phi: "\u03c6",
                    chi: "\u03c7",
                    psi: "\u03c8",
                    omega: "\u03c9",
                    thetasym: "\u03d1",
                    upsih: "\u03d2",
                    piv: "\u03d6",
                    bull: "\u2022",
                    hellip: "\u2026",
                    prime: "\u2032",
                    Prime: "\u2033",
                    oline: "\u203e",
                    frasl: "\u2044",
                    weierp: "\u2118",
                    image: "\u2111",
                    real: "\u211c",
                    trade: "\u2122",
                    alefsym: "\u2135",
                    larr: "\u2190",
                    uarr: "\u2191",
                    rarr: "\u2192",
                    darr: "\u2193",
                    harr: "\u2194",
                    crarr: "\u21b5",
                    lArr: "\u21d0",
                    uArr: "\u21d1",
                    rArr: "\u21d2",
                    dArr: "\u21d3",
                    hArr: "\u21d4",
                    forall: "\u2200",
                    part: "\u2202",
                    exist: "\u2203",
                    empty: "\u2205",
                    nabla: "\u2207",
                    isin: "\u2208",
                    notin: "\u2209",
                    ni: "\u220b",
                    prod: "\u220f",
                    sum: "\u2211",
                    minus: "\u2212",
                    lowast: "\u2217",
                    radic: "\u221a",
                    prop: "\u221d",
                    infin: "\u221e",
                    ang: "\u2220",
                    and: "\u2227",
                    or: "\u2228",
                    cap: "\u2229",
                    cup: "\u222a",
                    int: "\u222b",
                    there4: "\u2234",
                    sim: "\u223c",
                    cong: "\u2245",
                    asymp: "\u2248",
                    ne: "\u2260",
                    equiv: "\u2261",
                    le: "\u2264",
                    ge: "\u2265",
                    sub: "\u2282",
                    sup: "\u2283",
                    nsub: "\u2284",
                    sube: "\u2286",
                    supe: "\u2287",
                    oplus: "\u2295",
                    otimes: "\u2297",
                    perp: "\u22a5",
                    sdot: "\u22c5",
                    lceil: "\u2308",
                    rceil: "\u2309",
                    lfloor: "\u230a",
                    rfloor: "\u230b",
                    lang: "\u2329",
                    rang: "\u232a",
                    loz: "\u25ca",
                    spades: "\u2660",
                    clubs: "\u2663",
                    hearts: "\u2665",
                    diams: "\u2666",
                    quot: '"',
                    amp: "&",
                    lt: "<",
                    gt: ">",
                    OElig: "\u0152",
                    oelig: "\u0153",
                    Scaron: "\u0160",
                    scaron: "\u0161",
                    Yuml: "\u0178",
                    circ: "\u02c6",
                    tilde: "\u02dc",
                    ensp: "\u2002",
                    emsp: "\u2003",
                    thinsp: "\u2009",
                    zwnj: "\u200c",
                    zwj: "\u200d",
                    lrm: "\u200e",
                    rlm: "\u200f",
                    ndash: "\u2013",
                    mdash: "\u2014",
                    lsquo: "\u2018",
                    rsquo: "\u2019",
                    sbquo: "\u201a",
                    ldquo: "\u201c",
                    rdquo: "\u201d",
                    bdquo: "\u201e",
                    dagger: "\u2020",
                    Dagger: "\u2021",
                    permil: "\u2030",
                    lsaquo: "\u2039",
                    rsaquo: "\u203a",
                    euro: "\u20ac"
                }
                , p = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"]
                , f = {}.hasOwnProperty
                , m = {};
            let g;
            for (g in h)
                f.call(h, g) && (m[h[g]] = g);
            const b = /[^\dA-Za-z]/;
            function y(e, t, n) {
                let r, o = function (e, t, n) {
                    const r = "&#x" + e.toString(16).toUpperCase();
                    return n && t && !c.test(String.fromCharCode(t)) ? r : r + ";"
                }(e, t, n.omitOptionalSemicolons);
                if ((n.useNamedReferences || n.useShortestReferences) && (r = function (e, t, n, r) {
                    const o = String.fromCharCode(e);
                    if (f.call(m, o)) {
                        const e = m[o]
                            , i = "&" + e;
                        return n && u.includes(e) && !p.includes(e) && (!r || t && 61 !== t && b.test(String.fromCharCode(t))) ? i : i + ";"
                    }
                    return ""
                }(e, t, n.omitOptionalSemicolons, n.attribute)),
                    (n.useShortestReferences || !r) && n.useShortestReferences) {
                    const r = function (e, t, n) {
                        const r = "&#" + String(e);
                        return n && t && !d.test(String.fromCharCode(t)) ? r : r + ";"
                    }(e, t, n.omitOptionalSemicolons);
                    r.length < o.length && (o = r)
                }
                return r && (!n.useShortestReferences || r.length < o.length) ? r : o
            }
            function v(e, t) {
                return l(e, Object.assign({
                    format: y
                }, t))
            }
        }
        ,
        3780: (e, t, n) => {
            n.d(t, {
                A: () => o
            });
            const r = {}.hasOwnProperty;
            function o(e, t) {
                const n = t || {};
                function o(t) {
                    let n = o.invalid;
                    const i = o.handlers;
                    if (t && r.call(t, e)) {
                        const s = String(t[e]);
                        n = r.call(i, s) ? i[s] : o.unknown
                    }
                    if (n) {
                        for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
                            a[l - 1] = arguments[l];
                        return n.call(this, t, ...a)
                    }
                }
                return o.handlers = n.handlers || {},
                    o.invalid = n.invalid,
                    o.unknown = n.unknown,
                    o
            }
        }
    }
        , t = {};
    function n(r) {
        var o = t[r];
        if (void 0 !== o)
            return o.exports;
        var i = t[r] = {
            exports: {}
        };
        return e[r](i, i.exports, n),
            i.exports
    }
    n.m = e,
        (() => {
            var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
            n.t = function (r, o) {
                if (1 & o && (r = this(r)),
                    8 & o)
                    return r;
                if ("object" === typeof r && r) {
                    if (4 & o && r.__esModule)
                        return r;
                    if (16 & o && "function" === typeof r.then)
                        return r
                }
                var i = Object.create(null);
                n.r(i);
                var s = {};
                e = e || [null, t({}), t([]), t(t)];
                for (var a = 2 & o && r; "object" == typeof a && !~e.indexOf(a); a = t(a))
                    Object.getOwnPropertyNames(a).forEach((e => s[e] = () => r[e]));
                return s.default = () => r,
                    n.d(i, s),
                    i
            }
        }
        )(),
        n.d = (e, t) => {
            for (var r in t)
                n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
                    enumerable: !0,
                    get: t[r]
                })
        }
        ,
        n.f = {},
        n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t),
            t)), [])),
        n.u = e => "static/js/" + e + "." + {
            75: "29a5befe",
            119: "5692e542",
            120: "e16e8d15",
            154: "9ff047d6",
            187: "bb03c262",
            215: "87f8e80c",
            227: "aaf8a0df",
            232: "35d97702",
            251: "5c545b37",
            253: "5949d833",
            269: "000c3239",
            271: "eee32b3d",
            280: "7837417e",
            289: "81ba9629",
            332: "f802f505",
            357: "2db62f21",
            363: "212983c1",
            383: "1b19bbc6",
            410: "2bf9036d",
            431: "b744e484",
            456: "d79089dd",
            469: "534de025",
            483: "fe7320c1",
            522: "ea458e28",
            528: "c956edbb",
            561: "86f48ce8",
            567: "ddaaa5aa",
            585: "590bd824",
            590: "149b1af1",
            711: "05920685",
            762: "632fe1c1",
            795: "a363c711",
            800: "03da41ce",
            829: "c6f5fe3c",
            845: "e255db68",
            853: "76591a40",
            874: "66fffc4a",
            894: "fc07f382",
            942: "a0664919",
            966: "4e90cde4",
            992: "432902ad",
            1057: "82ac93c1",
            1064: "49694e2c",
            1082: "6bcadc14",
            1106: "4c4c2238",
            1174: "332f602b",
            1189: "8c9efa7a",
            1196: "67273035",
            1304: "d84aa3b0",
            1330: "52c74b36",
            1366: "bdb98dc7",
            1394: "982dda92",
            1474: "72304ff0",
            1567: "c902832d",
            1606: "c7f97d6c",
            1631: "cefa14c1",
            1639: "a05fdfa9",
            1650: "4beb0d7e",
            1667: "0d59cb6f",
            1668: "6acd3ce1",
            1752: "c9cabcfb",
            1763: "6af4a214",
            1814: "540b3ddb",
            1918: "ade0c73b",
            1922: "401e47ee",
            1926: "5f8fb7b4",
            2010: "2e93ec5c",
            2048: "e892f744",
            2062: "32566941",
            2069: "1dbf7c66",
            2078: "7b5b0b93",
            2080: "965e16f5",
            2101: "0c23ce1f",
            2144: "c7e6fc7b",
            2187: "0809ec1c",
            2317: "55e0c93d",
            2327: "923e0e8d",
            2393: "c0a9e0ca",
            2406: "075def5c",
            2454: "ef246b2f",
            2464: "f2d4d3d8",
            2477: "de8d64a9",
            2478: "ea0cdcd9",
            2482: "17947351",
            2484: "1c80401a",
            2509: "f82684cf",
            2549: "2cb66f58",
            2551: "bde7eda8",
            2573: "fcb314df",
            2609: "95717c1a",
            2667: "9d4fc6f6",
            2673: "0031af24",
            2707: "50e20c4a",
            2757: "5bb365e2",
            2768: "936cae71",
            2779: "04f00a00",
            2799: "92a43b1d",
            2835: "a7803ecb",
            2879: "b28b03f9",
            2881: "3fb6b32d",
            2969: "972004da",
            2998: "86cd070b",
            3014: "905cea8d",
            3082: "7b440f24",
            3083: "a30f0bd6",
            3117: "1cbe132b",
            3161: "12a7cb9e",
            3218: "9f354a36",
            3224: "58d12555",
            3232: "c330491d",
            3234: "6e006157",
            3253: "c12bbdbf",
            3254: "c2b258d3",
            3267: "02fdec2d",
            3284: "2d690bfc",
            3353: "3eb938a8",
            3355: "f10c8c3e",
            3378: "04ca78de",
            3383: "662ca259",
            3387: "729a9cb9",
            3397: "6651005a",
            3398: "66250062",
            3412: "13cee5be",
            3451: "1cd3c928",
            3454: "5805eda4",
            3468: "8d356d09",
            3510: "5de6721d",
            3535: "8dfbe8d2",
            3566: "912b7186",
            3569: "e7c391f5",
            3607: "167a3520",
            3722: "9519269a",
            3726: "8282eacd",
            3731: "75c7baa2",
            3798: "75f98c38",
            3816: "8d7a6f06",
            3848: "04d3f36b",
            3930: "31a93fcc",
            3934: "5157dcd5",
            3943: "d3fd84c8",
            3979: "91e1658e",
            3998: "55c58ba6",
            4027: "0bae57de",
            4054: "110647c4",
            4099: "da1b9f1d",
            4112: "d5260567",
            4213: "084faf73",
            4217: "069af320",
            4228: "13064579",
            4243: "f5bd0bdc",
            4247: "6dbc17aa",
            4304: "b90e7cf6",
            4349: "68401291",
            4377: "131e5371",
            4415: "1c0458f7",
            4421: "6872e403",
            4433: "f81477c8",
            4503: "21e69daf",
            4507: "8fc314a2",
            4606: "f7730207",
            4619: "a8f40adc",
            4645: "54664b55",
            4723: "265a6482",
            4730: "7261f820",
            4774: "4c54fb6a",
            4853: "c585cfa1",
            4859: "ff91381d",
            4891: "4cb81569",
            4918: "e97421d7",
            4947: "90bd05b3",
            4949: "98b1d98c",
            4951: "40f9591b",
            4960: "c221c876",
            4997: "4bf27418",
            5026: "acf3bad0",
            5053: "8ebc552e",
            5088: "12e779f1",
            5092: "79cadb88",
            5129: "58ea05f1",
            5131: "d1d0f430",
            5138: "93e8768f",
            5220: "8bc8a033",
            5318: "25dcb1e2",
            5331: "6bb643ca",
            5468: "4ee33f4a",
            5531: "5eeb9014",
            5551: "caccff32",
            5588: "ae309d83",
            5599: "b8232753",
            5696: "d51124ae",
            5710: "63c75879",
            5735: "cfcd7c4f",
            5747: "9a385446",
            5755: "fb9839f5",
            5768: "06fc3ac5",
            5769: "12010366",
            5796: "b58cbd92",
            5852: "2a796908",
            5942: "17d18eff",
            5972: "17008527",
            5992: "d7ec5274",
            5995: "8f5a2737",
            6e3: "4f1a566c",
            6078: "60331a08",
            6100: "fa3adbe4",
            6104: "ddc6f3e8",
            6114: "dea42627",
            6117: "a0ea3130",
            6141: "ccdeba6e",
            6200: "6308d958",
            6236: "89d9b822",
            6251: "856ce0ae",
            6262: "af29d367",
            6303: "ed2c6550",
            6320: "917bbe92",
            6322: "c76d39ae",
            6339: "d652d8fb",
            6345: "df7e6e53",
            6346: "a26fae53",
            6400: "4d85ef16",
            6404: "505ab777",
            6416: "1ae24ee1",
            6491: "e0265650",
            6550: "46955007",
            6743: "805b6182",
            6750: "663089d8",
            6764: "e0b5697d",
            6782: "fea2e30f",
            6795: "eceeb62e",
            6889: "466776b4",
            6893: "74b63d1d",
            6959: "11b7d0c2",
            6972: "33c7dd76",
            6996: "689b34ae",
            7013: "9217d15c",
            7016: "b8c7cb04",
            7026: "c08a2106",
            7031: "2f426f77",
            7041: "6c78a9ef",
            7051: "eb1e375f",
            7065: "5ec407b0",
            7088: "6ba6af2a",
            7096: "f72da394",
            7152: "c4cf85d0",
            7153: "5abd2053",
            7177: "171f67fb",
            7196: "59429542",
            7219: "b187900f",
            7223: "d62ef2db",
            7231: "e4522120",
            7318: "044dd365",
            7329: "3cb848c6",
            7352: "46b371c3",
            7363: "8731f0ef",
            7413: "994ad81f",
            7469: "8bfe0c9e",
            7499: "dc88c2ed",
            7591: "4adb0142",
            7647: "feaa643c",
            7670: "9f9a7596",
            7672: "435e1925",
            7673: "106f25c9",
            7730: "8ce260a4",
            7734: "1f889ce1",
            7817: "f0821d7a",
            7830: "737fd376",
            7902: "0cbb2711",
            7945: "9245fc7e",
            7973: "42726581",
            8014: "6a157a77",
            8055: "c2d3d830",
            8221: "20340bc2",
            8228: "842c74ba",
            8231: "e0c4a084",
            8283: "ea3cf9a6",
            8287: "351de111",
            8379: "42aa1cd1",
            8425: "d3548503",
            8470: "ffea6ca7",
            8493: "170a1453",
            8512: "c5a42821",
            8513: "3ea2f033",
            8522: "8633b26b",
            8552: "e42835db",
            8567: "c683a9ba",
            8611: "48e17fcb",
            8696: "8af8b5e8",
            8775: "8911e9a4",
            8806: "af52897e",
            8834: "83fc0b96",
            8846: "c9b6a707",
            8855: "ab5f9291",
            8860: "e6ca36a6",
            8897: "f99fb48f",
            8931: "cd55b4b3",
            8954: "78e19ebe",
            8984: "a14e0e5c",
            9068: "102d913a",
            9125: "5f1f1eb2",
            9130: "23dea192",
            9134: "4c787d67",
            9173: "299f6059",
            9184: "0c2a371f",
            9199: "9d5ebdab",
            9207: "b904665d",
            9226: "4d0e880a",
            9233: "912d0b4c",
            9274: "ddd00384",
            9293: "8cba62a5",
            9306: "67dd3916",
            9335: "485e1ee5",
            9367: "3d338674",
            9371: "ae01f9e8",
            9386: "5fe52698",
            9399: "b0a9c457",
            9425: "c51e1fd9",
            9464: "36566f97",
            9476: "0c2b5866",
            9480: "00d9e750",
            9483: "abffe617",
            9567: "b8acbf16",
            9568: "9380ca21",
            9579: "ef58870a",
            9654: "adc9603b",
            9662: "f2a6e1d1",
            9724: "be588a19",
            9730: "d009c276",
            9736: "399db36a",
            9764: "1a250d50",
            9828: "353cc1c3",
            9852: "dd95537f",
            9878: "592873d1",
            9880: "da4691c9",
            9962: "7b166d43"
        }[e] + ".chunk.js",
        n.miniCssF = e => { }
        ,
        n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
        (() => {
            var e = {}
                , t = "block-note:";
            n.l = (r, o, i, s) => {
                if (e[r])
                    e[r].push(o);
                else {
                    var a, l;
                    if (void 0 !== i)
                        for (var c = document.getElementsByTagName("script"), d = 0; d < c.length; d++) {
                            var u = c[d];
                            if (u.getAttribute("src") == r || u.getAttribute("data-webpack") == t + i) {
                                a = u;
                                break
                            }
                        }
                    a || (l = !0,
                        (a = document.createElement("script")).charset = "utf-8",
                        a.timeout = 120,
                        n.nc && a.setAttribute("nonce", n.nc),
                        a.setAttribute("data-webpack", t + i),
                        a.src = r),
                        e[r] = [o];
                    var h = (t, n) => {
                        a.onerror = a.onload = null,
                            clearTimeout(p);
                        var o = e[r];
                        if (delete e[r],
                            a.parentNode && a.parentNode.removeChild(a),
                            o && o.forEach((e => e(n))),
                            t)
                            return t(n)
                    }
                        , p = setTimeout(h.bind(null, void 0, {
                            type: "timeout",
                            target: a
                        }), 12e4);
                    a.onerror = h.bind(null, a.onerror),
                        a.onload = h.bind(null, a.onload),
                        l && document.head.appendChild(a)
                }
            }
        }
        )(),
        n.r = e => {
            "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }),
                Object.defineProperty(e, "__esModule", {
                    value: !0
                })
        }
        ,
        n.p = "",
        (() => {
            var e = {
                8792: 0
            };
            n.f.j = (t, r) => {
                var o = n.o(e, t) ? e[t] : void 0;
                if (0 !== o)
                    if (o)
                        r.push(o[2]);
                    else {
                        var i = new Promise(((n, r) => o = e[t] = [n, r]));
                        r.push(o[2] = i);
                        var s = n.p + n.u(t)
                            , a = new Error;
                        n.l(s, (r => {
                            if (n.o(e, t) && (0 !== (o = e[t]) && (e[t] = void 0),
                                o)) {
                                var i = r && ("load" === r.type ? "missing" : r.type)
                                    , s = r && r.target && r.target.src;
                                a.message = "Loading chunk " + t + " failed.\n(" + i + ": " + s + ")",
                                    a.name = "ChunkLoadError",
                                    a.type = i,
                                    a.request = s,
                                    o[1](a)
                            }
                        }
                        ), "chunk-" + t, t)
                    }
            }
                ;
            var t = (t, r) => {
                var o, i, s = r[0], a = r[1], l = r[2], c = 0;
                if (s.some((t => 0 !== e[t]))) {
                    for (o in a)
                        n.o(a, o) && (n.m[o] = a[o]);
                    if (l)
                        l(n)
                }
                for (t && t(r); c < s.length; c++)
                    i = s[c],
                        n.o(e, i) && e[i] && e[i][0](),
                        e[i] = 0
            }
                , r = self.webpackChunkblock_note = self.webpackChunkblock_note || [];
            r.forEach(t.bind(null, 0)),
                r.push = t.bind(null, r.push.bind(r))
        }
        )();
    var r = n(5043)
        , o = n.t(r, 2)
        , i = n(4391);
    function s(e) {
        this.content = e
    }
    s.prototype = {
        constructor: s,
        find: function (e) {
            for (var t = 0; t < this.content.length; t += 2)
                if (this.content[t] === e)
                    return t;
            return -1
        },
        get: function (e) {
            var t = this.find(e);
            return -1 == t ? void 0 : this.content[t + 1]
        },
        update: function (e, t, n) {
            var r = n && n != e ? this.remove(n) : this
                , o = r.find(e)
                , i = r.content.slice();
            return -1 == o ? i.push(n || e, t) : (i[o + 1] = t,
                n && (i[o] = n)),
                new s(i)
        },
        remove: function (e) {
            var t = this.find(e);
            if (-1 == t)
                return this;
            var n = this.content.slice();
            return n.splice(t, 2),
                new s(n)
        },
        addToStart: function (e, t) {
            return new s([e, t].concat(this.remove(e).content))
        },
        addToEnd: function (e, t) {
            var n = this.remove(e).content.slice();
            return n.push(e, t),
                new s(n)
        },
        addBefore: function (e, t, n) {
            var r = this.remove(t)
                , o = r.content.slice()
                , i = r.find(e);
            return o.splice(-1 == i ? o.length : i, 0, t, n),
                new s(o)
        },
        forEach: function (e) {
            for (var t = 0; t < this.content.length; t += 2)
                e(this.content[t], this.content[t + 1])
        },
        prepend: function (e) {
            return (e = s.from(e)).size ? new s(e.content.concat(this.subtract(e).content)) : this
        },
        append: function (e) {
            return (e = s.from(e)).size ? new s(this.subtract(e).content.concat(e.content)) : this
        },
        subtract: function (e) {
            var t = this;
            e = s.from(e);
            for (var n = 0; n < e.content.length; n += 2)
                t = t.remove(e.content[n]);
            return t
        },
        toObject: function () {
            var e = {};
            return this.forEach((function (t, n) {
                e[t] = n
            }
            )),
                e
        },
        get size() {
            return this.content.length >> 1
        }
    },
        s.from = function (e) {
            if (e instanceof s)
                return e;
            var t = [];
            if (e)
                for (var n in e)
                    t.push(n, e[n]);
            return new s(t)
        }
        ;
    const a = s;
    function l(e, t, n) {
        for (let r = 0; ; r++) {
            if (r == e.childCount || r == t.childCount)
                return e.childCount == t.childCount ? null : n;
            let o = e.child(r)
                , i = t.child(r);
            if (o != i) {
                if (!o.sameMarkup(i))
                    return n;
                if (o.isText && o.text != i.text) {
                    for (let e = 0; o.text[e] == i.text[e]; e++)
                        n++;
                    return n
                }
                if (o.content.size || i.content.size) {
                    let e = l(o.content, i.content, n + 1);
                    if (null != e)
                        return e
                }
                n += o.nodeSize
            } else
                n += o.nodeSize
        }
    }
    function c(e, t, n, r) {
        for (let o = e.childCount, i = t.childCount; ;) {
            if (0 == o || 0 == i)
                return o == i ? null : {
                    a: n,
                    b: r
                };
            let s = e.child(--o)
                , a = t.child(--i)
                , l = s.nodeSize;
            if (s != a) {
                if (!s.sameMarkup(a))
                    return {
                        a: n,
                        b: r
                    };
                if (s.isText && s.text != a.text) {
                    let e = 0
                        , t = Math.min(s.text.length, a.text.length);
                    for (; e < t && s.text[s.text.length - e - 1] == a.text[a.text.length - e - 1];)
                        e++,
                            n--,
                            r--;
                    return {
                        a: n,
                        b: r
                    }
                }
                if (s.content.size || a.content.size) {
                    let e = c(s.content, a.content, n - 1, r - 1);
                    if (e)
                        return e
                }
                n -= l,
                    r -= l
            } else
                n -= l,
                    r -= l
        }
    }
    class d {
        constructor(e, t) {
            if (this.content = e,
                this.size = t || 0,
                null == t)
                for (let n = 0; n < e.length; n++)
                    this.size += e[n].nodeSize
        }
        nodesBetween(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                , o = arguments.length > 4 ? arguments[4] : void 0;
            for (let i = 0, s = 0; s < t; i++) {
                let a = this.content[i]
                    , l = s + a.nodeSize;
                if (l > e && !1 !== n(a, r + s, o || null, i) && a.content.size) {
                    let o = s + 1;
                    a.nodesBetween(Math.max(0, e - o), Math.min(a.content.size, t - o), n, r + o)
                }
                s = l
            }
        }
        descendants(e) {
            this.nodesBetween(0, this.size, e)
        }
        textBetween(e, t, n, r) {
            let o = ""
                , i = !0;
            return this.nodesBetween(e, t, ((s, a) => {
                let l = s.isText ? s.text.slice(Math.max(e, a) - a, t - a) : s.isLeaf ? r ? "function" === typeof r ? r(s) : r : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
                s.isBlock && (s.isLeaf && l || s.isTextblock) && n && (i ? i = !1 : o += n),
                    o += l
            }
            ), 0),
                o
        }
        append(e) {
            if (!e.size)
                return this;
            if (!this.size)
                return e;
            let t = this.lastChild
                , n = e.firstChild
                , r = this.content.slice()
                , o = 0;
            for (t.isText && t.sameMarkup(n) && (r[r.length - 1] = t.withText(t.text + n.text),
                o = 1); o < e.content.length; o++)
                r.push(e.content[o]);
            return new d(r, this.size + e.size)
        }
        cut(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.size;
            if (0 == e && t == this.size)
                return this;
            let n = []
                , r = 0;
            if (t > e)
                for (let o = 0, i = 0; i < t; o++) {
                    let s = this.content[o]
                        , a = i + s.nodeSize;
                    a > e && ((i < e || a > t) && (s = s.isText ? s.cut(Math.max(0, e - i), Math.min(s.text.length, t - i)) : s.cut(Math.max(0, e - i - 1), Math.min(s.content.size, t - i - 1))),
                        n.push(s),
                        r += s.nodeSize),
                        i = a
                }
            return new d(n, r)
        }
        cutByIndex(e, t) {
            return e == t ? d.empty : 0 == e && t == this.content.length ? this : new d(this.content.slice(e, t))
        }
        replaceChild(e, t) {
            let n = this.content[e];
            if (n == t)
                return this;
            let r = this.content.slice()
                , o = this.size + t.nodeSize - n.nodeSize;
            return r[e] = t,
                new d(r, o)
        }
        addToStart(e) {
            return new d([e].concat(this.content), this.size + e.nodeSize)
        }
        addToEnd(e) {
            return new d(this.content.concat(e), this.size + e.nodeSize)
        }
        eq(e) {
            if (this.content.length != e.content.length)
                return !1;
            for (let t = 0; t < this.content.length; t++)
                if (!this.content[t].eq(e.content[t]))
                    return !1;
            return !0
        }
        get firstChild() {
            return this.content.length ? this.content[0] : null
        }
        get lastChild() {
            return this.content.length ? this.content[this.content.length - 1] : null
        }
        get childCount() {
            return this.content.length
        }
        child(e) {
            let t = this.content[e];
            if (!t)
                throw new RangeError("Index " + e + " out of range for " + this);
            return t
        }
        maybeChild(e) {
            return this.content[e] || null
        }
        forEach(e) {
            for (let t = 0, n = 0; t < this.content.length; t++) {
                let r = this.content[t];
                e(r, n, t),
                    n += r.nodeSize
            }
        }
        findDiffStart(e) {
            return l(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0)
        }
        findDiffEnd(e) {
            return c(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.size, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.size)
        }
        findIndex(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
            if (0 == e)
                return h(0, e);
            if (e == this.size)
                return h(this.content.length, e);
            if (e > this.size || e < 0)
                throw new RangeError(`Position ${e} outside of fragment (${this})`);
            for (let n = 0, r = 0; ; n++) {
                let o = r + this.child(n).nodeSize;
                if (o >= e)
                    return o == e || t > 0 ? h(n + 1, o) : h(n, r);
                r = o
            }
        }
        toString() {
            return "<" + this.toStringInner() + ">"
        }
        toStringInner() {
            return this.content.join(", ")
        }
        toJSON() {
            return this.content.length ? this.content.map((e => e.toJSON())) : null
        }
        static fromJSON(e, t) {
            if (!t)
                return d.empty;
            if (!Array.isArray(t))
                throw new RangeError("Invalid input for Fragment.fromJSON");
            return new d(t.map(e.nodeFromJSON))
        }
        static fromArray(e) {
            if (!e.length)
                return d.empty;
            let t, n = 0;
            for (let r = 0; r < e.length; r++) {
                let o = e[r];
                n += o.nodeSize,
                    r && o.isText && e[r - 1].sameMarkup(o) ? (t || (t = e.slice(0, r)),
                        t[t.length - 1] = o.withText(t[t.length - 1].text + o.text)) : t && t.push(o)
            }
            return new d(t || e, n)
        }
        static from(e) {
            if (!e)
                return d.empty;
            if (e instanceof d)
                return e;
            if (Array.isArray(e))
                return this.fromArray(e);
            if (e.attrs)
                return new d([e], e.nodeSize);
            throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
        }
    }
    d.empty = new d([], 0);
    const u = {
        index: 0,
        offset: 0
    };
    function h(e, t) {
        return u.index = e,
            u.offset = t,
            u
    }
    function p(e, t) {
        if (e === t)
            return !0;
        if (!e || "object" != typeof e || !t || "object" != typeof t)
            return !1;
        let n = Array.isArray(e);
        if (Array.isArray(t) != n)
            return !1;
        if (n) {
            if (e.length != t.length)
                return !1;
            for (let n = 0; n < e.length; n++)
                if (!p(e[n], t[n]))
                    return !1
        } else {
            for (let n in e)
                if (!(n in t) || !p(e[n], t[n]))
                    return !1;
            for (let n in t)
                if (!(n in e))
                    return !1
        }
        return !0
    }
    class f {
        constructor(e, t) {
            this.type = e,
                this.attrs = t
        }
        addToSet(e) {
            let t, n = !1;
            for (let r = 0; r < e.length; r++) {
                let o = e[r];
                if (this.eq(o))
                    return e;
                if (this.type.excludes(o.type))
                    t || (t = e.slice(0, r));
                else {
                    if (o.type.excludes(this.type))
                        return e;
                    !n && o.type.rank > this.type.rank && (t || (t = e.slice(0, r)),
                        t.push(this),
                        n = !0),
                        t && t.push(o)
                }
            }
            return t || (t = e.slice()),
                n || t.push(this),
                t
        }
        removeFromSet(e) {
            for (let t = 0; t < e.length; t++)
                if (this.eq(e[t]))
                    return e.slice(0, t).concat(e.slice(t + 1));
            return e
        }
        isInSet(e) {
            for (let t = 0; t < e.length; t++)
                if (this.eq(e[t]))
                    return !0;
            return !1
        }
        eq(e) {
            return this == e || this.type == e.type && p(this.attrs, e.attrs)
        }
        toJSON() {
            let e = {
                type: this.type.name
            };
            for (let t in this.attrs) {
                e.attrs = this.attrs;
                break
            }
            return e
        }
        static fromJSON(e, t) {
            if (!t)
                throw new RangeError("Invalid input for Mark.fromJSON");
            let n = e.marks[t.type];
            if (!n)
                throw new RangeError(`There is no mark type ${t.type} in this schema`);
            let r = n.create(t.attrs);
            return n.checkAttrs(r.attrs),
                r
        }
        static sameSet(e, t) {
            if (e == t)
                return !0;
            if (e.length != t.length)
                return !1;
            for (let n = 0; n < e.length; n++)
                if (!e[n].eq(t[n]))
                    return !1;
            return !0
        }
        static setFrom(e) {
            if (!e || Array.isArray(e) && 0 == e.length)
                return f.none;
            if (e instanceof f)
                return [e];
            let t = e.slice();
            return t.sort(((e, t) => e.type.rank - t.type.rank)),
                t
        }
    }
    f.none = [];
    class m extends Error {
    }
    class g {
        constructor(e, t, n) {
            this.content = e,
                this.openStart = t,
                this.openEnd = n
        }
        get size() {
            return this.content.size - this.openStart - this.openEnd
        }
        insertAt(e, t) {
            let n = y(this.content, e + this.openStart, t);
            return n && new g(n, this.openStart, this.openEnd)
        }
        removeBetween(e, t) {
            return new g(b(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd)
        }
        eq(e) {
            return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd
        }
        toString() {
            return this.content + "(" + this.openStart + "," + this.openEnd + ")"
        }
        toJSON() {
            if (!this.content.size)
                return null;
            let e = {
                content: this.content.toJSON()
            };
            return this.openStart > 0 && (e.openStart = this.openStart),
                this.openEnd > 0 && (e.openEnd = this.openEnd),
                e
        }
        static fromJSON(e, t) {
            if (!t)
                return g.empty;
            let n = t.openStart || 0
                , r = t.openEnd || 0;
            if ("number" != typeof n || "number" != typeof r)
                throw new RangeError("Invalid input for Slice.fromJSON");
            return new g(d.fromJSON(e, t.content), n, r)
        }
        static maxOpen(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                , n = 0
                , r = 0;
            for (let o = e.firstChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.firstChild)
                n++;
            for (let o = e.lastChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.lastChild)
                r++;
            return new g(e, n, r)
        }
    }
    function b(e, t, n) {
        let { index: r, offset: o } = e.findIndex(t)
            , i = e.maybeChild(r)
            , { index: s, offset: a } = e.findIndex(n);
        if (o == t || i.isText) {
            if (a != n && !e.child(s).isText)
                throw new RangeError("Removing non-flat range");
            return e.cut(0, t).append(e.cut(n))
        }
        if (r != s)
            throw new RangeError("Removing non-flat range");
        return e.replaceChild(r, i.copy(b(i.content, t - o - 1, n - o - 1)))
    }
    function y(e, t, n, r) {
        let { index: o, offset: i } = e.findIndex(t)
            , s = e.maybeChild(o);
        if (i == t || s.isText)
            return r && !r.canReplace(o, o, n) ? null : e.cut(0, t).append(n).append(e.cut(t));
        let a = y(s.content, t - i - 1, n);
        return a && e.replaceChild(o, s.copy(a))
    }
    function v(e, t, n) {
        if (n.openStart > e.depth)
            throw new m("Inserted content deeper than insertion position");
        if (e.depth - n.openStart != t.depth - n.openEnd)
            throw new m("Inconsistent open depths");
        return w(e, t, n, 0)
    }
    function w(e, t, n, r) {
        let o = e.index(r)
            , i = e.node(r);
        if (o == t.index(r) && r < e.depth - n.openStart) {
            let s = w(e, t, n, r + 1);
            return i.copy(i.content.replaceChild(o, s))
        }
        if (n.content.size) {
            if (n.openStart || n.openEnd || e.depth != r || t.depth != r) {
                let { start: o, end: s } = function (e, t) {
                    let n = t.depth - e.openStart
                        , r = t.node(n).copy(e.content);
                    for (let o = n - 1; o >= 0; o--)
                        r = t.node(o).copy(d.from(r));
                    return {
                        start: r.resolveNoCache(e.openStart + n),
                        end: r.resolveNoCache(r.content.size - e.openEnd - n)
                    }
                }(n, e);
                return E(i, M(e, o, s, t, r))
            }
            {
                let r = e.parent
                    , o = r.content;
                return E(r, o.cut(0, e.parentOffset).append(n.content).append(o.cut(t.parentOffset)))
            }
        }
        return E(i, T(e, t, r))
    }
    function k(e, t) {
        if (!t.type.compatibleContent(e.type))
            throw new m("Cannot join " + t.type.name + " onto " + e.type.name)
    }
    function C(e, t, n) {
        let r = e.node(n);
        return k(r, t.node(n)),
            r
    }
    function S(e, t) {
        let n = t.length - 1;
        n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e)
    }
    function x(e, t, n, r) {
        let o = (t || e).node(n)
            , i = 0
            , s = t ? t.index(n) : o.childCount;
        e && (i = e.index(n),
            e.depth > n ? i++ : e.textOffset && (S(e.nodeAfter, r),
                i++));
        for (let a = i; a < s; a++)
            S(o.child(a), r);
        t && t.depth == n && t.textOffset && S(t.nodeBefore, r)
    }
    function E(e, t) {
        return e.type.checkContent(t),
            e.copy(t)
    }
    function M(e, t, n, r, o) {
        let i = e.depth > o && C(e, t, o + 1)
            , s = r.depth > o && C(n, r, o + 1)
            , a = [];
        return x(null, e, o, a),
            i && s && t.index(o) == n.index(o) ? (k(i, s),
                S(E(i, M(e, t, n, r, o + 1)), a)) : (i && S(E(i, T(e, t, o + 1)), a),
                    x(t, n, o, a),
                    s && S(E(s, T(n, r, o + 1)), a)),
            x(r, null, o, a),
            new d(a)
    }
    function T(e, t, n) {
        let r = [];
        if (x(null, e, n, r),
            e.depth > n) {
            S(E(C(e, t, n + 1), T(e, t, n + 1)), r)
        }
        return x(t, null, n, r),
            new d(r)
    }
    g.empty = new g(d.empty, 0, 0);
    class N {
        constructor(e, t, n) {
            this.pos = e,
                this.path = t,
                this.parentOffset = n,
                this.depth = t.length / 3 - 1
        }
        resolveDepth(e) {
            return null == e ? this.depth : e < 0 ? this.depth + e : e
        }
        get parent() {
            return this.node(this.depth)
        }
        get doc() {
            return this.node(0)
        }
        node(e) {
            return this.path[3 * this.resolveDepth(e)]
        }
        index(e) {
            return this.path[3 * this.resolveDepth(e) + 1]
        }
        indexAfter(e) {
            return e = this.resolveDepth(e),
                this.index(e) + (e != this.depth || this.textOffset ? 1 : 0)
        }
        start(e) {
            return 0 == (e = this.resolveDepth(e)) ? 0 : this.path[3 * e - 1] + 1
        }
        end(e) {
            return e = this.resolveDepth(e),
                this.start(e) + this.node(e).content.size
        }
        before(e) {
            if (!(e = this.resolveDepth(e)))
                throw new RangeError("There is no position before the top-level node");
            return e == this.depth + 1 ? this.pos : this.path[3 * e - 1]
        }
        after(e) {
            if (!(e = this.resolveDepth(e)))
                throw new RangeError("There is no position after the top-level node");
            return e == this.depth + 1 ? this.pos : this.path[3 * e - 1] + this.path[3 * e].nodeSize
        }
        get textOffset() {
            return this.pos - this.path[this.path.length - 1]
        }
        get nodeAfter() {
            let e = this.parent
                , t = this.index(this.depth);
            if (t == e.childCount)
                return null;
            let n = this.pos - this.path[this.path.length - 1]
                , r = e.child(t);
            return n ? e.child(t).cut(n) : r
        }
        get nodeBefore() {
            let e = this.index(this.depth)
                , t = this.pos - this.path[this.path.length - 1];
            return t ? this.parent.child(e).cut(0, t) : 0 == e ? null : this.parent.child(e - 1)
        }
        posAtIndex(e, t) {
            t = this.resolveDepth(t);
            let n = this.path[3 * t]
                , r = 0 == t ? 0 : this.path[3 * t - 1] + 1;
            for (let o = 0; o < e; o++)
                r += n.child(o).nodeSize;
            return r
        }
        marks() {
            let e = this.parent
                , t = this.index();
            if (0 == e.content.size)
                return f.none;
            if (this.textOffset)
                return e.child(t).marks;
            let n = e.maybeChild(t - 1)
                , r = e.maybeChild(t);
            if (!n) {
                let e = n;
                n = r,
                    r = e
            }
            let o = n.marks;
            for (var i = 0; i < o.length; i++)
                !1 !== o[i].type.spec.inclusive || r && o[i].isInSet(r.marks) || (o = o[i--].removeFromSet(o));
            return o
        }
        marksAcross(e) {
            let t = this.parent.maybeChild(this.index());
            if (!t || !t.isInline)
                return null;
            let n = t.marks
                , r = e.parent.maybeChild(e.index());
            for (var o = 0; o < n.length; o++)
                !1 !== n[o].type.spec.inclusive || r && n[o].isInSet(r.marks) || (n = n[o--].removeFromSet(n));
            return n
        }
        sharedDepth(e) {
            for (let t = this.depth; t > 0; t--)
                if (this.start(t) <= e && this.end(t) >= e)
                    return t;
            return 0
        }
        blockRange() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this
                , t = arguments.length > 1 ? arguments[1] : void 0;
            if (e.pos < this.pos)
                return e.blockRange(this);
            for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)
                if (e.pos <= this.end(n) && (!t || t(this.node(n))))
                    return new P(this, e, n);
            return null
        }
        sameParent(e) {
            return this.pos - this.parentOffset == e.pos - e.parentOffset
        }
        max(e) {
            return e.pos > this.pos ? e : this
        }
        min(e) {
            return e.pos < this.pos ? e : this
        }
        toString() {
            let e = "";
            for (let t = 1; t <= this.depth; t++)
                e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
            return e + ":" + this.parentOffset
        }
        static resolve(e, t) {
            if (!(t >= 0 && t <= e.content.size))
                throw new RangeError("Position " + t + " out of range");
            let n = []
                , r = 0
                , o = t;
            for (let i = e; ;) {
                let { index: e, offset: t } = i.content.findIndex(o)
                    , s = o - t;
                if (n.push(i, e, r + t),
                    !s)
                    break;
                if (i = i.child(e),
                    i.isText)
                    break;
                o = s - 1,
                    r += t + 1
            }
            return new N(t, n, o)
        }
        static resolveCached(e, t) {
            let n = A.get(e);
            if (n)
                for (let o = 0; o < n.elts.length; o++) {
                    let e = n.elts[o];
                    if (e.pos == t)
                        return e
                }
            else
                A.set(e, n = new _);
            let r = n.elts[n.i] = N.resolve(e, t);
            return n.i = (n.i + 1) % O,
                r
        }
    }
    class _ {
        constructor() {
            this.elts = [],
                this.i = 0
        }
    }
    const O = 12
        , A = new WeakMap;
    class P {
        constructor(e, t, n) {
            this.$from = e,
                this.$to = t,
                this.depth = n
        }
        get start() {
            return this.$from.before(this.depth + 1)
        }
        get end() {
            return this.$to.after(this.depth + 1)
        }
        get parent() {
            return this.$from.node(this.depth)
        }
        get startIndex() {
            return this.$from.index(this.depth)
        }
        get endIndex() {
            return this.$to.indexAfter(this.depth)
        }
    }
    const L = Object.create(null);
    class R {
        constructor(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : f.none;
            this.type = e,
                this.attrs = t,
                this.marks = r,
                this.content = n || d.empty
        }
        get nodeSize() {
            return this.isLeaf ? 1 : 2 + this.content.size
        }
        get childCount() {
            return this.content.childCount
        }
        child(e) {
            return this.content.child(e)
        }
        maybeChild(e) {
            return this.content.maybeChild(e)
        }
        forEach(e) {
            this.content.forEach(e)
        }
        nodesBetween(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            this.content.nodesBetween(e, t, n, r, this)
        }
        descendants(e) {
            this.nodesBetween(0, this.content.size, e)
        }
        get textContent() {
            return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
        }
        textBetween(e, t, n, r) {
            return this.content.textBetween(e, t, n, r)
        }
        get firstChild() {
            return this.content.firstChild
        }
        get lastChild() {
            return this.content.lastChild
        }
        eq(e) {
            return this == e || this.sameMarkup(e) && this.content.eq(e.content)
        }
        sameMarkup(e) {
            return this.hasMarkup(e.type, e.attrs, e.marks)
        }
        hasMarkup(e, t, n) {
            return this.type == e && p(this.attrs, t || e.defaultAttrs || L) && f.sameSet(this.marks, n || f.none)
        }
        copy() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return e == this.content ? this : new R(this.type, this.attrs, e, this.marks)
        }
        mark(e) {
            return e == this.marks ? this : new R(this.type, this.attrs, this.content, e)
        }
        cut(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.content.size;
            return 0 == e && t == this.content.size ? this : this.copy(this.content.cut(e, t))
        }
        slice(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.content.size
                , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (e == t)
                return g.empty;
            let r = this.resolve(e)
                , o = this.resolve(t)
                , i = n ? 0 : r.sharedDepth(t)
                , s = r.start(i)
                , a = r.node(i).content.cut(r.pos - s, o.pos - s);
            return new g(a, r.depth - i, o.depth - i)
        }
        replace(e, t, n) {
            return v(this.resolve(e), this.resolve(t), n)
        }
        nodeAt(e) {
            for (let t = this; ;) {
                let { index: n, offset: r } = t.content.findIndex(e);
                if (t = t.maybeChild(n),
                    !t)
                    return null;
                if (r == e || t.isText)
                    return t;
                e -= r + 1
            }
        }
        childAfter(e) {
            let { index: t, offset: n } = this.content.findIndex(e);
            return {
                node: this.content.maybeChild(t),
                index: t,
                offset: n
            }
        }
        childBefore(e) {
            if (0 == e)
                return {
                    node: null,
                    index: 0,
                    offset: 0
                };
            let { index: t, offset: n } = this.content.findIndex(e);
            if (n < e)
                return {
                    node: this.content.child(t),
                    index: t,
                    offset: n
                };
            let r = this.content.child(t - 1);
            return {
                node: r,
                index: t - 1,
                offset: n - r.nodeSize
            }
        }
        resolve(e) {
            return N.resolveCached(this, e)
        }
        resolveNoCache(e) {
            return N.resolve(this, e)
        }
        rangeHasMark(e, t, n) {
            let r = !1;
            return t > e && this.nodesBetween(e, t, (e => (n.isInSet(e.marks) && (r = !0),
                !r))),
                r
        }
        get isBlock() {
            return this.type.isBlock
        }
        get isTextblock() {
            return this.type.isTextblock
        }
        get inlineContent() {
            return this.type.inlineContent
        }
        get isInline() {
            return this.type.isInline
        }
        get isText() {
            return this.type.isText
        }
        get isLeaf() {
            return this.type.isLeaf
        }
        get isAtom() {
            return this.type.isAtom
        }
        toString() {
            if (this.type.spec.toDebugString)
                return this.type.spec.toDebugString(this);
            let e = this.type.name;
            return this.content.size && (e += "(" + this.content.toStringInner() + ")"),
                I(this.marks, e)
        }
        contentMatchAt(e) {
            let t = this.type.contentMatch.matchFragment(this.content, 0, e);
            if (!t)
                throw new Error("Called contentMatchAt on a node with invalid content");
            return t
        }
        canReplace(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : d.empty
                , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : n.childCount
                , i = this.contentMatchAt(e).matchFragment(n, r, o)
                , s = i && i.matchFragment(this.content, t);
            if (!s || !s.validEnd)
                return !1;
            for (let a = r; a < o; a++)
                if (!this.type.allowsMarks(n.child(a).marks))
                    return !1;
            return !0
        }
        canReplaceWith(e, t, n, r) {
            if (r && !this.type.allowsMarks(r))
                return !1;
            let o = this.contentMatchAt(e).matchType(n)
                , i = o && o.matchFragment(this.content, t);
            return !!i && i.validEnd
        }
        canAppend(e) {
            return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type)
        }
        check() {
            this.type.checkContent(this.content),
                this.type.checkAttrs(this.attrs);
            let e = f.none;
            for (let t = 0; t < this.marks.length; t++) {
                let n = this.marks[t];
                n.type.checkAttrs(n.attrs),
                    e = n.addToSet(e)
            }
            if (!f.sameSet(e, this.marks))
                throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((e => e.type.name))}`);
            this.content.forEach((e => e.check()))
        }
        toJSON() {
            let e = {
                type: this.type.name
            };
            for (let t in this.attrs) {
                e.attrs = this.attrs;
                break
            }
            return this.content.size && (e.content = this.content.toJSON()),
                this.marks.length && (e.marks = this.marks.map((e => e.toJSON()))),
                e
        }
        static fromJSON(e, t) {
            if (!t)
                throw new RangeError("Invalid input for Node.fromJSON");
            let n;
            if (t.marks) {
                if (!Array.isArray(t.marks))
                    throw new RangeError("Invalid mark data for Node.fromJSON");
                n = t.marks.map(e.markFromJSON)
            }
            if ("text" == t.type) {
                if ("string" != typeof t.text)
                    throw new RangeError("Invalid text node in JSON");
                return e.text(t.text, n)
            }
            let r = d.fromJSON(e, t.content)
                , o = e.nodeType(t.type).create(t.attrs, r, n);
            return o.type.checkAttrs(o.attrs),
                o
        }
    }
    R.prototype.text = void 0;
    class D extends R {
        constructor(e, t, n, r) {
            if (super(e, t, null, r),
                !n)
                throw new RangeError("Empty text nodes are not allowed");
            this.text = n
        }
        toString() {
            return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : I(this.marks, JSON.stringify(this.text))
        }
        get textContent() {
            return this.text
        }
        textBetween(e, t) {
            return this.text.slice(e, t)
        }
        get nodeSize() {
            return this.text.length
        }
        mark(e) {
            return e == this.marks ? this : new D(this.type, this.attrs, this.text, e)
        }
        withText(e) {
            return e == this.text ? this : new D(this.type, this.attrs, e, this.marks)
        }
        cut() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.text.length;
            return 0 == e && t == this.text.length ? this : this.withText(this.text.slice(e, t))
        }
        eq(e) {
            return this.sameMarkup(e) && this.text == e.text
        }
        toJSON() {
            let e = super.toJSON();
            return e.text = this.text,
                e
        }
    }
    function I(e, t) {
        for (let n = e.length - 1; n >= 0; n--)
            t = e[n].type.name + "(" + t + ")";
        return t
    }
    class j {
        constructor(e) {
            this.validEnd = e,
                this.next = [],
                this.wrapCache = []
        }
        static parse(e, t) {
            let n = new H(e, t);
            if (null == n.next)
                return j.empty;
            let r = z(n);
            n.next && n.err("Unexpected trailing text");
            let o = function (e) {
                let t = Object.create(null);
                return n(W(e, 0));
                function n(r) {
                    let o = [];
                    r.forEach((t => {
                        e[t].forEach((t => {
                            let n, { term: r, to: i } = t;
                            if (r) {
                                for (let e = 0; e < o.length; e++)
                                    o[e][0] == r && (n = o[e][1]);
                                W(e, i).forEach((e => {
                                    n || o.push([r, n = []]),
                                        -1 == n.indexOf(e) && n.push(e)
                                }
                                ))
                            }
                        }
                        ))
                    }
                    ));
                    let i = t[r.join(",")] = new j(r.indexOf(e.length - 1) > -1);
                    for (let e = 0; e < o.length; e++) {
                        let r = o[e][1].sort(U);
                        i.next.push({
                            type: o[e][0],
                            next: t[r.join(",")] || n(r)
                        })
                    }
                    return i
                }
            }(function (e) {
                let t = [[]];
                return o(i(e, 0), n()),
                    t;
                function n() {
                    return t.push([]) - 1
                }
                function r(e, n, r) {
                    let o = {
                        term: r,
                        to: n
                    };
                    return t[e].push(o),
                        o
                }
                function o(e, t) {
                    e.forEach((e => e.to = t))
                }
                function i(e, t) {
                    if ("choice" == e.type)
                        return e.exprs.reduce(((e, n) => e.concat(i(n, t))), []);
                    if ("seq" != e.type) {
                        if ("star" == e.type) {
                            let s = n();
                            return r(t, s),
                                o(i(e.expr, s), s),
                                [r(s)]
                        }
                        if ("plus" == e.type) {
                            let s = n();
                            return o(i(e.expr, t), s),
                                o(i(e.expr, s), s),
                                [r(s)]
                        }
                        if ("opt" == e.type)
                            return [r(t)].concat(i(e.expr, t));
                        if ("range" == e.type) {
                            let s = t;
                            for (let t = 0; t < e.min; t++) {
                                let t = n();
                                o(i(e.expr, s), t),
                                    s = t
                            }
                            if (-1 == e.max)
                                o(i(e.expr, s), s);
                            else
                                for (let t = e.min; t < e.max; t++) {
                                    let t = n();
                                    r(s, t),
                                        o(i(e.expr, s), t),
                                        s = t
                                }
                            return [r(s)]
                        }
                        if ("name" == e.type)
                            return [r(t, void 0, e.value)];
                        throw new Error("Unknown expr type")
                    }
                    for (let r = 0; ; r++) {
                        let s = i(e.exprs[r], t);
                        if (r == e.exprs.length - 1)
                            return s;
                        o(s, t = n())
                    }
                }
            }(r));
            return function (e, t) {
                for (let n = 0, r = [e]; n < r.length; n++) {
                    let e = r[n]
                        , o = !e.validEnd
                        , i = [];
                    for (let t = 0; t < e.next.length; t++) {
                        let { type: n, next: s } = e.next[t];
                        i.push(n.name),
                            !o || n.isText || n.hasRequiredAttrs() || (o = !1),
                            -1 == r.indexOf(s) && r.push(s)
                    }
                    o && t.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
                }
            }(o, n),
                o
        }
        matchType(e) {
            for (let t = 0; t < this.next.length; t++)
                if (this.next[t].type == e)
                    return this.next[t].next;
            return null
        }
        matchFragment(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.childCount
                , r = this;
            for (let o = t; r && o < n; o++)
                r = r.matchType(e.child(o).type);
            return r
        }
        get inlineContent() {
            return 0 != this.next.length && this.next[0].type.isInline
        }
        get defaultType() {
            for (let e = 0; e < this.next.length; e++) {
                let { type: t } = this.next[e];
                if (!t.isText && !t.hasRequiredAttrs())
                    return t
            }
            return null
        }
        compatible(e) {
            for (let t = 0; t < this.next.length; t++)
                for (let n = 0; n < e.next.length; n++)
                    if (this.next[t].type == e.next[n].type)
                        return !0;
            return !1
        }
        fillBefore(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                , r = [this];
            return function o(i, s) {
                let a = i.matchFragment(e, n);
                if (a && (!t || a.validEnd))
                    return d.from(s.map((e => e.createAndFill())));
                for (let e = 0; e < i.next.length; e++) {
                    let { type: t, next: n } = i.next[e];
                    if (!t.isText && !t.hasRequiredAttrs() && -1 == r.indexOf(n)) {
                        r.push(n);
                        let e = o(n, s.concat(t));
                        if (e)
                            return e
                    }
                }
                return null
            }(this, [])
        }
        findWrapping(e) {
            for (let n = 0; n < this.wrapCache.length; n += 2)
                if (this.wrapCache[n] == e)
                    return this.wrapCache[n + 1];
            let t = this.computeWrapping(e);
            return this.wrapCache.push(e, t),
                t
        }
        computeWrapping(e) {
            let t = Object.create(null)
                , n = [{
                    match: this,
                    type: null,
                    via: null
                }];
            for (; n.length;) {
                let r = n.shift()
                    , o = r.match;
                if (o.matchType(e)) {
                    let e = [];
                    for (let t = r; t.type; t = t.via)
                        e.push(t.type);
                    return e.reverse()
                }
                for (let e = 0; e < o.next.length; e++) {
                    let { type: i, next: s } = o.next[e];
                    i.isLeaf || i.hasRequiredAttrs() || i.name in t || r.type && !s.validEnd || (n.push({
                        match: i.contentMatch,
                        type: i,
                        via: r
                    }),
                        t[i.name] = !0)
                }
            }
            return null
        }
        get edgeCount() {
            return this.next.length
        }
        edge(e) {
            if (e >= this.next.length)
                throw new RangeError(`There's no ${e}th edge in this content match`);
            return this.next[e]
        }
        toString() {
            let e = [];
            return function t(n) {
                e.push(n);
                for (let r = 0; r < n.next.length; r++)
                    -1 == e.indexOf(n.next[r].next) && t(n.next[r].next)
            }(this),
                e.map(((t, n) => {
                    let r = n + (t.validEnd ? "*" : " ") + " ";
                    for (let o = 0; o < t.next.length; o++)
                        r += (o ? ", " : "") + t.next[o].type.name + "->" + e.indexOf(t.next[o].next);
                    return r
                }
                )).join("\n")
        }
    }
    j.empty = new j(!0);
    class H {
        constructor(e, t) {
            this.string = e,
                this.nodeTypes = t,
                this.inline = null,
                this.pos = 0,
                this.tokens = e.split(/\s*(?=\b|\W|$)/),
                "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(),
                "" == this.tokens[0] && this.tokens.shift()
        }
        get next() {
            return this.tokens[this.pos]
        }
        eat(e) {
            return this.next == e && (this.pos++ || !0)
        }
        err(e) {
            throw new SyntaxError(e + " (in content expression '" + this.string + "')")
        }
    }
    function z(e) {
        let t = [];
        do {
            t.push($(e))
        } while (e.eat("|"));
        return 1 == t.length ? t[0] : {
            type: "choice",
            exprs: t
        }
    }
    function $(e) {
        let t = [];
        do {
            t.push(B(e))
        } while (e.next && ")" != e.next && "|" != e.next);
        return 1 == t.length ? t[0] : {
            type: "seq",
            exprs: t
        }
    }
    function B(e) {
        let t = function (e) {
            if (e.eat("(")) {
                let t = z(e);
                return e.eat(")") || e.err("Missing closing paren"),
                    t
            }
            if (!/\W/.test(e.next)) {
                let t = function (e, t) {
                    let n = e.nodeTypes
                        , r = n[t];
                    if (r)
                        return [r];
                    let o = [];
                    for (let i in n) {
                        let e = n[i];
                        e.isInGroup(t) && o.push(e)
                    }
                    0 == o.length && e.err("No node type or group '" + t + "' found");
                    return o
                }(e, e.next).map((t => (null == e.inline ? e.inline = t.isInline : e.inline != t.isInline && e.err("Mixing inline and block content"),
                {
                    type: "name",
                    value: t
                })));
                return e.pos++,
                    1 == t.length ? t[0] : {
                        type: "choice",
                        exprs: t
                    }
            }
            e.err("Unexpected token '" + e.next + "'")
        }(e);
        for (; ;)
            if (e.eat("+"))
                t = {
                    type: "plus",
                    expr: t
                };
            else if (e.eat("*"))
                t = {
                    type: "star",
                    expr: t
                };
            else if (e.eat("?"))
                t = {
                    type: "opt",
                    expr: t
                };
            else {
                if (!e.eat("{"))
                    break;
                t = F(e, t)
            }
        return t
    }
    function V(e) {
        /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
        let t = Number(e.next);
        return e.pos++,
            t
    }
    function F(e, t) {
        let n = V(e)
            , r = n;
        return e.eat(",") && (r = "}" != e.next ? V(e) : -1),
            e.eat("}") || e.err("Unclosed braced range"),
        {
            type: "range",
            min: n,
            max: r,
            expr: t
        }
    }
    function U(e, t) {
        return t - e
    }
    function W(e, t) {
        let n = [];
        return function t(r) {
            let o = e[r];
            if (1 == o.length && !o[0].term)
                return t(o[0].to);
            n.push(r);
            for (let e = 0; e < o.length; e++) {
                let { term: r, to: i } = o[e];
                r || -1 != n.indexOf(i) || t(i)
            }
        }(t),
            n.sort(U)
    }
    function q(e) {
        let t = Object.create(null);
        for (let n in e) {
            let r = e[n];
            if (!r.hasDefault)
                return null;
            t[n] = r.default
        }
        return t
    }
    function G(e, t) {
        let n = Object.create(null);
        for (let r in e) {
            let o = t && t[r];
            if (void 0 === o) {
                let t = e[r];
                if (!t.hasDefault)
                    throw new RangeError("No value supplied for attribute " + r);
                o = t.default
            }
            n[r] = o
        }
        return n
    }
    function K(e, t, n, r) {
        for (let o in t)
            if (!(o in e))
                throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
        for (let o in e) {
            let n = e[o];
            n.validate && n.validate(t[o])
        }
    }
    function J(e, t) {
        let n = Object.create(null);
        if (t)
            for (let r in t)
                n[r] = new X(e, r, t[r]);
        return n
    }
    class Z {
        constructor(e, t, n) {
            this.name = e,
                this.schema = t,
                this.spec = n,
                this.markSet = null,
                this.groups = n.group ? n.group.split(" ") : [],
                this.attrs = J(e, n.attrs),
                this.defaultAttrs = q(this.attrs),
                this.contentMatch = null,
                this.inlineContent = null,
                this.isBlock = !(n.inline || "text" == e),
                this.isText = "text" == e
        }
        get isInline() {
            return !this.isBlock
        }
        get isTextblock() {
            return this.isBlock && this.inlineContent
        }
        get isLeaf() {
            return this.contentMatch == j.empty
        }
        get isAtom() {
            return this.isLeaf || !!this.spec.atom
        }
        isInGroup(e) {
            return this.groups.indexOf(e) > -1
        }
        get whitespace() {
            return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
        }
        hasRequiredAttrs() {
            for (let e in this.attrs)
                if (this.attrs[e].isRequired)
                    return !0;
            return !1
        }
        compatibleContent(e) {
            return this == e || this.contentMatch.compatible(e.contentMatch)
        }
        computeAttrs(e) {
            return !e && this.defaultAttrs ? this.defaultAttrs : G(this.attrs, e)
        }
        create() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                , t = arguments.length > 1 ? arguments[1] : void 0
                , n = arguments.length > 2 ? arguments[2] : void 0;
            if (this.isText)
                throw new Error("NodeType.create can't construct text nodes");
            return new R(this, this.computeAttrs(e), d.from(t), f.setFrom(n))
        }
        createChecked() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                , t = arguments.length > 1 ? arguments[1] : void 0
                , n = arguments.length > 2 ? arguments[2] : void 0;
            return t = d.from(t),
                this.checkContent(t),
                new R(this, this.computeAttrs(e), t, f.setFrom(n))
        }
        createAndFill() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                , t = arguments.length > 1 ? arguments[1] : void 0
                , n = arguments.length > 2 ? arguments[2] : void 0;
            if (e = this.computeAttrs(e),
                t = d.from(t),
                t.size) {
                let e = this.contentMatch.fillBefore(t);
                if (!e)
                    return null;
                t = e.append(t)
            }
            let r = this.contentMatch.matchFragment(t)
                , o = r && r.fillBefore(d.empty, !0);
            return o ? new R(this, e, t.append(o), f.setFrom(n)) : null
        }
        validContent(e) {
            let t = this.contentMatch.matchFragment(e);
            if (!t || !t.validEnd)
                return !1;
            for (let n = 0; n < e.childCount; n++)
                if (!this.allowsMarks(e.child(n).marks))
                    return !1;
            return !0
        }
        checkContent(e) {
            if (!this.validContent(e))
                throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`)
        }
        checkAttrs(e) {
            K(this.attrs, e, "node", this.name)
        }
        allowsMarkType(e) {
            return null == this.markSet || this.markSet.indexOf(e) > -1
        }
        allowsMarks(e) {
            if (null == this.markSet)
                return !0;
            for (let t = 0; t < e.length; t++)
                if (!this.allowsMarkType(e[t].type))
                    return !1;
            return !0
        }
        allowedMarks(e) {
            if (null == this.markSet)
                return e;
            let t;
            for (let n = 0; n < e.length; n++)
                this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n));
            return t ? t.length ? t : f.none : e
        }
        static compile(e, t) {
            let n = Object.create(null);
            e.forEach(((e, r) => n[e] = new Z(e, t, r)));
            let r = t.spec.topNode || "doc";
            if (!n[r])
                throw new RangeError("Schema is missing its top node type ('" + r + "')");
            if (!n.text)
                throw new RangeError("Every schema needs a 'text' type");
            for (let o in n.text.attrs)
                throw new RangeError("The text node type should not have attributes");
            return n
        }
    }
    class X {
        constructor(e, t, n) {
            this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"),
                this.default = n.default,
                this.validate = "string" == typeof n.validate ? function (e, t, n) {
                    let r = n.split("|");
                    return n => {
                        let o = null === n ? "null" : typeof n;
                        if (r.indexOf(o) < 0)
                            throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`)
                    }
                }(e, t, n.validate) : n.validate
        }
        get isRequired() {
            return !this.hasDefault
        }
    }
    class Q {
        constructor(e, t, n, r) {
            this.name = e,
                this.rank = t,
                this.schema = n,
                this.spec = r,
                this.attrs = J(e, r.attrs),
                this.excluded = null;
            let o = q(this.attrs);
            this.instance = o ? new f(this, o) : null
        }
        create() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return !e && this.instance ? this.instance : new f(this, G(this.attrs, e))
        }
        static compile(e, t) {
            let n = Object.create(null)
                , r = 0;
            return e.forEach(((e, o) => n[e] = new Q(e, r++, t, o))),
                n
        }
        removeFromSet(e) {
            for (var t = 0; t < e.length; t++)
                e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)),
                    t--);
            return e
        }
        isInSet(e) {
            for (let t = 0; t < e.length; t++)
                if (e[t].type == this)
                    return e[t]
        }
        checkAttrs(e) {
            K(this.attrs, e, "mark", this.name)
        }
        excludes(e) {
            return this.excluded.indexOf(e) > -1
        }
    }
    class Y {
        constructor(e) {
            this.linebreakReplacement = null,
                this.cached = Object.create(null);
            let t = this.spec = {};
            for (let r in e)
                t[r] = e[r];
            t.nodes = a.from(e.nodes),
                t.marks = a.from(e.marks || {}),
                this.nodes = Z.compile(this.spec.nodes, this),
                this.marks = Q.compile(this.spec.marks, this);
            let n = Object.create(null);
            for (let r in this.nodes) {
                if (r in this.marks)
                    throw new RangeError(r + " can not be both a node and a mark");
                let e = this.nodes[r]
                    , t = e.spec.content || ""
                    , o = e.spec.marks;
                if (e.contentMatch = n[t] || (n[t] = j.parse(t, this.nodes)),
                    e.inlineContent = e.contentMatch.inlineContent,
                    e.spec.linebreakReplacement) {
                    if (this.linebreakReplacement)
                        throw new RangeError("Multiple linebreak nodes defined");
                    if (!e.isInline || !e.isLeaf)
                        throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
                    this.linebreakReplacement = e
                }
                e.markSet = "_" == o ? null : o ? ee(this, o.split(" ")) : "" != o && e.inlineContent ? null : []
            }
            for (let r in this.marks) {
                let e = this.marks[r]
                    , t = e.spec.excludes;
                e.excluded = null == t ? [e] : "" == t ? [] : ee(this, t.split(" "))
            }
            this.nodeFromJSON = this.nodeFromJSON.bind(this),
                this.markFromJSON = this.markFromJSON.bind(this),
                this.topNodeType = this.nodes[this.spec.topNode || "doc"],
                this.cached.wrappings = Object.create(null)
        }
        node(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                , n = arguments.length > 2 ? arguments[2] : void 0
                , r = arguments.length > 3 ? arguments[3] : void 0;
            if ("string" == typeof e)
                e = this.nodeType(e);
            else {
                if (!(e instanceof Z))
                    throw new RangeError("Invalid node type: " + e);
                if (e.schema != this)
                    throw new RangeError("Node type from different schema used (" + e.name + ")")
            }
            return e.createChecked(t, n, r)
        }
        text(e, t) {
            let n = this.nodes.text;
            return new D(n, n.defaultAttrs, e, f.setFrom(t))
        }
        mark(e, t) {
            return "string" == typeof e && (e = this.marks[e]),
                e.create(t)
        }
        nodeFromJSON(e) {
            return R.fromJSON(this, e)
        }
        markFromJSON(e) {
            return f.fromJSON(this, e)
        }
        nodeType(e) {
            let t = this.nodes[e];
            if (!t)
                throw new RangeError("Unknown node type: " + e);
            return t
        }
    }
    function ee(e, t) {
        let n = [];
        for (let r = 0; r < t.length; r++) {
            let o = t[r]
                , i = e.marks[o]
                , s = i;
            if (i)
                n.push(i);
            else
                for (let t in e.marks) {
                    let r = e.marks[t];
                    ("_" == o || r.spec.group && r.spec.group.split(" ").indexOf(o) > -1) && n.push(s = r)
                }
            if (!s)
                throw new SyntaxError("Unknown mark type: '" + t[r] + "'")
        }
        return n
    }
    class te {
        constructor(e, t) {
            this.schema = e,
                this.rules = t,
                this.tags = [],
                this.styles = [];
            let n = this.matchedStyles = [];
            t.forEach((e => {
                if (function (e) {
                    return null != e.tag
                }(e))
                    this.tags.push(e);
                else if (function (e) {
                    return null != e.style
                }(e)) {
                    let t = /[^=]*/.exec(e.style)[0];
                    n.indexOf(t) < 0 && n.push(t),
                        this.styles.push(e)
                }
            }
            )),
                this.normalizeLists = !this.tags.some((t => {
                    if (!/^(ul|ol)\b/.test(t.tag) || !t.node)
                        return !1;
                    let n = e.nodes[t.node];
                    return n.contentMatch.matchType(n)
                }
                ))
        }
        parse(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = new ae(this, t, !1);
            return n.addAll(e, f.none, t.from, t.to),
                n.finish()
        }
        parseSlice(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = new ae(this, t, !0);
            return n.addAll(e, f.none, t.from, t.to),
                g.maxOpen(n.finish())
        }
        matchTag(e, t, n) {
            for (let r = n ? this.tags.indexOf(n) + 1 : 0; r < this.tags.length; r++) {
                let n = this.tags[r];
                if (le(e, n.tag) && (void 0 === n.namespace || e.namespaceURI == n.namespace) && (!n.context || t.matchesContext(n.context))) {
                    if (n.getAttrs) {
                        let t = n.getAttrs(e);
                        if (!1 === t)
                            continue;
                        n.attrs = t || void 0
                    }
                    return n
                }
            }
        }
        matchStyle(e, t, n, r) {
            for (let o = r ? this.styles.indexOf(r) + 1 : 0; o < this.styles.length; o++) {
                let r = this.styles[o]
                    , i = r.style;
                if (!(0 != i.indexOf(e) || r.context && !n.matchesContext(r.context) || i.length > e.length && (61 != i.charCodeAt(e.length) || i.slice(e.length + 1) != t))) {
                    if (r.getAttrs) {
                        let e = r.getAttrs(t);
                        if (!1 === e)
                            continue;
                        r.attrs = e || void 0
                    }
                    return r
                }
            }
        }
        static schemaRules(e) {
            let t = [];
            function n(e) {
                let n = null == e.priority ? 50 : e.priority
                    , r = 0;
                for (; r < t.length; r++) {
                    let e = t[r];
                    if ((null == e.priority ? 50 : e.priority) < n)
                        break
                }
                t.splice(r, 0, e)
            }
            for (let r in e.marks) {
                let t = e.marks[r].spec.parseDOM;
                t && t.forEach((e => {
                    n(e = ce(e)),
                        e.mark || e.ignore || e.clearMark || (e.mark = r)
                }
                ))
            }
            for (let r in e.nodes) {
                let t = e.nodes[r].spec.parseDOM;
                t && t.forEach((e => {
                    n(e = ce(e)),
                        e.node || e.ignore || e.mark || (e.node = r)
                }
                ))
            }
            return t
        }
        static fromSchema(e) {
            return e.cached.domParser || (e.cached.domParser = new te(e, te.schemaRules(e)))
        }
    }
    const ne = {
        address: !0,
        article: !0,
        aside: !0,
        blockquote: !0,
        canvas: !0,
        dd: !0,
        div: !0,
        dl: !0,
        fieldset: !0,
        figcaption: !0,
        figure: !0,
        footer: !0,
        form: !0,
        h1: !0,
        h2: !0,
        h3: !0,
        h4: !0,
        h5: !0,
        h6: !0,
        header: !0,
        hgroup: !0,
        hr: !0,
        li: !0,
        noscript: !0,
        ol: !0,
        output: !0,
        p: !0,
        pre: !0,
        section: !0,
        table: !0,
        tfoot: !0,
        ul: !0
    }
        , re = {
            head: !0,
            noscript: !0,
            object: !0,
            script: !0,
            style: !0,
            title: !0
        }
        , oe = {
            ol: !0,
            ul: !0
        };
    function ie(e, t, n) {
        return null != t ? (t ? 1 : 0) | ("full" === t ? 2 : 0) : e && "pre" == e.whitespace ? 3 : -5 & n
    }
    class se {
        constructor(e, t, n, r, o, i) {
            this.type = e,
                this.attrs = t,
                this.marks = n,
                this.solid = r,
                this.options = i,
                this.content = [],
                this.activeMarks = f.none,
                this.match = o || (4 & i ? null : e.contentMatch)
        }
        findWrapping(e) {
            if (!this.match) {
                if (!this.type)
                    return [];
                let t = this.type.contentMatch.fillBefore(d.from(e));
                if (!t) {
                    let t, n = this.type.contentMatch;
                    return (t = n.findWrapping(e.type)) ? (this.match = n,
                        t) : null
                }
                this.match = this.type.contentMatch.matchFragment(t)
            }
            return this.match.findWrapping(e.type)
        }
        finish(e) {
            if (!(1 & this.options)) {
                let e, t = this.content[this.content.length - 1];
                if (t && t.isText && (e = /[ \t\r\n\u000c]+$/.exec(t.text))) {
                    let n = t;
                    t.text.length == e[0].length ? this.content.pop() : this.content[this.content.length - 1] = n.withText(n.text.slice(0, n.text.length - e[0].length))
                }
            }
            let t = d.from(this.content);
            return !e && this.match && (t = t.append(this.match.fillBefore(d.empty, !0))),
                this.type ? this.type.create(this.attrs, t, this.marks) : t
        }
        inlineContext(e) {
            return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !ne.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
        }
    }
    class ae {
        constructor(e, t, n) {
            this.parser = e,
                this.options = t,
                this.isOpen = n,
                this.open = 0;
            let r, o = t.topNode, i = ie(null, t.preserveWhitespace, 0) | (n ? 4 : 0);
            r = o ? new se(o.type, o.attrs, f.none, !0, t.topMatch || o.type.contentMatch, i) : new se(n ? null : e.schema.topNodeType, null, f.none, !0, null, i),
                this.nodes = [r],
                this.find = t.findPositions,
                this.needsBlock = !1
        }
        get top() {
            return this.nodes[this.open]
        }
        addDOM(e, t) {
            3 == e.nodeType ? this.addTextNode(e, t) : 1 == e.nodeType && this.addElement(e, t)
        }
        addTextNode(e, t) {
            let n = e.nodeValue
                , r = this.top;
            if (2 & r.options || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
                if (1 & r.options)
                    n = 2 & r.options ? n.replace(/\r\n?/g, "\n") : n.replace(/\r?\n|\r/g, " ");
                else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "),
                    /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
                    let t = r.content[r.content.length - 1]
                        , o = e.previousSibling;
                    (!t || o && "BR" == o.nodeName || t.isText && /[ \t\r\n\u000c]$/.test(t.text)) && (n = n.slice(1))
                }
                n && this.insertNode(this.parser.schema.text(n), t),
                    this.findInText(e)
            } else
                this.findInside(e)
        }
        addElement(e, t, n) {
            let r, o = e.nodeName.toLowerCase();
            oe.hasOwnProperty(o) && this.parser.normalizeLists && function (e) {
                for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
                    let e = 1 == t.nodeType ? t.nodeName.toLowerCase() : null;
                    e && oe.hasOwnProperty(e) && n ? (n.appendChild(t),
                        t = n) : "li" == e ? n = t : e && (n = null)
                }
            }(e);
            let i = this.options.ruleFromNode && this.options.ruleFromNode(e) || (r = this.parser.matchTag(e, this, n));
            if (i ? i.ignore : re.hasOwnProperty(o))
                this.findInside(e),
                    this.ignoreFallback(e, t);
            else if (!i || i.skip || i.closeParent) {
                i && i.closeParent ? this.open = Math.max(0, this.open - 1) : i && i.skip.nodeType && (e = i.skip);
                let n, r = this.top, s = this.needsBlock;
                if (ne.hasOwnProperty(o))
                    r.content.length && r.content[0].isInline && this.open && (this.open--,
                        r = this.top),
                        n = !0,
                        r.type || (this.needsBlock = !0);
                else if (!e.firstChild)
                    return void this.leafFallback(e, t);
                let a = i && i.skip ? t : this.readStyles(e, t);
                a && this.addAll(e, a),
                    n && this.sync(r),
                    this.needsBlock = s
            } else {
                let n = this.readStyles(e, t);
                n && this.addElementByRule(e, i, n, !1 === i.consuming ? r : void 0)
            }
        }
        leafFallback(e, t) {
            "BR" == e.nodeName && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode("\n"), t)
        }
        ignoreFallback(e, t) {
            "BR" != e.nodeName || this.top.type && this.top.type.inlineContent || this.findPlace(this.parser.schema.text("-"), t)
        }
        readStyles(e, t) {
            let n = e.style;
            if (n && n.length)
                for (let r = 0; r < this.parser.matchedStyles.length; r++) {
                    let e = this.parser.matchedStyles[r]
                        , o = n.getPropertyValue(e);
                    if (o)
                        for (let n; ;) {
                            let r = this.parser.matchStyle(e, o, this, n);
                            if (!r)
                                break;
                            if (r.ignore)
                                return null;
                            if (t = r.clearMark ? t.filter((e => !r.clearMark(e))) : t.concat(this.parser.schema.marks[r.mark].create(r.attrs)),
                                !1 !== r.consuming)
                                break;
                            n = r
                        }
                }
            return t
        }
        addElementByRule(e, t, n, r) {
            let o, i;
            if (t.node)
                if (i = this.parser.schema.nodes[t.node],
                    i.isLeaf)
                    this.insertNode(i.create(t.attrs), n) || this.leafFallback(e, n);
                else {
                    let e = this.enter(i, t.attrs || null, n, t.preserveWhitespace);
                    e && (o = !0,
                        n = e)
                }
            else {
                let e = this.parser.schema.marks[t.mark];
                n = n.concat(e.create(t.attrs))
            }
            let s = this.top;
            if (i && i.isLeaf)
                this.findInside(e);
            else if (r)
                this.addElement(e, n, r);
            else if (t.getContent)
                this.findInside(e),
                    t.getContent(e, this.parser.schema).forEach((e => this.insertNode(e, n)));
            else {
                let r = e;
                "string" == typeof t.contentElement ? r = e.querySelector(t.contentElement) : "function" == typeof t.contentElement ? r = t.contentElement(e) : t.contentElement && (r = t.contentElement),
                    this.findAround(e, r, !0),
                    this.addAll(r, n),
                    this.findAround(e, r, !1)
            }
            o && this.sync(s) && this.open--
        }
        addAll(e, t, n, r) {
            let o = n || 0;
            for (let i = n ? e.childNodes[n] : e.firstChild, s = null == r ? null : e.childNodes[r]; i != s; i = i.nextSibling,
                ++o)
                this.findAtPoint(e, o),
                    this.addDOM(i, t);
            this.findAtPoint(e, o)
        }
        findPlace(e, t) {
            let n, r;
            for (let o = this.open; o >= 0; o--) {
                let t = this.nodes[o]
                    , i = t.findWrapping(e);
                if (i && (!n || n.length > i.length) && (n = i,
                    r = t,
                    !i.length))
                    break;
                if (t.solid)
                    break
            }
            if (!n)
                return null;
            this.sync(r);
            for (let o = 0; o < n.length; o++)
                t = this.enterInner(n[o], null, t, !1);
            return t
        }
        insertNode(e, t) {
            if (e.isInline && this.needsBlock && !this.top.type) {
                let e = this.textblockFromContext();
                e && (t = this.enterInner(e, null, t))
            }
            let n = this.findPlace(e, t);
            if (n) {
                this.closeExtra();
                let t = this.top;
                t.match && (t.match = t.match.matchType(e.type));
                let r = f.none;
                for (let o of n.concat(e.marks))
                    (t.type ? t.type.allowsMarkType(o.type) : de(o.type, e.type)) && (r = o.addToSet(r));
                return t.content.push(e.mark(r)),
                    !0
            }
            return !1
        }
        enter(e, t, n, r) {
            let o = this.findPlace(e.create(t), n);
            return o && (o = this.enterInner(e, t, n, !0, r)),
                o
        }
        enterInner(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                , o = arguments.length > 4 ? arguments[4] : void 0;
            this.closeExtra();
            let i = this.top;
            i.match = i.match && i.match.matchType(e);
            let s = ie(e, o, i.options);
            4 & i.options && 0 == i.content.length && (s |= 4);
            let a = f.none;
            return n = n.filter((t => !(i.type ? i.type.allowsMarkType(t.type) : de(t.type, e)) || (a = t.addToSet(a),
                !1))),
                this.nodes.push(new se(e, t, a, r, null, s)),
                this.open++,
                n
        }
        closeExtra() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                , t = this.nodes.length - 1;
            if (t > this.open) {
                for (; t > this.open; t--)
                    this.nodes[t - 1].content.push(this.nodes[t].finish(e));
                this.nodes.length = this.open + 1
            }
        }
        finish() {
            return this.open = 0,
                this.closeExtra(this.isOpen),
                this.nodes[0].finish(this.isOpen || this.options.topOpen)
        }
        sync(e) {
            for (let t = this.open; t >= 0; t--)
                if (this.nodes[t] == e)
                    return this.open = t,
                        !0;
            return !1
        }
        get currentPos() {
            this.closeExtra();
            let e = 0;
            for (let t = this.open; t >= 0; t--) {
                let n = this.nodes[t].content;
                for (let t = n.length - 1; t >= 0; t--)
                    e += n[t].nodeSize;
                t && e++
            }
            return e
        }
        findAtPoint(e, t) {
            if (this.find)
                for (let n = 0; n < this.find.length; n++)
                    this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos)
        }
        findInside(e) {
            if (this.find)
                for (let t = 0; t < this.find.length; t++)
                    null == this.find[t].pos && 1 == e.nodeType && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos)
        }
        findAround(e, t, n) {
            if (e != t && this.find)
                for (let r = 0; r < this.find.length; r++)
                    if (null == this.find[r].pos && 1 == e.nodeType && e.contains(this.find[r].node)) {
                        t.compareDocumentPosition(this.find[r].node) & (n ? 2 : 4) && (this.find[r].pos = this.currentPos)
                    }
        }
        findInText(e) {
            if (this.find)
                for (let t = 0; t < this.find.length; t++)
                    this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset))
        }
        matchesContext(e) {
            if (e.indexOf("|") > -1)
                return e.split(/\s*\|\s*/).some(this.matchesContext, this);
            let t = e.split("/")
                , n = this.options.context
                , r = !this.isOpen && (!n || n.parent.type == this.nodes[0].type)
                , o = -(n ? n.depth + 1 : 0) + (r ? 0 : 1)
                , i = (e, s) => {
                    for (; e >= 0; e--) {
                        let a = t[e];
                        if ("" == a) {
                            if (e == t.length - 1 || 0 == e)
                                continue;
                            for (; s >= o; s--)
                                if (i(e - 1, s))
                                    return !0;
                            return !1
                        }
                        {
                            let e = s > 0 || 0 == s && r ? this.nodes[s].type : n && s >= o ? n.node(s - o).type : null;
                            if (!e || e.name != a && !e.isInGroup(a))
                                return !1;
                            s--
                        }
                    }
                    return !0
                }
                ;
            return i(t.length - 1, this.open)
        }
        textblockFromContext() {
            let e = this.options.context;
            if (e)
                for (let t = e.depth; t >= 0; t--) {
                    let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
                    if (n && n.isTextblock && n.defaultAttrs)
                        return n
                }
            for (let t in this.parser.schema.nodes) {
                let e = this.parser.schema.nodes[t];
                if (e.isTextblock && e.defaultAttrs)
                    return e
            }
        }
    }
    function le(e, t) {
        return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t)
    }
    function ce(e) {
        let t = {};
        for (let n in e)
            t[n] = e[n];
        return t
    }
    function de(e, t) {
        let n = t.schema.nodes;
        for (let r in n) {
            let o = n[r];
            if (!o.allowsMarkType(e))
                continue;
            let i = []
                , s = e => {
                    i.push(e);
                    for (let n = 0; n < e.edgeCount; n++) {
                        let { type: r, next: o } = e.edge(n);
                        if (r == t)
                            return !0;
                        if (i.indexOf(o) < 0 && s(o))
                            return !0
                    }
                }
                ;
            if (s(o.contentMatch))
                return !0
        }
    }
    class ue {
        constructor(e, t) {
            this.nodes = e,
                this.marks = t
        }
        serializeFragment(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = arguments.length > 2 ? arguments[2] : void 0;
            n || (n = pe(t).createDocumentFragment());
            let r = n
                , o = [];
            return e.forEach((e => {
                if (o.length || e.marks.length) {
                    let n = 0
                        , i = 0;
                    for (; n < o.length && i < e.marks.length;) {
                        let t = e.marks[i];
                        if (this.marks[t.type.name]) {
                            if (!t.eq(o[n][0]) || !1 === t.type.spec.spanning)
                                break;
                            n++,
                                i++
                        } else
                            i++
                    }
                    for (; n < o.length;)
                        r = o.pop()[1];
                    for (; i < e.marks.length;) {
                        let n = e.marks[i++]
                            , s = this.serializeMark(n, e.isInline, t);
                        s && (o.push([n, r]),
                            r.appendChild(s.dom),
                            r = s.contentDOM || s.dom)
                    }
                }
                r.appendChild(this.serializeNodeInner(e, t))
            }
            )),
                n
        }
        serializeNodeInner(e, t) {
            let { dom: n, contentDOM: r } = ge(pe(t), this.nodes[e.type.name](e), null, e.attrs);
            if (r) {
                if (e.isLeaf)
                    throw new RangeError("Content hole not allowed in a leaf node spec");
                this.serializeFragment(e.content, t, r)
            }
            return n
        }
        serializeNode(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = this.serializeNodeInner(e, t);
            for (let r = e.marks.length - 1; r >= 0; r--) {
                let o = this.serializeMark(e.marks[r], e.isInline, t);
                o && ((o.contentDOM || o.dom).appendChild(n),
                    n = o.dom)
            }
            return n
        }
        serializeMark(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                , r = this.marks[e.type.name];
            return r && ge(pe(n), r(e, t), null, e.attrs)
        }
        static renderSpec(e, t) {
            return ge(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, arguments.length > 3 ? arguments[3] : void 0)
        }
        static fromSchema(e) {
            return e.cached.domSerializer || (e.cached.domSerializer = new ue(this.nodesFromSchema(e), this.marksFromSchema(e)))
        }
        static nodesFromSchema(e) {
            let t = he(e.nodes);
            return t.text || (t.text = e => e.text),
                t
        }
        static marksFromSchema(e) {
            return he(e.marks)
        }
    }
    function he(e) {
        let t = {};
        for (let n in e) {
            let r = e[n].spec.toDOM;
            r && (t[n] = r)
        }
        return t
    }
    function pe(e) {
        return e.document || window.document
    }
    const fe = new WeakMap;
    function me(e) {
        let t = fe.get(e);
        return void 0 === t && fe.set(e, t = function (e) {
            let t = null;
            function n(e) {
                if (e && "object" == typeof e)
                    if (Array.isArray(e))
                        if ("string" == typeof e[0])
                            t || (t = []),
                                t.push(e);
                        else
                            for (let t = 0; t < e.length; t++)
                                n(e[t]);
                    else
                        for (let t in e)
                            n(e[t])
            }
            return n(e),
                t
        }(e)),
            t
    }
    function ge(e, t, n, r) {
        if ("string" == typeof t)
            return {
                dom: e.createTextNode(t)
            };
        if (null != t.nodeType)
            return {
                dom: t
            };
        if (t.dom && null != t.dom.nodeType)
            return t;
        let o, i = t[0];
        if ("string" != typeof i)
            throw new RangeError("Invalid array passed to renderSpec");
        if (r && (o = me(r)) && o.indexOf(t) > -1)
            throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
        let s, a = i.indexOf(" ");
        a > 0 && (n = i.slice(0, a),
            i = i.slice(a + 1));
        let l = n ? e.createElementNS(n, i) : e.createElement(i)
            , c = t[1]
            , d = 1;
        if (c && "object" == typeof c && null == c.nodeType && !Array.isArray(c)) {
            d = 2;
            for (let e in c)
                if (null != c[e]) {
                    let t = e.indexOf(" ");
                    t > 0 ? l.setAttributeNS(e.slice(0, t), e.slice(t + 1), c[e]) : l.setAttribute(e, c[e])
                }
        }
        for (let u = d; u < t.length; u++) {
            let o = t[u];
            if (0 === o) {
                if (u < t.length - 1 || u > d)
                    throw new RangeError("Content hole must be the only child of its parent node");
                return {
                    dom: l,
                    contentDOM: l
                }
            }
            {
                let { dom: t, contentDOM: i } = ge(e, o, n, r);
                if (l.appendChild(t),
                    i) {
                    if (s)
                        throw new RangeError("Multiple content holes");
                    s = i
                }
            }
        }
        return {
            dom: l,
            contentDOM: s
        }
    }
    const be = Math.pow(2, 16);
    function ye(e, t) {
        return e + t * be
    }
    function ve(e) {
        return 65535 & e
    }
    class we {
        constructor(e, t, n) {
            this.pos = e,
                this.delInfo = t,
                this.recover = n
        }
        get deleted() {
            return (8 & this.delInfo) > 0
        }
        get deletedBefore() {
            return (5 & this.delInfo) > 0
        }
        get deletedAfter() {
            return (6 & this.delInfo) > 0
        }
        get deletedAcross() {
            return (4 & this.delInfo) > 0
        }
    }
    class ke {
        constructor(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this.ranges = e,
                this.inverted = t,
                !e.length && ke.empty)
                return ke.empty
        }
        recover(e) {
            let t = 0
                , n = ve(e);
            if (!this.inverted)
                for (let r = 0; r < n; r++)
                    t += this.ranges[3 * r + 2] - this.ranges[3 * r + 1];
            return this.ranges[3 * n] + t + function (e) {
                return (e - (65535 & e)) / be
            }(e)
        }
        mapResult(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return this._map(e, t, !1)
        }
        map(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return this._map(e, t, !0)
        }
        _map(e, t, n) {
            let r = 0
                , o = this.inverted ? 2 : 1
                , i = this.inverted ? 1 : 2;
            for (let s = 0; s < this.ranges.length; s += 3) {
                let a = this.ranges[s] - (this.inverted ? r : 0);
                if (a > e)
                    break;
                let l = this.ranges[s + o]
                    , c = this.ranges[s + i]
                    , d = a + l;
                if (e <= d) {
                    let o = a + r + ((l ? e == a ? -1 : e == d ? 1 : t : t) < 0 ? 0 : c);
                    if (n)
                        return o;
                    let i = e == (t < 0 ? a : d) ? null : ye(s / 3, e - a)
                        , u = e == a ? 2 : e == d ? 1 : 4;
                    return (t < 0 ? e != a : e != d) && (u |= 8),
                        new we(o, u, i)
                }
                r += c - l
            }
            return n ? e + r : new we(e + r, 0, null)
        }
        touches(e, t) {
            let n = 0
                , r = ve(t)
                , o = this.inverted ? 2 : 1
                , i = this.inverted ? 1 : 2;
            for (let s = 0; s < this.ranges.length; s += 3) {
                let t = this.ranges[s] - (this.inverted ? n : 0);
                if (t > e)
                    break;
                let a = this.ranges[s + o];
                if (e <= t + a && s == 3 * r)
                    return !0;
                n += this.ranges[s + i] - a
            }
            return !1
        }
        forEach(e) {
            let t = this.inverted ? 2 : 1
                , n = this.inverted ? 1 : 2;
            for (let r = 0, o = 0; r < this.ranges.length; r += 3) {
                let i = this.ranges[r]
                    , s = i - (this.inverted ? o : 0)
                    , a = i + (this.inverted ? 0 : o)
                    , l = this.ranges[r + t]
                    , c = this.ranges[r + n];
                e(s, s + l, a, a + c),
                    o += c - l
            }
        }
        invert() {
            return new ke(this.ranges, !this.inverted)
        }
        toString() {
            return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
        }
        static offset(e) {
            return 0 == e ? ke.empty : new ke(e < 0 ? [0, -e, 0] : [0, 0, e])
        }
    }
    ke.empty = new ke([]);
    class Ce {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                , t = arguments.length > 1 ? arguments[1] : void 0
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.length;
            this.maps = e,
                this.mirror = t,
                this.from = n,
                this.to = r
        }
        slice() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.maps.length;
            return new Ce(this.maps, this.mirror, e, t)
        }
        copy() {
            return new Ce(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
        }
        appendMap(e, t) {
            this.to = this.maps.push(e),
                null != t && this.setMirror(this.maps.length - 1, t)
        }
        appendMapping(e) {
            for (let t = 0, n = this.maps.length; t < e.maps.length; t++) {
                let r = e.getMirror(t);
                this.appendMap(e.maps[t], null != r && r < t ? n + r : void 0)
            }
        }
        getMirror(e) {
            if (this.mirror)
                for (let t = 0; t < this.mirror.length; t++)
                    if (this.mirror[t] == e)
                        return this.mirror[t + (t % 2 ? -1 : 1)]
        }
        setMirror(e, t) {
            this.mirror || (this.mirror = []),
                this.mirror.push(e, t)
        }
        appendMappingInverted(e) {
            for (let t = e.maps.length - 1, n = this.maps.length + e.maps.length; t >= 0; t--) {
                let r = e.getMirror(t);
                this.appendMap(e.maps[t].invert(), null != r && r > t ? n - r - 1 : void 0)
            }
        }
        invert() {
            let e = new Ce;
            return e.appendMappingInverted(this),
                e
        }
        map(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            if (this.mirror)
                return this._map(e, t, !0);
            for (let n = this.from; n < this.to; n++)
                e = this.maps[n].map(e, t);
            return e
        }
        mapResult(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return this._map(e, t, !1)
        }
        _map(e, t, n) {
            let r = 0;
            for (let o = this.from; o < this.to; o++) {
                let n = this.maps[o].mapResult(e, t);
                if (null != n.recover) {
                    let t = this.getMirror(o);
                    if (null != t && t > o && t < this.to) {
                        o = t,
                            e = this.maps[t].recover(n.recover);
                        continue
                    }
                }
                r |= n.delInfo,
                    e = n.pos
            }
            return n ? e : new we(e, r, null)
        }
    }
    const Se = Object.create(null);
    class xe {
        getMap() {
            return ke.empty
        }
        merge(e) {
            return null
        }
        static fromJSON(e, t) {
            if (!t || !t.stepType)
                throw new RangeError("Invalid input for Step.fromJSON");
            let n = Se[t.stepType];
            if (!n)
                throw new RangeError(`No step type ${t.stepType} defined`);
            return n.fromJSON(e, t)
        }
        static jsonID(e, t) {
            if (e in Se)
                throw new RangeError("Duplicate use of step JSON ID " + e);
            return Se[e] = t,
                t.prototype.jsonID = e,
                t
        }
    }
    class Ee {
        constructor(e, t) {
            this.doc = e,
                this.failed = t
        }
        static ok(e) {
            return new Ee(e, null)
        }
        static fail(e) {
            return new Ee(null, e)
        }
        static fromReplace(e, t, n, r) {
            try {
                return Ee.ok(e.replace(t, n, r))
            } catch (o) {
                if (o instanceof m)
                    return Ee.fail(o.message);
                throw o
            }
        }
    }
    function Me(e, t, n) {
        let r = [];
        for (let o = 0; o < e.childCount; o++) {
            let i = e.child(o);
            i.content.size && (i = i.copy(Me(i.content, t, i))),
                i.isInline && (i = t(i, n, o)),
                r.push(i)
        }
        return d.fromArray(r)
    }
    class Te extends xe {
        constructor(e, t, n) {
            super(),
                this.from = e,
                this.to = t,
                this.mark = n
        }
        apply(e) {
            let t = e.slice(this.from, this.to)
                , n = e.resolve(this.from)
                , r = n.node(n.sharedDepth(this.to))
                , o = new g(Me(t.content, ((e, t) => e.isAtom && t.type.allowsMarkType(this.mark.type) ? e.mark(this.mark.addToSet(e.marks)) : e), r), t.openStart, t.openEnd);
            return Ee.fromReplace(e, this.from, this.to, o)
        }
        invert() {
            return new Ne(this.from, this.to, this.mark)
        }
        map(e) {
            let t = e.mapResult(this.from, 1)
                , n = e.mapResult(this.to, -1);
            return t.deleted && n.deleted || t.pos >= n.pos ? null : new Te(t.pos, n.pos, this.mark)
        }
        merge(e) {
            return e instanceof Te && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Te(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null
        }
        toJSON() {
            return {
                stepType: "addMark",
                mark: this.mark.toJSON(),
                from: this.from,
                to: this.to
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.from || "number" != typeof t.to)
                throw new RangeError("Invalid input for AddMarkStep.fromJSON");
            return new Te(t.from, t.to, e.markFromJSON(t.mark))
        }
    }
    xe.jsonID("addMark", Te);
    class Ne extends xe {
        constructor(e, t, n) {
            super(),
                this.from = e,
                this.to = t,
                this.mark = n
        }
        apply(e) {
            let t = e.slice(this.from, this.to)
                , n = new g(Me(t.content, (e => e.mark(this.mark.removeFromSet(e.marks))), e), t.openStart, t.openEnd);
            return Ee.fromReplace(e, this.from, this.to, n)
        }
        invert() {
            return new Te(this.from, this.to, this.mark)
        }
        map(e) {
            let t = e.mapResult(this.from, 1)
                , n = e.mapResult(this.to, -1);
            return t.deleted && n.deleted || t.pos >= n.pos ? null : new Ne(t.pos, n.pos, this.mark)
        }
        merge(e) {
            return e instanceof Ne && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ne(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null
        }
        toJSON() {
            return {
                stepType: "removeMark",
                mark: this.mark.toJSON(),
                from: this.from,
                to: this.to
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.from || "number" != typeof t.to)
                throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
            return new Ne(t.from, t.to, e.markFromJSON(t.mark))
        }
    }
    xe.jsonID("removeMark", Ne);
    class _e extends xe {
        constructor(e, t) {
            super(),
                this.pos = e,
                this.mark = t
        }
        apply(e) {
            let t = e.nodeAt(this.pos);
            if (!t)
                return Ee.fail("No node at mark step's position");
            let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
            return Ee.fromReplace(e, this.pos, this.pos + 1, new g(d.from(n), 0, t.isLeaf ? 0 : 1))
        }
        invert(e) {
            let t = e.nodeAt(this.pos);
            if (t) {
                let e = this.mark.addToSet(t.marks);
                if (e.length == t.marks.length) {
                    for (let n = 0; n < t.marks.length; n++)
                        if (!t.marks[n].isInSet(e))
                            return new _e(this.pos, t.marks[n]);
                    return new _e(this.pos, this.mark)
                }
            }
            return new Oe(this.pos, this.mark)
        }
        map(e) {
            let t = e.mapResult(this.pos, 1);
            return t.deletedAfter ? null : new _e(t.pos, this.mark)
        }
        toJSON() {
            return {
                stepType: "addNodeMark",
                pos: this.pos,
                mark: this.mark.toJSON()
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.pos)
                throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
            return new _e(t.pos, e.markFromJSON(t.mark))
        }
    }
    xe.jsonID("addNodeMark", _e);
    class Oe extends xe {
        constructor(e, t) {
            super(),
                this.pos = e,
                this.mark = t
        }
        apply(e) {
            let t = e.nodeAt(this.pos);
            if (!t)
                return Ee.fail("No node at mark step's position");
            let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
            return Ee.fromReplace(e, this.pos, this.pos + 1, new g(d.from(n), 0, t.isLeaf ? 0 : 1))
        }
        invert(e) {
            let t = e.nodeAt(this.pos);
            return t && this.mark.isInSet(t.marks) ? new _e(this.pos, this.mark) : this
        }
        map(e) {
            let t = e.mapResult(this.pos, 1);
            return t.deletedAfter ? null : new Oe(t.pos, this.mark)
        }
        toJSON() {
            return {
                stepType: "removeNodeMark",
                pos: this.pos,
                mark: this.mark.toJSON()
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.pos)
                throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
            return new Oe(t.pos, e.markFromJSON(t.mark))
        }
    }
    xe.jsonID("removeNodeMark", Oe);
    class Ae extends xe {
        constructor(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            super(),
                this.from = e,
                this.to = t,
                this.slice = n,
                this.structure = r
        }
        apply(e) {
            return this.structure && Le(e, this.from, this.to) ? Ee.fail("Structure replace would overwrite content") : Ee.fromReplace(e, this.from, this.to, this.slice)
        }
        getMap() {
            return new ke([this.from, this.to - this.from, this.slice.size])
        }
        invert(e) {
            return new Ae(this.from, this.from + this.slice.size, e.slice(this.from, this.to))
        }
        map(e) {
            let t = e.mapResult(this.from, 1)
                , n = e.mapResult(this.to, -1);
            return t.deletedAcross && n.deletedAcross ? null : new Ae(t.pos, Math.max(t.pos, n.pos), this.slice)
        }
        merge(e) {
            if (!(e instanceof Ae) || e.structure || this.structure)
                return null;
            if (this.from + this.slice.size != e.from || this.slice.openEnd || e.slice.openStart) {
                if (e.to != this.from || this.slice.openStart || e.slice.openEnd)
                    return null;
                {
                    let t = this.slice.size + e.slice.size == 0 ? g.empty : new g(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
                    return new Ae(e.from, this.to, t, this.structure)
                }
            }
            {
                let t = this.slice.size + e.slice.size == 0 ? g.empty : new g(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
                return new Ae(this.from, this.to + (e.to - e.from), t, this.structure)
            }
        }
        toJSON() {
            let e = {
                stepType: "replace",
                from: this.from,
                to: this.to
            };
            return this.slice.size && (e.slice = this.slice.toJSON()),
                this.structure && (e.structure = !0),
                e
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.from || "number" != typeof t.to)
                throw new RangeError("Invalid input for ReplaceStep.fromJSON");
            return new Ae(t.from, t.to, g.fromJSON(e, t.slice), !!t.structure)
        }
    }
    xe.jsonID("replace", Ae);
    class Pe extends xe {
        constructor(e, t, n, r, o, i) {
            let s = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
            super(),
                this.from = e,
                this.to = t,
                this.gapFrom = n,
                this.gapTo = r,
                this.slice = o,
                this.insert = i,
                this.structure = s
        }
        apply(e) {
            if (this.structure && (Le(e, this.from, this.gapFrom) || Le(e, this.gapTo, this.to)))
                return Ee.fail("Structure gap-replace would overwrite content");
            let t = e.slice(this.gapFrom, this.gapTo);
            if (t.openStart || t.openEnd)
                return Ee.fail("Gap is not a flat range");
            let n = this.slice.insertAt(this.insert, t.content);
            return n ? Ee.fromReplace(e, this.from, this.to, n) : Ee.fail("Content does not fit in gap")
        }
        getMap() {
            return new ke([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
        }
        invert(e) {
            let t = this.gapTo - this.gapFrom;
            return new Pe(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure)
        }
        map(e) {
            let t = e.mapResult(this.from, 1)
                , n = e.mapResult(this.to, -1)
                , r = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1)
                , o = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1);
            return t.deletedAcross && n.deletedAcross || r < t.pos || o > n.pos ? null : new Pe(t.pos, n.pos, r, o, this.slice, this.insert, this.structure)
        }
        toJSON() {
            let e = {
                stepType: "replaceAround",
                from: this.from,
                to: this.to,
                gapFrom: this.gapFrom,
                gapTo: this.gapTo,
                insert: this.insert
            };
            return this.slice.size && (e.slice = this.slice.toJSON()),
                this.structure && (e.structure = !0),
                e
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.from || "number" != typeof t.to || "number" != typeof t.gapFrom || "number" != typeof t.gapTo || "number" != typeof t.insert)
                throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
            return new Pe(t.from, t.to, t.gapFrom, t.gapTo, g.fromJSON(e, t.slice), t.insert, !!t.structure)
        }
    }
    function Le(e, t, n) {
        let r = e.resolve(t)
            , o = n - t
            , i = r.depth;
        for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount;)
            i--,
                o--;
        if (o > 0) {
            let e = r.node(i).maybeChild(r.indexAfter(i));
            for (; o > 0;) {
                if (!e || e.isLeaf)
                    return !0;
                e = e.firstChild,
                    o--
            }
        }
        return !1
    }
    function Re(e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : n.contentMatch
            , o = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
            , i = e.doc.nodeAt(t)
            , s = []
            , a = t + 1;
        for (let l = 0; l < i.childCount; l++) {
            let t = i.child(l)
                , c = a + t.nodeSize
                , u = r.matchType(t.type);
            if (u) {
                r = u;
                for (let r = 0; r < t.marks.length; r++)
                    n.allowsMarkType(t.marks[r].type) || e.step(new Ne(a, c, t.marks[r]));
                if (o && t.isText && "pre" != n.whitespace) {
                    let e, r, o = /\r?\n|\r/g;
                    for (; e = o.exec(t.text);)
                        r || (r = new g(d.from(n.schema.text(" ", n.allowedMarks(t.marks))), 0, 0)),
                            s.push(new Ae(a + e.index, a + e.index + e[0].length, r))
                }
            } else
                s.push(new Ae(a, c, g.empty));
            a = c
        }
        if (!r.validEnd) {
            let t = r.fillBefore(d.empty, !0);
            e.replace(a, a, new g(t, 0, 0))
        }
        for (let l = s.length - 1; l >= 0; l--)
            e.step(s[l])
    }
    function De(e, t, n) {
        return (0 == t || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n))
    }
    function Ie(e) {
        let t = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
        for (let n = e.depth; ; --n) {
            let r = e.$from.node(n)
                , o = e.$from.index(n)
                , i = e.$to.indexAfter(n);
            if (n < e.depth && r.canReplace(o, i, t))
                return n;
            if (0 == n || r.type.spec.isolating || !De(r, o, i))
                break
        }
        return null
    }
    function je(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
            , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e
            , o = function (e, t) {
                let { parent: n, startIndex: r, endIndex: o } = e
                    , i = n.contentMatchAt(r).findWrapping(t);
                if (!i)
                    return null;
                let s = i.length ? i[0] : t;
                return n.canReplaceWith(r, o, s) ? i : null
            }(e, t)
            , i = o && function (e, t) {
                let { parent: n, startIndex: r, endIndex: o } = e
                    , i = n.child(r)
                    , s = t.contentMatch.findWrapping(i.type);
                if (!s)
                    return null;
                let a = (s.length ? s[s.length - 1] : t).contentMatch;
                for (let l = r; a && l < o; l++)
                    a = a.matchType(n.child(l).type);
                return a && a.validEnd ? s : null
            }(r, t);
        return i ? o.map(He).concat({
            type: t,
            attrs: n
        }).concat(i.map(He)) : null
    }
    function He(e) {
        return {
            type: e,
            attrs: null
        }
    }
    function ze(e, t, n, r) {
        t.forEach(((o, i) => {
            if (o.isText) {
                let s, a = /\r?\n|\r/g;
                for (; s = a.exec(o.text);) {
                    let o = e.mapping.slice(r).map(n + 1 + i + s.index);
                    e.replaceWith(o, o + 1, t.type.schema.linebreakReplacement.create())
                }
            }
        }
        ))
    }
    function $e(e, t, n, r) {
        t.forEach(((o, i) => {
            if (o.type == o.type.schema.linebreakReplacement) {
                let o = e.mapping.slice(r).map(n + 1 + i);
                e.replaceWith(o, o + 1, t.type.schema.text("\n"))
            }
        }
        ))
    }
    function Be(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
            , r = arguments.length > 3 ? arguments[3] : void 0
            , o = e.resolve(t)
            , i = o.depth - n
            , s = r && r[r.length - 1] || o.parent;
        if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
            return !1;
        for (let c = o.depth - 1, d = n - 2; c > i; c--,
            d--) {
            let e = o.node(c)
                , t = o.index(c);
            if (e.type.spec.isolating)
                return !1;
            let n = e.content.cutByIndex(t, e.childCount)
                , i = r && r[d + 1];
            i && (n = n.replaceChild(0, i.type.create(i.attrs)));
            let s = r && r[d] || e;
            if (!e.canReplace(t + 1, e.childCount) || !s.type.validContent(n))
                return !1
        }
        let a = o.indexAfter(i)
            , l = r && r[0];
        return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type)
    }
    function Ve(e, t) {
        let n = e.resolve(t)
            , r = n.index();
        return Fe(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
    }
    function Fe(e, t) {
        return !(!e || !t || e.isLeaf || !function (e, t) {
            t.content.size || e.type.compatibleContent(t.type);
            let n = e.contentMatchAt(e.childCount)
                , { linebreakReplacement: r } = e.type.schema;
            for (let o = 0; o < t.childCount; o++) {
                let i = t.child(o)
                    , s = i.type == r ? e.type.schema.nodes.text : i.type;
                if (n = n.matchType(s),
                    !n)
                    return !1;
                if (!e.type.allowsMarks(i.marks))
                    return !1
            }
            return n.validEnd
        }(e, t))
    }
    function Ue(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1
            , r = e.resolve(t);
        for (let o = r.depth; ; o--) {
            let e, i, s = r.index(o);
            if (o == r.depth ? (e = r.nodeBefore,
                i = r.nodeAfter) : n > 0 ? (e = r.node(o + 1),
                    s++,
                    i = r.node(o).maybeChild(s)) : (e = r.node(o).maybeChild(s - 1),
                        i = r.node(o + 1)),
                e && !e.isTextblock && Fe(e, i) && r.node(o).canReplace(s, s + 1))
                return t;
            if (0 == o)
                break;
            t = n < 0 ? r.before(o) : r.after(o)
        }
    }
    function We(e, t, n) {
        let r = e.resolve(t);
        if (!n.content.size)
            return t;
        let o = n.content;
        for (let i = 0; i < n.openStart; i++)
            o = o.firstChild.content;
        for (let i = 1; i <= (0 == n.openStart && n.size ? 2 : 1); i++)
            for (let e = r.depth; e >= 0; e--) {
                let t = e == r.depth ? 0 : r.pos <= (r.start(e + 1) + r.end(e + 1)) / 2 ? -1 : 1
                    , n = r.index(e) + (t > 0 ? 1 : 0)
                    , s = r.node(e)
                    , a = !1;
                if (1 == i)
                    a = s.canReplace(n, n, o);
                else {
                    let e = s.contentMatchAt(n).findWrapping(o.firstChild.type);
                    a = e && s.canReplaceWith(n, n, e[0])
                }
                if (a)
                    return 0 == t ? r.pos : t < 0 ? r.before(e + 1) : r.after(e + 1)
            }
        return null
    }
    function qe(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t
            , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : g.empty;
        if (t == n && !r.size)
            return null;
        let o = e.resolve(t)
            , i = e.resolve(n);
        return Ge(o, i, r) ? new Ae(t, n, r) : new Ke(o, i, r).fit()
    }
    function Ge(e, t, n) {
        return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content)
    }
    xe.jsonID("replaceAround", Pe);
    class Ke {
        constructor(e, t, n) {
            this.$from = e,
                this.$to = t,
                this.unplaced = n,
                this.frontier = [],
                this.placed = d.empty;
            for (let r = 0; r <= e.depth; r++) {
                let t = e.node(r);
                this.frontier.push({
                    type: t.type,
                    match: t.contentMatchAt(e.indexAfter(r))
                })
            }
            for (let r = e.depth; r > 0; r--)
                this.placed = d.from(e.node(r).copy(this.placed))
        }
        get depth() {
            return this.frontier.length - 1
        }
        fit() {
            for (; this.unplaced.size;) {
                let e = this.findFittable();
                e ? this.placeNodes(e) : this.openMore() || this.dropNode()
            }
            let e = this.mustMoveInline()
                , t = this.placed.size - this.depth - this.$from.depth
                , n = this.$from
                , r = this.close(e < 0 ? this.$to : n.doc.resolve(e));
            if (!r)
                return null;
            let o = this.placed
                , i = n.depth
                , s = r.depth;
            for (; i && s && 1 == o.childCount;)
                o = o.firstChild.content,
                    i--,
                    s--;
            let a = new g(o, i, s);
            return e > -1 ? new Pe(n.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || n.pos != this.$to.pos ? new Ae(n.pos, r.pos, a) : null
        }
        findFittable() {
            let e = this.unplaced.openStart;
            for (let t = this.unplaced.content, n = 0, r = this.unplaced.openEnd; n < e; n++) {
                let o = t.firstChild;
                if (t.childCount > 1 && (r = 0),
                    o.type.spec.isolating && r <= n) {
                    e = n;
                    break
                }
                t = o.content
            }
            for (let t = 1; t <= 2; t++)
                for (let n = 1 == t ? e : this.unplaced.openStart; n >= 0; n--) {
                    let e, r = null;
                    n ? (r = Xe(this.unplaced.content, n - 1).firstChild,
                        e = r.content) : e = this.unplaced.content;
                    let o = e.firstChild;
                    for (let i = this.depth; i >= 0; i--) {
                        let e, { type: s, match: a } = this.frontier[i], l = null;
                        if (1 == t && (o ? a.matchType(o.type) || (l = a.fillBefore(d.from(o), !1)) : r && s.compatibleContent(r.type)))
                            return {
                                sliceDepth: n,
                                frontierDepth: i,
                                parent: r,
                                inject: l
                            };
                        if (2 == t && o && (e = a.findWrapping(o.type)))
                            return {
                                sliceDepth: n,
                                frontierDepth: i,
                                parent: r,
                                wrap: e
                            };
                        if (r && a.matchType(r.type))
                            break
                    }
                }
        }
        openMore() {
            let { content: e, openStart: t, openEnd: n } = this.unplaced
                , r = Xe(e, t);
            return !(!r.childCount || r.firstChild.isLeaf) && (this.unplaced = new g(e, t + 1, Math.max(n, r.size + t >= e.size - n ? t + 1 : 0)),
                !0)
        }
        dropNode() {
            let { content: e, openStart: t, openEnd: n } = this.unplaced
                , r = Xe(e, t);
            if (r.childCount <= 1 && t > 0) {
                let o = e.size - t <= t + r.size;
                this.unplaced = new g(Je(e, t - 1, 1), t - 1, o ? t - 1 : n)
            } else
                this.unplaced = new g(Je(e, t, 1), t, n)
        }
        placeNodes(e) {
            let { sliceDepth: t, frontierDepth: n, parent: r, inject: o, wrap: i } = e;
            for (; this.depth > n;)
                this.closeFrontierNode();
            if (i)
                for (let d = 0; d < i.length; d++)
                    this.openFrontierNode(i[d]);
            let s = this.unplaced
                , a = r ? r.content : s.content
                , l = s.openStart - t
                , c = 0
                , u = []
                , { match: h, type: p } = this.frontier[n];
            if (o) {
                for (let e = 0; e < o.childCount; e++)
                    u.push(o.child(e));
                h = h.matchFragment(o)
            }
            let f = a.size + t - (s.content.size - s.openEnd);
            for (; c < a.childCount;) {
                let e = a.child(c)
                    , t = h.matchType(e.type);
                if (!t)
                    break;
                c++,
                    (c > 1 || 0 == l || e.content.size) && (h = t,
                        u.push(Qe(e.mark(p.allowedMarks(e.marks)), 1 == c ? l : 0, c == a.childCount ? f : -1)))
            }
            let m = c == a.childCount;
            m || (f = -1),
                this.placed = Ze(this.placed, n, d.from(u)),
                this.frontier[n].match = h,
                m && f < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
            for (let d = 0, g = a; d < f; d++) {
                let e = g.lastChild;
                this.frontier.push({
                    type: e.type,
                    match: e.contentMatchAt(e.childCount)
                }),
                    g = e.content
            }
            this.unplaced = m ? 0 == t ? g.empty : new g(Je(s.content, t - 1, 1), t - 1, f < 0 ? s.openEnd : t - 1) : new g(Je(s.content, t, c), s.openStart, s.openEnd)
        }
        mustMoveInline() {
            if (!this.$to.parent.isTextblock)
                return -1;
            let e, t = this.frontier[this.depth];
            if (!t.type.isTextblock || !Ye(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (e = this.findCloseLevel(this.$to)) && e.depth == this.depth)
                return -1;
            let { depth: n } = this.$to
                , r = this.$to.after(n);
            for (; n > 1 && r == this.$to.end(--n);)
                ++r;
            return r
        }
        findCloseLevel(e) {
            e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
                let { match: n, type: r } = this.frontier[t]
                    , o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1))
                    , i = Ye(e, t, r, n, o);
                if (i) {
                    for (let n = t - 1; n >= 0; n--) {
                        let { match: t, type: r } = this.frontier[n]
                            , o = Ye(e, n, r, t, !0);
                        if (!o || o.childCount)
                            continue e
                    }
                    return {
                        depth: t,
                        fit: i,
                        move: o ? e.doc.resolve(e.after(t + 1)) : e
                    }
                }
            }
        }
        close(e) {
            let t = this.findCloseLevel(e);
            if (!t)
                return null;
            for (; this.depth > t.depth;)
                this.closeFrontierNode();
            t.fit.childCount && (this.placed = Ze(this.placed, t.depth, t.fit)),
                e = t.move;
            for (let n = t.depth + 1; n <= e.depth; n++) {
                let t = e.node(n)
                    , r = t.type.contentMatch.fillBefore(t.content, !0, e.index(n));
                this.openFrontierNode(t.type, t.attrs, r)
            }
            return e
        }
        openFrontierNode(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                , n = arguments.length > 2 ? arguments[2] : void 0
                , r = this.frontier[this.depth];
            r.match = r.match.matchType(e),
                this.placed = Ze(this.placed, this.depth, d.from(e.create(t, n))),
                this.frontier.push({
                    type: e,
                    match: e.contentMatch
                })
        }
        closeFrontierNode() {
            let e = this.frontier.pop().match.fillBefore(d.empty, !0);
            e.childCount && (this.placed = Ze(this.placed, this.frontier.length, e))
        }
    }
    function Je(e, t, n) {
        return 0 == t ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(Je(e.firstChild.content, t - 1, n)))
    }
    function Ze(e, t, n) {
        return 0 == t ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(Ze(e.lastChild.content, t - 1, n)))
    }
    function Xe(e, t) {
        for (let n = 0; n < t; n++)
            e = e.firstChild.content;
        return e
    }
    function Qe(e, t, n) {
        if (t <= 0)
            return e;
        let r = e.content;
        return t > 1 && (r = r.replaceChild(0, Qe(r.firstChild, t - 1, 1 == r.childCount ? n - 1 : 0))),
            t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r),
                n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(d.empty, !0)))),
            e.copy(r)
    }
    function Ye(e, t, n, r, o) {
        let i = e.node(t)
            , s = o ? e.indexAfter(t) : e.index(t);
        if (s == i.childCount && !n.compatibleContent(i.type))
            return null;
        let a = r.fillBefore(i.content, !0, s);
        return a && !function (e, t, n) {
            for (let r = n; r < t.childCount; r++)
                if (!e.allowsMarks(t.child(r).marks))
                    return !0;
            return !1
        }(n, i.content, s) ? a : null
    }
    function et(e, t, n, r, o) {
        if (t < n) {
            let o = e.firstChild;
            e = e.replaceChild(0, o.copy(et(o.content, t + 1, n, r, o)))
        }
        if (t > r) {
            let t = o.contentMatchAt(0)
                , n = t.fillBefore(e).append(e);
            e = n.append(t.matchFragment(n).fillBefore(d.empty, !0))
        }
        return e
    }
    function tt(e, t) {
        let n = [];
        for (let r = Math.min(e.depth, t.depth); r >= 0; r--) {
            let o = e.start(r);
            if (o < e.pos - (e.depth - r) || t.end(r) > t.pos + (t.depth - r) || e.node(r).type.spec.isolating || t.node(r).type.spec.isolating)
                break;
            (o == t.start(r) || r == e.depth && r == t.depth && e.parent.inlineContent && t.parent.inlineContent && r && t.start(r - 1) == o - 1) && n.push(r)
        }
        return n
    }
    class nt extends xe {
        constructor(e, t, n) {
            super(),
                this.pos = e,
                this.attr = t,
                this.value = n
        }
        apply(e) {
            let t = e.nodeAt(this.pos);
            if (!t)
                return Ee.fail("No node at attribute step's position");
            let n = Object.create(null);
            for (let o in t.attrs)
                n[o] = t.attrs[o];
            n[this.attr] = this.value;
            let r = t.type.create(n, null, t.marks);
            return Ee.fromReplace(e, this.pos, this.pos + 1, new g(d.from(r), 0, t.isLeaf ? 0 : 1))
        }
        getMap() {
            return ke.empty
        }
        invert(e) {
            return new nt(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr])
        }
        map(e) {
            let t = e.mapResult(this.pos, 1);
            return t.deletedAfter ? null : new nt(t.pos, this.attr, this.value)
        }
        toJSON() {
            return {
                stepType: "attr",
                pos: this.pos,
                attr: this.attr,
                value: this.value
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.pos || "string" != typeof t.attr)
                throw new RangeError("Invalid input for AttrStep.fromJSON");
            return new nt(t.pos, t.attr, t.value)
        }
    }
    xe.jsonID("attr", nt);
    class rt extends xe {
        constructor(e, t) {
            super(),
                this.attr = e,
                this.value = t
        }
        apply(e) {
            let t = Object.create(null);
            for (let r in e.attrs)
                t[r] = e.attrs[r];
            t[this.attr] = this.value;
            let n = e.type.create(t, e.content, e.marks);
            return Ee.ok(n)
        }
        getMap() {
            return ke.empty
        }
        invert(e) {
            return new rt(this.attr, e.attrs[this.attr])
        }
        map(e) {
            return this
        }
        toJSON() {
            return {
                stepType: "docAttr",
                attr: this.attr,
                value: this.value
            }
        }
        static fromJSON(e, t) {
            if ("string" != typeof t.attr)
                throw new RangeError("Invalid input for DocAttrStep.fromJSON");
            return new rt(t.attr, t.value)
        }
    }
    xe.jsonID("docAttr", rt);
    let ot = class extends Error {
    }
        ;
    ot = function e(t) {
        let n = Error.call(this, t);
        return n.__proto__ = e.prototype,
            n
    }
        ,
        (ot.prototype = Object.create(Error.prototype)).constructor = ot,
        ot.prototype.name = "TransformError";
    class it {
        constructor(e) {
            this.doc = e,
                this.steps = [],
                this.docs = [],
                this.mapping = new Ce
        }
        get before() {
            return this.docs.length ? this.docs[0] : this.doc
        }
        step(e) {
            let t = this.maybeStep(e);
            if (t.failed)
                throw new ot(t.failed);
            return this
        }
        maybeStep(e) {
            let t = e.apply(this.doc);
            return t.failed || this.addStep(e, t.doc),
                t
        }
        get docChanged() {
            return this.steps.length > 0
        }
        addStep(e, t) {
            this.docs.push(this.doc),
                this.steps.push(e),
                this.mapping.appendMap(e.getMap()),
                this.doc = t
        }
        replace(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : g.empty
                , r = qe(this.doc, e, t, n);
            return r && this.step(r),
                this
        }
        replaceWith(e, t, n) {
            return this.replace(e, t, new g(d.from(n), 0, 0))
        }
        delete(e, t) {
            return this.replace(e, t, g.empty)
        }
        insert(e, t) {
            return this.replaceWith(e, e, t)
        }
        replaceRange(e, t, n) {
            return function (e, t, n, r) {
                if (!r.size)
                    return e.deleteRange(t, n);
                let o = e.doc.resolve(t)
                    , i = e.doc.resolve(n);
                if (Ge(o, i, r))
                    return e.step(new Ae(t, n, r));
                let s = tt(o, e.doc.resolve(n));
                0 == s[s.length - 1] && s.pop();
                let a = -(o.depth + 1);
                s.unshift(a);
                for (let p = o.depth, f = o.pos - 1; p > 0; p--,
                    f--) {
                    let e = o.node(p).type.spec;
                    if (e.defining || e.definingAsContext || e.isolating)
                        break;
                    s.indexOf(p) > -1 ? a = p : o.before(p) == f && s.splice(1, 0, -p)
                }
                let l = s.indexOf(a)
                    , c = []
                    , d = r.openStart;
                for (let p = r.content, f = 0; ; f++) {
                    let e = p.firstChild;
                    if (c.push(e),
                        f == r.openStart)
                        break;
                    p = e.content
                }
                for (let p = d - 1; p >= 0; p--) {
                    let e = c[p]
                        , t = (u = e.type).spec.defining || u.spec.definingForContent;
                    if (t && !e.sameMarkup(o.node(Math.abs(a) - 1)))
                        d = p;
                    else if (t || !e.type.isTextblock)
                        break
                }
                var u;
                for (let p = r.openStart; p >= 0; p--) {
                    let t = (p + d + 1) % (r.openStart + 1)
                        , a = c[t];
                    if (a)
                        for (let c = 0; c < s.length; c++) {
                            let d = s[(c + l) % s.length]
                                , u = !0;
                            d < 0 && (u = !1,
                                d = -d);
                            let h = o.node(d - 1)
                                , p = o.index(d - 1);
                            if (h.canReplaceWith(p, p, a.type, a.marks))
                                return e.replace(o.before(d), u ? i.after(d) : n, new g(et(r.content, 0, r.openStart, t), t, r.openEnd))
                        }
                }
                let h = e.steps.length;
                for (let p = s.length - 1; p >= 0 && (e.replace(t, n, r),
                    !(e.steps.length > h)); p--) {
                    let e = s[p];
                    e < 0 || (t = o.before(e),
                        n = i.after(e))
                }
            }(this, e, t, n),
                this
        }
        replaceRangeWith(e, t, n) {
            return function (e, t, n, r) {
                if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
                    let o = function (e, t, n) {
                        let r = e.resolve(t);
                        if (r.parent.canReplaceWith(r.index(), r.index(), n))
                            return t;
                        if (0 == r.parentOffset)
                            for (let o = r.depth - 1; o >= 0; o--) {
                                let e = r.index(o);
                                if (r.node(o).canReplaceWith(e, e, n))
                                    return r.before(o + 1);
                                if (e > 0)
                                    return null
                            }
                        if (r.parentOffset == r.parent.content.size)
                            for (let o = r.depth - 1; o >= 0; o--) {
                                let e = r.indexAfter(o);
                                if (r.node(o).canReplaceWith(e, e, n))
                                    return r.after(o + 1);
                                if (e < r.node(o).childCount)
                                    return null
                            }
                        return null
                    }(e.doc, t, r.type);
                    null != o && (t = n = o)
                }
                e.replaceRange(t, n, new g(d.from(r), 0, 0))
            }(this, e, t, n),
                this
        }
        deleteRange(e, t) {
            return function (e, t, n) {
                let r = e.doc.resolve(t)
                    , o = e.doc.resolve(n)
                    , i = tt(r, o);
                for (let s = 0; s < i.length; s++) {
                    let t = i[s]
                        , n = s == i.length - 1;
                    if (n && 0 == t || r.node(t).type.contentMatch.validEnd)
                        return e.delete(r.start(t), o.end(t));
                    if (t > 0 && (n || r.node(t - 1).canReplace(r.index(t - 1), o.indexAfter(t - 1))))
                        return e.delete(r.before(t), o.after(t))
                }
                for (let s = 1; s <= r.depth && s <= o.depth; s++)
                    if (t - r.start(s) == r.depth - s && n > r.end(s) && o.end(s) - n != o.depth - s && r.start(s - 1) == o.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1)))
                        return e.delete(r.before(s), n);
                e.delete(t, n)
            }(this, e, t),
                this
        }
        lift(e, t) {
            return function (e, t, n) {
                let { $from: r, $to: o, depth: i } = t
                    , s = r.before(i + 1)
                    , a = o.after(i + 1)
                    , l = s
                    , c = a
                    , u = d.empty
                    , h = 0;
                for (let m = i, g = !1; m > n; m--)
                    g || r.index(m) > 0 ? (g = !0,
                        u = d.from(r.node(m).copy(u)),
                        h++) : l--;
                let p = d.empty
                    , f = 0;
                for (let m = i, g = !1; m > n; m--)
                    g || o.after(m + 1) < o.end(m) ? (g = !0,
                        p = d.from(o.node(m).copy(p)),
                        f++) : c++;
                e.step(new Pe(l, c, s, a, new g(u.append(p), h, f), u.size - h, !0))
            }(this, e, t),
                this
        }
        join(e) {
            return function (e, t, n) {
                let r = null
                    , { linebreakReplacement: o } = e.doc.type.schema
                    , i = e.doc.resolve(t - n)
                    , s = i.node().type;
                if (o && s.inlineContent) {
                    let e = "pre" == s.whitespace
                        , t = !!s.contentMatch.matchType(o);
                    e && !t ? r = !1 : !e && t && (r = !0)
                }
                let a = e.steps.length;
                if (!1 === r) {
                    let r = e.doc.resolve(t + n);
                    $e(e, r.node(), r.before(), a)
                }
                s.inlineContent && Re(e, t + n - 1, s, i.node().contentMatchAt(i.index()), null == r);
                let l = e.mapping.slice(a)
                    , c = l.map(t - n);
                if (e.step(new Ae(c, l.map(t + n, -1), g.empty, !0)),
                    !0 === r) {
                    let t = e.doc.resolve(c);
                    ze(e, t.node(), t.before(), e.steps.length)
                }
            }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1),
                this
        }
        wrap(e, t) {
            return function (e, t, n) {
                let r = d.empty;
                for (let s = n.length - 1; s >= 0; s--) {
                    if (r.size) {
                        let e = n[s].type.contentMatch.matchFragment(r);
                        if (!e || !e.validEnd)
                            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
                    }
                    r = d.from(n[s].type.create(n[s].attrs, r))
                }
                let o = t.start
                    , i = t.end;
                e.step(new Pe(o, i, o, i, new g(r, 0, 0), n.length, !0))
            }(this, e, t),
                this
        }
        setBlockType(e) {
            return function (e, t, n, r, o) {
                if (!r.isTextblock)
                    throw new RangeError("Type given to setBlockType should be a textblock");
                let i = e.steps.length;
                e.doc.nodesBetween(t, n, ((t, n) => {
                    let s = "function" == typeof o ? o(t) : o;
                    if (t.isTextblock && !t.hasMarkup(r, s) && function (e, t, n) {
                        let r = e.resolve(t)
                            , o = r.index();
                        return r.parent.canReplaceWith(o, o + 1, n)
                    }(e.doc, e.mapping.slice(i).map(n), r)) {
                        let o = null;
                        if (r.schema.linebreakReplacement) {
                            let e = "pre" == r.whitespace
                                , t = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                            e && !t ? o = !1 : !e && t && (o = !0)
                        }
                        !1 === o && $e(e, t, n, i),
                            Re(e, e.mapping.slice(i).map(n, 1), r, void 0, null === o);
                        let a = e.mapping.slice(i)
                            , l = a.map(n, 1)
                            , c = a.map(n + t.nodeSize, 1);
                        return e.step(new Pe(l, c, l + 1, c - 1, new g(d.from(r.create(s, null, t.marks)), 0, 0), 1, !0)),
                            !0 === o && ze(e, t, n, i),
                            !1
                    }
                }
                ))
            }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e, arguments.length > 2 ? arguments[2] : void 0, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null),
                this
        }
        setNodeMarkup(e, t) {
            return function (e, t, n, r, o) {
                let i = e.doc.nodeAt(t);
                if (!i)
                    throw new RangeError("No node at given position");
                n || (n = i.type);
                let s = n.create(r, null, o || i.marks);
                if (i.isLeaf)
                    return e.replaceWith(t, t + i.nodeSize, s);
                if (!n.validContent(i.content))
                    throw new RangeError("Invalid content for node type " + n.name);
                e.step(new Pe(t, t + i.nodeSize, t + 1, t + i.nodeSize - 1, new g(d.from(s), 0, 0), 1, !0))
            }(this, e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, arguments.length > 3 ? arguments[3] : void 0),
                this
        }
        setNodeAttribute(e, t, n) {
            return this.step(new nt(e, t, n)),
                this
        }
        setDocAttribute(e, t) {
            return this.step(new rt(e, t)),
                this
        }
        addNodeMark(e, t) {
            return this.step(new _e(e, t)),
                this
        }
        removeNodeMark(e, t) {
            if (!(t instanceof f)) {
                let n = this.doc.nodeAt(e);
                if (!n)
                    throw new RangeError("No node at position " + e);
                if (!(t = t.isInSet(n.marks)))
                    return this
            }
            return this.step(new Oe(e, t)),
                this
        }
        split(e) {
            return function (e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                    , r = arguments.length > 3 ? arguments[3] : void 0
                    , o = e.doc.resolve(t)
                    , i = d.empty
                    , s = d.empty;
                for (let a = o.depth, l = o.depth - n, c = n - 1; a > l; a--,
                    c--) {
                    i = d.from(o.node(a).copy(i));
                    let e = r && r[c];
                    s = d.from(e ? e.type.create(e.attrs, s) : o.node(a).copy(s))
                }
                e.step(new Ae(t, t, new g(i.append(s), n, n), !0))
            }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 ? arguments[2] : void 0),
                this
        }
        addMark(e, t, n) {
            return function (e, t, n, r) {
                let o, i, s = [], a = [];
                e.doc.nodesBetween(t, n, ((e, l, c) => {
                    if (!e.isInline)
                        return;
                    let d = e.marks;
                    if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
                        let c = Math.max(l, t)
                            , u = Math.min(l + e.nodeSize, n)
                            , h = r.addToSet(d);
                        for (let e = 0; e < d.length; e++)
                            d[e].isInSet(h) || (o && o.to == c && o.mark.eq(d[e]) ? o.to = u : s.push(o = new Ne(c, u, d[e])));
                        i && i.to == c ? i.to = u : a.push(i = new Te(c, u, r))
                    }
                }
                )),
                    s.forEach((t => e.step(t))),
                    a.forEach((t => e.step(t)))
            }(this, e, t, n),
                this
        }
        removeMark(e, t, n) {
            return function (e, t, n, r) {
                let o = []
                    , i = 0;
                e.doc.nodesBetween(t, n, ((e, s) => {
                    if (!e.isInline)
                        return;
                    i++;
                    let a = null;
                    if (r instanceof Q) {
                        let t, n = e.marks;
                        for (; t = r.isInSet(n);)
                            (a || (a = [])).push(t),
                                n = t.removeFromSet(n)
                    } else
                        r ? r.isInSet(e.marks) && (a = [r]) : a = e.marks;
                    if (a && a.length) {
                        let r = Math.min(s + e.nodeSize, n);
                        for (let e = 0; e < a.length; e++) {
                            let n, l = a[e];
                            for (let e = 0; e < o.length; e++) {
                                let t = o[e];
                                t.step == i - 1 && l.eq(o[e].style) && (n = t)
                            }
                            n ? (n.to = r,
                                n.step = i) : o.push({
                                    style: l,
                                    from: Math.max(s, t),
                                    to: r,
                                    step: i
                                })
                        }
                    }
                }
                )),
                    o.forEach((t => e.step(new Ne(t.from, t.to, t.style))))
            }(this, e, t, n),
                this
        }
        clearIncompatible(e, t, n) {
            return Re(this, e, t, n),
                this
        }
    }
    const st = Object.create(null);
    class at {
        constructor(e, t, n) {
            this.$anchor = e,
                this.$head = t,
                this.ranges = n || [new lt(e.min(t), e.max(t))]
        }
        get anchor() {
            return this.$anchor.pos
        }
        get head() {
            return this.$head.pos
        }
        get from() {
            return this.$from.pos
        }
        get to() {
            return this.$to.pos
        }
        get $from() {
            return this.ranges[0].$from
        }
        get $to() {
            return this.ranges[0].$to
        }
        get empty() {
            let e = this.ranges;
            for (let t = 0; t < e.length; t++)
                if (e[t].$from.pos != e[t].$to.pos)
                    return !1;
            return !0
        }
        content() {
            return this.$from.doc.slice(this.from, this.to, !0)
        }
        replace(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.empty
                , n = t.content.lastChild
                , r = null;
            for (let s = 0; s < t.openEnd; s++)
                r = n,
                    n = n.lastChild;
            let o = e.steps.length
                , i = this.ranges;
            for (let s = 0; s < i.length; s++) {
                let { $from: a, $to: l } = i[s]
                    , c = e.mapping.slice(o);
                e.replaceRange(c.map(a.pos), c.map(l.pos), s ? g.empty : t),
                    0 == s && yt(e, o, (n ? n.isInline : r && r.isTextblock) ? -1 : 1)
            }
        }
        replaceWith(e, t) {
            let n = e.steps.length
                , r = this.ranges;
            for (let o = 0; o < r.length; o++) {
                let { $from: i, $to: s } = r[o]
                    , a = e.mapping.slice(n)
                    , l = a.map(i.pos)
                    , c = a.map(s.pos);
                o ? e.deleteRange(l, c) : (e.replaceRangeWith(l, c, t),
                    yt(e, n, t.isInline ? -1 : 1))
            }
        }
        static findFrom(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                , r = e.parent.inlineContent ? new ut(e) : bt(e.node(0), e.parent, e.pos, e.index(), t, n);
            if (r)
                return r;
            for (let o = e.depth - 1; o >= 0; o--) {
                let r = t < 0 ? bt(e.node(0), e.node(o), e.before(o + 1), e.index(o), t, n) : bt(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, t, n);
                if (r)
                    return r
            }
            return null
        }
        static near(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return this.findFrom(e, t) || this.findFrom(e, -t) || new mt(e.node(0))
        }
        static atStart(e) {
            return bt(e, e, 0, 0, 1) || new mt(e)
        }
        static atEnd(e) {
            return bt(e, e, e.content.size, e.childCount, -1) || new mt(e)
        }
        static fromJSON(e, t) {
            if (!t || !t.type)
                throw new RangeError("Invalid input for Selection.fromJSON");
            let n = st[t.type];
            if (!n)
                throw new RangeError(`No selection type ${t.type} defined`);
            return n.fromJSON(e, t)
        }
        static jsonID(e, t) {
            if (e in st)
                throw new RangeError("Duplicate use of selection JSON ID " + e);
            return st[e] = t,
                t.prototype.jsonID = e,
                t
        }
        getBookmark() {
            return ut.between(this.$anchor, this.$head).getBookmark()
        }
    }
    at.prototype.visible = !0;
    class lt {
        constructor(e, t) {
            this.$from = e,
                this.$to = t
        }
    }
    let ct = !1;
    function dt(e) {
        ct || e.parent.inlineContent || (ct = !0,
            console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"))
    }
    class ut extends at {
        constructor(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e;
            dt(e),
                dt(t),
                super(e, t)
        }
        get $cursor() {
            return this.$anchor.pos == this.$head.pos ? this.$head : null
        }
        map(e, t) {
            let n = e.resolve(t.map(this.head));
            if (!n.parent.inlineContent)
                return at.near(n);
            let r = e.resolve(t.map(this.anchor));
            return new ut(r.parent.inlineContent ? r : n, n)
        }
        replace(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.empty;
            if (super.replace(e, t),
                t == g.empty) {
                let t = this.$from.marksAcross(this.$to);
                t && e.ensureMarks(t)
            }
        }
        eq(e) {
            return e instanceof ut && e.anchor == this.anchor && e.head == this.head
        }
        getBookmark() {
            return new ht(this.anchor, this.head)
        }
        toJSON() {
            return {
                type: "text",
                anchor: this.anchor,
                head: this.head
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.anchor || "number" != typeof t.head)
                throw new RangeError("Invalid input for TextSelection.fromJSON");
            return new ut(e.resolve(t.anchor), e.resolve(t.head))
        }
        static create(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t
                , r = e.resolve(t);
            return new this(r, n == t ? r : e.resolve(n))
        }
        static between(e, t, n) {
            let r = e.pos - t.pos;
            if (n && !r || (n = r >= 0 ? 1 : -1),
                !t.parent.inlineContent) {
                let e = at.findFrom(t, n, !0) || at.findFrom(t, -n, !0);
                if (!e)
                    return at.near(t, n);
                t = e.$head
            }
            return e.parent.inlineContent || (0 == r || (e = (at.findFrom(e, -n, !0) || at.findFrom(e, n, !0)).$anchor).pos < t.pos != r < 0) && (e = t),
                new ut(e, t)
        }
    }
    at.jsonID("text", ut);
    class ht {
        constructor(e, t) {
            this.anchor = e,
                this.head = t
        }
        map(e) {
            return new ht(e.map(this.anchor), e.map(this.head))
        }
        resolve(e) {
            return ut.between(e.resolve(this.anchor), e.resolve(this.head))
        }
    }
    class pt extends at {
        constructor(e) {
            let t = e.nodeAfter
                , n = e.node(0).resolve(e.pos + t.nodeSize);
            super(e, n),
                this.node = t
        }
        map(e, t) {
            let { deleted: n, pos: r } = t.mapResult(this.anchor)
                , o = e.resolve(r);
            return n ? at.near(o) : new pt(o)
        }
        content() {
            return new g(d.from(this.node), 0, 0)
        }
        eq(e) {
            return e instanceof pt && e.anchor == this.anchor
        }
        toJSON() {
            return {
                type: "node",
                anchor: this.anchor
            }
        }
        getBookmark() {
            return new ft(this.anchor)
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.anchor)
                throw new RangeError("Invalid input for NodeSelection.fromJSON");
            return new pt(e.resolve(t.anchor))
        }
        static create(e, t) {
            return new pt(e.resolve(t))
        }
        static isSelectable(e) {
            return !e.isText && !1 !== e.type.spec.selectable
        }
    }
    pt.prototype.visible = !1,
        at.jsonID("node", pt);
    class ft {
        constructor(e) {
            this.anchor = e
        }
        map(e) {
            let { deleted: t, pos: n } = e.mapResult(this.anchor);
            return t ? new ht(n, n) : new ft(n)
        }
        resolve(e) {
            let t = e.resolve(this.anchor)
                , n = t.nodeAfter;
            return n && pt.isSelectable(n) ? new pt(t) : at.near(t)
        }
    }
    class mt extends at {
        constructor(e) {
            super(e.resolve(0), e.resolve(e.content.size))
        }
        replace(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.empty;
            if (t == g.empty) {
                e.delete(0, e.doc.content.size);
                let t = at.atStart(e.doc);
                t.eq(e.selection) || e.setSelection(t)
            } else
                super.replace(e, t)
        }
        toJSON() {
            return {
                type: "all"
            }
        }
        static fromJSON(e) {
            return new mt(e)
        }
        map(e) {
            return new mt(e)
        }
        eq(e) {
            return e instanceof mt
        }
        getBookmark() {
            return gt
        }
    }
    at.jsonID("all", mt);
    const gt = {
        map() {
            return this
        },
        resolve: e => new mt(e)
    };
    function bt(e, t, n, r, o) {
        let i = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
        if (t.inlineContent)
            return ut.create(e, n);
        for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < t.childCount : s >= 0; s += o) {
            let r = t.child(s);
            if (r.isAtom) {
                if (!i && pt.isSelectable(r))
                    return pt.create(e, n - (o < 0 ? r.nodeSize : 0))
            } else {
                let t = bt(e, r, n + o, o < 0 ? r.childCount : 0, o, i);
                if (t)
                    return t
            }
            n += r.nodeSize * o
        }
        return null
    }
    function yt(e, t, n) {
        let r = e.steps.length - 1;
        if (r < t)
            return;
        let o, i = e.steps[r];
        (i instanceof Ae || i instanceof Pe) && (e.mapping.maps[r].forEach(((e, t, n, r) => {
            null == o && (o = r)
        }
        )),
            e.setSelection(at.near(e.doc.resolve(o), n)))
    }
    class vt extends it {
        constructor(e) {
            super(e.doc),
                this.curSelectionFor = 0,
                this.updated = 0,
                this.meta = Object.create(null),
                this.time = Date.now(),
                this.curSelection = e.selection,
                this.storedMarks = e.storedMarks
        }
        get selection() {
            return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)),
                this.curSelectionFor = this.steps.length),
                this.curSelection
        }
        setSelection(e) {
            if (e.$from.doc != this.doc)
                throw new RangeError("Selection passed to setSelection must point at the current document");
            return this.curSelection = e,
                this.curSelectionFor = this.steps.length,
                this.updated = -3 & this.updated | 1,
                this.storedMarks = null,
                this
        }
        get selectionSet() {
            return (1 & this.updated) > 0
        }
        setStoredMarks(e) {
            return this.storedMarks = e,
                this.updated |= 2,
                this
        }
        ensureMarks(e) {
            return f.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e),
                this
        }
        addStoredMark(e) {
            return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()))
        }
        removeStoredMark(e) {
            return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()))
        }
        get storedMarksSet() {
            return (2 & this.updated) > 0
        }
        addStep(e, t) {
            super.addStep(e, t),
                this.updated = -3 & this.updated,
                this.storedMarks = null
        }
        setTime(e) {
            return this.time = e,
                this
        }
        replaceSelection(e) {
            return this.selection.replace(this, e),
                this
        }
        replaceSelectionWith(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                , n = this.selection;
            return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || f.none))),
                n.replaceWith(this, e),
                this
        }
        deleteSelection() {
            return this.selection.replace(this),
                this
        }
        insertText(e, t, n) {
            let r = this.doc.type.schema;
            if (null == t)
                return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
            {
                if (null == n && (n = t),
                    n = null == n ? t : n,
                    !e)
                    return this.deleteRange(t, n);
                let o = this.storedMarks;
                if (!o) {
                    let e = this.doc.resolve(t);
                    o = n == t ? e.marks() : e.marksAcross(this.doc.resolve(n))
                }
                return this.replaceRangeWith(t, n, r.text(e, o)),
                    this.selection.empty || this.setSelection(at.near(this.selection.$to)),
                    this
            }
        }
        setMeta(e, t) {
            return this.meta["string" == typeof e ? e : e.key] = t,
                this
        }
        getMeta(e) {
            return this.meta["string" == typeof e ? e : e.key]
        }
        get isGeneric() {
            for (let e in this.meta)
                return !1;
            return !0
        }
        scrollIntoView() {
            return this.updated |= 4,
                this
        }
        get scrolledIntoView() {
            return (4 & this.updated) > 0
        }
    }
    function wt(e, t) {
        return t && e ? e.bind(t) : e
    }
    class kt {
        constructor(e, t, n) {
            this.name = e,
                this.init = wt(t.init, n),
                this.apply = wt(t.apply, n)
        }
    }
    const Ct = [new kt("doc", {
        init: e => e.doc || e.schema.topNodeType.createAndFill(),
        apply: e => e.doc
    }), new kt("selection", {
        init: (e, t) => e.selection || at.atStart(t.doc),
        apply: e => e.selection
    }), new kt("storedMarks", {
        init: e => e.storedMarks || null,
        apply: (e, t, n, r) => r.selection.$cursor ? e.storedMarks : null
    }), new kt("scrollToSelection", {
        init: () => 0,
        apply: (e, t) => e.scrolledIntoView ? t + 1 : t
    })];
    class St {
        constructor(e, t) {
            this.schema = e,
                this.plugins = [],
                this.pluginsByKey = Object.create(null),
                this.fields = Ct.slice(),
                t && t.forEach((e => {
                    if (this.pluginsByKey[e.key])
                        throw new RangeError("Adding different instances of a keyed plugin (" + e.key + ")");
                    this.plugins.push(e),
                        this.pluginsByKey[e.key] = e,
                        e.spec.state && this.fields.push(new kt(e.key, e.spec.state, e))
                }
                ))
        }
    }
    class xt {
        constructor(e) {
            this.config = e
        }
        get schema() {
            return this.config.schema
        }
        get plugins() {
            return this.config.plugins
        }
        apply(e) {
            return this.applyTransaction(e).state
        }
        filterTransaction(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
            for (let n = 0; n < this.config.plugins.length; n++)
                if (n != t) {
                    let t = this.config.plugins[n];
                    if (t.spec.filterTransaction && !t.spec.filterTransaction.call(t, e, this))
                        return !1
                }
            return !0
        }
        applyTransaction(e) {
            if (!this.filterTransaction(e))
                return {
                    state: this,
                    transactions: []
                };
            let t = [e]
                , n = this.applyInner(e)
                , r = null;
            for (; ;) {
                let o = !1;
                for (let i = 0; i < this.config.plugins.length; i++) {
                    let s = this.config.plugins[i];
                    if (s.spec.appendTransaction) {
                        let a = r ? r[i].n : 0
                            , l = r ? r[i].state : this
                            , c = a < t.length && s.spec.appendTransaction.call(s, a ? t.slice(a) : t, l, n);
                        if (c && n.filterTransaction(c, i)) {
                            if (c.setMeta("appendedTransaction", e),
                                !r) {
                                r = [];
                                for (let e = 0; e < this.config.plugins.length; e++)
                                    r.push(e < i ? {
                                        state: n,
                                        n: t.length
                                    } : {
                                        state: this,
                                        n: 0
                                    })
                            }
                            t.push(c),
                                n = n.applyInner(c),
                                o = !0
                        }
                        r && (r[i] = {
                            state: n,
                            n: t.length
                        })
                    }
                }
                if (!o)
                    return {
                        state: n,
                        transactions: t
                    }
            }
        }
        applyInner(e) {
            if (!e.before.eq(this.doc))
                throw new RangeError("Applying a mismatched transaction");
            let t = new xt(this.config)
                , n = this.config.fields;
            for (let r = 0; r < n.length; r++) {
                let o = n[r];
                t[o.name] = o.apply(e, this[o.name], this, t)
            }
            return t
        }
        get tr() {
            return new vt(this)
        }
        static create(e) {
            let t = new St(e.doc ? e.doc.type.schema : e.schema, e.plugins)
                , n = new xt(t);
            for (let r = 0; r < t.fields.length; r++)
                n[t.fields[r].name] = t.fields[r].init(e, n);
            return n
        }
        reconfigure(e) {
            let t = new St(this.schema, e.plugins)
                , n = t.fields
                , r = new xt(t);
            for (let o = 0; o < n.length; o++) {
                let t = n[o].name;
                r[t] = this.hasOwnProperty(t) ? this[t] : n[o].init(e, r)
            }
            return r
        }
        toJSON(e) {
            let t = {
                doc: this.doc.toJSON(),
                selection: this.selection.toJSON()
            };
            if (this.storedMarks && (t.storedMarks = this.storedMarks.map((e => e.toJSON()))),
                e && "object" == typeof e)
                for (let n in e) {
                    if ("doc" == n || "selection" == n)
                        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                    let r = e[n]
                        , o = r.spec.state;
                    o && o.toJSON && (t[n] = o.toJSON.call(r, this[r.key]))
                }
            return t
        }
        static fromJSON(e, t, n) {
            if (!t)
                throw new RangeError("Invalid input for EditorState.fromJSON");
            if (!e.schema)
                throw new RangeError("Required config field 'schema' missing");
            let r = new St(e.schema, e.plugins)
                , o = new xt(r);
            return r.fields.forEach((r => {
                if ("doc" == r.name)
                    o.doc = R.fromJSON(e.schema, t.doc);
                else if ("selection" == r.name)
                    o.selection = at.fromJSON(o.doc, t.selection);
                else if ("storedMarks" == r.name)
                    t.storedMarks && (o.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
                else {
                    if (n)
                        for (let i in n) {
                            let s = n[i]
                                , a = s.spec.state;
                            if (s.key == r.name && a && a.fromJSON && Object.prototype.hasOwnProperty.call(t, i))
                                return void (o[r.name] = a.fromJSON.call(s, e, t[i], o))
                        }
                    o[r.name] = r.init(e, o)
                }
            }
            )),
                o
        }
    }
    function Et(e, t, n) {
        for (let r in e) {
            let o = e[r];
            o instanceof Function ? o = o.bind(t) : "handleDOMEvents" == r && (o = Et(o, t, {})),
                n[r] = o
        }
        return n
    }
    class Mt {
        constructor(e) {
            this.spec = e,
                this.props = {},
                e.props && Et(e.props, this, this.props),
                this.key = e.key ? e.key.key : Nt("plugin")
        }
        getState(e) {
            return e[this.key]
        }
    }
    const Tt = Object.create(null);
    function Nt(e) {
        return e in Tt ? e + "$" + ++Tt[e] : (Tt[e] = 0,
            e + "$")
    }
    class _t {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "key";
            this.key = Nt(e)
        }
        get(e) {
            return e.config.pluginsByKey[this.key]
        }
        getState(e) {
            return e[this.key]
        }
    }
    const Ot = function (e) {
        for (var t = 0; ; t++)
            if (!(e = e.previousSibling))
                return t
    }
        , At = function (e) {
            let t = e.assignedSlot || e.parentNode;
            return t && 11 == t.nodeType ? t.host : t
        };
    let Pt = null;
    const Lt = function (e, t, n) {
        let r = Pt || (Pt = document.createRange());
        return r.setEnd(e, null == n ? e.nodeValue.length : n),
            r.setStart(e, t || 0),
            r
    }
        , Rt = function (e, t, n, r) {
            return n && (It(e, t, n, r, -1) || It(e, t, n, r, 1))
        }
        , Dt = /^(img|br|input|textarea|hr)$/i;
    function It(e, t, n, r, o) {
        for (; ;) {
            if (e == n && t == r)
                return !0;
            if (t == (o < 0 ? 0 : jt(e))) {
                let n = e.parentNode;
                if (!n || 1 != n.nodeType || Ht(e) || Dt.test(e.nodeName) || "false" == e.contentEditable)
                    return !1;
                t = Ot(e) + (o < 0 ? 0 : 1),
                    e = n
            } else {
                if (1 != e.nodeType)
                    return !1;
                if ("false" == (e = e.childNodes[t + (o < 0 ? -1 : 0)]).contentEditable)
                    return !1;
                t = o < 0 ? jt(e) : 0
            }
        }
    }
    function jt(e) {
        return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length
    }
    function Ht(e) {
        let t;
        for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
            ;
        return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e)
    }
    const zt = function (e) {
        return e.focusNode && Rt(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
    };
    function $t(e, t) {
        let n = document.createEvent("Event");
        return n.initEvent("keydown", !0, !0),
            n.keyCode = e,
            n.key = n.code = t,
            n
    }
    const Bt = "undefined" != typeof navigator ? navigator : null
        , Vt = "undefined" != typeof document ? document : null
        , Ft = Bt && Bt.userAgent || ""
        , Ut = /Edge\/(\d+)/.exec(Ft)
        , Wt = /MSIE \d/.exec(Ft)
        , qt = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ft)
        , Gt = !!(Wt || qt || Ut)
        , Kt = Wt ? document.documentMode : qt ? +qt[1] : Ut ? +Ut[1] : 0
        , Jt = !Gt && /gecko\/(\d+)/i.test(Ft);
    Jt && (/Firefox\/(\d+)/.exec(Ft) || [0, 0])[1];
    const Zt = !Gt && /Chrome\/(\d+)/.exec(Ft)
        , Xt = !!Zt
        , Qt = Zt ? +Zt[1] : 0
        , Yt = !Gt && !!Bt && /Apple Computer/.test(Bt.vendor)
        , en = Yt && (/Mobile\/\w+/.test(Ft) || !!Bt && Bt.maxTouchPoints > 2)
        , tn = en || !!Bt && /Mac/.test(Bt.platform)
        , nn = !!Bt && /Win/.test(Bt.platform)
        , rn = /Android \d/.test(Ft)
        , on = !!Vt && "webkitFontSmoothing" in Vt.documentElement.style
        , sn = on ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function an(e) {
        let t = e.defaultView && e.defaultView.visualViewport;
        return t ? {
            left: 0,
            right: t.width,
            top: 0,
            bottom: t.height
        } : {
            left: 0,
            right: e.documentElement.clientWidth,
            top: 0,
            bottom: e.documentElement.clientHeight
        }
    }
    function ln(e, t) {
        return "number" == typeof e ? e : e[t]
    }
    function cn(e) {
        let t = e.getBoundingClientRect()
            , n = t.width / e.offsetWidth || 1
            , r = t.height / e.offsetHeight || 1;
        return {
            left: t.left,
            right: t.left + e.clientWidth * n,
            top: t.top,
            bottom: t.top + e.clientHeight * r
        }
    }
    function dn(e, t, n) {
        let r = e.someProp("scrollThreshold") || 0
            , o = e.someProp("scrollMargin") || 5
            , i = e.dom.ownerDocument;
        for (let s = n || e.dom; s; s = At(s)) {
            if (1 != s.nodeType)
                continue;
            let e = s
                , n = e == i.body
                , a = n ? an(i) : cn(e)
                , l = 0
                , c = 0;
            if (t.top < a.top + ln(r, "top") ? c = -(a.top - t.top + ln(o, "top")) : t.bottom > a.bottom - ln(r, "bottom") && (c = t.bottom - t.top > a.bottom - a.top ? t.top + ln(o, "top") - a.top : t.bottom - a.bottom + ln(o, "bottom")),
                t.left < a.left + ln(r, "left") ? l = -(a.left - t.left + ln(o, "left")) : t.right > a.right - ln(r, "right") && (l = t.right - a.right + ln(o, "right")),
                l || c)
                if (n)
                    i.defaultView.scrollBy(l, c);
                else {
                    let n = e.scrollLeft
                        , r = e.scrollTop;
                    c && (e.scrollTop += c),
                        l && (e.scrollLeft += l);
                    let o = e.scrollLeft - n
                        , i = e.scrollTop - r;
                    t = {
                        left: t.left - o,
                        top: t.top - i,
                        right: t.right - o,
                        bottom: t.bottom - i
                    }
                }
            if (n || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
                break
        }
    }
    function un(e) {
        let t = []
            , n = e.ownerDocument;
        for (let r = e; r && (t.push({
            dom: r,
            top: r.scrollTop,
            left: r.scrollLeft
        }),
            e != n); r = At(r))
            ;
        return t
    }
    function hn(e, t) {
        for (let n = 0; n < e.length; n++) {
            let { dom: r, top: o, left: i } = e[n];
            r.scrollTop != o + t && (r.scrollTop = o + t),
                r.scrollLeft != i && (r.scrollLeft = i)
        }
    }
    let pn = null;
    function fn(e, t) {
        let n, r, o, i, s = 2e8, a = 0, l = t.top, c = t.top;
        for (let d = e.firstChild, u = 0; d; d = d.nextSibling,
            u++) {
            let e;
            if (1 == d.nodeType)
                e = d.getClientRects();
            else {
                if (3 != d.nodeType)
                    continue;
                e = Lt(d).getClientRects()
            }
            for (let h = 0; h < e.length; h++) {
                let p = e[h];
                if (p.top <= l && p.bottom >= c) {
                    l = Math.max(p.bottom, l),
                        c = Math.min(p.top, c);
                    let e = p.left > t.left ? p.left - t.left : p.right < t.left ? t.left - p.right : 0;
                    if (e < s) {
                        n = d,
                            s = e,
                            r = e && 3 == n.nodeType ? {
                                left: p.right < t.left ? p.right : p.left,
                                top: t.top
                            } : t,
                            1 == d.nodeType && e && (a = u + (t.left >= (p.left + p.right) / 2 ? 1 : 0));
                        continue
                    }
                } else
                    p.top > t.top && !o && p.left <= t.left && p.right >= t.left && (o = d,
                        i = {
                            left: Math.max(p.left, Math.min(p.right, t.left)),
                            top: p.top
                        });
                !n && (t.left >= p.right && t.top >= p.top || t.left >= p.left && t.top >= p.bottom) && (a = u + 1)
            }
        }
        return !n && o && (n = o,
            r = i,
            s = 0),
            n && 3 == n.nodeType ? function (e, t) {
                let n = e.nodeValue.length
                    , r = document.createRange();
                for (let o = 0; o < n; o++) {
                    r.setEnd(e, o + 1),
                        r.setStart(e, o);
                    let n = vn(r, 1);
                    if (n.top != n.bottom && mn(t, n))
                        return {
                            node: e,
                            offset: o + (t.left >= (n.left + n.right) / 2 ? 1 : 0)
                        }
                }
                return {
                    node: e,
                    offset: 0
                }
            }(n, r) : !n || s && 1 == n.nodeType ? {
                node: e,
                offset: a
            } : fn(n, r)
    }
    function mn(e, t) {
        return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1
    }
    function gn(e, t, n) {
        let r = e.childNodes.length;
        if (r && n.top < n.bottom)
            for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ;) {
                let n = e.childNodes[i];
                if (1 == n.nodeType) {
                    let e = n.getClientRects();
                    for (let r = 0; r < e.length; r++) {
                        let o = e[r];
                        if (mn(t, o))
                            return gn(n, t, o)
                    }
                }
                if ((i = (i + 1) % r) == o)
                    break
            }
        return e
    }
    function bn(e, t) {
        let n, r = e.dom.ownerDocument, o = 0, i = function (e, t, n) {
            if (e.caretPositionFromPoint)
                try {
                    let r = e.caretPositionFromPoint(t, n);
                    if (r)
                        return {
                            node: r.offsetNode,
                            offset: Math.min(jt(r.offsetNode), r.offset)
                        }
                } catch (uN) { }
            if (e.caretRangeFromPoint) {
                let r = e.caretRangeFromPoint(t, n);
                if (r)
                    return {
                        node: r.startContainer,
                        offset: Math.min(jt(r.startContainer), r.startOffset)
                    }
            }
        }(r, t.left, t.top);
        i && ({ node: n, offset: o } = i);
        let s, a = (e.root.elementFromPoint ? e.root : r).elementFromPoint(t.left, t.top);
        if (!a || !e.dom.contains(1 != a.nodeType ? a.parentNode : a)) {
            let n = e.dom.getBoundingClientRect();
            if (!mn(t, n))
                return null;
            if (a = gn(e.dom, t, n),
                !a)
                return null
        }
        if (Yt)
            for (let c = a; n && c; c = At(c))
                c.draggable && (n = void 0);
        if (a = function (e, t) {
            let n = e.parentNode;
            return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e
        }(a, t),
            n) {
            if (Jt && 1 == n.nodeType && (o = Math.min(o, n.childNodes.length),
                o < n.childNodes.length)) {
                let e, r = n.childNodes[o];
                "IMG" == r.nodeName && (e = r.getBoundingClientRect()).right <= t.left && e.bottom > t.top && o++
            }
            let r;
            on && o && 1 == n.nodeType && 1 == (r = n.childNodes[o - 1]).nodeType && "false" == r.contentEditable && r.getBoundingClientRect().top >= t.top && o--,
                n == e.dom && o == n.childNodes.length - 1 && 1 == n.lastChild.nodeType && t.top > n.lastChild.getBoundingClientRect().bottom ? s = e.state.doc.content.size : 0 != o && 1 == n.nodeType && "BR" == n.childNodes[o - 1].nodeName || (s = function (e, t, n, r) {
                    let o = -1;
                    for (let i = t, s = !1; i != e.dom;) {
                        let t = e.docView.nearestDesc(i, !0);
                        if (!t)
                            return null;
                        if (1 == t.dom.nodeType && (t.node.isBlock && t.parent || !t.contentDOM)) {
                            let e = t.dom.getBoundingClientRect();
                            if (t.node.isBlock && t.parent && (!s && e.left > r.left || e.top > r.top ? o = t.posBefore : (!s && e.right < r.left || e.bottom < r.top) && (o = t.posAfter),
                                s = !0),
                                !t.contentDOM && o < 0 && !t.node.isText)
                                return (t.node.isBlock ? r.top < (e.top + e.bottom) / 2 : r.left < (e.left + e.right) / 2) ? t.posBefore : t.posAfter
                        }
                        i = t.dom.parentNode
                    }
                    return o > -1 ? o : e.docView.posFromDOM(t, n, -1)
                }(e, n, o, t))
        }
        null == s && (s = function (e, t, n) {
            let { node: r, offset: o } = fn(t, n)
                , i = -1;
            if (1 == r.nodeType && !r.firstChild) {
                let e = r.getBoundingClientRect();
                i = e.left != e.right && n.left > (e.left + e.right) / 2 ? 1 : -1
            }
            return e.docView.posFromDOM(r, o, i)
        }(e, a, t));
        let l = e.docView.nearestDesc(a, !0);
        return {
            pos: s,
            inside: l ? l.posAtStart - l.border : -1
        }
    }
    function yn(e) {
        return e.top < e.bottom || e.left < e.right
    }
    function vn(e, t) {
        let n = e.getClientRects();
        if (n.length) {
            let e = n[t < 0 ? 0 : n.length - 1];
            if (yn(e))
                return e
        }
        return Array.prototype.find.call(n, yn) || e.getBoundingClientRect()
    }
    const wn = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function kn(e, t, n) {
        let { node: r, offset: o, atom: i } = e.docView.domFromPos(t, n < 0 ? -1 : 1)
            , s = on || Jt;
        if (3 == r.nodeType) {
            if (!s || !wn.test(r.nodeValue) && (n < 0 ? o : o != r.nodeValue.length)) {
                let e = o
                    , t = o
                    , i = n < 0 ? 1 : -1;
                return n < 0 && !o ? (t++,
                    i = -1) : n >= 0 && o == r.nodeValue.length ? (e--,
                        i = 1) : n < 0 ? e-- : t++,
                    Cn(vn(Lt(r, e, t), i), i < 0)
            }
            {
                let e = vn(Lt(r, o, o), n);
                if (Jt && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
                    let t = vn(Lt(r, o - 1, o - 1), -1);
                    if (t.top == e.top) {
                        let n = vn(Lt(r, o, o + 1), -1);
                        if (n.top != e.top)
                            return Cn(n, n.left < t.left)
                    }
                }
                return e
            }
        }
        if (!e.state.doc.resolve(t - (i || 0)).parent.inlineContent) {
            if (null == i && o && (n < 0 || o == jt(r))) {
                let e = r.childNodes[o - 1];
                if (1 == e.nodeType)
                    return Sn(e.getBoundingClientRect(), !1)
            }
            if (null == i && o < jt(r)) {
                let e = r.childNodes[o];
                if (1 == e.nodeType)
                    return Sn(e.getBoundingClientRect(), !0)
            }
            return Sn(r.getBoundingClientRect(), n >= 0)
        }
        if (null == i && o && (n < 0 || o == jt(r))) {
            let e = r.childNodes[o - 1]
                , t = 3 == e.nodeType ? Lt(e, jt(e) - (s ? 0 : 1)) : 1 != e.nodeType || "BR" == e.nodeName && e.nextSibling ? null : e;
            if (t)
                return Cn(vn(t, 1), !1)
        }
        if (null == i && o < jt(r)) {
            let e = r.childNodes[o];
            for (; e.pmViewDesc && e.pmViewDesc.ignoreForCoords;)
                e = e.nextSibling;
            let t = e ? 3 == e.nodeType ? Lt(e, 0, s ? 0 : 1) : 1 == e.nodeType ? e : null : null;
            if (t)
                return Cn(vn(t, -1), !0)
        }
        return Cn(vn(3 == r.nodeType ? Lt(r) : r, -n), n >= 0)
    }
    function Cn(e, t) {
        if (0 == e.width)
            return e;
        let n = t ? e.left : e.right;
        return {
            top: e.top,
            bottom: e.bottom,
            left: n,
            right: n
        }
    }
    function Sn(e, t) {
        if (0 == e.height)
            return e;
        let n = t ? e.top : e.bottom;
        return {
            top: n,
            bottom: n,
            left: e.left,
            right: e.right
        }
    }
    function xn(e, t, n) {
        let r = e.state
            , o = e.root.activeElement;
        r != t && e.updateState(t),
            o != e.dom && e.focus();
        try {
            return n()
        } finally {
            r != t && e.updateState(r),
                o != e.dom && o && o.focus()
        }
    }
    const En = /[\u0590-\u08ac]/;
    let Mn = null
        , Tn = null
        , Nn = !1;
    function _n(e, t, n) {
        return Mn == t && Tn == n ? Nn : (Mn = t,
            Tn = n,
            Nn = "up" == n || "down" == n ? function (e, t, n) {
                let r = t.selection
                    , o = "up" == n ? r.$from : r.$to;
                return xn(e, t, (() => {
                    let { node: t } = e.docView.domFromPos(o.pos, "up" == n ? -1 : 1);
                    for (; ;) {
                        let n = e.docView.nearestDesc(t, !0);
                        if (!n)
                            break;
                        if (n.node.isBlock) {
                            t = n.contentDOM || n.dom;
                            break
                        }
                        t = n.dom.parentNode
                    }
                    let r = kn(e, o.pos, 1);
                    for (let e = t.firstChild; e; e = e.nextSibling) {
                        let t;
                        if (1 == e.nodeType)
                            t = e.getClientRects();
                        else {
                            if (3 != e.nodeType)
                                continue;
                            t = Lt(e, 0, e.nodeValue.length).getClientRects()
                        }
                        for (let e = 0; e < t.length; e++) {
                            let o = t[e];
                            if (o.bottom > o.top + 1 && ("up" == n ? r.top - o.top > 2 * (o.bottom - r.top) : o.bottom - r.bottom > 2 * (r.bottom - o.top)))
                                return !1
                        }
                    }
                    return !0
                }
                ))
            }(e, t, n) : function (e, t, n) {
                let { $head: r } = t.selection;
                if (!r.parent.isTextblock)
                    return !1;
                let o = r.parentOffset
                    , i = !o
                    , s = o == r.parent.content.size
                    , a = e.domSelection();
                return a ? En.test(r.parent.textContent) && a.modify ? xn(e, t, (() => {
                    let { focusNode: t, focusOffset: o, anchorNode: i, anchorOffset: s } = e.domSelectionRange()
                        , l = a.caretBidiLevel;
                    a.modify("move", n, "character");
                    let c = r.depth ? e.docView.domAfterPos(r.before()) : e.dom
                        , { focusNode: d, focusOffset: u } = e.domSelectionRange()
                        , h = d && !c.contains(1 == d.nodeType ? d : d.parentNode) || t == d && o == u;
                    try {
                        a.collapse(i, s),
                            t && (t != i || o != s) && a.extend && a.extend(t, o)
                    } catch (uN) { }
                    return null != l && (a.caretBidiLevel = l),
                        h
                }
                )) : "left" == n || "backward" == n ? i : s : r.pos == r.start() || r.pos == r.end()
            }(e, t, n))
    }
    class On {
        constructor(e, t, n, r) {
            this.parent = e,
                this.children = t,
                this.dom = n,
                this.contentDOM = r,
                this.dirty = 0,
                n.pmViewDesc = this
        }
        matchesWidget(e) {
            return !1
        }
        matchesMark(e) {
            return !1
        }
        matchesNode(e, t, n) {
            return !1
        }
        matchesHack(e) {
            return !1
        }
        parseRule() {
            return null
        }
        stopEvent(e) {
            return !1
        }
        get size() {
            let e = 0;
            for (let t = 0; t < this.children.length; t++)
                e += this.children[t].size;
            return e
        }
        get border() {
            return 0
        }
        destroy() {
            this.parent = void 0,
                this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
            for (let e = 0; e < this.children.length; e++)
                this.children[e].destroy()
        }
        posBeforeChild(e) {
            for (let t = 0, n = this.posAtStart; ; t++) {
                let r = this.children[t];
                if (r == e)
                    return n;
                n += r.size
            }
        }
        get posBefore() {
            return this.parent.posBeforeChild(this)
        }
        get posAtStart() {
            return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
        }
        get posAfter() {
            return this.posBefore + this.size
        }
        get posAtEnd() {
            return this.posAtStart + this.size - 2 * this.border
        }
        localPosFromDOM(e, t, n) {
            if (this.contentDOM && this.contentDOM.contains(1 == e.nodeType ? e : e.parentNode)) {
                if (n < 0) {
                    let n, r;
                    if (e == this.contentDOM)
                        n = e.childNodes[t - 1];
                    else {
                        for (; e.parentNode != this.contentDOM;)
                            e = e.parentNode;
                        n = e.previousSibling
                    }
                    for (; n && (!(r = n.pmViewDesc) || r.parent != this);)
                        n = n.previousSibling;
                    return n ? this.posBeforeChild(r) + r.size : this.posAtStart
                }
                {
                    let n, r;
                    if (e == this.contentDOM)
                        n = e.childNodes[t];
                    else {
                        for (; e.parentNode != this.contentDOM;)
                            e = e.parentNode;
                        n = e.nextSibling
                    }
                    for (; n && (!(r = n.pmViewDesc) || r.parent != this);)
                        n = n.nextSibling;
                    return n ? this.posBeforeChild(r) : this.posAtEnd
                }
            }
            let r;
            if (e == this.dom && this.contentDOM)
                r = t > Ot(this.contentDOM);
            else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
                r = 2 & e.compareDocumentPosition(this.contentDOM);
            else if (this.dom.firstChild) {
                if (0 == t)
                    for (let t = e; ; t = t.parentNode) {
                        if (t == this.dom) {
                            r = !1;
                            break
                        }
                        if (t.previousSibling)
                            break
                    }
                if (null == r && t == e.childNodes.length)
                    for (let t = e; ; t = t.parentNode) {
                        if (t == this.dom) {
                            r = !0;
                            break
                        }
                        if (t.nextSibling)
                            break
                    }
            }
            return (null == r ? n > 0 : r) ? this.posAtEnd : this.posAtStart
        }
        nearestDesc(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            for (let n = !0, r = e; r; r = r.parentNode) {
                let o, i = this.getDesc(r);
                if (i && (!t || i.node)) {
                    if (!n || !(o = i.nodeDOM) || (1 == o.nodeType ? o.contains(1 == e.nodeType ? e : e.parentNode) : o == e))
                        return i;
                    n = !1
                }
            }
        }
        getDesc(e) {
            let t = e.pmViewDesc;
            for (let n = t; n; n = n.parent)
                if (n == this)
                    return t
        }
        posFromDOM(e, t, n) {
            for (let r = e; r; r = r.parentNode) {
                let o = this.getDesc(r);
                if (o)
                    return o.localPosFromDOM(e, t, n)
            }
            return -1
        }
        descAt(e) {
            for (let t = 0, n = 0; t < this.children.length; t++) {
                let r = this.children[t]
                    , o = n + r.size;
                if (n == e && o != n) {
                    for (; !r.border && r.children.length;)
                        r = r.children[0];
                    return r
                }
                if (e < o)
                    return r.descAt(e - n - r.border);
                n = o
            }
        }
        domFromPos(e, t) {
            if (!this.contentDOM)
                return {
                    node: this.dom,
                    offset: 0,
                    atom: e + 1
                };
            let n = 0
                , r = 0;
            for (let o = 0; n < this.children.length; n++) {
                let t = this.children[n]
                    , i = o + t.size;
                if (i > e || t instanceof jn) {
                    r = e - o;
                    break
                }
                o = i
            }
            if (r)
                return this.children[n].domFromPos(r - this.children[n].border, t);
            for (let o; n && !(o = this.children[n - 1]).size && o instanceof An && o.side >= 0; n--)
                ;
            if (t <= 0) {
                let e, r = !0;
                for (; e = n ? this.children[n - 1] : null,
                    e && e.dom.parentNode != this.contentDOM; n--,
                    r = !1)
                    ;
                return e && t && r && !e.border && !e.domAtom ? e.domFromPos(e.size, t) : {
                    node: this.contentDOM,
                    offset: e ? Ot(e.dom) + 1 : 0
                }
            }
            {
                let e, r = !0;
                for (; e = n < this.children.length ? this.children[n] : null,
                    e && e.dom.parentNode != this.contentDOM; n++,
                    r = !1)
                    ;
                return e && r && !e.border && !e.domAtom ? e.domFromPos(0, t) : {
                    node: this.contentDOM,
                    offset: e ? Ot(e.dom) : this.contentDOM.childNodes.length
                }
            }
        }
        parseRange(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (0 == this.children.length)
                return {
                    node: this.contentDOM,
                    from: e,
                    to: t,
                    fromOffset: 0,
                    toOffset: this.contentDOM.childNodes.length
                };
            let r = -1
                , o = -1;
            for (let i = n, s = 0; ; s++) {
                let n = this.children[s]
                    , a = i + n.size;
                if (-1 == r && e <= a) {
                    let o = i + n.border;
                    if (e >= o && t <= a - n.border && n.node && n.contentDOM && this.contentDOM.contains(n.contentDOM))
                        return n.parseRange(e, t, o);
                    e = i;
                    for (let t = s; t > 0; t--) {
                        let n = this.children[t - 1];
                        if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(1)) {
                            r = Ot(n.dom) + 1;
                            break
                        }
                        e -= n.size
                    }
                    -1 == r && (r = 0)
                }
                if (r > -1 && (a > t || s == this.children.length - 1)) {
                    t = a;
                    for (let e = s + 1; e < this.children.length; e++) {
                        let n = this.children[e];
                        if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(-1)) {
                            o = Ot(n.dom);
                            break
                        }
                        t += n.size
                    }
                    -1 == o && (o = this.contentDOM.childNodes.length);
                    break
                }
                i = a
            }
            return {
                node: this.contentDOM,
                from: e,
                to: t,
                fromOffset: r,
                toOffset: o
            }
        }
        emptyChildAt(e) {
            if (this.border || !this.contentDOM || !this.children.length)
                return !1;
            let t = this.children[e < 0 ? 0 : this.children.length - 1];
            return 0 == t.size || t.emptyChildAt(e)
        }
        domAfterPos(e) {
            let { node: t, offset: n } = this.domFromPos(e, 0);
            if (1 != t.nodeType || n == t.childNodes.length)
                throw new RangeError("No node after pos " + e);
            return t.childNodes[n]
        }
        setSelection(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                , o = Math.min(e, t)
                , i = Math.max(e, t);
            for (let u = 0, h = 0; u < this.children.length; u++) {
                let s = this.children[u]
                    , a = h + s.size;
                if (o > h && i < a)
                    return s.setSelection(e - h - s.border, t - h - s.border, n, r);
                h = a
            }
            let s = this.domFromPos(e, e ? -1 : 1)
                , a = t == e ? s : this.domFromPos(t, t ? -1 : 1)
                , l = n.getSelection()
                , c = !1;
            if ((Jt || Yt) && e == t) {
                let { node: e, offset: t } = s;
                if (3 == e.nodeType) {
                    if (c = !(!t || "\n" != e.nodeValue[t - 1]),
                        c && t == e.nodeValue.length)
                        for (let n, r = e; r; r = r.parentNode) {
                            if (n = r.nextSibling) {
                                "BR" == n.nodeName && (s = a = {
                                    node: n.parentNode,
                                    offset: Ot(n) + 1
                                });
                                break
                            }
                            let e = r.pmViewDesc;
                            if (e && e.node && e.node.isBlock)
                                break
                        }
                } else {
                    let n = e.childNodes[t - 1];
                    c = n && ("BR" == n.nodeName || "false" == n.contentEditable)
                }
            }
            if (Jt && l.focusNode && l.focusNode != a.node && 1 == l.focusNode.nodeType) {
                let e = l.focusNode.childNodes[l.focusOffset];
                e && "false" == e.contentEditable && (r = !0)
            }
            if (!(r || c && Yt) && Rt(s.node, s.offset, l.anchorNode, l.anchorOffset) && Rt(a.node, a.offset, l.focusNode, l.focusOffset))
                return;
            let d = !1;
            if ((l.extend || e == t) && !c) {
                l.collapse(s.node, s.offset);
                try {
                    e != t && l.extend(a.node, a.offset),
                        d = !0
                } catch (uN) { }
            }
            if (!d) {
                if (e > t) {
                    let e = s;
                    s = a,
                        a = e
                }
                let n = document.createRange();
                n.setEnd(a.node, a.offset),
                    n.setStart(s.node, s.offset),
                    l.removeAllRanges(),
                    l.addRange(n)
            }
        }
        ignoreMutation(e) {
            return !this.contentDOM && "selection" != e.type
        }
        get contentLost() {
            return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
        }
        markDirty(e, t) {
            for (let n = 0, r = 0; r < this.children.length; r++) {
                let o = this.children[r]
                    , i = n + o.size;
                if (n == i ? e <= i && t >= n : e < i && t > n) {
                    let r = n + o.border
                        , s = i - o.border;
                    if (e >= r && t <= s)
                        return this.dirty = e == n || t == i ? 2 : 1,
                            void (e != r || t != s || !o.contentLost && o.dom.parentNode == this.contentDOM ? o.markDirty(e - r, t - r) : o.dirty = 3);
                    o.dirty = o.dom != o.contentDOM || o.dom.parentNode != this.contentDOM || o.children.length ? 3 : 2
                }
                n = i
            }
            this.dirty = 2
        }
        markParentsDirty() {
            let e = 1;
            for (let t = this.parent; t; t = t.parent,
                e++) {
                let n = 1 == e ? 2 : 1;
                t.dirty < n && (t.dirty = n)
            }
        }
        get domAtom() {
            return !1
        }
        get ignoreForCoords() {
            return !1
        }
        isText(e) {
            return !1
        }
    }
    class An extends On {
        constructor(e, t, n, r) {
            let o, i = t.type.toDOM;
            if ("function" == typeof i && (i = i(n, (() => o ? o.parent ? o.parent.posBeforeChild(o) : void 0 : r))),
                !t.type.spec.raw) {
                if (1 != i.nodeType) {
                    let e = document.createElement("span");
                    e.appendChild(i),
                        i = e
                }
                i.contentEditable = "false",
                    i.classList.add("ProseMirror-widget")
            }
            super(e, [], i, null),
                this.widget = t,
                this.widget = t,
                o = this
        }
        matchesWidget(e) {
            return 0 == this.dirty && e.type.eq(this.widget.type)
        }
        parseRule() {
            return {
                ignore: !0
            }
        }
        stopEvent(e) {
            let t = this.widget.spec.stopEvent;
            return !!t && t(e)
        }
        ignoreMutation(e) {
            return "selection" != e.type || this.widget.spec.ignoreSelection
        }
        destroy() {
            this.widget.type.destroy(this.dom),
                super.destroy()
        }
        get domAtom() {
            return !0
        }
        get side() {
            return this.widget.type.side
        }
    }
    class Pn extends On {
        constructor(e, t, n, r) {
            super(e, [], t, null),
                this.textDOM = n,
                this.text = r
        }
        get size() {
            return this.text.length
        }
        localPosFromDOM(e, t) {
            return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t
        }
        domFromPos(e) {
            return {
                node: this.textDOM,
                offset: e
            }
        }
        ignoreMutation(e) {
            return "characterData" === e.type && e.target.nodeValue == e.oldValue
        }
    }
    class Ln extends On {
        constructor(e, t, n, r) {
            super(e, [], n, r),
                this.mark = t
        }
        static create(e, t, n, r) {
            let o = r.nodeViews[t.type.name]
                , i = o && o(t, r, n);
            return i && i.dom || (i = ue.renderSpec(document, t.type.spec.toDOM(t, n), null, t.attrs)),
                new Ln(e, t, i.dom, i.contentDOM || i.dom)
        }
        parseRule() {
            return 3 & this.dirty || this.mark.type.spec.reparseInView ? null : {
                mark: this.mark.type.name,
                attrs: this.mark.attrs,
                contentElement: this.contentDOM
            }
        }
        matchesMark(e) {
            return 3 != this.dirty && this.mark.eq(e)
        }
        markDirty(e, t) {
            if (super.markDirty(e, t),
                0 != this.dirty) {
                let e = this.parent;
                for (; !e.node;)
                    e = e.parent;
                e.dirty < this.dirty && (e.dirty = this.dirty),
                    this.dirty = 0
            }
        }
        slice(e, t, n) {
            let r = Ln.create(this.parent, this.mark, !0, n)
                , o = this.children
                , i = this.size;
            t < i && (o = Zn(o, t, i, n)),
                e > 0 && (o = Zn(o, 0, e, n));
            for (let s = 0; s < o.length; s++)
                o[s].parent = r;
            return r.children = o,
                r
        }
    }
    class Rn extends On {
        constructor(e, t, n, r, o, i, s, a, l) {
            super(e, [], o, i),
                this.node = t,
                this.outerDeco = n,
                this.innerDeco = r,
                this.nodeDOM = s
        }
        static create(e, t, n, r, o, i) {
            let s, a = o.nodeViews[t.type.name], l = a && a(t, o, (() => s ? s.parent ? s.parent.posBeforeChild(s) : void 0 : i), n, r), c = l && l.dom, d = l && l.contentDOM;
            if (t.isText)
                if (c) {
                    if (3 != c.nodeType)
                        throw new RangeError("Text must be rendered as a DOM text node")
                } else
                    c = document.createTextNode(t.text);
            else if (!c) {
                let e = ue.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs);
                ({ dom: c, contentDOM: d } = e)
            }
            d || t.isText || "BR" == c.nodeName || (c.hasAttribute("contenteditable") || (c.contentEditable = "false"),
                t.type.spec.draggable && (c.draggable = !0));
            let u = c;
            return c = Wn(c, n, t),
                l ? s = new Hn(e, t, n, r, c, d || null, u, l, o, i + 1) : t.isText ? new In(e, t, n, r, c, u, o) : new Rn(e, t, n, r, c, d || null, u, o, i + 1)
        }
        parseRule() {
            if (this.node.type.spec.reparseInView)
                return null;
            let e = {
                node: this.node.type.name,
                attrs: this.node.attrs
            };
            if ("pre" == this.node.type.whitespace && (e.preserveWhitespace = "full"),
                this.contentDOM)
                if (this.contentLost) {
                    for (let t = this.children.length - 1; t >= 0; t--) {
                        let n = this.children[t];
                        if (this.dom.contains(n.dom.parentNode)) {
                            e.contentElement = n.dom.parentNode;
                            break
                        }
                    }
                    e.contentElement || (e.getContent = () => d.empty)
                } else
                    e.contentElement = this.contentDOM;
            else
                e.getContent = () => this.node.content;
            return e
        }
        matchesNode(e, t, n) {
            return 0 == this.dirty && e.eq(this.node) && qn(t, this.outerDeco) && n.eq(this.innerDeco)
        }
        get size() {
            return this.node.nodeSize
        }
        get border() {
            return this.node.isLeaf ? 0 : 1
        }
        updateChildren(e, t) {
            let n = this.node.inlineContent
                , r = t
                , o = e.composing ? this.localCompositionInfo(e, t) : null
                , i = o && o.pos > -1 ? o : null
                , s = o && o.pos < 0
                , a = new Kn(this, i && i.node, e);
            !function (e, t, n, r) {
                let o = t.locals(e)
                    , i = 0;
                if (0 == o.length) {
                    for (let n = 0; n < e.childCount; n++) {
                        let s = e.child(n);
                        r(s, o, t.forChild(i, s), n),
                            i += s.nodeSize
                    }
                    return
                }
                let s = 0
                    , a = []
                    , l = null;
                for (let c = 0; ;) {
                    let d, u, h, p;
                    for (; s < o.length && o[s].to == i;) {
                        let e = o[s++];
                        e.widget && (d ? (u || (u = [d])).push(e) : d = e)
                    }
                    if (d)
                        if (u) {
                            u.sort(Jn);
                            for (let e = 0; e < u.length; e++)
                                n(u[e], c, !!l)
                        } else
                            n(d, c, !!l);
                    if (l)
                        p = -1,
                            h = l,
                            l = null;
                    else {
                        if (!(c < e.childCount))
                            break;
                        p = c,
                            h = e.child(c++)
                    }
                    for (let e = 0; e < a.length; e++)
                        a[e].to <= i && a.splice(e--, 1);
                    for (; s < o.length && o[s].from <= i && o[s].to > i;)
                        a.push(o[s++]);
                    let f = i + h.nodeSize;
                    if (h.isText) {
                        let e = f;
                        s < o.length && o[s].from < e && (e = o[s].from);
                        for (let t = 0; t < a.length; t++)
                            a[t].to < e && (e = a[t].to);
                        e < f && (l = h.cut(e - i),
                            h = h.cut(0, e - i),
                            f = e,
                            p = -1)
                    } else
                        for (; s < o.length && o[s].to < f;)
                            s++;
                    r(h, h.isInline && !h.isLeaf ? a.filter((e => !e.inline)) : a.slice(), t.forChild(i, h), p),
                        i = f
                }
            }(this.node, this.innerDeco, ((t, o, i) => {
                t.spec.marks ? a.syncToMarks(t.spec.marks, n, e) : t.type.side >= 0 && !i && a.syncToMarks(o == this.node.childCount ? f.none : this.node.child(o).marks, n, e),
                    a.placeWidget(t, e, r)
            }
            ), ((t, i, l, c) => {
                let d;
                a.syncToMarks(t.marks, n, e),
                    a.findNodeMatch(t, i, l, c) || s && e.state.selection.from > r && e.state.selection.to < r + t.nodeSize && (d = a.findIndexWithChild(o.node)) > -1 && a.updateNodeAt(t, i, l, d, e) || a.updateNextNode(t, i, l, e, c, r) || a.addNode(t, i, l, e, r),
                    r += t.nodeSize
            }
            )),
                a.syncToMarks([], n, e),
                this.node.isTextblock && a.addTextblockHacks(),
                a.destroyRest(),
                (a.changed || 2 == this.dirty) && (i && this.protectLocalComposition(e, i),
                    zn(this.contentDOM, this.children, e),
                    en && function (e) {
                        if ("UL" == e.nodeName || "OL" == e.nodeName) {
                            let t = e.style.cssText;
                            e.style.cssText = t + "; list-style: square !important",
                                window.getComputedStyle(e).listStyle,
                                e.style.cssText = t
                        }
                    }(this.dom))
        }
        localCompositionInfo(e, t) {
            let { from: n, to: r } = e.state.selection;
            if (!(e.state.selection instanceof ut) || n < t || r > t + this.node.content.size)
                return null;
            let o = e.input.compositionNode;
            if (!o || !this.dom.contains(o.parentNode))
                return null;
            if (this.node.inlineContent) {
                let e = o.nodeValue
                    , i = function (e, t, n, r) {
                        for (let o = 0, i = 0; o < e.childCount && i <= r;) {
                            let s = e.child(o++)
                                , a = i;
                            if (i += s.nodeSize,
                                !s.isText)
                                continue;
                            let l = s.text;
                            for (; o < e.childCount;) {
                                let t = e.child(o++);
                                if (i += t.nodeSize,
                                    !t.isText)
                                    break;
                                l += t.text
                            }
                            if (i >= n) {
                                if (i >= r && l.slice(r - t.length - a, r - a) == t)
                                    return r - t.length;
                                let e = a < r ? l.lastIndexOf(t, r - a - 1) : -1;
                                if (e >= 0 && e + t.length + a >= n)
                                    return a + e;
                                if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t)
                                    return r
                            }
                        }
                        return -1
                    }(this.node.content, e, n - t, r - t);
                return i < 0 ? null : {
                    node: o,
                    pos: i,
                    text: e
                }
            }
            return {
                node: o,
                pos: -1,
                text: ""
            }
        }
        protectLocalComposition(e, t) {
            let { node: n, pos: r, text: o } = t;
            if (this.getDesc(n))
                return;
            let i = n;
            for (; i.parentNode != this.contentDOM; i = i.parentNode) {
                for (; i.previousSibling;)
                    i.parentNode.removeChild(i.previousSibling);
                for (; i.nextSibling;)
                    i.parentNode.removeChild(i.nextSibling);
                i.pmViewDesc && (i.pmViewDesc = void 0)
            }
            let s = new Pn(this, i, n, o);
            e.input.compositionNodes.push(s),
                this.children = Zn(this.children, r, r + o.length, e, s)
        }
        update(e, t, n, r) {
            return !(3 == this.dirty || !e.sameMarkup(this.node)) && (this.updateInner(e, t, n, r),
                !0)
        }
        updateInner(e, t, n, r) {
            this.updateOuterDeco(t),
                this.node = e,
                this.innerDeco = n,
                this.contentDOM && this.updateChildren(r, this.posAtStart),
                this.dirty = 0
        }
        updateOuterDeco(e) {
            if (qn(e, this.outerDeco))
                return;
            let t = 1 != this.nodeDOM.nodeType
                , n = this.dom;
            this.dom = Fn(this.dom, this.nodeDOM, Vn(this.outerDeco, this.node, t), Vn(e, this.node, t)),
                this.dom != n && (n.pmViewDesc = void 0,
                    this.dom.pmViewDesc = this),
                this.outerDeco = e
        }
        selectNode() {
            1 == this.nodeDOM.nodeType && this.nodeDOM.classList.add("ProseMirror-selectednode"),
                !this.contentDOM && this.node.type.spec.draggable || (this.dom.draggable = !0)
        }
        deselectNode() {
            1 == this.nodeDOM.nodeType && (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
                !this.contentDOM && this.node.type.spec.draggable || this.dom.removeAttribute("draggable"))
        }
        get domAtom() {
            return this.node.isAtom
        }
    }
    function Dn(e, t, n, r, o) {
        Wn(r, t, e);
        let i = new Rn(void 0, e, t, n, r, r, r, o, 0);
        return i.contentDOM && i.updateChildren(o, 0),
            i
    }
    class In extends Rn {
        constructor(e, t, n, r, o, i, s) {
            super(e, t, n, r, o, null, i, s, 0)
        }
        parseRule() {
            let e = this.nodeDOM.parentNode;
            for (; e && e != this.dom && !e.pmIsDeco;)
                e = e.parentNode;
            return {
                skip: e || !0
            }
        }
        update(e, t, n, r) {
            return !(3 == this.dirty || 0 != this.dirty && !this.inParent() || !e.sameMarkup(this.node)) && (this.updateOuterDeco(t),
                0 == this.dirty && e.text == this.node.text || e.text == this.nodeDOM.nodeValue || (this.nodeDOM.nodeValue = e.text,
                    r.trackWrites == this.nodeDOM && (r.trackWrites = null)),
                this.node = e,
                this.dirty = 0,
                !0)
        }
        inParent() {
            let e = this.parent.contentDOM;
            for (let t = this.nodeDOM; t; t = t.parentNode)
                if (t == e)
                    return !0;
            return !1
        }
        domFromPos(e) {
            return {
                node: this.nodeDOM,
                offset: e
            }
        }
        localPosFromDOM(e, t, n) {
            return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, n)
        }
        ignoreMutation(e) {
            return "characterData" != e.type && "selection" != e.type
        }
        slice(e, t, n) {
            let r = this.node.cut(e, t)
                , o = document.createTextNode(r.text);
            return new In(this.parent, r, this.outerDeco, this.innerDeco, o, o, n)
        }
        markDirty(e, t) {
            super.markDirty(e, t),
                this.dom == this.nodeDOM || 0 != e && t != this.nodeDOM.nodeValue.length || (this.dirty = 3)
        }
        get domAtom() {
            return !1
        }
        isText(e) {
            return this.node.text == e
        }
    }
    class jn extends On {
        parseRule() {
            return {
                ignore: !0
            }
        }
        matchesHack(e) {
            return 0 == this.dirty && this.dom.nodeName == e
        }
        get domAtom() {
            return !0
        }
        get ignoreForCoords() {
            return "IMG" == this.dom.nodeName
        }
    }
    class Hn extends Rn {
        constructor(e, t, n, r, o, i, s, a, l, c) {
            super(e, t, n, r, o, i, s, l, c),
                this.spec = a
        }
        update(e, t, n, r) {
            if (3 == this.dirty)
                return !1;
            if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
                let o = this.spec.update(e, t, n);
                return o && this.updateInner(e, t, n, r),
                    o
            }
            return !(!this.contentDOM && !e.isLeaf) && super.update(e, t, n, r)
        }
        selectNode() {
            this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
        }
        deselectNode() {
            this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
        }
        setSelection(e, t, n, r) {
            this.spec.setSelection ? this.spec.setSelection(e, t, n) : super.setSelection(e, t, n, r)
        }
        destroy() {
            this.spec.destroy && this.spec.destroy(),
                super.destroy()
        }
        stopEvent(e) {
            return !!this.spec.stopEvent && this.spec.stopEvent(e)
        }
        ignoreMutation(e) {
            return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
        }
    }
    function zn(e, t, n) {
        let r = e.firstChild
            , o = !1;
        for (let i = 0; i < t.length; i++) {
            let s = t[i]
                , a = s.dom;
            if (a.parentNode == e) {
                for (; a != r;)
                    r = Gn(r),
                        o = !0;
                r = r.nextSibling
            } else
                o = !0,
                    e.insertBefore(a, r);
            if (s instanceof Ln) {
                let t = r ? r.previousSibling : e.lastChild;
                zn(s.contentDOM, s.children, n),
                    r = t ? t.nextSibling : e.firstChild
            }
        }
        for (; r;)
            r = Gn(r),
                o = !0;
        o && n.trackWrites == e && (n.trackWrites = null)
    }
    const $n = function (e) {
        e && (this.nodeName = e)
    };
    $n.prototype = Object.create(null);
    const Bn = [new $n];
    function Vn(e, t, n) {
        if (0 == e.length)
            return Bn;
        let r = n ? Bn[0] : new $n
            , o = [r];
        for (let i = 0; i < e.length; i++) {
            let s = e[i].type.attrs;
            if (s) {
                s.nodeName && o.push(r = new $n(s.nodeName));
                for (let e in s) {
                    let i = s[e];
                    null != i && (n && 1 == o.length && o.push(r = new $n(t.isInline ? "span" : "div")),
                        "class" == e ? r.class = (r.class ? r.class + " " : "") + i : "style" == e ? r.style = (r.style ? r.style + ";" : "") + i : "nodeName" != e && (r[e] = i))
                }
            }
        }
        return o
    }
    function Fn(e, t, n, r) {
        if (n == Bn && r == Bn)
            return t;
        let o = t;
        for (let i = 0; i < r.length; i++) {
            let t = r[i]
                , s = n[i];
            if (i) {
                let n;
                s && s.nodeName == t.nodeName && o != e && (n = o.parentNode) && n.nodeName.toLowerCase() == t.nodeName || (n = document.createElement(t.nodeName),
                    n.pmIsDeco = !0,
                    n.appendChild(o),
                    s = Bn[0]),
                    o = n
            }
            Un(o, s || Bn[0], t)
        }
        return o
    }
    function Un(e, t, n) {
        for (let r in t)
            "class" == r || "style" == r || "nodeName" == r || r in n || e.removeAttribute(r);
        for (let r in n)
            "class" != r && "style" != r && "nodeName" != r && n[r] != t[r] && e.setAttribute(r, n[r]);
        if (t.class != n.class) {
            let r = t.class ? t.class.split(" ").filter(Boolean) : []
                , o = n.class ? n.class.split(" ").filter(Boolean) : [];
            for (let t = 0; t < r.length; t++)
                -1 == o.indexOf(r[t]) && e.classList.remove(r[t]);
            for (let t = 0; t < o.length; t++)
                -1 == r.indexOf(o[t]) && e.classList.add(o[t]);
            0 == e.classList.length && e.removeAttribute("class")
        }
        if (t.style != n.style) {
            if (t.style) {
                let n, r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;
                for (; n = r.exec(t.style);)
                    e.style.removeProperty(n[1])
            }
            n.style && (e.style.cssText += n.style)
        }
    }
    function Wn(e, t, n) {
        return Fn(e, e, Bn, Vn(t, n, 1 != e.nodeType))
    }
    function qn(e, t) {
        if (e.length != t.length)
            return !1;
        for (let n = 0; n < e.length; n++)
            if (!e[n].type.eq(t[n].type))
                return !1;
        return !0
    }
    function Gn(e) {
        let t = e.nextSibling;
        return e.parentNode.removeChild(e),
            t
    }
    class Kn {
        constructor(e, t, n) {
            this.lock = t,
                this.view = n,
                this.index = 0,
                this.stack = [],
                this.changed = !1,
                this.top = e,
                this.preMatch = function (e, t) {
                    let n = t
                        , r = n.children.length
                        , o = e.childCount
                        , i = new Map
                        , s = [];
                    e: for (; o > 0;) {
                        let a;
                        for (; ;)
                            if (r) {
                                let e = n.children[r - 1];
                                if (!(e instanceof Ln)) {
                                    a = e,
                                        r--;
                                    break
                                }
                                n = e,
                                    r = e.children.length
                            } else {
                                if (n == t)
                                    break e;
                                r = n.parent.children.indexOf(n),
                                    n = n.parent
                            }
                        let l = a.node;
                        if (l) {
                            if (l != e.child(o - 1))
                                break;
                            --o,
                                i.set(a, o),
                                s.push(a)
                        }
                    }
                    return {
                        index: o,
                        matched: i,
                        matches: s.reverse()
                    }
                }(e.node.content, e)
        }
        destroyBetween(e, t) {
            if (e != t) {
                for (let n = e; n < t; n++)
                    this.top.children[n].destroy();
                this.top.children.splice(e, t - e),
                    this.changed = !0
            }
        }
        destroyRest() {
            this.destroyBetween(this.index, this.top.children.length)
        }
        syncToMarks(e, t, n) {
            let r = 0
                , o = this.stack.length >> 1
                , i = Math.min(o, e.length);
            for (; r < i && (r == o - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && !1 !== e[r].type.spec.spanning;)
                r++;
            for (; r < o;)
                this.destroyRest(),
                    this.top.dirty = 0,
                    this.index = this.stack.pop(),
                    this.top = this.stack.pop(),
                    o--;
            for (; o < e.length;) {
                this.stack.push(this.top, this.index + 1);
                let r = -1;
                for (let t = this.index; t < Math.min(this.index + 3, this.top.children.length); t++) {
                    let n = this.top.children[t];
                    if (n.matchesMark(e[o]) && !this.isLocked(n.dom)) {
                        r = t;
                        break
                    }
                }
                if (r > -1)
                    r > this.index && (this.changed = !0,
                        this.destroyBetween(this.index, r)),
                        this.top = this.top.children[this.index];
                else {
                    let r = Ln.create(this.top, e[o], t, n);
                    this.top.children.splice(this.index, 0, r),
                        this.top = r,
                        this.changed = !0
                }
                this.index = 0,
                    o++
            }
        }
        findNodeMatch(e, t, n, r) {
            let o, i = -1;
            if (r >= this.preMatch.index && (o = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, n))
                i = this.top.children.indexOf(o, this.index);
            else
                for (let s = this.index, a = Math.min(this.top.children.length, s + 5); s < a; s++) {
                    let r = this.top.children[s];
                    if (r.matchesNode(e, t, n) && !this.preMatch.matched.has(r)) {
                        i = s;
                        break
                    }
                }
            return !(i < 0) && (this.destroyBetween(this.index, i),
                this.index++,
                !0)
        }
        updateNodeAt(e, t, n, r, o) {
            let i = this.top.children[r];
            return 3 == i.dirty && i.dom == i.contentDOM && (i.dirty = 2),
                !!i.update(e, t, n, o) && (this.destroyBetween(this.index, r),
                    this.index++,
                    !0)
        }
        findIndexWithChild(e) {
            for (; ;) {
                let t = e.parentNode;
                if (!t)
                    return -1;
                if (t == this.top.contentDOM) {
                    let t = e.pmViewDesc;
                    if (t)
                        for (let e = this.index; e < this.top.children.length; e++)
                            if (this.top.children[e] == t)
                                return e;
                    return -1
                }
                e = t
            }
        }
        updateNextNode(e, t, n, r, o, i) {
            for (let s = this.index; s < this.top.children.length; s++) {
                let a = this.top.children[s];
                if (a instanceof Rn) {
                    let l = this.preMatch.matched.get(a);
                    if (null != l && l != o)
                        return !1;
                    let c, d = a.dom, u = this.isLocked(d) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && 3 != a.dirty && qn(t, a.outerDeco));
                    if (!u && a.update(e, t, n, r))
                        return this.destroyBetween(this.index, s),
                            a.dom != d && (this.changed = !0),
                            this.index++,
                            !0;
                    if (!u && (c = this.recreateWrapper(a, e, t, n, r, i)))
                        return this.destroyBetween(this.index, s),
                            this.top.children[this.index] = c,
                            c.contentDOM && (c.dirty = 2,
                                c.updateChildren(r, i + 1),
                                c.dirty = 0),
                            this.changed = !0,
                            this.index++,
                            !0;
                    break
                }
            }
            return !1
        }
        recreateWrapper(e, t, n, r, o, i) {
            if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !qn(n, e.outerDeco) || !r.eq(e.innerDeco))
                return null;
            let s = Rn.create(this.top, t, n, r, o, i);
            if (s.contentDOM) {
                s.children = e.children,
                    e.children = [];
                for (let e of s.children)
                    e.parent = s
            }
            return e.destroy(),
                s
        }
        addNode(e, t, n, r, o) {
            let i = Rn.create(this.top, e, t, n, r, o);
            i.contentDOM && i.updateChildren(r, o + 1),
                this.top.children.splice(this.index++, 0, i),
                this.changed = !0
        }
        placeWidget(e, t, n) {
            let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
            if (!r || !r.matchesWidget(e) || e != r.widget && r.widget.type.toDOM.parentNode) {
                let r = new An(this.top, e, t, n);
                this.top.children.splice(this.index++, 0, r),
                    this.changed = !0
            } else
                this.index++
        }
        addTextblockHacks() {
            let e = this.top.children[this.index - 1]
                , t = this.top;
            for (; e instanceof Ln;)
                t = e,
                    e = t.children[t.children.length - 1];
            (!e || !(e instanceof In) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Yt || Xt) && e && "false" == e.dom.contentEditable && this.addHackNode("IMG", t),
                this.addHackNode("BR", this.top))
        }
        addHackNode(e, t) {
            if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
                this.index++;
            else {
                let n = document.createElement(e);
                "IMG" == e && (n.className = "ProseMirror-separator",
                    n.alt = ""),
                    "BR" == e && (n.className = "ProseMirror-trailingBreak");
                let r = new jn(this.top, [], n, null);
                t != this.top ? t.children.push(r) : t.children.splice(this.index++, 0, r),
                    this.changed = !0
            }
        }
        isLocked(e) {
            return this.lock && (e == this.lock || 1 == e.nodeType && e.contains(this.lock.parentNode))
        }
    }
    function Jn(e, t) {
        return e.type.side - t.type.side
    }
    function Zn(e, t, n, r, o) {
        let i = [];
        for (let s = 0, a = 0; s < e.length; s++) {
            let l = e[s]
                , c = a
                , d = a += l.size;
            c >= n || d <= t ? i.push(l) : (c < t && i.push(l.slice(0, t - c, r)),
                o && (i.push(o),
                    o = void 0),
                d > n && i.push(l.slice(n - c, l.size, r)))
        }
        return i
    }
    function Xn(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            , n = e.domSelectionRange()
            , r = e.state.doc;
        if (!n.focusNode)
            return null;
        let o = e.docView.nearestDesc(n.focusNode)
            , i = o && 0 == o.size
            , s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
        if (s < 0)
            return null;
        let a, l, c = r.resolve(s);
        if (zt(n)) {
            for (a = s; o && !o.node;)
                o = o.parent;
            let e = o.node;
            if (o && e.isAtom && pt.isSelectable(e) && o.parent && (!e.isInline || !function (e, t, n) {
                for (let r = 0 == t, o = t == jt(e); r || o;) {
                    if (e == n)
                        return !0;
                    let t = Ot(e);
                    if (!(e = e.parentNode))
                        return !1;
                    r = r && 0 == t,
                        o = o && t == jt(e)
                }
            }(n.focusNode, n.focusOffset, o.dom))) {
                let e = o.posBefore;
                l = new pt(s == e ? c : r.resolve(e))
            }
        } else {
            if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
                let t = s
                    , o = s;
                for (let r = 0; r < n.rangeCount; r++) {
                    let i = n.getRangeAt(r);
                    t = Math.min(t, e.docView.posFromDOM(i.startContainer, i.startOffset, 1)),
                        o = Math.max(o, e.docView.posFromDOM(i.endContainer, i.endOffset, -1))
                }
                if (t < 0)
                    return null;
                [a, s] = o == e.state.selection.anchor ? [o, t] : [t, o],
                    c = r.resolve(s)
            } else
                a = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
            if (a < 0)
                return null
        }
        let d = r.resolve(a);
        if (!l) {
            l = sr(e, d, c, "pointer" == t || e.state.selection.head < c.pos && !i ? 1 : -1)
        }
        return l
    }
    function Qn(e) {
        return e.editable ? e.hasFocus() : lr(e) && document.activeElement && document.activeElement.contains(e.dom)
    }
    function Yn(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            , n = e.state.selection;
        if (or(e, n),
            Qn(e)) {
            if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && Xt) {
                let t = e.domSelectionRange()
                    , n = e.domObserver.currentSelection;
                if (t.anchorNode && n.anchorNode && Rt(t.anchorNode, t.anchorOffset, n.anchorNode, n.anchorOffset))
                    return e.input.mouseDown.delayedSelectionSync = !0,
                        void e.domObserver.setCurSelection()
            }
            if (e.domObserver.disconnectSelection(),
                e.cursorWrapper)
                !function (e) {
                    let t = e.domSelection()
                        , n = document.createRange();
                    if (!t)
                        return;
                    let r = e.cursorWrapper.dom
                        , o = "IMG" == r.nodeName;
                    o ? n.setStart(r.parentNode, Ot(r) + 1) : n.setStart(r, 0);
                    n.collapse(!0),
                        t.removeAllRanges(),
                        t.addRange(n),
                        !o && !e.state.selection.visible && Gt && Kt <= 11 && (r.disabled = !0,
                            r.disabled = !1)
                }(e);
            else {
                let r, o, { anchor: i, head: s } = n;
                !er || n instanceof ut || (n.$from.parent.inlineContent || (r = tr(e, n.from)),
                    n.empty || n.$from.parent.inlineContent || (o = tr(e, n.to))),
                    e.docView.setSelection(i, s, e.root, t),
                    er && (r && rr(r),
                        o && rr(o)),
                    n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"),
                        "onselectionchange" in document && function (e) {
                            let t = e.dom.ownerDocument;
                            t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
                            let n = e.domSelectionRange()
                                , r = n.anchorNode
                                , o = n.anchorOffset;
                            t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
                                n.anchorNode == r && n.anchorOffset == o || (t.removeEventListener("selectionchange", e.input.hideSelectionGuard),
                                    setTimeout((() => {
                                        Qn(e) && !e.state.selection.visible || e.dom.classList.remove("ProseMirror-hideselection")
                                    }
                                    ), 20))
                            }
                            )
                        }(e))
            }
            e.domObserver.setCurSelection(),
                e.domObserver.connectSelection()
        }
    }
    const er = Yt || Xt && Qt < 63;
    function tr(e, t) {
        let { node: n, offset: r } = e.docView.domFromPos(t, 0)
            , o = r < n.childNodes.length ? n.childNodes[r] : null
            , i = r ? n.childNodes[r - 1] : null;
        if (Yt && o && "false" == o.contentEditable)
            return nr(o);
        if ((!o || "false" == o.contentEditable) && (!i || "false" == i.contentEditable)) {
            if (o)
                return nr(o);
            if (i)
                return nr(i)
        }
    }
    function nr(e) {
        return e.contentEditable = "true",
            Yt && e.draggable && (e.draggable = !1,
                e.wasDraggable = !0),
            e
    }
    function rr(e) {
        e.contentEditable = "false",
            e.wasDraggable && (e.draggable = !0,
                e.wasDraggable = null)
    }
    function or(e, t) {
        if (t instanceof pt) {
            let n = e.docView.descAt(t.from);
            n != e.lastSelectedViewDesc && (ir(e),
                n && n.selectNode(),
                e.lastSelectedViewDesc = n)
        } else
            ir(e)
    }
    function ir(e) {
        e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(),
            e.lastSelectedViewDesc = void 0)
    }
    function sr(e, t, n, r) {
        return e.someProp("createSelectionBetween", (r => r(e, t, n))) || ut.between(t, n, r)
    }
    function ar(e) {
        return !(e.editable && !e.hasFocus()) && lr(e)
    }
    function lr(e) {
        let t = e.domSelectionRange();
        if (!t.anchorNode)
            return !1;
        try {
            return e.dom.contains(3 == t.anchorNode.nodeType ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(3 == t.focusNode.nodeType ? t.focusNode.parentNode : t.focusNode))
        } catch (uN) {
            return !1
        }
    }
    function cr(e, t) {
        let { $anchor: n, $head: r } = e.selection
            , o = t > 0 ? n.max(r) : n.min(r)
            , i = o.parent.inlineContent ? o.depth ? e.doc.resolve(t > 0 ? o.after() : o.before()) : null : o;
        return i && at.findFrom(i, t)
    }
    function dr(e, t) {
        return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()),
            !0
    }
    function ur(e, t, n) {
        let r = e.state.selection;
        if (!(r instanceof ut)) {
            if (r instanceof pt && r.node.isInline)
                return dr(e, new ut(t > 0 ? r.$to : r.$from));
            {
                let n = cr(e.state, t);
                return !!n && dr(e, n)
            }
        }
        if (n.indexOf("s") > -1) {
            let { $head: n } = r
                , o = n.textOffset ? null : t < 0 ? n.nodeBefore : n.nodeAfter;
            if (!o || o.isText || !o.isLeaf)
                return !1;
            let i = e.state.doc.resolve(n.pos + o.nodeSize * (t < 0 ? -1 : 1));
            return dr(e, new ut(r.$anchor, i))
        }
        if (!r.empty)
            return !1;
        if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
            let n = cr(e.state, t);
            return !!(n && n instanceof pt) && dr(e, n)
        }
        if (!(tn && n.indexOf("m") > -1)) {
            let n, o = r.$head, i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter;
            if (!i || i.isText)
                return !1;
            let s = t < 0 ? o.pos - i.nodeSize : o.pos;
            return !!(i.isAtom || (n = e.docView.descAt(s)) && !n.contentDOM) && (pt.isSelectable(i) ? dr(e, new pt(t < 0 ? e.state.doc.resolve(o.pos - i.nodeSize) : o)) : !!on && dr(e, new ut(e.state.doc.resolve(t < 0 ? s : s + i.nodeSize))))
        }
    }
    function hr(e) {
        return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length
    }
    function pr(e, t) {
        let n = e.pmViewDesc;
        return n && 0 == n.size && (t < 0 || e.nextSibling || "BR" != e.nodeName)
    }
    function fr(e, t) {
        return t < 0 ? function (e) {
            let t = e.domSelectionRange()
                , n = t.focusNode
                , r = t.focusOffset;
            if (!n)
                return;
            let o, i, s = !1;
            Jt && 1 == n.nodeType && r < hr(n) && pr(n.childNodes[r], -1) && (s = !0);
            for (; ;)
                if (r > 0) {
                    if (1 != n.nodeType)
                        break;
                    {
                        let e = n.childNodes[r - 1];
                        if (pr(e, -1))
                            o = n,
                                i = --r;
                        else {
                            if (3 != e.nodeType)
                                break;
                            n = e,
                                r = n.nodeValue.length
                        }
                    }
                } else {
                    if (mr(n))
                        break;
                    {
                        let t = n.previousSibling;
                        for (; t && pr(t, -1);)
                            o = n.parentNode,
                                i = Ot(t),
                                t = t.previousSibling;
                        if (t)
                            n = t,
                                r = hr(n);
                        else {
                            if (n = n.parentNode,
                                n == e.dom)
                                break;
                            r = 0
                        }
                    }
                }
            s ? gr(e, n, r) : o && gr(e, o, i)
        }(e) : function (e) {
            let t = e.domSelectionRange()
                , n = t.focusNode
                , r = t.focusOffset;
            if (!n)
                return;
            let o, i, s = hr(n);
            for (; ;)
                if (r < s) {
                    if (1 != n.nodeType)
                        break;
                    if (!pr(n.childNodes[r], 1))
                        break;
                    o = n,
                        i = ++r
                } else {
                    if (mr(n))
                        break;
                    {
                        let t = n.nextSibling;
                        for (; t && pr(t, 1);)
                            o = t.parentNode,
                                i = Ot(t) + 1,
                                t = t.nextSibling;
                        if (t)
                            n = t,
                                r = 0,
                                s = hr(n);
                        else {
                            if (n = n.parentNode,
                                n == e.dom)
                                break;
                            r = s = 0
                        }
                    }
                }
            o && gr(e, o, i)
        }(e)
    }
    function mr(e) {
        let t = e.pmViewDesc;
        return t && t.node && t.node.isBlock
    }
    function gr(e, t, n) {
        if (3 != t.nodeType) {
            let e, r;
            (r = function (e, t) {
                for (; e && t == e.childNodes.length && !Ht(e);)
                    t = Ot(e) + 1,
                        e = e.parentNode;
                for (; e && t < e.childNodes.length;) {
                    let n = e.childNodes[t];
                    if (3 == n.nodeType)
                        return n;
                    if (1 == n.nodeType && "false" == n.contentEditable)
                        break;
                    e = n,
                        t = 0
                }
            }(t, n)) ? (t = r,
                n = 0) : (e = function (e, t) {
                    for (; e && !t && !Ht(e);)
                        t = Ot(e),
                            e = e.parentNode;
                    for (; e && t;) {
                        let n = e.childNodes[t - 1];
                        if (3 == n.nodeType)
                            return n;
                        if (1 == n.nodeType && "false" == n.contentEditable)
                            break;
                        t = (e = n).childNodes.length
                    }
                }(t, n)) && (t = e,
                    n = e.nodeValue.length)
        }
        let r = e.domSelection();
        if (!r)
            return;
        if (zt(r)) {
            let e = document.createRange();
            e.setEnd(t, n),
                e.setStart(t, n),
                r.removeAllRanges(),
                r.addRange(e)
        } else
            r.extend && r.extend(t, n);
        e.domObserver.setCurSelection();
        let { state: o } = e;
        setTimeout((() => {
            e.state == o && Yn(e)
        }
        ), 50)
    }
    function br(e, t) {
        let n = e.state.doc.resolve(t);
        if (!Xt && !nn && n.parent.inlineContent) {
            let r = e.coordsAtPos(t);
            if (t > n.start()) {
                let n = e.coordsAtPos(t - 1)
                    , o = (n.top + n.bottom) / 2;
                if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1)
                    return n.left < r.left ? "ltr" : "rtl"
            }
            if (t < n.end()) {
                let n = e.coordsAtPos(t + 1)
                    , o = (n.top + n.bottom) / 2;
                if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1)
                    return n.left > r.left ? "ltr" : "rtl"
            }
        }
        return "rtl" == getComputedStyle(e.dom).direction ? "rtl" : "ltr"
    }
    function yr(e, t, n) {
        let r = e.state.selection;
        if (r instanceof ut && !r.empty || n.indexOf("s") > -1)
            return !1;
        if (tn && n.indexOf("m") > -1)
            return !1;
        let { $from: o, $to: i } = r;
        if (!o.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
            let n = cr(e.state, t);
            if (n && n instanceof pt)
                return dr(e, n)
        }
        if (!o.parent.inlineContent) {
            let n = t < 0 ? o : i
                , s = r instanceof mt ? at.near(n, t) : at.findFrom(n, t);
            return !!s && dr(e, s)
        }
        return !1
    }
    function vr(e, t) {
        if (!(e.state.selection instanceof ut))
            return !0;
        let { $head: n, $anchor: r, empty: o } = e.state.selection;
        if (!n.sameParent(r))
            return !0;
        if (!o)
            return !1;
        if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
            return !0;
        let i = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
        if (i && !i.isText) {
            let r = e.state.tr;
            return t < 0 ? r.delete(n.pos - i.nodeSize, n.pos) : r.delete(n.pos, n.pos + i.nodeSize),
                e.dispatch(r),
                !0
        }
        return !1
    }
    function wr(e, t, n) {
        e.domObserver.stop(),
            t.contentEditable = n,
            e.domObserver.start()
    }
    function kr(e, t) {
        let n = t.keyCode
            , r = function (e) {
                let t = "";
                return e.ctrlKey && (t += "c"),
                    e.metaKey && (t += "m"),
                    e.altKey && (t += "a"),
                    e.shiftKey && (t += "s"),
                    t
            }(t);
        if (8 == n || tn && 72 == n && "c" == r)
            return vr(e, -1) || fr(e, -1);
        if (46 == n && !t.shiftKey || tn && 68 == n && "c" == r)
            return vr(e, 1) || fr(e, 1);
        if (13 == n || 27 == n)
            return !0;
        if (37 == n || tn && 66 == n && "c" == r) {
            let t = 37 == n ? "ltr" == br(e, e.state.selection.from) ? -1 : 1 : -1;
            return ur(e, t, r) || fr(e, t)
        }
        if (39 == n || tn && 70 == n && "c" == r) {
            let t = 39 == n ? "ltr" == br(e, e.state.selection.from) ? 1 : -1 : 1;
            return ur(e, t, r) || fr(e, t)
        }
        return 38 == n || tn && 80 == n && "c" == r ? yr(e, -1, r) || fr(e, -1) : 40 == n || tn && 78 == n && "c" == r ? function (e) {
            if (!Yt || e.state.selection.$head.parentOffset > 0)
                return !1;
            let { focusNode: t, focusOffset: n } = e.domSelectionRange();
            if (t && 1 == t.nodeType && 0 == n && t.firstChild && "false" == t.firstChild.contentEditable) {
                let n = t.firstChild;
                wr(e, n, "true"),
                    setTimeout((() => wr(e, n, "false")), 20)
            }
            return !1
        }(e) || yr(e, 1, r) || fr(e, 1) : r == (tn ? "m" : "c") && (66 == n || 73 == n || 89 == n || 90 == n)
    }
    function Cr(e, t) {
        e.someProp("transformCopied", (n => {
            t = n(t, e)
        }
        ));
        let n = []
            , { content: r, openStart: o, openEnd: i } = t;
        for (; o > 1 && i > 1 && 1 == r.childCount && 1 == r.firstChild.childCount;) {
            o--,
                i--;
            let e = r.firstChild;
            n.push(e.type.name, e.attrs != e.type.defaultAttrs ? e.attrs : null),
                r = e.content
        }
        let s = e.someProp("clipboardSerializer") || ue.fromSchema(e.state.schema)
            , a = Pr()
            , l = a.createElement("div");
        l.appendChild(s.serializeFragment(r, {
            document: a
        }));
        let c, d = l.firstChild, u = 0;
        for (; d && 1 == d.nodeType && (c = Or[d.nodeName.toLowerCase()]);) {
            for (let e = c.length - 1; e >= 0; e--) {
                let t = a.createElement(c[e]);
                for (; l.firstChild;)
                    t.appendChild(l.firstChild);
                l.appendChild(t),
                    u++
            }
            d = l.firstChild
        }
        return d && 1 == d.nodeType && d.setAttribute("data-pm-slice", `${o} ${i}${u ? ` -${u}` : ""} ${JSON.stringify(n)}`),
        {
            dom: l,
            text: e.someProp("clipboardTextSerializer", (n => n(t, e))) || t.content.textBetween(0, t.content.size, "\n\n"),
            slice: t
        }
    }
    function Sr(e, t, n, r, o) {
        let i, s, a = o.parent.type.spec.code;
        if (!n && !t)
            return null;
        let l = t && (r || a || !n);
        if (l) {
            if (e.someProp("transformPastedText", (n => {
                t = n(t, a || r, e)
            }
            )),
                a)
                return t ? new g(d.from(e.state.schema.text(t.replace(/\r\n?/g, "\n"))), 0, 0) : g.empty;
            let n = e.someProp("clipboardTextParser", (n => n(t, o, r, e)));
            if (n)
                s = n;
            else {
                let n = o.marks()
                    , { schema: r } = e.state
                    , s = ue.fromSchema(r);
                i = document.createElement("div"),
                    t.split(/(?:\r\n?|\n)+/).forEach((e => {
                        let t = i.appendChild(document.createElement("p"));
                        e && t.appendChild(s.serializeNode(r.text(e, n)))
                    }
                    ))
            }
        } else
            e.someProp("transformPastedHTML", (t => {
                n = t(n, e)
            }
            )),
                i = function (e) {
                    let t = /^(\s*<meta [^>]*>)*/.exec(e);
                    t && (e = e.slice(t[0].length));
                    let n, r = Pr().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(e);
                    (n = o && Or[o[1].toLowerCase()]) && (e = n.map((e => "<" + e + ">")).join("") + e + n.map((e => "</" + e + ">")).reverse().join(""));
                    if (r.innerHTML = function (e) {
                        let t = window.trustedTypes;
                        return t ? t.createPolicy("detachedDocument", {
                            createHTML: e => e
                        }).createHTML(e) : e
                    }(e),
                        n)
                        for (let i = 0; i < n.length; i++)
                            r = r.querySelector(n[i]) || r;
                    return r
                }(n),
                on && function (e) {
                    let t = e.querySelectorAll(Xt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
                    for (let n = 0; n < t.length; n++) {
                        let r = t[n];
                        1 == r.childNodes.length && "\xa0" == r.textContent && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r)
                    }
                }(i);
        let c = i && i.querySelector("[data-pm-slice]")
            , u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
        if (u && u[3])
            for (let d = +u[3]; d > 0; d--) {
                let e = i.firstChild;
                for (; e && 1 != e.nodeType;)
                    e = e.nextSibling;
                if (!e)
                    break;
                i = e
            }
        if (!s) {
            let t = e.someProp("clipboardParser") || e.someProp("domParser") || te.fromSchema(e.state.schema);
            s = t.parseSlice(i, {
                preserveWhitespace: !(!l && !u),
                context: o,
                ruleFromNode: e => "BR" != e.nodeName || e.nextSibling || !e.parentNode || xr.test(e.parentNode.nodeName) ? null : {
                    ignore: !0
                }
            })
        }
        if (u)
            s = function (e, t) {
                if (!e.size)
                    return e;
                let n, r = e.content.firstChild.type.schema;
                try {
                    n = JSON.parse(t)
                } catch (a) {
                    return e
                }
                let { content: o, openStart: i, openEnd: s } = e;
                for (let l = n.length - 2; l >= 0; l -= 2) {
                    let e = r.nodes[n[l]];
                    if (!e || e.hasRequiredAttrs())
                        break;
                    o = d.from(e.create(n[l + 1], o)),
                        i++,
                        s++
                }
                return new g(o, i, s)
            }(_r(s, +u[1], +u[2]), u[4]);
        else if (s = g.maxOpen(function (e, t) {
            if (e.childCount < 2)
                return e;
            for (let n = t.depth; n >= 0; n--) {
                let r, o = t.node(n).contentMatchAt(t.index(n)), i = [];
                if (e.forEach((e => {
                    if (!i)
                        return;
                    let t, n = o.findWrapping(e.type);
                    if (!n)
                        return i = null;
                    if (t = i.length && r.length && Mr(n, r, e, i[i.length - 1], 0))
                        i[i.length - 1] = t;
                    else {
                        i.length && (i[i.length - 1] = Tr(i[i.length - 1], r.length));
                        let t = Er(e, n);
                        i.push(t),
                            o = o.matchType(t.type),
                            r = n
                    }
                }
                )),
                    i)
                    return d.from(i)
            }
            return e
        }(s.content, o), !0),
            s.openStart || s.openEnd) {
            let e = 0
                , t = 0;
            for (let n = s.content.firstChild; e < s.openStart && !n.type.spec.isolating; e++,
                n = n.firstChild)
                ;
            for (let n = s.content.lastChild; t < s.openEnd && !n.type.spec.isolating; t++,
                n = n.lastChild)
                ;
            s = _r(s, e, t)
        }
        return e.someProp("transformPasted", (t => {
            s = t(s, e)
        }
        )),
            s
    }
    const xr = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function Er(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        for (let r = t.length - 1; r >= n; r--)
            e = t[r].create(null, d.from(e));
        return e
    }
    function Mr(e, t, n, r, o) {
        if (o < e.length && o < t.length && e[o] == t[o]) {
            let i = Mr(e, t, n, r.lastChild, o + 1);
            if (i)
                return r.copy(r.content.replaceChild(r.childCount - 1, i));
            if (r.contentMatchAt(r.childCount).matchType(o == e.length - 1 ? n.type : e[o + 1]))
                return r.copy(r.content.append(d.from(Er(n, e, o + 1))))
        }
    }
    function Tr(e, t) {
        if (0 == t)
            return e;
        let n = e.content.replaceChild(e.childCount - 1, Tr(e.lastChild, t - 1))
            , r = e.contentMatchAt(e.childCount).fillBefore(d.empty, !0);
        return e.copy(n.append(r))
    }
    function Nr(e, t, n, r, o, i) {
        let s = t < 0 ? e.firstChild : e.lastChild
            , a = s.content;
        return e.childCount > 1 && (i = 0),
            o < r - 1 && (a = Nr(a, t, n, r, o + 1, i)),
            o >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(d.empty, !0))),
            e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a))
    }
    function _r(e, t, n) {
        return t < e.openStart && (e = new g(Nr(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)),
            n < e.openEnd && (e = new g(Nr(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)),
            e
    }
    const Or = {
        thead: ["table"],
        tbody: ["table"],
        tfoot: ["table"],
        caption: ["table"],
        colgroup: ["table"],
        col: ["table", "colgroup"],
        tr: ["table", "tbody"],
        td: ["table", "tbody", "tr"],
        th: ["table", "tbody", "tr"]
    };
    let Ar = null;
    function Pr() {
        return Ar || (Ar = document.implementation.createHTMLDocument("title"))
    }
    const Lr = {}
        , Rr = {}
        , Dr = {
            touchstart: !0,
            touchmove: !0
        };
    class Ir {
        constructor() {
            this.shiftKey = !1,
                this.mouseDown = null,
                this.lastKeyCode = null,
                this.lastKeyCodeTime = 0,
                this.lastClick = {
                    time: 0,
                    x: 0,
                    y: 0,
                    type: ""
                },
                this.lastSelectionOrigin = null,
                this.lastSelectionTime = 0,
                this.lastIOSEnter = 0,
                this.lastIOSEnterFallbackTimeout = -1,
                this.lastFocus = 0,
                this.lastTouch = 0,
                this.lastAndroidDelete = 0,
                this.composing = !1,
                this.compositionNode = null,
                this.composingTimeout = -1,
                this.compositionNodes = [],
                this.compositionEndedAt = -2e8,
                this.compositionID = 1,
                this.compositionPendingChanges = 0,
                this.domChangeCount = 0,
                this.eventHandlers = Object.create(null),
                this.hideSelectionGuard = null
        }
    }
    function jr(e, t) {
        e.input.lastSelectionOrigin = t,
            e.input.lastSelectionTime = Date.now()
    }
    function Hr(e) {
        e.someProp("handleDOMEvents", (t => {
            for (let n in t)
                e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = t => zr(e, t))
        }
        ))
    }
    function zr(e, t) {
        return e.someProp("handleDOMEvents", (n => {
            let r = n[t.type];
            return !!r && (r(e, t) || t.defaultPrevented)
        }
        ))
    }
    function $r(e, t) {
        if (!t.bubbles)
            return !0;
        if (t.defaultPrevented)
            return !1;
        for (let n = t.target; n != e.dom; n = n.parentNode)
            if (!n || 11 == n.nodeType || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
                return !1;
        return !0
    }
    function Br(e) {
        return {
            left: e.clientX,
            top: e.clientY
        }
    }
    function Vr(e, t, n, r, o) {
        if (-1 == r)
            return !1;
        let i = e.state.doc.resolve(r);
        for (let s = i.depth + 1; s > 0; s--)
            if (e.someProp(t, (t => s > i.depth ? t(e, n, i.nodeAfter, i.before(s), o, !0) : t(e, n, i.node(s), i.before(s), o, !1))))
                return !0;
        return !1
    }
    function Fr(e, t, n) {
        if (e.focused || e.focus(),
            e.state.selection.eq(t))
            return;
        let r = e.state.tr.setSelection(t);
        "pointer" == n && r.setMeta("pointer", !0),
            e.dispatch(r)
    }
    function Ur(e, t, n, r, o) {
        return Vr(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (n => n(e, t, r))) || (o ? function (e, t) {
            if (-1 == t)
                return !1;
            let n, r, o = e.state.selection;
            o instanceof pt && (n = o.node);
            let i = e.state.doc.resolve(t);
            for (let s = i.depth + 1; s > 0; s--) {
                let e = s > i.depth ? i.nodeAfter : i.node(s);
                if (pt.isSelectable(e)) {
                    r = n && o.$from.depth > 0 && s >= o.$from.depth && i.before(o.$from.depth + 1) == o.$from.pos ? i.before(o.$from.depth) : i.before(s);
                    break
                }
            }
            return null != r && (Fr(e, pt.create(e.state.doc, r), "pointer"),
                !0)
        }(e, n) : function (e, t) {
            if (-1 == t)
                return !1;
            let n = e.state.doc.resolve(t)
                , r = n.nodeAfter;
            return !!(r && r.isAtom && pt.isSelectable(r)) && (Fr(e, new pt(n), "pointer"),
                !0)
        }(e, n))
    }
    function Wr(e, t, n, r) {
        return Vr(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (n => n(e, t, r)))
    }
    function qr(e, t, n, r) {
        return Vr(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (n => n(e, t, r))) || function (e, t, n) {
            if (0 != n.button)
                return !1;
            let r = e.state.doc;
            if (-1 == t)
                return !!r.inlineContent && (Fr(e, ut.create(r, 0, r.content.size), "pointer"),
                    !0);
            let o = r.resolve(t);
            for (let i = o.depth + 1; i > 0; i--) {
                let t = i > o.depth ? o.nodeAfter : o.node(i)
                    , n = o.before(i);
                if (t.inlineContent)
                    Fr(e, ut.create(r, n + 1, n + 1 + t.content.size), "pointer");
                else {
                    if (!pt.isSelectable(t))
                        continue;
                    Fr(e, pt.create(r, n), "pointer")
                }
                return !0
            }
        }(e, n, r)
    }
    function Gr(e) {
        return to(e)
    }
    Rr.keydown = (e, t) => {
        let n = t;
        if (e.input.shiftKey = 16 == n.keyCode || n.shiftKey,
            !Zr(e, n) && (e.input.lastKeyCode = n.keyCode,
                e.input.lastKeyCodeTime = Date.now(),
                !rn || !Xt || 13 != n.keyCode))
            if (229 != n.keyCode && e.domObserver.forceFlush(),
                !en || 13 != n.keyCode || n.ctrlKey || n.altKey || n.metaKey)
                e.someProp("handleKeyDown", (t => t(e, n))) || kr(e, n) ? n.preventDefault() : jr(e, "key");
            else {
                let t = Date.now();
                e.input.lastIOSEnter = t,
                    e.input.lastIOSEnterFallbackTimeout = setTimeout((() => {
                        e.input.lastIOSEnter == t && (e.someProp("handleKeyDown", (t => t(e, $t(13, "Enter")))),
                            e.input.lastIOSEnter = 0)
                    }
                    ), 200)
            }
    }
        ,
        Rr.keyup = (e, t) => {
            16 == t.keyCode && (e.input.shiftKey = !1)
        }
        ,
        Rr.keypress = (e, t) => {
            let n = t;
            if (Zr(e, n) || !n.charCode || n.ctrlKey && !n.altKey || tn && n.metaKey)
                return;
            if (e.someProp("handleKeyPress", (t => t(e, n))))
                return void n.preventDefault();
            let r = e.state.selection;
            if (!(r instanceof ut) || !r.$from.sameParent(r.$to)) {
                let t = String.fromCharCode(n.charCode);
                /[\r\n]/.test(t) || e.someProp("handleTextInput", (n => n(e, r.$from.pos, r.$to.pos, t))) || e.dispatch(e.state.tr.insertText(t).scrollIntoView()),
                    n.preventDefault()
            }
        }
        ;
    const Kr = tn ? "metaKey" : "ctrlKey";
    Lr.mousedown = (e, t) => {
        let n = t;
        e.input.shiftKey = n.shiftKey;
        let r = Gr(e)
            , o = Date.now()
            , i = "singleClick";
        o - e.input.lastClick.time < 500 && function (e, t) {
            let n = t.x - e.clientX
                , r = t.y - e.clientY;
            return n * n + r * r < 100
        }(n, e.input.lastClick) && !n[Kr] && ("singleClick" == e.input.lastClick.type ? i = "doubleClick" : "doubleClick" == e.input.lastClick.type && (i = "tripleClick")),
            e.input.lastClick = {
                time: o,
                x: n.clientX,
                y: n.clientY,
                type: i
            };
        let s = e.posAtCoords(Br(n));
        s && ("singleClick" == i ? (e.input.mouseDown && e.input.mouseDown.done(),
            e.input.mouseDown = new Jr(e, s, n, !!r)) : ("doubleClick" == i ? Wr : qr)(e, s.pos, s.inside, n) ? n.preventDefault() : jr(e, "pointer"))
    }
        ;
    class Jr {
        constructor(e, t, n, r) {
            let o, i;
            if (this.view = e,
                this.pos = t,
                this.event = n,
                this.flushed = r,
                this.delayedSelectionSync = !1,
                this.mightDrag = null,
                this.startDoc = e.state.doc,
                this.selectNode = !!n[Kr],
                this.allowDefault = n.shiftKey,
                t.inside > -1)
                o = e.state.doc.nodeAt(t.inside),
                    i = t.inside;
            else {
                let n = e.state.doc.resolve(t.pos);
                o = n.parent,
                    i = n.depth ? n.before() : 0
            }
            const s = r ? null : n.target
                , a = s ? e.docView.nearestDesc(s, !0) : null;
            this.target = a && 1 == a.dom.nodeType ? a.dom : null;
            let { selection: l } = e.state;
            (0 == n.button && o.type.spec.draggable && !1 !== o.type.spec.selectable || l instanceof pt && l.from <= i && l.to > i) && (this.mightDrag = {
                node: o,
                pos: i,
                addAttr: !(!this.target || this.target.draggable),
                setUneditable: !(!this.target || !Jt || this.target.hasAttribute("contentEditable"))
            }),
                this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(),
                    this.mightDrag.addAttr && (this.target.draggable = !0),
                    this.mightDrag.setUneditable && setTimeout((() => {
                        this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
                    }
                    ), 20),
                    this.view.domObserver.start()),
                e.root.addEventListener("mouseup", this.up = this.up.bind(this)),
                e.root.addEventListener("mousemove", this.move = this.move.bind(this)),
                jr(e, "pointer")
        }
        done() {
            this.view.root.removeEventListener("mouseup", this.up),
                this.view.root.removeEventListener("mousemove", this.move),
                this.mightDrag && this.target && (this.view.domObserver.stop(),
                    this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
                    this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
                    this.view.domObserver.start()),
                this.delayedSelectionSync && setTimeout((() => Yn(this.view))),
                this.view.input.mouseDown = null
        }
        up(e) {
            if (this.done(),
                !this.view.dom.contains(e.target))
                return;
            let t = this.pos;
            this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Br(e))),
                this.updateAllowDefault(e),
                this.allowDefault || !t ? jr(this.view, "pointer") : Ur(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : 0 == e.button && (this.flushed || Yt && this.mightDrag && !this.mightDrag.node.isAtom || Xt && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Fr(this.view, at.near(this.view.state.doc.resolve(t.pos)), "pointer"),
                    e.preventDefault()) : jr(this.view, "pointer")
        }
        move(e) {
            this.updateAllowDefault(e),
                jr(this.view, "pointer"),
                0 == e.buttons && this.done()
        }
        updateAllowDefault(e) {
            !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0)
        }
    }
    function Zr(e, t) {
        return !!e.composing || !!(Yt && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500) && (e.input.compositionEndedAt = -2e8,
            !0)
    }
    Lr.touchstart = e => {
        e.input.lastTouch = Date.now(),
            Gr(e),
            jr(e, "pointer")
    }
        ,
        Lr.touchmove = e => {
            e.input.lastTouch = Date.now(),
                jr(e, "pointer")
        }
        ,
        Lr.contextmenu = e => Gr(e);
    const Xr = rn ? 5e3 : -1;
    function Qr(e, t) {
        clearTimeout(e.input.composingTimeout),
            t > -1 && (e.input.composingTimeout = setTimeout((() => to(e)), t))
    }
    function Yr(e) {
        for (e.composing && (e.input.composing = !1,
            e.input.compositionEndedAt = function () {
                let e = document.createEvent("Event");
                return e.initEvent("event", !0, !0),
                    e.timeStamp
            }()); e.input.compositionNodes.length > 0;)
            e.input.compositionNodes.pop().markParentsDirty()
    }
    function eo(e) {
        let t = e.domSelectionRange();
        if (!t.focusNode)
            return null;
        let n = function (e, t) {
            for (; ;) {
                if (3 == e.nodeType && t)
                    return e;
                if (1 == e.nodeType && t > 0) {
                    if ("false" == e.contentEditable)
                        return null;
                    t = jt(e = e.childNodes[t - 1])
                } else {
                    if (!e.parentNode || Ht(e))
                        return null;
                    t = Ot(e),
                        e = e.parentNode
                }
            }
        }(t.focusNode, t.focusOffset)
            , r = function (e, t) {
                for (; ;) {
                    if (3 == e.nodeType && t < e.nodeValue.length)
                        return e;
                    if (1 == e.nodeType && t < e.childNodes.length) {
                        if ("false" == e.contentEditable)
                            return null;
                        e = e.childNodes[t],
                            t = 0
                    } else {
                        if (!e.parentNode || Ht(e))
                            return null;
                        t = Ot(e) + 1,
                            e = e.parentNode
                    }
                }
            }(t.focusNode, t.focusOffset);
        if (n && r && n != r) {
            let t = r.pmViewDesc
                , o = e.domObserver.lastChangedTextNode;
            if (n == o || r == o)
                return o;
            if (!t || !t.isText(r.nodeValue))
                return r;
            if (e.input.compositionNode == r) {
                let e = n.pmViewDesc;
                if (e && e.isText(n.nodeValue))
                    return r
            }
        }
        return n || r
    }
    function to(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!(rn && e.domObserver.flushingSoon >= 0)) {
            if (e.domObserver.forceFlush(),
                Yr(e),
                t || e.docView && e.docView.dirty) {
                let n = Xn(e);
                return n && !n.eq(e.state.selection) ? e.dispatch(e.state.tr.setSelection(n)) : !e.markCursor && !t || e.state.selection.empty ? e.updateState(e.state) : e.dispatch(e.state.tr.deleteSelection()),
                    !0
            }
            return !1
        }
    }
    Rr.compositionstart = Rr.compositionupdate = e => {
        if (!e.composing) {
            e.domObserver.flush();
            let { state: t } = e
                , n = t.selection.$to;
            if (t.selection instanceof ut && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((e => !1 === e.type.spec.inclusive))))
                e.markCursor = e.state.storedMarks || n.marks(),
                    to(e, !0),
                    e.markCursor = null;
            else if (to(e, !t.selection.empty),
                Jt && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
                let t = e.domSelectionRange();
                for (let n = t.focusNode, r = t.focusOffset; n && 1 == n.nodeType && 0 != r;) {
                    let t = r < 0 ? n.lastChild : n.childNodes[r - 1];
                    if (!t)
                        break;
                    if (3 == t.nodeType) {
                        let n = e.domSelection();
                        n && n.collapse(t, t.nodeValue.length);
                        break
                    }
                    n = t,
                        r = -1
                }
            }
            e.input.composing = !0
        }
        Qr(e, Xr)
    }
        ,
        Rr.compositionend = (e, t) => {
            e.composing && (e.input.composing = !1,
                e.input.compositionEndedAt = t.timeStamp,
                e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0,
                e.input.compositionNode = null,
                e.input.compositionPendingChanges && Promise.resolve().then((() => e.domObserver.flush())),
                e.input.compositionID++,
                Qr(e, 20))
        }
        ;
    const no = Gt && Kt < 15 || en && sn < 604;
    function ro(e, t, n, r, o) {
        let i = Sr(e, t, n, r, e.state.selection.$from);
        if (e.someProp("handlePaste", (t => t(e, o, i || g.empty))))
            return !0;
        if (!i)
            return !1;
        let s = function (e) {
            return 0 == e.openStart && 0 == e.openEnd && 1 == e.content.childCount ? e.content.firstChild : null
        }(i)
            , a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(i);
        return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
            !0
    }
    function oo(e) {
        let t = e.getData("text/plain") || e.getData("Text");
        if (t)
            return t;
        let n = e.getData("text/uri-list");
        return n ? n.replace(/\r?\n/g, " ") : ""
    }
    Lr.copy = Rr.cut = (e, t) => {
        let n = t
            , r = e.state.selection
            , o = "cut" == n.type;
        if (r.empty)
            return;
        let i = no ? null : n.clipboardData
            , s = r.content()
            , { dom: a, text: l } = Cr(e, s);
        i ? (n.preventDefault(),
            i.clearData(),
            i.setData("text/html", a.innerHTML),
            i.setData("text/plain", l)) : function (e, t) {
                if (!e.dom.parentNode)
                    return;
                let n = e.dom.parentNode.appendChild(document.createElement("div"));
                n.appendChild(t),
                    n.style.cssText = "position: fixed; left: -10000px; top: 10px";
                let r = getSelection()
                    , o = document.createRange();
                o.selectNodeContents(t),
                    e.dom.blur(),
                    r.removeAllRanges(),
                    r.addRange(o),
                    setTimeout((() => {
                        n.parentNode && n.parentNode.removeChild(n),
                            e.focus()
                    }
                    ), 50)
            }(e, a),
            o && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
    }
        ,
        Rr.paste = (e, t) => {
            let n = t;
            if (e.composing && !rn)
                return;
            let r = no ? null : n.clipboardData
                , o = e.input.shiftKey && 45 != e.input.lastKeyCode;
            r && ro(e, oo(r), r.getData("text/html"), o, n) ? n.preventDefault() : function (e, t) {
                if (!e.dom.parentNode)
                    return;
                let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code
                    , r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
                n || (r.contentEditable = "true"),
                    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
                    r.focus();
                let o = e.input.shiftKey && 45 != e.input.lastKeyCode;
                setTimeout((() => {
                    e.focus(),
                        r.parentNode && r.parentNode.removeChild(r),
                        n ? ro(e, r.value, null, o, t) : ro(e, r.textContent, r.innerHTML, o, t)
                }
                ), 50)
            }(e, n)
        }
        ;
    class io {
        constructor(e, t, n) {
            this.slice = e,
                this.move = t,
                this.node = n
        }
    }
    const so = tn ? "altKey" : "ctrlKey";
    Lr.dragstart = (e, t) => {
        let n = t
            , r = e.input.mouseDown;
        if (r && r.done(),
            !n.dataTransfer)
            return;
        let o, i = e.state.selection, s = i.empty ? null : e.posAtCoords(Br(n));
        if (s && s.pos >= i.from && s.pos <= (i instanceof pt ? i.to - 1 : i.to))
            ;
        else if (r && r.mightDrag)
            o = pt.create(e.state.doc, r.mightDrag.pos);
        else if (n.target && 1 == n.target.nodeType) {
            let t = e.docView.nearestDesc(n.target, !0);
            t && t.node.type.spec.draggable && t != e.docView && (o = pt.create(e.state.doc, t.posBefore))
        }
        let a = (o || e.state.selection).content()
            , { dom: l, text: c, slice: d } = Cr(e, a);
        (!n.dataTransfer.files.length || !Xt || Qt > 120) && n.dataTransfer.clearData(),
            n.dataTransfer.setData(no ? "Text" : "text/html", l.innerHTML),
            n.dataTransfer.effectAllowed = "copyMove",
            no || n.dataTransfer.setData("text/plain", c),
            e.dragging = new io(d, !n[so], o)
    }
        ,
        Lr.dragend = e => {
            let t = e.dragging;
            window.setTimeout((() => {
                e.dragging == t && (e.dragging = null)
            }
            ), 50)
        }
        ,
        Rr.dragover = Rr.dragenter = (e, t) => t.preventDefault(),
        Rr.drop = (e, t) => {
            let n = t
                , r = e.dragging;
            if (e.dragging = null,
                !n.dataTransfer)
                return;
            let o = e.posAtCoords(Br(n));
            if (!o)
                return;
            let i = e.state.doc.resolve(o.pos)
                , s = r && r.slice;
            s ? e.someProp("transformPasted", (t => {
                s = t(s, e)
            }
            )) : s = Sr(e, oo(n.dataTransfer), no ? null : n.dataTransfer.getData("text/html"), !1, i);
            let a = !(!r || n[so]);
            if (e.someProp("handleDrop", (t => t(e, n, s || g.empty, a))))
                return void n.preventDefault();
            if (!s)
                return;
            n.preventDefault();
            let l = s ? We(e.state.doc, i.pos, s) : i.pos;
            null == l && (l = i.pos);
            let c = e.state.tr;
            if (a) {
                let { node: e } = r;
                e ? e.replace(c) : c.deleteSelection()
            }
            let d = c.mapping.map(l)
                , u = 0 == s.openStart && 0 == s.openEnd && 1 == s.content.childCount
                , h = c.doc;
            if (u ? c.replaceRangeWith(d, d, s.content.firstChild) : c.replaceRange(d, d, s),
                c.doc.eq(h))
                return;
            let p = c.doc.resolve(d);
            if (u && pt.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild))
                c.setSelection(new pt(p));
            else {
                let t = c.mapping.map(l);
                c.mapping.maps[c.mapping.maps.length - 1].forEach(((e, n, r, o) => t = o)),
                    c.setSelection(sr(e, p, c.doc.resolve(t)))
            }
            e.focus(),
                e.dispatch(c.setMeta("uiEvent", "drop"))
        }
        ,
        Lr.focus = e => {
            e.input.lastFocus = Date.now(),
                e.focused || (e.domObserver.stop(),
                    e.dom.classList.add("ProseMirror-focused"),
                    e.domObserver.start(),
                    e.focused = !0,
                    setTimeout((() => {
                        e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Yn(e)
                    }
                    ), 20))
        }
        ,
        Lr.blur = (e, t) => {
            let n = t;
            e.focused && (e.domObserver.stop(),
                e.dom.classList.remove("ProseMirror-focused"),
                e.domObserver.start(),
                n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(),
                e.focused = !1)
        }
        ,
        Lr.beforeinput = (e, t) => {
            if (Xt && rn && "deleteContentBackward" == t.inputType) {
                e.domObserver.flushSoon();
                let { domChangeCount: t } = e.input;
                setTimeout((() => {
                    if (e.input.domChangeCount != t)
                        return;
                    if (e.dom.blur(),
                        e.focus(),
                        e.someProp("handleKeyDown", (t => t(e, $t(8, "Backspace")))))
                        return;
                    let { $cursor: n } = e.state.selection;
                    n && n.pos > 0 && e.dispatch(e.state.tr.delete(n.pos - 1, n.pos).scrollIntoView())
                }
                ), 50)
            }
        }
        ;
    for (let os in Rr)
        Lr[os] = Rr[os];
    function ao(e, t) {
        if (e == t)
            return !0;
        for (let n in e)
            if (e[n] !== t[n])
                return !1;
        for (let n in t)
            if (!(n in e))
                return !1;
        return !0
    }
    class lo {
        constructor(e, t) {
            this.toDOM = e,
                this.spec = t || fo,
                this.side = this.spec.side || 0
        }
        map(e, t, n, r) {
            let { pos: o, deleted: i } = e.mapResult(t.from + r, this.side < 0 ? -1 : 1);
            return i ? null : new ho(o - n, o - n, this)
        }
        valid() {
            return !0
        }
        eq(e) {
            return this == e || e instanceof lo && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && ao(this.spec, e.spec))
        }
        destroy(e) {
            this.spec.destroy && this.spec.destroy(e)
        }
    }
    class co {
        constructor(e, t) {
            this.attrs = e,
                this.spec = t || fo
        }
        map(e, t, n, r) {
            let o = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - n
                , i = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - n;
            return o >= i ? null : new ho(o, i, this)
        }
        valid(e, t) {
            return t.from < t.to
        }
        eq(e) {
            return this == e || e instanceof co && ao(this.attrs, e.attrs) && ao(this.spec, e.spec)
        }
        static is(e) {
            return e.type instanceof co
        }
        destroy() { }
    }
    class uo {
        constructor(e, t) {
            this.attrs = e,
                this.spec = t || fo
        }
        map(e, t, n, r) {
            let o = e.mapResult(t.from + r, 1);
            if (o.deleted)
                return null;
            let i = e.mapResult(t.to + r, -1);
            return i.deleted || i.pos <= o.pos ? null : new ho(o.pos - n, i.pos - n, this)
        }
        valid(e, t) {
            let n, { index: r, offset: o } = e.content.findIndex(t.from);
            return o == t.from && !(n = e.child(r)).isText && o + n.nodeSize == t.to
        }
        eq(e) {
            return this == e || e instanceof uo && ao(this.attrs, e.attrs) && ao(this.spec, e.spec)
        }
        destroy() { }
    }
    class ho {
        constructor(e, t, n) {
            this.from = e,
                this.to = t,
                this.type = n
        }
        copy(e, t) {
            return new ho(e, t, this.type)
        }
        eq(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to
        }
        map(e, t, n) {
            return this.type.map(e, this, t, n)
        }
        static widget(e, t, n) {
            return new ho(e, e, new lo(t, n))
        }
        static inline(e, t, n, r) {
            return new ho(e, t, new co(n, r))
        }
        static node(e, t, n, r) {
            return new ho(e, t, new uo(n, r))
        }
        get spec() {
            return this.type.spec
        }
        get inline() {
            return this.type instanceof co
        }
        get widget() {
            return this.type instanceof lo
        }
    }
    const po = []
        , fo = {};
    class mo {
        constructor(e, t) {
            this.local = e.length ? e : po,
                this.children = t.length ? t : po
        }
        static create(e, t) {
            return t.length ? ko(t, e, 0, fo) : go
        }
        find(e, t, n) {
            let r = [];
            return this.findInner(null == e ? 0 : e, null == t ? 1e9 : t, r, 0, n),
                r
        }
        findInner(e, t, n, r, o) {
            for (let i = 0; i < this.local.length; i++) {
                let s = this.local[i];
                s.from <= t && s.to >= e && (!o || o(s.spec)) && n.push(s.copy(s.from + r, s.to + r))
            }
            for (let i = 0; i < this.children.length; i += 3)
                if (this.children[i] < t && this.children[i + 1] > e) {
                    let s = this.children[i] + 1;
                    this.children[i + 2].findInner(e - s, t - s, n, r + s, o)
                }
        }
        map(e, t, n) {
            return this == go || 0 == e.maps.length ? this : this.mapInner(e, t, 0, 0, n || fo)
        }
        mapInner(e, t, n, r, o) {
            let i;
            for (let s = 0; s < this.local.length; s++) {
                let a = this.local[s].map(e, n, r);
                a && a.type.valid(t, a) ? (i || (i = [])).push(a) : o.onRemove && o.onRemove(this.local[s].spec)
            }
            return this.children.length ? function (e, t, n, r, o, i, s) {
                let a = e.slice();
                for (let c = 0, d = i; c < n.maps.length; c++) {
                    let e = 0;
                    n.maps[c].forEach(((t, n, r, o) => {
                        let i = o - r - (n - t);
                        for (let s = 0; s < a.length; s += 3) {
                            let r = a[s + 1];
                            if (r < 0 || t > r + d - e)
                                continue;
                            let o = a[s] + d - e;
                            n >= o ? a[s + 1] = t <= o ? -2 : -1 : t >= d && i && (a[s] += i,
                                a[s + 1] += i)
                        }
                        e += i
                    }
                    )),
                        d = n.maps[c].map(d, -1)
                }
                let l = !1;
                for (let c = 0; c < a.length; c += 3)
                    if (a[c + 1] < 0) {
                        if (-2 == a[c + 1]) {
                            l = !0,
                                a[c + 1] = -1;
                            continue
                        }
                        let t = n.map(e[c] + i)
                            , d = t - o;
                        if (d < 0 || d >= r.content.size) {
                            l = !0;
                            continue
                        }
                        let u = n.map(e[c + 1] + i, -1) - o
                            , { index: h, offset: p } = r.content.findIndex(d)
                            , f = r.maybeChild(h);
                        if (f && p == d && p + f.nodeSize == u) {
                            let r = a[c + 2].mapInner(n, f, t + 1, e[c] + i + 1, s);
                            r != go ? (a[c] = d,
                                a[c + 1] = u,
                                a[c + 2] = r) : (a[c + 1] = -2,
                                    l = !0)
                        } else
                            l = !0
                    }
                if (l) {
                    let l = function (e, t, n, r, o, i, s) {
                        function a(e, t) {
                            for (let i = 0; i < e.local.length; i++) {
                                let a = e.local[i].map(r, o, t);
                                a ? n.push(a) : s.onRemove && s.onRemove(e.local[i].spec)
                            }
                            for (let n = 0; n < e.children.length; n += 3)
                                a(e.children[n + 2], e.children[n] + t + 1)
                        }
                        for (let l = 0; l < e.length; l += 3)
                            -1 == e[l + 1] && a(e[l + 2], t[l] + i + 1);
                        return n
                    }(a, e, t, n, o, i, s)
                        , c = ko(l, r, 0, s);
                    t = c.local;
                    for (let e = 0; e < a.length; e += 3)
                        a[e + 1] < 0 && (a.splice(e, 3),
                            e -= 3);
                    for (let e = 0, t = 0; e < c.children.length; e += 3) {
                        let n = c.children[e];
                        for (; t < a.length && a[t] < n;)
                            t += 3;
                        a.splice(t, 0, c.children[e], c.children[e + 1], c.children[e + 2])
                    }
                }
                return new mo(t.sort(Co), a)
            }(this.children, i || [], e, t, n, r, o) : i ? new mo(i.sort(Co), po) : go
        }
        add(e, t) {
            return t.length ? this == go ? mo.create(e, t) : this.addInner(e, t, 0) : this
        }
        addInner(e, t, n) {
            let r, o = 0;
            e.forEach(((e, i) => {
                let s, a = i + n;
                if (s = vo(t, e, a)) {
                    for (r || (r = this.children.slice()); o < r.length && r[o] < i;)
                        o += 3;
                    r[o] == i ? r[o + 2] = r[o + 2].addInner(e, s, a + 1) : r.splice(o, 0, i, i + e.nodeSize, ko(s, e, a + 1, fo)),
                        o += 3
                }
            }
            ));
            let i = yo(o ? wo(t) : t, -n);
            for (let s = 0; s < i.length; s++)
                i[s].type.valid(e, i[s]) || i.splice(s--, 1);
            return new mo(i.length ? this.local.concat(i).sort(Co) : this.local, r || this.children)
        }
        remove(e) {
            return 0 == e.length || this == go ? this : this.removeInner(e, 0)
        }
        removeInner(e, t) {
            let n = this.children
                , r = this.local;
            for (let o = 0; o < n.length; o += 3) {
                let r, i = n[o] + t, s = n[o + 1] + t;
                for (let t, n = 0; n < e.length; n++)
                    (t = e[n]) && t.from > i && t.to < s && (e[n] = null,
                        (r || (r = [])).push(t));
                if (!r)
                    continue;
                n == this.children && (n = this.children.slice());
                let a = n[o + 2].removeInner(r, i + 1);
                a != go ? n[o + 2] = a : (n.splice(o, 3),
                    o -= 3)
            }
            if (r.length)
                for (let o, i = 0; i < e.length; i++)
                    if (o = e[i])
                        for (let e = 0; e < r.length; e++)
                            r[e].eq(o, t) && (r == this.local && (r = this.local.slice()),
                                r.splice(e--, 1));
            return n == this.children && r == this.local ? this : r.length || n.length ? new mo(r, n) : go
        }
        forChild(e, t) {
            if (this == go)
                return this;
            if (t.isLeaf)
                return mo.empty;
            let n, r;
            for (let s = 0; s < this.children.length; s += 3)
                if (this.children[s] >= e) {
                    this.children[s] == e && (n = this.children[s + 2]);
                    break
                }
            let o = e + 1
                , i = o + t.content.size;
            for (let s = 0; s < this.local.length; s++) {
                let e = this.local[s];
                if (e.from < i && e.to > o && e.type instanceof co) {
                    let t = Math.max(o, e.from) - o
                        , n = Math.min(i, e.to) - o;
                    t < n && (r || (r = [])).push(e.copy(t, n))
                }
            }
            if (r) {
                let e = new mo(r.sort(Co), po);
                return n ? new bo([e, n]) : e
            }
            return n || go
        }
        eq(e) {
            if (this == e)
                return !0;
            if (!(e instanceof mo) || this.local.length != e.local.length || this.children.length != e.children.length)
                return !1;
            for (let t = 0; t < this.local.length; t++)
                if (!this.local[t].eq(e.local[t]))
                    return !1;
            for (let t = 0; t < this.children.length; t += 3)
                if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
                    return !1;
            return !0
        }
        locals(e) {
            return So(this.localsInner(e))
        }
        localsInner(e) {
            if (this == go)
                return po;
            if (e.inlineContent || !this.local.some(co.is))
                return this.local;
            let t = [];
            for (let n = 0; n < this.local.length; n++)
                this.local[n].type instanceof co || t.push(this.local[n]);
            return t
        }
        forEachSet(e) {
            e(this)
        }
    }
    mo.empty = new mo([], []),
        mo.removeOverlap = So;
    const go = mo.empty;
    class bo {
        constructor(e) {
            this.members = e
        }
        map(e, t) {
            const n = this.members.map((n => n.map(e, t, fo)));
            return bo.from(n)
        }
        forChild(e, t) {
            if (t.isLeaf)
                return mo.empty;
            let n = [];
            for (let r = 0; r < this.members.length; r++) {
                let o = this.members[r].forChild(e, t);
                o != go && (o instanceof bo ? n = n.concat(o.members) : n.push(o))
            }
            return bo.from(n)
        }
        eq(e) {
            if (!(e instanceof bo) || e.members.length != this.members.length)
                return !1;
            for (let t = 0; t < this.members.length; t++)
                if (!this.members[t].eq(e.members[t]))
                    return !1;
            return !0
        }
        locals(e) {
            let t, n = !0;
            for (let r = 0; r < this.members.length; r++) {
                let o = this.members[r].localsInner(e);
                if (o.length)
                    if (t) {
                        n && (t = t.slice(),
                            n = !1);
                        for (let e = 0; e < o.length; e++)
                            t.push(o[e])
                    } else
                        t = o
            }
            return t ? So(n ? t : t.sort(Co)) : po
        }
        static from(e) {
            switch (e.length) {
                case 0:
                    return go;
                case 1:
                    return e[0];
                default:
                    return new bo(e.every((e => e instanceof mo)) ? e : e.reduce(((e, t) => e.concat(t instanceof mo ? t : t.members)), []))
            }
        }
        forEachSet(e) {
            for (let t = 0; t < this.members.length; t++)
                this.members[t].forEachSet(e)
        }
    }
    function yo(e, t) {
        if (!t || !e.length)
            return e;
        let n = [];
        for (let r = 0; r < e.length; r++) {
            let o = e[r];
            n.push(new ho(o.from + t, o.to + t, o.type))
        }
        return n
    }
    function vo(e, t, n) {
        if (t.isLeaf)
            return null;
        let r = n + t.nodeSize
            , o = null;
        for (let i, s = 0; s < e.length; s++)
            (i = e[s]) && i.from > n && i.to < r && ((o || (o = [])).push(i),
                e[s] = null);
        return o
    }
    function wo(e) {
        let t = [];
        for (let n = 0; n < e.length; n++)
            null != e[n] && t.push(e[n]);
        return t
    }
    function ko(e, t, n, r) {
        let o = []
            , i = !1;
        t.forEach(((t, s) => {
            let a = vo(e, t, s + n);
            if (a) {
                i = !0;
                let e = ko(a, t, n + s + 1, r);
                e != go && o.push(s, s + t.nodeSize, e)
            }
        }
        ));
        let s = yo(i ? wo(e) : e, -n).sort(Co);
        for (let a = 0; a < s.length; a++)
            s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec),
                s.splice(a--, 1));
        return s.length || o.length ? new mo(s, o) : go
    }
    function Co(e, t) {
        return e.from - t.from || e.to - t.to
    }
    function So(e) {
        let t = e;
        for (let n = 0; n < t.length - 1; n++) {
            let r = t[n];
            if (r.from != r.to)
                for (let o = n + 1; o < t.length; o++) {
                    let i = t[o];
                    if (i.from != r.from) {
                        i.from < r.to && (t == e && (t = e.slice()),
                            t[n] = r.copy(r.from, i.from),
                            xo(t, o, r.copy(i.from, r.to)));
                        break
                    }
                    i.to != r.to && (t == e && (t = e.slice()),
                        t[o] = i.copy(i.from, r.to),
                        xo(t, o + 1, i.copy(r.to, i.to)))
                }
        }
        return t
    }
    function xo(e, t, n) {
        for (; t < e.length && Co(n, e[t]) > 0;)
            t++;
        e.splice(t, 0, n)
    }
    function Eo(e) {
        let t = [];
        return e.someProp("decorations", (n => {
            let r = n(e.state);
            r && r != go && t.push(r)
        }
        )),
            e.cursorWrapper && t.push(mo.create(e.state.doc, [e.cursorWrapper.deco])),
            bo.from(t)
    }
    const Mo = {
        childList: !0,
        characterData: !0,
        characterDataOldValue: !0,
        attributes: !0,
        attributeOldValue: !0,
        subtree: !0
    }
        , To = Gt && Kt <= 11;
    class No {
        constructor() {
            this.anchorNode = null,
                this.anchorOffset = 0,
                this.focusNode = null,
                this.focusOffset = 0
        }
        set(e) {
            this.anchorNode = e.anchorNode,
                this.anchorOffset = e.anchorOffset,
                this.focusNode = e.focusNode,
                this.focusOffset = e.focusOffset
        }
        clear() {
            this.anchorNode = this.focusNode = null
        }
        eq(e) {
            return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset
        }
    }
    class _o {
        constructor(e, t) {
            this.view = e,
                this.handleDOMChange = t,
                this.queue = [],
                this.flushingSoon = -1,
                this.observer = null,
                this.currentSelection = new No,
                this.onCharData = null,
                this.suppressingSelectionUpdates = !1,
                this.lastChangedTextNode = null,
                this.observer = window.MutationObserver && new window.MutationObserver((e => {
                    for (let t = 0; t < e.length; t++)
                        this.queue.push(e[t]);
                    Gt && Kt <= 11 && e.some((e => "childList" == e.type && e.removedNodes.length || "characterData" == e.type && e.oldValue.length > e.target.nodeValue.length)) ? this.flushSoon() : this.flush()
                }
                )),
                To && (this.onCharData = e => {
                    this.queue.push({
                        target: e.target,
                        type: "characterData",
                        oldValue: e.prevValue
                    }),
                        this.flushSoon()
                }
                ),
                this.onSelectionChange = this.onSelectionChange.bind(this)
        }
        flushSoon() {
            this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout((() => {
                this.flushingSoon = -1,
                    this.flush()
            }
            ), 20))
        }
        forceFlush() {
            this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon),
                this.flushingSoon = -1,
                this.flush())
        }
        start() {
            this.observer && (this.observer.takeRecords(),
                this.observer.observe(this.view.dom, Mo)),
                this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
                this.connectSelection()
        }
        stop() {
            if (this.observer) {
                let e = this.observer.takeRecords();
                if (e.length) {
                    for (let t = 0; t < e.length; t++)
                        this.queue.push(e[t]);
                    window.setTimeout((() => this.flush()), 20)
                }
                this.observer.disconnect()
            }
            this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
                this.disconnectSelection()
        }
        connectSelection() {
            this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
        }
        disconnectSelection() {
            this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
        }
        suppressSelectionUpdates() {
            this.suppressingSelectionUpdates = !0,
                setTimeout((() => this.suppressingSelectionUpdates = !1), 50)
        }
        onSelectionChange() {
            if (ar(this.view)) {
                if (this.suppressingSelectionUpdates)
                    return Yn(this.view);
                if (Gt && Kt <= 11 && !this.view.state.selection.empty) {
                    let e = this.view.domSelectionRange();
                    if (e.focusNode && Rt(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
                        return this.flushSoon()
                }
                this.flush()
            }
        }
        setCurSelection() {
            this.currentSelection.set(this.view.domSelectionRange())
        }
        ignoreSelectionChange(e) {
            if (!e.focusNode)
                return !0;
            let t, n = new Set;
            for (let o = e.focusNode; o; o = At(o))
                n.add(o);
            for (let o = e.anchorNode; o; o = At(o))
                if (n.has(o)) {
                    t = o;
                    break
                }
            let r = t && this.view.docView.nearestDesc(t);
            return r && r.ignoreMutation({
                type: "selection",
                target: 3 == t.nodeType ? t.parentNode : t
            }) ? (this.setCurSelection(),
                !0) : void 0
        }
        pendingRecords() {
            if (this.observer)
                for (let e of this.observer.takeRecords())
                    this.queue.push(e);
            return this.queue
        }
        flush() {
            let { view: e } = this;
            if (!e.docView || this.flushingSoon > -1)
                return;
            let t = this.pendingRecords();
            t.length && (this.queue = []);
            let n = e.domSelectionRange()
                , r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(n) && ar(e) && !this.ignoreSelectionChange(n)
                , o = -1
                , i = -1
                , s = !1
                , a = [];
            if (e.editable)
                for (let c = 0; c < t.length; c++) {
                    let e = this.registerMutation(t[c], a);
                    e && (o = o < 0 ? e.from : Math.min(e.from, o),
                        i = i < 0 ? e.to : Math.max(e.to, i),
                        e.typeOver && (s = !0))
                }
            if (Jt && a.length) {
                let t = a.filter((e => "BR" == e.nodeName));
                if (2 == t.length) {
                    let [e, n] = t;
                    e.parentNode && e.parentNode.parentNode == n.parentNode ? n.remove() : e.remove()
                } else {
                    let { focusNode: n } = this.currentSelection;
                    for (let r of t) {
                        let t = r.parentNode;
                        !t || "LI" != t.nodeName || n && Lo(e, n) == t || r.remove()
                    }
                }
            }
            let l = null;
            o < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && zt(n) && (l = Xn(e)) && l.eq(at.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0,
                Yn(e),
                this.currentSelection.set(n),
                e.scrollToSelection()) : (o > -1 || r) && (o > -1 && (e.docView.markDirty(o, i),
                    function (e) {
                        if (Oo.has(e))
                            return;
                        if (Oo.set(e, null),
                            -1 !== ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace)) {
                            if (e.requiresGeckoHackNode = Jt,
                                Ao)
                                return;
                            console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
                                Ao = !0
                        }
                    }(e)),
                    this.handleDOMChange(o, i, s, a),
                    e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(n) || Yn(e),
                    this.currentSelection.set(n))
        }
        registerMutation(e, t) {
            if (t.indexOf(e.target) > -1)
                return null;
            let n = this.view.docView.nearestDesc(e.target);
            if ("attributes" == e.type && (n == this.view.docView || "contenteditable" == e.attributeName || "style" == e.attributeName && !e.oldValue && !e.target.getAttribute("style")))
                return null;
            if (!n || n.ignoreMutation(e))
                return null;
            if ("childList" == e.type) {
                for (let n = 0; n < e.addedNodes.length; n++) {
                    let r = e.addedNodes[n];
                    t.push(r),
                        3 == r.nodeType && (this.lastChangedTextNode = r)
                }
                if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target))
                    return {
                        from: n.posBefore,
                        to: n.posAfter
                    };
                let r = e.previousSibling
                    , o = e.nextSibling;
                if (Gt && Kt <= 11 && e.addedNodes.length)
                    for (let t = 0; t < e.addedNodes.length; t++) {
                        let { previousSibling: n, nextSibling: i } = e.addedNodes[t];
                        (!n || Array.prototype.indexOf.call(e.addedNodes, n) < 0) && (r = n),
                            (!i || Array.prototype.indexOf.call(e.addedNodes, i) < 0) && (o = i)
                    }
                let i = r && r.parentNode == e.target ? Ot(r) + 1 : 0
                    , s = n.localPosFromDOM(e.target, i, -1)
                    , a = o && o.parentNode == e.target ? Ot(o) : e.target.childNodes.length;
                return {
                    from: s,
                    to: n.localPosFromDOM(e.target, a, 1)
                }
            }
            return "attributes" == e.type ? {
                from: n.posAtStart - n.border,
                to: n.posAtEnd + n.border
            } : (this.lastChangedTextNode = e.target,
            {
                from: n.posAtStart,
                to: n.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            })
        }
    }
    let Oo = new WeakMap
        , Ao = !1;
    function Po(e, t) {
        let n = t.startContainer
            , r = t.startOffset
            , o = t.endContainer
            , i = t.endOffset
            , s = e.domAtPos(e.state.selection.anchor);
        return Rt(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]),
        {
            anchorNode: n,
            anchorOffset: r,
            focusNode: o,
            focusOffset: i
        }
    }
    function Lo(e, t) {
        for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
            let t = e.docView.nearestDesc(n, !0);
            if (t && t.node.isBlock)
                return n
        }
        return null
    }
    function Ro(e) {
        let t = e.pmViewDesc;
        if (t)
            return t.parseRule();
        if ("BR" == e.nodeName && e.parentNode) {
            if (Yt && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
                let e = document.createElement("div");
                return e.appendChild(document.createElement("li")),
                {
                    skip: e
                }
            }
            if (e.parentNode.lastChild == e || Yt && /^(tr|table)$/i.test(e.parentNode.nodeName))
                return {
                    ignore: !0
                }
        } else if ("IMG" == e.nodeName && e.getAttribute("mark-placeholder"))
            return {
                ignore: !0
            };
        return null
    }
    const Do = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function Io(e, t, n, r, o) {
        let i = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
        if (e.input.compositionPendingChanges = 0,
            t < 0) {
            let t = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null
                , n = Xn(e, t);
            if (n && !e.state.selection.eq(n)) {
                if (Xt && rn && 13 === e.input.lastKeyCode && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", (t => t(e, $t(13, "Enter")))))
                    return;
                let r = e.state.tr.setSelection(n);
                "pointer" == t ? r.setMeta("pointer", !0) : "key" == t && r.scrollIntoView(),
                    i && r.setMeta("composition", i),
                    e.dispatch(r)
            }
            return
        }
        let s = e.state.doc.resolve(t)
            , a = s.sharedDepth(n);
        t = s.before(a + 1),
            n = e.state.doc.resolve(n).after(a + 1);
        let l, c, u = e.state.selection, h = function (e, t, n) {
            let r, { node: o, fromOffset: i, toOffset: s, from: a, to: l } = e.docView.parseRange(t, n), c = e.domSelectionRange(), d = c.anchorNode;
            if (d && e.dom.contains(1 == d.nodeType ? d : d.parentNode) && (r = [{
                node: d,
                offset: c.anchorOffset
            }],
                zt(c) || r.push({
                    node: c.focusNode,
                    offset: c.focusOffset
                })),
                Xt && 8 === e.input.lastKeyCode)
                for (let g = s; g > i; g--) {
                    let e = o.childNodes[g - 1]
                        , t = e.pmViewDesc;
                    if ("BR" == e.nodeName && !t) {
                        s = g;
                        break
                    }
                    if (!t || t.size)
                        break
                }
            let u = e.state.doc
                , h = e.someProp("domParser") || te.fromSchema(e.state.schema)
                , p = u.resolve(a)
                , f = null
                , m = h.parse(o, {
                    topNode: p.parent,
                    topMatch: p.parent.contentMatchAt(p.index()),
                    topOpen: !0,
                    from: i,
                    to: s,
                    preserveWhitespace: "pre" != p.parent.type.whitespace || "full",
                    findPositions: r,
                    ruleFromNode: Ro,
                    context: p
                });
            if (r && null != r[0].pos) {
                let e = r[0].pos
                    , t = r[1] && r[1].pos;
                null == t && (t = e),
                    f = {
                        anchor: e + a,
                        head: t + a
                    }
            }
            return {
                doc: m,
                sel: f,
                from: a,
                to: l
            }
        }(e, t, n), p = e.state.doc, f = p.slice(h.from, h.to);
        8 === e.input.lastKeyCode && Date.now() - 100 < e.input.lastKeyCodeTime ? (l = e.state.selection.to,
            c = "end") : (l = e.state.selection.from,
                c = "start"),
            e.input.lastKeyCode = null;
        let m = function (e, t, n, r, o) {
            let i = e.findDiffStart(t, n);
            if (null == i)
                return null;
            let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size);
            if ("end" == o) {
                r -= s + Math.max(0, i - Math.min(s, a)) - i
            }
            if (s < i && e.size < t.size) {
                let e = r <= i && r >= s ? i - r : 0;
                i -= e,
                    i && i < t.size && zo(t.textBetween(i - 1, i + 1)) && (i += e ? 1 : -1),
                    a = i + (a - s),
                    s = i
            } else if (a < i) {
                let t = r <= i && r >= a ? i - r : 0;
                i -= t,
                    i && i < e.size && zo(e.textBetween(i - 1, i + 1)) && (i += t ? 1 : -1),
                    s = i + (s - a),
                    a = i
            }
            return {
                start: i,
                endA: s,
                endB: a
            }
        }(f.content, h.doc.content, h.from, l, c);
        if (m && e.input.domChangeCount++,
            (en && e.input.lastIOSEnter > Date.now() - 225 || rn) && o.some((e => 1 == e.nodeType && !Do.test(e.nodeName))) && (!m || m.endA >= m.endB) && e.someProp("handleKeyDown", (t => t(e, $t(13, "Enter")))))
            return void (e.input.lastIOSEnter = 0);
        if (!m) {
            if (!(r && u instanceof ut && !u.empty && u.$head.sameParent(u.$anchor)) || e.composing || h.sel && h.sel.anchor != h.sel.head) {
                if (h.sel) {
                    let t = jo(e, e.state.doc, h.sel);
                    if (t && !t.eq(e.state.selection)) {
                        let n = e.state.tr.setSelection(t);
                        i && n.setMeta("composition", i),
                            e.dispatch(n)
                    }
                }
                return
            }
            m = {
                start: u.from,
                endA: u.to,
                endB: u.to
            }
        }
        e.state.selection.from < e.state.selection.to && m.start == m.endB && e.state.selection instanceof ut && (m.start > e.state.selection.from && m.start <= e.state.selection.from + 2 && e.state.selection.from >= h.from ? m.start = e.state.selection.from : m.endA < e.state.selection.to && m.endA >= e.state.selection.to - 2 && e.state.selection.to <= h.to && (m.endB += e.state.selection.to - m.endA,
            m.endA = e.state.selection.to)),
            Gt && Kt <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > h.from && " \xa0" == h.doc.textBetween(m.start - h.from - 1, m.start - h.from + 1) && (m.start--,
                m.endA--,
                m.endB--);
        let g, b = h.doc.resolveNoCache(m.start - h.from), y = h.doc.resolveNoCache(m.endB - h.from), v = p.resolve(m.start), w = b.sameParent(y) && b.parent.inlineContent && v.end() >= m.endA;
        if ((en && e.input.lastIOSEnter > Date.now() - 225 && (!w || o.some((e => "DIV" == e.nodeName || "P" == e.nodeName))) || !w && b.pos < h.doc.content.size && !b.sameParent(y) && (g = at.findFrom(h.doc.resolve(b.pos + 1), 1, !0)) && g.head == y.pos) && e.someProp("handleKeyDown", (t => t(e, $t(13, "Enter")))))
            return void (e.input.lastIOSEnter = 0);
        if (e.state.selection.anchor > m.start && function (e, t, n, r, o) {
            if (n - t <= o.pos - r.pos || Ho(r, !0, !1) < o.pos)
                return !1;
            let i = e.resolve(t);
            if (!r.parent.isTextblock) {
                let e = i.nodeAfter;
                return null != e && n == t + e.nodeSize
            }
            if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
                return !1;
            let s = e.resolve(Ho(i, !0, !0));
            return !(!s.parent.isTextblock || s.pos > n || Ho(s, !0, !1) < n) && r.parent.content.cut(r.parentOffset).eq(s.parent.content)
        }(p, m.start, m.endA, b, y) && e.someProp("handleKeyDown", (t => t(e, $t(8, "Backspace")))))
            return void (rn && Xt && e.domObserver.suppressSelectionUpdates());
        Xt && rn && m.endB == m.start && (e.input.lastAndroidDelete = Date.now()),
            rn && !w && b.start() != y.start() && 0 == y.parentOffset && b.depth == y.depth && h.sel && h.sel.anchor == h.sel.head && h.sel.head == m.endA && (m.endB -= 2,
                y = h.doc.resolveNoCache(m.endB - h.from),
                setTimeout((() => {
                    e.someProp("handleKeyDown", (function (t) {
                        return t(e, $t(13, "Enter"))
                    }
                    ))
                }
                ), 20));
        let k, C, S, x = m.start, E = m.endA;
        if (w)
            if (b.pos == y.pos)
                Gt && Kt <= 11 && 0 == b.parentOffset && (e.domObserver.suppressSelectionUpdates(),
                    setTimeout((() => Yn(e)), 20)),
                    k = e.state.tr.delete(x, E),
                    C = p.resolve(m.start).marksAcross(p.resolve(m.endA));
            else if (m.endA == m.endB && (S = function (e, t) {
                let n, r, o, i = e.firstChild.marks, s = t.firstChild.marks, a = i, l = s;
                for (let d = 0; d < s.length; d++)
                    a = s[d].removeFromSet(a);
                for (let d = 0; d < i.length; d++)
                    l = i[d].removeFromSet(l);
                if (1 == a.length && 0 == l.length)
                    r = a[0],
                        n = "add",
                        o = e => e.mark(r.addToSet(e.marks));
                else {
                    if (0 != a.length || 1 != l.length)
                        return null;
                    r = l[0],
                        n = "remove",
                        o = e => e.mark(r.removeFromSet(e.marks))
                }
                let c = [];
                for (let d = 0; d < t.childCount; d++)
                    c.push(o(t.child(d)));
                if (d.from(c).eq(e))
                    return {
                        mark: r,
                        type: n
                    }
            }(b.parent.content.cut(b.parentOffset, y.parentOffset), v.parent.content.cut(v.parentOffset, m.endA - v.start()))))
                k = e.state.tr,
                    "add" == S.type ? k.addMark(x, E, S.mark) : k.removeMark(x, E, S.mark);
            else if (b.parent.child(b.index()).isText && b.index() == y.index() - (y.textOffset ? 0 : 1)) {
                let t = b.parent.textBetween(b.parentOffset, y.parentOffset);
                if (e.someProp("handleTextInput", (n => n(e, x, E, t))))
                    return;
                k = e.state.tr.insertText(t, x, E)
            }
        if (k || (k = e.state.tr.replace(x, E, h.doc.slice(m.start - h.from, m.endB - h.from))),
            h.sel) {
            let t = jo(e, k.doc, h.sel);
            t && !(Xt && rn && e.composing && t.empty && (m.start != m.endB || e.input.lastAndroidDelete < Date.now() - 100) && (t.head == x || t.head == k.mapping.map(E) - 1) || Gt && t.empty && t.head == x) && k.setSelection(t)
        }
        C && k.ensureMarks(C),
            i && k.setMeta("composition", i),
            e.dispatch(k.scrollIntoView())
    }
    function jo(e, t, n) {
        return Math.max(n.anchor, n.head) > t.content.size ? null : sr(e, t.resolve(n.anchor), t.resolve(n.head))
    }
    function Ho(e, t, n) {
        let r = e.depth
            , o = t ? e.end() : e.pos;
        for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount);)
            r--,
                o++,
                t = !1;
        if (n) {
            let t = e.node(r).maybeChild(e.indexAfter(r));
            for (; t && !t.isLeaf;)
                t = t.firstChild,
                    o++
        }
        return o
    }
    function zo(e) {
        if (2 != e.length)
            return !1;
        let t = e.charCodeAt(0)
            , n = e.charCodeAt(1);
        return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319
    }
    const $o = Cr;
    class Bo {
        constructor(e, t) {
            this._root = null,
                this.focused = !1,
                this.trackWrites = null,
                this.mounted = !1,
                this.markCursor = null,
                this.cursorWrapper = null,
                this.lastSelectedViewDesc = void 0,
                this.input = new Ir,
                this.prevDirectPlugins = [],
                this.pluginViews = [],
                this.requiresGeckoHackNode = !1,
                this.dragging = null,
                this._props = t,
                this.state = t.state,
                this.directPlugins = t.plugins || [],
                this.directPlugins.forEach(qo),
                this.dispatch = this.dispatch.bind(this),
                this.dom = e && e.mount || document.createElement("div"),
                e && (e.appendChild ? e.appendChild(this.dom) : "function" == typeof e ? e(this.dom) : e.mount && (this.mounted = !0)),
                this.editable = Uo(this),
                Fo(this),
                this.nodeViews = Wo(this),
                this.docView = Dn(this.state.doc, Vo(this), Eo(this), this.dom, this),
                this.domObserver = new _o(this, ((e, t, n, r) => Io(this, e, t, n, r))),
                this.domObserver.start(),
                function (e) {
                    for (let t in Lr) {
                        let n = Lr[t];
                        e.dom.addEventListener(t, e.input.eventHandlers[t] = t => {
                            !$r(e, t) || zr(e, t) || !e.editable && t.type in Rr || n(e, t)
                        }
                            , Dr[t] ? {
                                passive: !0
                            } : void 0)
                    }
                    Yt && e.dom.addEventListener("input", (() => null)),
                        Hr(e)
                }(this),
                this.updatePluginViews()
        }
        get composing() {
            return this.input.composing
        }
        get props() {
            if (this._props.state != this.state) {
                let e = this._props;
                this._props = {};
                for (let t in e)
                    this._props[t] = e[t];
                this._props.state = this.state
            }
            return this._props
        }
        update(e) {
            e.handleDOMEvents != this._props.handleDOMEvents && Hr(this);
            let t = this._props;
            this._props = e,
                e.plugins && (e.plugins.forEach(qo),
                    this.directPlugins = e.plugins),
                this.updateStateInner(e.state, t)
        }
        setProps(e) {
            let t = {};
            for (let n in this._props)
                t[n] = this._props[n];
            t.state = this.state;
            for (let n in e)
                t[n] = e[n];
            this.update(t)
        }
        updateState(e) {
            this.updateStateInner(e, this._props)
        }
        updateStateInner(e, t) {
            var n;
            let r = this.state
                , o = !1
                , i = !1;
            e.storedMarks && this.composing && (Yr(this),
                i = !0),
                this.state = e;
            let s = r.plugins != e.plugins || this._props.plugins != t.plugins;
            if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
                let e = Wo(this);
                (function (e, t) {
                    let n = 0
                        , r = 0;
                    for (let o in e) {
                        if (e[o] != t[o])
                            return !0;
                        n++
                    }
                    for (let o in t)
                        r++;
                    return n != r
                }
                )(e, this.nodeViews) && (this.nodeViews = e,
                    o = !0)
            }
            (s || t.handleDOMEvents != this._props.handleDOMEvents) && Hr(this),
                this.editable = Uo(this),
                Fo(this);
            let a = Eo(this)
                , l = Vo(this)
                , c = r.plugins == e.plugins || r.doc.eq(e.doc) ? e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve" : "reset"
                , d = o || !this.docView.matchesNode(e.doc, l, a);
            !d && e.selection.eq(r.selection) || (i = !0);
            let u = "preserve" == c && i && null == this.dom.style.overflowAnchor && function (e) {
                let t, n, r = e.dom.getBoundingClientRect(), o = Math.max(0, r.top);
                for (let i = (r.left + r.right) / 2, s = o + 1; s < Math.min(innerHeight, r.bottom); s += 5) {
                    let r = e.root.elementFromPoint(i, s);
                    if (!r || r == e.dom || !e.dom.contains(r))
                        continue;
                    let a = r.getBoundingClientRect();
                    if (a.top >= o - 20) {
                        t = r,
                            n = a.top;
                        break
                    }
                }
                return {
                    refDOM: t,
                    refTop: n,
                    stack: un(e.dom)
                }
            }(this);
            if (i) {
                this.domObserver.stop();
                let t = d && (Gt || Xt) && !this.composing && !r.selection.empty && !e.selection.empty && function (e, t) {
                    let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
                    return e.$anchor.start(n) != t.$anchor.start(n)
                }(r.selection, e.selection);
                if (d) {
                    let n = Xt ? this.trackWrites = this.domSelectionRange().focusNode : null;
                    this.composing && (this.input.compositionNode = eo(this)),
                        !o && this.docView.update(e.doc, l, a, this) || (this.docView.updateOuterDeco(l),
                            this.docView.destroy(),
                            this.docView = Dn(e.doc, l, a, this.dom, this)),
                        n && !this.trackWrites && (t = !0)
                }
                t || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && function (e) {
                    let t = e.docView.domFromPos(e.state.selection.anchor, 0)
                        , n = e.domSelectionRange();
                    return Rt(t.node, t.offset, n.anchorNode, n.anchorOffset)
                }(this)) ? Yn(this, t) : (or(this, e.selection),
                    this.domObserver.setCurSelection()),
                    this.domObserver.start()
            }
            this.updatePluginViews(r),
                (null === (n = this.dragging) || void 0 === n ? void 0 : n.node) && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r),
                "reset" == c ? this.dom.scrollTop = 0 : "to selection" == c ? this.scrollToSelection() : u && function (e) {
                    let { refDOM: t, refTop: n, stack: r } = e
                        , o = t ? t.getBoundingClientRect().top : 0;
                    hn(r, 0 == o ? 0 : o - n)
                }(u)
        }
        scrollToSelection() {
            let e = this.domSelectionRange().focusNode;
            if (this.someProp("handleScrollToSelection", (e => e(this))))
                ;
            else if (this.state.selection instanceof pt) {
                let t = this.docView.domAfterPos(this.state.selection.from);
                1 == t.nodeType && dn(this, t.getBoundingClientRect(), e)
            } else
                dn(this, this.coordsAtPos(this.state.selection.head, 1), e)
        }
        destroyPluginViews() {
            let e;
            for (; e = this.pluginViews.pop();)
                e.destroy && e.destroy()
        }
        updatePluginViews(e) {
            if (e && e.plugins == this.state.plugins && this.directPlugins == this.prevDirectPlugins)
                for (let t = 0; t < this.pluginViews.length; t++) {
                    let n = this.pluginViews[t];
                    n.update && n.update(this, e)
                }
            else {
                this.prevDirectPlugins = this.directPlugins,
                    this.destroyPluginViews();
                for (let e = 0; e < this.directPlugins.length; e++) {
                    let t = this.directPlugins[e];
                    t.spec.view && this.pluginViews.push(t.spec.view(this))
                }
                for (let e = 0; e < this.state.plugins.length; e++) {
                    let t = this.state.plugins[e];
                    t.spec.view && this.pluginViews.push(t.spec.view(this))
                }
            }
        }
        updateDraggedNode(e, t) {
            let n = e.node
                , r = -1;
            if (this.state.doc.nodeAt(n.from) == n.node)
                r = n.from;
            else {
                let e = n.from + (this.state.doc.content.size - t.doc.content.size);
                (e > 0 && this.state.doc.nodeAt(e)) == n.node && (r = e)
            }
            this.dragging = new io(e.slice, e.move, r < 0 ? void 0 : pt.create(this.state.doc, r))
        }
        someProp(e, t) {
            let n, r = this._props && this._props[e];
            if (null != r && (n = t ? t(r) : r))
                return n;
            for (let i = 0; i < this.directPlugins.length; i++) {
                let r = this.directPlugins[i].props[e];
                if (null != r && (n = t ? t(r) : r))
                    return n
            }
            let o = this.state.plugins;
            if (o)
                for (let i = 0; i < o.length; i++) {
                    let r = o[i].props[e];
                    if (null != r && (n = t ? t(r) : r))
                        return n
                }
        }
        hasFocus() {
            if (Gt) {
                let e = this.root.activeElement;
                if (e == this.dom)
                    return !0;
                if (!e || !this.dom.contains(e))
                    return !1;
                for (; e && this.dom != e && this.dom.contains(e);) {
                    if ("false" == e.contentEditable)
                        return !1;
                    e = e.parentElement
                }
                return !0
            }
            return this.root.activeElement == this.dom
        }
        focus() {
            this.domObserver.stop(),
                this.editable && function (e) {
                    if (e.setActive)
                        return e.setActive();
                    if (pn)
                        return e.focus(pn);
                    let t = un(e);
                    e.focus(null == pn ? {
                        get preventScroll() {
                            return pn = {
                                preventScroll: !0
                            },
                                !0
                        }
                    } : void 0),
                        pn || (pn = !1,
                            hn(t, 0))
                }(this.dom),
                Yn(this),
                this.domObserver.start()
        }
        get root() {
            let e = this._root;
            if (null == e)
                for (let t = this.dom.parentNode; t; t = t.parentNode)
                    if (9 == t.nodeType || 11 == t.nodeType && t.host)
                        return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()),
                            this._root = t;
            return e || document
        }
        updateRoot() {
            this._root = null
        }
        posAtCoords(e) {
            return bn(this, e)
        }
        coordsAtPos(e) {
            return kn(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1)
        }
        domAtPos(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.docView.domFromPos(e, t)
        }
        nodeDOM(e) {
            let t = this.docView.descAt(e);
            return t ? t.nodeDOM : null
        }
        posAtDOM(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1
                , r = this.docView.posFromDOM(e, t, n);
            if (null == r)
                throw new RangeError("DOM position not inside the editor");
            return r
        }
        endOfTextblock(e, t) {
            return _n(this, t || this.state, e)
        }
        pasteHTML(e, t) {
            return ro(this, "", e, !1, t || new ClipboardEvent("paste"))
        }
        pasteText(e, t) {
            return ro(this, e, null, !0, t || new ClipboardEvent("paste"))
        }
        destroy() {
            this.docView && (!function (e) {
                e.domObserver.stop();
                for (let t in e.input.eventHandlers)
                    e.dom.removeEventListener(t, e.input.eventHandlers[t]);
                clearTimeout(e.input.composingTimeout),
                    clearTimeout(e.input.lastIOSEnterFallbackTimeout)
            }(this),
                this.destroyPluginViews(),
                this.mounted ? (this.docView.update(this.state.doc, [], Eo(this), this),
                    this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
                this.docView.destroy(),
                this.docView = null,
                Pt = null)
        }
        get isDestroyed() {
            return null == this.docView
        }
        dispatchEvent(e) {
            return function (e, t) {
                zr(e, t) || !Lr[t.type] || !e.editable && t.type in Rr || Lr[t.type](e, t)
            }(this, e)
        }
        dispatch(e) {
            let t = this._props.dispatchTransaction;
            t ? t.call(this, e) : this.updateState(this.state.apply(e))
        }
        domSelectionRange() {
            let e = this.domSelection();
            return e ? Yt && 11 === this.root.nodeType && function (e) {
                let t = e.activeElement;
                for (; t && t.shadowRoot;)
                    t = t.shadowRoot.activeElement;
                return t
            }(this.dom.ownerDocument) == this.dom && function (e, t) {
                if (t.getComposedRanges) {
                    let n = t.getComposedRanges(e.root)[0];
                    if (n)
                        return Po(e, n)
                }
                let n;
                function r(e) {
                    e.preventDefault(),
                        e.stopImmediatePropagation(),
                        n = e.getTargetRanges()[0]
                }
                return e.dom.addEventListener("beforeinput", r, !0),
                    document.execCommand("indent"),
                    e.dom.removeEventListener("beforeinput", r, !0),
                    n ? Po(e, n) : null
            }(this, e) || e : {
                focusNode: null,
                focusOffset: 0,
                anchorNode: null,
                anchorOffset: 0
            }
        }
        domSelection() {
            return this.root.getSelection()
        }
    }
    function Vo(e) {
        let t = Object.create(null);
        return t.class = "ProseMirror",
            t.contenteditable = String(e.editable),
            e.someProp("attributes", (n => {
                if ("function" == typeof n && (n = n(e.state)),
                    n)
                    for (let e in n)
                        "class" == e ? t.class += " " + n[e] : "style" == e ? t.style = (t.style ? t.style + ";" : "") + n[e] : t[e] || "contenteditable" == e || "nodeName" == e || (t[e] = String(n[e]))
            }
            )),
            t.translate || (t.translate = "no"),
            [ho.node(0, e.state.doc.content.size, t)]
    }
    function Fo(e) {
        if (e.markCursor) {
            let t = document.createElement("img");
            t.className = "ProseMirror-separator",
                t.setAttribute("mark-placeholder", "true"),
                t.setAttribute("alt", ""),
                e.cursorWrapper = {
                    dom: t,
                    deco: ho.widget(e.state.selection.from, t, {
                        raw: !0,
                        marks: e.markCursor
                    })
                }
        } else
            e.cursorWrapper = null
    }
    function Uo(e) {
        return !e.someProp("editable", (t => !1 === t(e.state)))
    }
    function Wo(e) {
        let t = Object.create(null);
        function n(e) {
            for (let n in e)
                Object.prototype.hasOwnProperty.call(t, n) || (t[n] = e[n])
        }
        return e.someProp("nodeViews", n),
            e.someProp("markViews", n),
            t
    }
    function qo(e) {
        if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
            throw new RangeError("Plugins passed directly to the view must not have a state component")
    }
    for (var Go = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    }, Ko = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
    }, Jo = "undefined" != typeof navigator && /Mac/.test(navigator.platform), Zo = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), Xo = 0; Xo < 10; Xo++)
        Go[48 + Xo] = Go[96 + Xo] = String(Xo);
    for (Xo = 1; Xo <= 24; Xo++)
        Go[Xo + 111] = "F" + Xo;
    for (Xo = 65; Xo <= 90; Xo++)
        Go[Xo] = String.fromCharCode(Xo + 32),
            Ko[Xo] = String.fromCharCode(Xo);
    for (var Qo in Go)
        Ko.hasOwnProperty(Qo) || (Ko[Qo] = Go[Qo]);
    const Yo = "undefined" != typeof navigator && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
    function ei(e) {
        let t, n, r, o, i = e.split(/-(?!$)/), s = i[i.length - 1];
        "Space" == s && (s = " ");
        for (let a = 0; a < i.length - 1; a++) {
            let e = i[a];
            if (/^(cmd|meta|m)$/i.test(e))
                o = !0;
            else if (/^a(lt)?$/i.test(e))
                t = !0;
            else if (/^(c|ctrl|control)$/i.test(e))
                n = !0;
            else if (/^s(hift)?$/i.test(e))
                r = !0;
            else {
                if (!/^mod$/i.test(e))
                    throw new Error("Unrecognized modifier name: " + e);
                Yo ? o = !0 : n = !0
            }
        }
        return t && (s = "Alt-" + s),
            n && (s = "Ctrl-" + s),
            o && (s = "Meta-" + s),
            r && (s = "Shift-" + s),
            s
    }
    function ti(e, t) {
        let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        return t.altKey && (e = "Alt-" + e),
            t.ctrlKey && (e = "Ctrl-" + e),
            t.metaKey && (e = "Meta-" + e),
            n && t.shiftKey && (e = "Shift-" + e),
            e
    }
    function ni(e) {
        let t = function (e) {
            let t = Object.create(null);
            for (let n in e)
                t[ei(n)] = e[n];
            return t
        }(e);
        return function (e, n) {
            let r, o = function (e) {
                var t = !(Jo && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || Zo && e.shiftKey && e.key && 1 == e.key.length || "Unidentified" == e.key) && e.key || (e.shiftKey ? Ko : Go)[e.keyCode] || e.key || "Unidentified";
                return "Esc" == t && (t = "Escape"),
                    "Del" == t && (t = "Delete"),
                    "Left" == t && (t = "ArrowLeft"),
                    "Up" == t && (t = "ArrowUp"),
                    "Right" == t && (t = "ArrowRight"),
                    "Down" == t && (t = "ArrowDown"),
                    t
            }(n), i = t[ti(o, n)];
            if (i && i(e.state, e.dispatch, e))
                return !0;
            if (1 == o.length && " " != o) {
                if (n.shiftKey) {
                    let r = t[ti(o, n, !1)];
                    if (r && r(e.state, e.dispatch, e))
                        return !0
                }
                if ((n.shiftKey || n.altKey || n.metaKey || o.charCodeAt(0) > 127) && (r = Go[n.keyCode]) && r != o) {
                    let o = t[ti(r, n)];
                    if (o && o(e.state, e.dispatch, e))
                        return !0
                }
            }
            return !1
        }
    }
    const ri = (e, t) => !e.selection.empty && (t && t(e.tr.deleteSelection().scrollIntoView()),
        !0);
    function oi(e, t) {
        let { $cursor: n } = e.selection;
        return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n
    }
    const ii = (e, t, n) => {
        let r = oi(e, n);
        if (!r)
            return !1;
        let o = ci(r);
        if (!o) {
            let n = r.blockRange()
                , o = n && Ie(n);
            return null != o && (t && t(e.tr.lift(n, o).scrollIntoView()),
                !0)
        }
        let i = o.nodeBefore;
        if (ki(e, o, t, -1))
            return !0;
        if (0 == r.parent.content.size && (ai(i, "end") || pt.isSelectable(i)))
            for (let s = r.depth; ; s--) {
                let n = qe(e.doc, r.before(s), r.after(s), g.empty);
                if (n && n.slice.size < n.to - n.from) {
                    if (t) {
                        let r = e.tr.step(n);
                        r.setSelection(ai(i, "end") ? at.findFrom(r.doc.resolve(r.mapping.map(o.pos, -1)), -1) : pt.create(r.doc, o.pos - i.nodeSize)),
                            t(r.scrollIntoView())
                    }
                    return !0
                }
                if (1 == s || r.node(s - 1).childCount > 1)
                    break
            }
        return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()),
            !0)
    }
        ;
    function si(e, t, n) {
        let r = t.nodeBefore
            , o = t.pos - 1;
        for (; !r.isTextblock; o--) {
            if (r.type.spec.isolating)
                return !1;
            let e = r.lastChild;
            if (!e)
                return !1;
            r = e
        }
        let i = t.nodeAfter
            , s = t.pos + 1;
        for (; !i.isTextblock; s++) {
            if (i.type.spec.isolating)
                return !1;
            let e = i.firstChild;
            if (!e)
                return !1;
            i = e
        }
        let a = qe(e.doc, o, s, g.empty);
        if (!a || a.from != o || a instanceof Ae && a.slice.size >= s - o)
            return !1;
        if (n) {
            let t = e.tr.step(a);
            t.setSelection(ut.create(t.doc, o)),
                n(t.scrollIntoView())
        }
        return !0
    }
    function ai(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        for (let r = e; r; r = "start" == t ? r.firstChild : r.lastChild) {
            if (r.isTextblock)
                return !0;
            if (n && 1 != r.childCount)
                return !1
        }
        return !1
    }
    const li = (e, t, n) => {
        let { $head: r, empty: o } = e.selection
            , i = r;
        if (!o)
            return !1;
        if (r.parent.isTextblock) {
            if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
                return !1;
            i = ci(r)
        }
        let s = i && i.nodeBefore;
        return !(!s || !pt.isSelectable(s)) && (t && t(e.tr.setSelection(pt.create(e.doc, i.pos - s.nodeSize)).scrollIntoView()),
            !0)
    }
        ;
    function ci(e) {
        if (!e.parent.type.spec.isolating)
            for (let t = e.depth - 1; t >= 0; t--) {
                if (e.index(t) > 0)
                    return e.doc.resolve(e.before(t + 1));
                if (e.node(t).type.spec.isolating)
                    break
            }
        return null
    }
    function di(e, t) {
        let { $cursor: n } = e.selection;
        return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n
    }
    const ui = (e, t, n) => {
        let r = di(e, n);
        if (!r)
            return !1;
        let o = pi(r);
        if (!o)
            return !1;
        let i = o.nodeAfter;
        if (ki(e, o, t, 1))
            return !0;
        if (0 == r.parent.content.size && (ai(i, "start") || pt.isSelectable(i))) {
            let n = qe(e.doc, r.before(), r.after(), g.empty);
            if (n && n.slice.size < n.to - n.from) {
                if (t) {
                    let r = e.tr.step(n);
                    r.setSelection(ai(i, "start") ? at.findFrom(r.doc.resolve(r.mapping.map(o.pos)), 1) : pt.create(r.doc, r.mapping.map(o.pos))),
                        t(r.scrollIntoView())
                }
                return !0
            }
        }
        return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()),
            !0)
    }
        , hi = (e, t, n) => {
            let { $head: r, empty: o } = e.selection
                , i = r;
            if (!o)
                return !1;
            if (r.parent.isTextblock) {
                if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
                    return !1;
                i = pi(r)
            }
            let s = i && i.nodeAfter;
            return !(!s || !pt.isSelectable(s)) && (t && t(e.tr.setSelection(pt.create(e.doc, i.pos)).scrollIntoView()),
                !0)
        }
        ;
    function pi(e) {
        if (!e.parent.type.spec.isolating)
            for (let t = e.depth - 1; t >= 0; t--) {
                let n = e.node(t);
                if (e.index(t) + 1 < n.childCount)
                    return e.doc.resolve(e.after(t + 1));
                if (n.type.spec.isolating)
                    break
            }
        return null
    }
    const fi = (e, t) => {
        let { $head: n, $anchor: r } = e.selection;
        return !(!n.parent.type.spec.code || !n.sameParent(r)) && (t && t(e.tr.insertText("\n").scrollIntoView()),
            !0)
    }
        ;
    function mi(e) {
        for (let t = 0; t < e.edgeCount; t++) {
            let { type: n } = e.edge(t);
            if (n.isTextblock && !n.hasRequiredAttrs())
                return n
        }
        return null
    }
    const gi = (e, t) => {
        let { $head: n, $anchor: r } = e.selection;
        if (!n.parent.type.spec.code || !n.sameParent(r))
            return !1;
        let o = n.node(-1)
            , i = n.indexAfter(-1)
            , s = mi(o.contentMatchAt(i));
        if (!s || !o.canReplaceWith(i, i, s))
            return !1;
        if (t) {
            let r = n.after()
                , o = e.tr.replaceWith(r, r, s.createAndFill());
            o.setSelection(at.near(o.doc.resolve(r), 1)),
                t(o.scrollIntoView())
        }
        return !0
    }
        , bi = (e, t) => {
            let n = e.selection
                , { $from: r, $to: o } = n;
            if (n instanceof mt || r.parent.inlineContent || o.parent.inlineContent)
                return !1;
            let i = mi(o.parent.contentMatchAt(o.indexAfter()));
            if (!i || !i.isTextblock)
                return !1;
            if (t) {
                let n = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos
                    , s = e.tr.insert(n, i.createAndFill());
                s.setSelection(ut.create(s.doc, n + 1)),
                    t(s.scrollIntoView())
            }
            return !0
        }
        , yi = (e, t) => {
            let { $cursor: n } = e.selection;
            if (!n || n.parent.content.size)
                return !1;
            if (n.depth > 1 && n.after() != n.end(-1)) {
                let r = n.before();
                if (Be(e.doc, r))
                    return t && t(e.tr.split(r).scrollIntoView()),
                        !0
            }
            let r = n.blockRange()
                , o = r && Ie(r);
            return null != o && (t && t(e.tr.lift(r, o).scrollIntoView()),
                !0)
        }
        ;
    const vi = (e, t) => {
        let { $from: n, $to: r } = e.selection;
        if (e.selection instanceof pt && e.selection.node.isBlock)
            return !(!n.parentOffset || !Be(e.doc, n.pos)) && (t && t(e.tr.split(n.pos).scrollIntoView()),
                !0);
        if (!n.depth)
            return !1;
        let o, i, s = [], a = !1, l = !1;
        for (let h = n.depth; ; h--) {
            if (n.node(h).isBlock) {
                a = n.end(h) == n.pos + (n.depth - h),
                    l = n.start(h) == n.pos - (n.depth - h),
                    i = mi(n.node(h - 1).contentMatchAt(n.indexAfter(h - 1)));
                let e = wi && wi(r.parent, a, n);
                s.unshift(e || (a && i ? {
                    type: i
                } : null)),
                    o = h;
                break
            }
            if (1 == h)
                return !1;
            s.unshift(null)
        }
        let c = e.tr;
        (e.selection instanceof ut || e.selection instanceof mt) && c.deleteSelection();
        let d = c.mapping.map(n.pos)
            , u = Be(c.doc, d, s.length, s);
        if (u || (s[0] = i ? {
            type: i
        } : null,
            u = Be(c.doc, d, s.length, s)),
            c.split(d, s.length, s),
            !a && l && n.node(o).type != i) {
            let e = c.mapping.map(n.before(o))
                , t = c.doc.resolve(e);
            i && n.node(o - 1).canReplaceWith(t.index(), t.index() + 1, i) && c.setNodeMarkup(c.mapping.map(n.before(o)), i)
        }
        return t && t(c.scrollIntoView()),
            !0
    }
        ;
    var wi;
    function ki(e, t, n, r) {
        let o, i, s = t.nodeBefore, a = t.nodeAfter, l = s.type.spec.isolating || a.type.spec.isolating;
        if (!l && function (e, t, n) {
            let r = t.nodeBefore
                , o = t.nodeAfter
                , i = t.index();
            return !!(r && o && r.type.compatibleContent(o.type)) && (!r.content.size && t.parent.canReplace(i - 1, i) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()),
                !0) : !(!t.parent.canReplace(i, i + 1) || !o.isTextblock && !Ve(e.doc, t.pos)) && (n && n(e.tr.join(t.pos).scrollIntoView()),
                    !0))
        }(e, t, n))
            return !0;
        let c = !l && t.parent.canReplace(t.index(), t.index() + 1);
        if (c && (o = (i = s.contentMatchAt(s.childCount)).findWrapping(a.type)) && i.matchType(o[0] || a.type).validEnd) {
            if (n) {
                let r = t.pos + a.nodeSize
                    , i = d.empty;
                for (let e = o.length - 1; e >= 0; e--)
                    i = d.from(o[e].create(null, i));
                i = d.from(s.copy(i));
                let l = e.tr.step(new Pe(t.pos - 1, r, t.pos, r, new g(i, 1, 0), o.length, !0))
                    , c = l.doc.resolve(r + 2 * o.length);
                c.nodeAfter && c.nodeAfter.type == s.type && Ve(l.doc, c.pos) && l.join(c.pos),
                    n(l.scrollIntoView())
            }
            return !0
        }
        let u = a.type.spec.isolating || r > 0 && l ? null : at.findFrom(t, 1)
            , h = u && u.$from.blockRange(u.$to)
            , p = h && Ie(h);
        if (null != p && p >= t.depth)
            return n && n(e.tr.lift(h, p).scrollIntoView()),
                !0;
        if (c && ai(a, "start", !0) && ai(s, "end")) {
            let r = s
                , o = [];
            for (; o.push(r),
                !r.isTextblock;)
                r = r.lastChild;
            let i = a
                , l = 1;
            for (; !i.isTextblock; i = i.firstChild)
                l++;
            if (r.canReplace(r.childCount, r.childCount, i.content)) {
                if (n) {
                    let r = d.empty;
                    for (let e = o.length - 1; e >= 0; e--)
                        r = d.from(o[e].copy(r));
                    n(e.tr.step(new Pe(t.pos - o.length, t.pos + a.nodeSize, t.pos + l, t.pos + a.nodeSize - l, new g(r, o.length, 0), 0, !0)).scrollIntoView())
                }
                return !0
            }
        }
        return !1
    }
    function Ci(e) {
        return function (t, n) {
            let r = t.selection
                , o = e < 0 ? r.$from : r.$to
                , i = o.depth;
            for (; o.node(i).isInline;) {
                if (!i)
                    return !1;
                i--
            }
            return !!o.node(i).isTextblock && (n && n(t.tr.setSelection(ut.create(t.doc, e < 0 ? o.start(i) : o.end(i)))),
                !0)
        }
    }
    const Si = Ci(-1)
        , xi = Ci(1);
    function Ei(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return function (n, r) {
            let o = !1;
            for (let i = 0; i < n.selection.ranges.length && !o; i++) {
                let { $from: { pos: r }, $to: { pos: s } } = n.selection.ranges[i];
                n.doc.nodesBetween(r, s, ((r, i) => {
                    if (o)
                        return !1;
                    if (r.isTextblock && !r.hasMarkup(e, t))
                        if (r.type == e)
                            o = !0;
                        else {
                            let t = n.doc.resolve(i)
                                , r = t.index();
                            o = t.parent.canReplaceWith(r, r + 1, e)
                        }
                }
                ))
            }
            if (!o)
                return !1;
            if (r) {
                let o = n.tr;
                for (let r = 0; r < n.selection.ranges.length; r++) {
                    let { $from: { pos: i }, $to: { pos: s } } = n.selection.ranges[r];
                    o.setBlockType(i, s, e, t)
                }
                r(o.scrollIntoView())
            }
            return !0
        }
    }
    function Mi() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return function (e, n, r) {
            for (let o = 0; o < t.length; o++)
                if (t[o](e, n, r))
                    return !0;
            return !1
        }
    }
    let Ti = Mi(ri, ii, li)
        , Ni = Mi(ri, ui, hi);
    const _i = {
        Enter: Mi(fi, bi, yi, vi),
        "Mod-Enter": gi,
        Backspace: Ti,
        "Mod-Backspace": Ti,
        "Shift-Backspace": Ti,
        Delete: Ni,
        "Mod-Delete": Ni,
        "Mod-a": (e, t) => (t && t(e.tr.setSelection(new mt(e.doc))),
            !0)
    }
        , Oi = {
            "Ctrl-h": _i.Backspace,
            "Alt-Backspace": _i["Mod-Backspace"],
            "Ctrl-d": _i.Delete,
            "Ctrl-Alt-Backspace": _i["Mod-Delete"],
            "Alt-Delete": _i["Mod-Delete"],
            "Alt-d": _i["Mod-Delete"],
            "Ctrl-a": Si,
            "Ctrl-e": xi
        };
    for (let os in _i)
        Oi[os] = _i[os];
    "undefined" != typeof navigator ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !("undefined" == typeof os || !os.platform) && os.platform();
    function Ai(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return function (n, r) {
            let { $from: o, $to: i } = n.selection
                , s = o.blockRange(i)
                , a = !1
                , l = s;
            if (!s)
                return !1;
            if (s.depth >= 2 && o.node(s.depth - 1).type.compatibleContent(e) && 0 == s.startIndex) {
                if (0 == o.index(s.depth - 1))
                    return !1;
                let e = n.doc.resolve(s.start - 2);
                l = new P(e, e, s.depth),
                    s.endIndex < s.parent.childCount && (s = new P(o, n.doc.resolve(i.end(s.depth)), s.depth)),
                    a = !0
            }
            let c = je(l, e, t, s);
            return !!c && (r && r(function (e, t, n, r, o) {
                let i = d.empty;
                for (let u = n.length - 1; u >= 0; u--)
                    i = d.from(n[u].type.create(n[u].attrs, i));
                e.step(new Pe(t.start - (r ? 2 : 0), t.end, t.start, t.end, new g(i, 0, 0), n.length, !0));
                let s = 0;
                for (let d = 0; d < n.length; d++)
                    n[d].type == o && (s = d + 1);
                let a = n.length - s
                    , l = t.start + n.length - (r ? 2 : 0)
                    , c = t.parent;
                for (let d = t.startIndex, u = t.endIndex, h = !0; d < u; d++,
                    h = !1)
                    !h && Be(e.doc, l, a) && (e.split(l, a),
                        l += 2 * a),
                        l += c.child(d).nodeSize;
                return e
            }(n.tr, s, c, a, e).scrollIntoView()),
                !0)
        }
    }
    function Pi(e) {
        return function (t, n) {
            let { $from: r, $to: o } = t.selection
                , i = r.blockRange(o, (t => t.childCount > 0 && t.firstChild.type == e));
            return !!i && (!n || (r.node(i.depth - 1).type == e ? function (e, t, n, r) {
                let o = e.tr
                    , i = r.end
                    , s = r.$to.end(r.depth);
                i < s && (o.step(new Pe(i - 1, s, i, s, new g(d.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)),
                    r = new P(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
                const a = Ie(r);
                if (null == a)
                    return !1;
                o.lift(r, a);
                let l = o.mapping.map(i, -1) - 1;
                Ve(o.doc, l) && o.join(l);
                return t(o.scrollIntoView()),
                    !0
            }(t, n, e, i) : function (e, t, n) {
                let r = e.tr
                    , o = n.parent;
                for (let d = n.end, f = n.endIndex - 1, m = n.startIndex; f > m; f--)
                    d -= o.child(f).nodeSize,
                        r.delete(d - 1, d + 1);
                let i = r.doc.resolve(n.start)
                    , s = i.nodeAfter;
                if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
                    return !1;
                let a = 0 == n.startIndex
                    , l = n.endIndex == o.childCount
                    , c = i.node(-1)
                    , u = i.index(-1);
                if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? d.empty : d.from(o))))
                    return !1;
                let h = i.pos
                    , p = h + s.nodeSize;
                return r.step(new Pe(h - (a ? 1 : 0), p + (l ? 1 : 0), h + 1, p - 1, new g((a ? d.empty : d.from(o.copy(d.empty))).append(l ? d.empty : d.from(o.copy(d.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)),
                    t(r.scrollIntoView()),
                    !0
            }(t, n, i)))
        }
    }
    function Li(e) {
        const { state: t, transaction: n } = e;
        let { selection: r } = n
            , { doc: o } = n
            , { storedMarks: i } = n;
        return {
            ...t,
            apply: t.apply.bind(t),
            applyTransaction: t.applyTransaction.bind(t),
            plugins: t.plugins,
            schema: t.schema,
            reconfigure: t.reconfigure.bind(t),
            toJSON: t.toJSON.bind(t),
            get storedMarks() {
                return i
            },
            get selection() {
                return r
            },
            get doc() {
                return o
            },
            get tr() {
                return r = n.selection,
                    o = n.doc,
                    i = n.storedMarks,
                    n
            }
        }
    }
    class Ri {
        constructor(e) {
            this.editor = e.editor,
                this.rawCommands = this.editor.extensionManager.commands,
                this.customState = e.state
        }
        get hasCustomState() {
            return !!this.customState
        }
        get state() {
            return this.customState || this.editor.state
        }
        get commands() {
            var e = this;
            const { rawCommands: t, editor: n, state: r } = this
                , { view: o } = n
                , { tr: i } = r
                , s = this.buildProps(i);
            return Object.fromEntries(Object.entries(t).map((t => {
                let [n, r] = t;
                return [n, function () {
                    const t = r(...arguments)(s);
                    return i.getMeta("preventDispatch") || e.hasCustomState || o.dispatch(i),
                        t
                }
                ]
            }
            )))
        }
        get chain() {
            return () => this.createChain()
        }
        get can() {
            return () => this.createCan()
        }
        createChain(e) {
            var t = this;
            let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const { rawCommands: r, editor: o, state: i } = this
                , { view: s } = o
                , a = []
                , l = !!e
                , c = e || i.tr
                , d = {
                    ...Object.fromEntries(Object.entries(r).map((e => {
                        let [r, o] = e;
                        return [r, function () {
                            const e = t.buildProps(c, n)
                                , r = o(...arguments)(e);
                            return a.push(r),
                                d
                        }
                        ]
                    }
                    ))),
                    run: () => (l || !n || c.getMeta("preventDispatch") || this.hasCustomState || s.dispatch(c),
                        a.every((e => !0 === e)))
                };
            return d
        }
        createCan(e) {
            const { rawCommands: t, state: n } = this
                , r = !1
                , o = e || n.tr
                , i = this.buildProps(o, r)
                , s = Object.fromEntries(Object.entries(t).map((e => {
                    let [t, n] = e;
                    return [t, function () {
                        return n(...arguments)({
                            ...i,
                            dispatch: void 0
                        })
                    }
                    ]
                }
                )));
            return {
                ...s,
                chain: () => this.createChain(o, r)
            }
        }
        buildProps(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const { rawCommands: n, editor: r, state: o } = this
                , { view: i } = r
                , s = {
                    tr: e,
                    editor: r,
                    view: i,
                    state: Li({
                        state: o,
                        transaction: e
                    }),
                    dispatch: t ? () => { }
                        : void 0,
                    chain: () => this.createChain(e, t),
                    can: () => this.createCan(e),
                    get commands() {
                        return Object.fromEntries(Object.entries(n).map((e => {
                            let [t, n] = e;
                            return [t, function () {
                                return n(...arguments)(s)
                            }
                            ]
                        }
                        )))
                    }
                };
            return s
        }
    }
    class Di {
        constructor() {
            this.callbacks = {}
        }
        on(e, t) {
            return this.callbacks[e] || (this.callbacks[e] = []),
                this.callbacks[e].push(t),
                this
        }
        emit(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                n[r - 1] = arguments[r];
            const o = this.callbacks[e];
            return o && o.forEach((e => e.apply(this, n))),
                this
        }
        off(e, t) {
            const n = this.callbacks[e];
            return n && (t ? this.callbacks[e] = n.filter((e => e !== t)) : delete this.callbacks[e]),
                this
        }
        removeAllListeners() {
            this.callbacks = {}
        }
    }
    function Ii(e, t, n) {
        if (void 0 === e.config[t] && e.parent)
            return Ii(e.parent, t, n);
        if ("function" === typeof e.config[t]) {
            return e.config[t].bind({
                ...n,
                parent: e.parent ? Ii(e.parent, t, n) : null
            })
        }
        return e.config[t]
    }
    function ji(e) {
        return {
            baseExtensions: e.filter((e => "extension" === e.type)),
            nodeExtensions: e.filter((e => "node" === e.type)),
            markExtensions: e.filter((e => "mark" === e.type))
        }
    }
    function Hi(e) {
        const t = []
            , { nodeExtensions: n, markExtensions: r } = ji(e)
            , o = [...n, ...r]
            , i = {
                default: null,
                rendered: !0,
                renderHTML: null,
                parseHTML: null,
                keepOnSplit: !0,
                isRequired: !1
            };
        return e.forEach((e => {
            const n = Ii(e, "addGlobalAttributes", {
                name: e.name,
                options: e.options,
                storage: e.storage,
                extensions: o
            });
            if (!n)
                return;
            n().forEach((e => {
                e.types.forEach((n => {
                    Object.entries(e.attributes).forEach((e => {
                        let [r, o] = e;
                        t.push({
                            type: n,
                            name: r,
                            attribute: {
                                ...i,
                                ...o
                            }
                        })
                    }
                    ))
                }
                ))
            }
            ))
        }
        )),
            o.forEach((e => {
                const n = {
                    name: e.name,
                    options: e.options,
                    storage: e.storage
                }
                    , r = Ii(e, "addAttributes", n);
                if (!r)
                    return;
                const o = r();
                Object.entries(o).forEach((n => {
                    let [r, o] = n;
                    const s = {
                        ...i,
                        ...o
                    };
                    "function" === typeof (null === s || void 0 === s ? void 0 : s.default) && (s.default = s.default()),
                        (null === s || void 0 === s ? void 0 : s.isRequired) && void 0 === (null === s || void 0 === s ? void 0 : s.default) && delete s.default,
                        t.push({
                            type: e.name,
                            name: r,
                            attribute: s
                        })
                }
                ))
            }
            )),
            t
    }
    function zi(e, t) {
        if ("string" === typeof e) {
            if (!t.nodes[e])
                throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
            return t.nodes[e]
        }
        return e
    }
    function $i() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return t.filter((e => !!e)).reduce(((e, t) => {
            const n = {
                ...e
            };
            return Object.entries(t).forEach((e => {
                let [t, r] = e;
                if (n[t])
                    if ("class" === t) {
                        const e = r ? r.split(" ") : []
                            , o = n[t] ? n[t].split(" ") : []
                            , i = e.filter((e => !o.includes(e)));
                        n[t] = [...o, ...i].join(" ")
                    } else if ("style" === t) {
                        const e = r ? r.split(";").map((e => e.trim())).filter(Boolean) : []
                            , o = n[t] ? n[t].split(";").map((e => e.trim())).filter(Boolean) : []
                            , i = new Map;
                        o.forEach((e => {
                            const [t, n] = e.split(":").map((e => e.trim()));
                            i.set(t, n)
                        }
                        )),
                            e.forEach((e => {
                                const [t, n] = e.split(":").map((e => e.trim()));
                                i.set(t, n)
                            }
                            )),
                            n[t] = Array.from(i.entries()).map((e => {
                                let [t, n] = e;
                                return `${t}: ${n}`
                            }
                            )).join("; ")
                    } else
                        n[t] = r;
                else
                    n[t] = r
            }
            )),
                n
        }
        ), {})
    }
    function Bi(e, t) {
        return t.filter((t => t.type === e.type.name)).filter((e => e.attribute.rendered)).map((t => t.attribute.renderHTML ? t.attribute.renderHTML(e.attrs) || {} : {
            [t.name]: e.attrs[t.name]
        })).reduce(((e, t) => $i(e, t)), {})
    }
    function Vi(e) {
        return "function" === typeof e
    }
    function Fi(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
        if (Vi(e)) {
            for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
                r[o - 2] = arguments[o];
            return t ? e.bind(t)(...r) : e(...r)
        }
        return e
    }
    function Ui(e, t) {
        return "style" in e ? e : {
            ...e,
            getAttrs: n => {
                const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
                if (!1 === r)
                    return !1;
                const o = t.reduce(((e, t) => {
                    const r = t.attribute.parseHTML ? t.attribute.parseHTML(n) : function (e) {
                        return "string" !== typeof e ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : "true" === e || "false" !== e && e
                    }(n.getAttribute(t.name));
                    return null === r || void 0 === r ? e : {
                        ...e,
                        [t.name]: r
                    }
                }
                ), {});
                return {
                    ...r,
                    ...o
                }
            }
        }
    }
    function Wi(e) {
        return Object.fromEntries(Object.entries(e).filter((e => {
            let [t, n] = e;
            return ("attrs" !== t || !function () {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return 0 === Object.keys(e).length && e.constructor === Object
            }(n)) && (null !== n && void 0 !== n)
        }
        )))
    }
    function qi(e, t) {
        var n;
        const r = Hi(e)
            , { nodeExtensions: o, markExtensions: i } = ji(e)
            , s = null === (n = o.find((e => Ii(e, "topNode")))) || void 0 === n ? void 0 : n.name
            , a = Object.fromEntries(o.map((n => {
                const o = r.filter((e => e.type === n.name))
                    , i = {
                        name: n.name,
                        options: n.options,
                        storage: n.storage,
                        editor: t
                    }
                    , s = Wi({
                        ...e.reduce(((e, t) => {
                            const r = Ii(t, "extendNodeSchema", i);
                            return {
                                ...e,
                                ...r ? r(n) : {}
                            }
                        }
                        ), {}),
                        content: Fi(Ii(n, "content", i)),
                        marks: Fi(Ii(n, "marks", i)),
                        group: Fi(Ii(n, "group", i)),
                        inline: Fi(Ii(n, "inline", i)),
                        atom: Fi(Ii(n, "atom", i)),
                        selectable: Fi(Ii(n, "selectable", i)),
                        draggable: Fi(Ii(n, "draggable", i)),
                        code: Fi(Ii(n, "code", i)),
                        whitespace: Fi(Ii(n, "whitespace", i)),
                        defining: Fi(Ii(n, "defining", i)),
                        isolating: Fi(Ii(n, "isolating", i)),
                        attrs: Object.fromEntries(o.map((e => {
                            var t;
                            return [e.name, {
                                default: null === (t = null === e || void 0 === e ? void 0 : e.attribute) || void 0 === t ? void 0 : t.default
                            }]
                        }
                        )))
                    })
                    , a = Fi(Ii(n, "parseHTML", i));
                a && (s.parseDOM = a.map((e => Ui(e, o))));
                const l = Ii(n, "renderHTML", i);
                l && (s.toDOM = e => l({
                    node: e,
                    HTMLAttributes: Bi(e, o)
                }));
                const c = Ii(n, "renderText", i);
                return c && (s.toText = c),
                    [n.name, s]
            }
            )))
            , l = Object.fromEntries(i.map((n => {
                const o = r.filter((e => e.type === n.name))
                    , i = {
                        name: n.name,
                        options: n.options,
                        storage: n.storage,
                        editor: t
                    }
                    , s = Wi({
                        ...e.reduce(((e, t) => {
                            const r = Ii(t, "extendMarkSchema", i);
                            return {
                                ...e,
                                ...r ? r(n) : {}
                            }
                        }
                        ), {}),
                        inclusive: Fi(Ii(n, "inclusive", i)),
                        excludes: Fi(Ii(n, "excludes", i)),
                        group: Fi(Ii(n, "group", i)),
                        spanning: Fi(Ii(n, "spanning", i)),
                        code: Fi(Ii(n, "code", i)),
                        attrs: Object.fromEntries(o.map((e => {
                            var t;
                            return [e.name, {
                                default: null === (t = null === e || void 0 === e ? void 0 : e.attribute) || void 0 === t ? void 0 : t.default
                            }]
                        }
                        )))
                    })
                    , a = Fi(Ii(n, "parseHTML", i));
                a && (s.parseDOM = a.map((e => Ui(e, o))));
                const l = Ii(n, "renderHTML", i);
                return l && (s.toDOM = e => l({
                    mark: e,
                    HTMLAttributes: Bi(e, o)
                })),
                    [n.name, s]
            }
            )));
        return new Y({
            topNode: s,
            nodes: a,
            marks: l
        })
    }
    function Gi(e, t) {
        return t.nodes[e] || t.marks[e] || null
    }
    function Ki(e, t) {
        return Array.isArray(t) ? t.some((t => ("string" === typeof t ? t : t.name) === e.name)) : t
    }
    function Ji(e) {
        return "[object RegExp]" === Object.prototype.toString.call(e)
    }
    class Zi {
        constructor(e) {
            this.find = e.find,
                this.handler = e.handler
        }
    }
    function Xi(e) {
        var t;
        const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = e
            , { view: l } = n;
        if (l.composing)
            return !1;
        const c = l.state.doc.resolve(r);
        if (c.parent.type.spec.code || (null === (t = c.nodeBefore || c.nodeAfter) || void 0 === t ? void 0 : t.marks.find((e => e.type.spec.code))))
            return !1;
        let d = !1;
        const u = function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500
                , n = "";
            const r = e.parentOffset;
            return e.parent.nodesBetween(Math.max(0, r - t), r, ((e, t, o, i) => {
                var s, a;
                const l = (null === (a = (s = e.type.spec).toText) || void 0 === a ? void 0 : a.call(s, {
                    node: e,
                    pos: t,
                    parent: o,
                    index: i
                })) || e.textContent || "%leaf%";
                n += e.isAtom && !e.isText ? l : l.slice(0, Math.max(0, r - t))
            }
            )),
                n
        }(c) + i;
        return s.forEach((e => {
            if (d)
                return;
            const t = ((e, t) => {
                if (Ji(t))
                    return t.exec(e);
                const n = t(e);
                if (!n)
                    return null;
                const r = [n.text];
                return r.index = n.index,
                    r.input = e,
                    r.data = n.data,
                    n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),
                        r.push(n.replaceWith)),
                    r
            }
            )(u, e.find);
            if (!t)
                return;
            const s = l.state.tr
                , c = Li({
                    state: l.state,
                    transaction: s
                })
                , h = {
                    from: r - (t[0].length - i.length),
                    to: o
                }
                , { commands: p, chain: f, can: m } = new Ri({
                    editor: n,
                    state: c
                });
            null !== e.handler({
                state: c,
                range: h,
                match: t,
                commands: p,
                chain: f,
                can: m
            }) && s.steps.length && (s.setMeta(a, {
                transform: s,
                from: r,
                to: o,
                text: i
            }),
                l.dispatch(s),
                d = !0)
        }
        )),
            d
    }
    function Qi(e) {
        const { editor: t, rules: n } = e
            , r = new Mt({
                state: {
                    init: () => null,
                    apply(e, o) {
                        const i = e.getMeta(r);
                        if (i)
                            return i;
                        const s = e.getMeta("applyInputRules");
                        return !!s && setTimeout((() => {
                            const { from: e, text: o } = s
                                , i = e + o.length;
                            Xi({
                                editor: t,
                                from: e,
                                to: i,
                                text: o,
                                rules: n,
                                plugin: r
                            })
                        }
                        )),
                            e.selectionSet || e.docChanged ? null : o
                    }
                },
                props: {
                    handleTextInput: (e, o, i, s) => Xi({
                        editor: t,
                        from: o,
                        to: i,
                        text: s,
                        rules: n,
                        plugin: r
                    }),
                    handleDOMEvents: {
                        compositionend: e => (setTimeout((() => {
                            const { $cursor: o } = e.state.selection;
                            o && Xi({
                                editor: t,
                                from: o.pos,
                                to: o.pos,
                                text: "",
                                rules: n,
                                plugin: r
                            })
                        }
                        )),
                            !1)
                    },
                    handleKeyDown(e, o) {
                        if ("Enter" !== o.key)
                            return !1;
                        const { $cursor: i } = e.state.selection;
                        return !!i && Xi({
                            editor: t,
                            from: i.pos,
                            to: i.pos,
                            text: "\n",
                            rules: n,
                            plugin: r
                        })
                    }
                },
                isInputRules: !0
            });
        return r
    }
    function Yi(e) {
        return "Object" === function (e) {
            return Object.prototype.toString.call(e).slice(8, -1)
        }(e) && (e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype)
    }
    function es(e, t) {
        const n = {
            ...e
        };
        return Yi(e) && Yi(t) && Object.keys(t).forEach((r => {
            Yi(t[r]) && Yi(e[r]) ? n[r] = es(e[r], t[r]) : n[r] = t[r]
        }
        )),
            n
    }
    class ts {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.type = "mark",
                this.name = "mark",
                this.parent = null,
                this.child = null,
                this.config = {
                    name: this.name,
                    defaultOptions: {}
                },
                this.config = {
                    ...this.config,
                    ...e
                },
                this.name = this.config.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
                this.options = this.config.defaultOptions,
                this.config.addOptions && (this.options = Fi(Ii(this, "addOptions", {
                    name: this.name
                }))),
                this.storage = Fi(Ii(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
        }
        static create() {
            return new ts(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
        }
        configure() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = this.extend({
                ...this.config,
                addOptions: () => es(this.options, e)
            });
            return t.name = this.name,
                t.parent = this.parent,
                t
        }
        extend() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = new ts(e);
            return t.parent = this,
                this.child = t,
                t.name = e.name ? e.name : t.parent.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),
                t.options = Fi(Ii(t, "addOptions", {
                    name: t.name
                })),
                t.storage = Fi(Ii(t, "addStorage", {
                    name: t.name,
                    options: t.options
                })),
                t
        }
        static handleExit(e) {
            let { editor: t, mark: n } = e;
            const { tr: r } = t.state
                , o = t.state.selection.$from;
            if (o.pos === o.end()) {
                const e = o.marks()
                    , i = !!e.find((e => (null === e || void 0 === e ? void 0 : e.type.name) === n.name));
                if (!i)
                    return !1;
                const s = e.find((e => (null === e || void 0 === e ? void 0 : e.type.name) === n.name));
                return s && r.removeStoredMark(s),
                    r.insertText(" ", o.pos),
                    t.view.dispatch(r),
                    !0
            }
            return !1
        }
    }
    class ns {
        constructor(e) {
            this.find = e.find,
                this.handler = e.handler
        }
    }
    function rs(e) {
        const { editor: t, state: n, from: r, to: o, rule: i, pasteEvent: s, dropEvent: a } = e
            , { commands: l, chain: c, can: d } = new Ri({
                editor: t,
                state: n
            })
            , u = [];
        n.doc.nodesBetween(r, o, ((e, t) => {
            if (!e.isTextblock || e.type.spec.code)
                return;
            const h = Math.max(r, t)
                , p = Math.min(o, t + e.content.size)
                , f = ((e, t, n) => {
                    if (Ji(t))
                        return [...e.matchAll(t)];
                    const r = t(e, n);
                    return r ? r.map((t => {
                        const n = [t.text];
                        return n.index = t.index,
                            n.input = e,
                            n.data = t.data,
                            t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'),
                                n.push(t.replaceWith)),
                            n
                    }
                    )) : []
                }
                )(e.textBetween(h - t, p - t, void 0, "\ufffc"), i.find, s);
            f.forEach((e => {
                if (void 0 === e.index)
                    return;
                const t = h + e.index + 1
                    , r = t + e[0].length
                    , o = {
                        from: n.tr.mapping.map(t),
                        to: n.tr.mapping.map(r)
                    }
                    , p = i.handler({
                        state: n,
                        range: o,
                        match: e,
                        commands: l,
                        chain: c,
                        can: d,
                        pasteEvent: s,
                        dropEvent: a
                    });
                u.push(p)
            }
            ))
        }
        ));
        return u.every((e => null !== e))
    }
    function is(e) {
        const { editor: t, rules: n } = e;
        let r = null
            , o = !1
            , i = !1
            , s = "undefined" !== typeof ClipboardEvent ? new ClipboardEvent("paste") : null
            , a = "undefined" !== typeof DragEvent ? new DragEvent("drop") : null;
        const l = e => {
            let { state: n, from: r, to: o, rule: i, pasteEvt: l } = e;
            const c = n.tr
                , d = Li({
                    state: n,
                    transaction: c
                });
            if (rs({
                editor: t,
                state: d,
                from: Math.max(r - 1, 0),
                to: o.b - 1,
                rule: i,
                pasteEvent: l,
                dropEvent: a
            }) && c.steps.length)
                return a = "undefined" !== typeof DragEvent ? new DragEvent("drop") : null,
                    s = "undefined" !== typeof ClipboardEvent ? new ClipboardEvent("paste") : null,
                    c
        }
            , c = n.map((e => new Mt({
                view(e) {
                    const t = t => {
                        var n;
                        r = (null === (n = e.dom.parentElement) || void 0 === n ? void 0 : n.contains(t.target)) ? e.dom.parentElement : null
                    }
                        ;
                    return window.addEventListener("dragstart", t),
                    {
                        destroy() {
                            window.removeEventListener("dragstart", t)
                        }
                    }
                },
                props: {
                    handleDOMEvents: {
                        drop: (e, t) => (i = r === e.dom.parentElement,
                            a = t,
                            !1),
                        paste: (e, t) => {
                            var n;
                            const r = null === (n = t.clipboardData) || void 0 === n ? void 0 : n.getData("text/html");
                            return s = t,
                                o = !!(null === r || void 0 === r ? void 0 : r.includes("data-pm-slice")),
                                !1
                        }
                    }
                },
                appendTransaction: (t, n, r) => {
                    const a = t[0]
                        , c = "paste" === a.getMeta("uiEvent") && !o
                        , d = "drop" === a.getMeta("uiEvent") && !i
                        , u = a.getMeta("applyPasteRules")
                        , h = !!u;
                    if (!c && !d && !h)
                        return;
                    if (h) {
                        const { from: t, text: n } = u
                            , o = t + n.length
                            , i = (e => {
                                var t;
                                const n = new ClipboardEvent("paste", {
                                    clipboardData: new DataTransfer
                                });
                                return null === (t = n.clipboardData) || void 0 === t || t.setData("text/html", e),
                                    n
                            }
                            )(n);
                        return l({
                            rule: e,
                            state: r,
                            from: t,
                            to: {
                                b: o
                            },
                            pasteEvt: i
                        })
                    }
                    const p = n.doc.content.findDiffStart(r.doc.content)
                        , f = n.doc.content.findDiffEnd(r.doc.content);
                    return "number" === typeof p && f && p !== f.b ? l({
                        rule: e,
                        state: r,
                        from: p,
                        to: f,
                        pasteEvt: s
                    }) : void 0
                }
            })));
        return c
    }
    class ss {
        constructor(e, t) {
            this.splittableMarks = [],
                this.editor = t,
                this.extensions = ss.resolve(e),
                this.schema = qi(this.extensions, t),
                this.setupExtensions()
        }
        static resolve(e) {
            const t = ss.sort(ss.flatten(e))
                , n = function (e) {
                    const t = e.filter(((t, n) => e.indexOf(t) !== n));
                    return Array.from(new Set(t))
                }(t.map((e => e.name)));
            return n.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((e => `'${e}'`)).join(", ")}]. This can lead to issues.`),
                t
        }
        static flatten(e) {
            return e.map((e => {
                const t = Ii(e, "addExtensions", {
                    name: e.name,
                    options: e.options,
                    storage: e.storage
                });
                return t ? [e, ...this.flatten(t())] : e
            }
            )).flat(10)
        }
        static sort(e) {
            return e.sort(((e, t) => {
                const n = Ii(e, "priority") || 100
                    , r = Ii(t, "priority") || 100;
                return n > r ? -1 : n < r ? 1 : 0
            }
            ))
        }
        get commands() {
            return this.extensions.reduce(((e, t) => {
                const n = Ii(t, "addCommands", {
                    name: t.name,
                    options: t.options,
                    storage: t.storage,
                    editor: this.editor,
                    type: Gi(t.name, this.schema)
                });
                return n ? {
                    ...e,
                    ...n()
                } : e
            }
            ), {})
        }
        get plugins() {
            const { editor: e } = this
                , t = ss.sort([...this.extensions].reverse())
                , n = []
                , r = []
                , o = t.map((t => {
                    const o = {
                        name: t.name,
                        options: t.options,
                        storage: t.storage,
                        editor: e,
                        type: Gi(t.name, this.schema)
                    }
                        , i = []
                        , s = Ii(t, "addKeyboardShortcuts", o);
                    let a = {};
                    if ("mark" === t.type && Ii(t, "exitable", o) && (a.ArrowRight = () => ts.handleExit({
                        editor: e,
                        mark: t
                    })),
                        s) {
                        const t = Object.fromEntries(Object.entries(s()).map((t => {
                            let [n, r] = t;
                            return [n, () => r({
                                editor: e
                            })]
                        }
                        )));
                        a = {
                            ...a,
                            ...t
                        }
                    }
                    const l = new Mt({
                        props: {
                            handleKeyDown: ni(a)
                        }
                    });
                    i.push(l);
                    const c = Ii(t, "addInputRules", o);
                    Ki(t, e.options.enableInputRules) && c && n.push(...c());
                    const d = Ii(t, "addPasteRules", o);
                    Ki(t, e.options.enablePasteRules) && d && r.push(...d());
                    const u = Ii(t, "addProseMirrorPlugins", o);
                    if (u) {
                        const e = u();
                        i.push(...e)
                    }
                    return i
                }
                )).flat();
            return [Qi({
                editor: e,
                rules: n
            }), ...is({
                editor: e,
                rules: r
            }), ...o]
        }
        get attributes() {
            return Hi(this.extensions)
        }
        get nodeViews() {
            const { editor: e } = this
                , { nodeExtensions: t } = ji(this.extensions);
            return Object.fromEntries(t.filter((e => !!Ii(e, "addNodeView"))).map((t => {
                const n = this.attributes.filter((e => e.type === t.name))
                    , r = {
                        name: t.name,
                        options: t.options,
                        storage: t.storage,
                        editor: e,
                        type: zi(t.name, this.schema)
                    }
                    , o = Ii(t, "addNodeView", r);
                if (!o)
                    return [];
                return [t.name, (r, i, s, a, l) => {
                    const c = Bi(r, n);
                    return o()({
                        node: r,
                        view: i,
                        getPos: s,
                        decorations: a,
                        innerDecorations: l,
                        editor: e,
                        extension: t,
                        HTMLAttributes: c
                    })
                }
                ]
            }
            )))
        }
        setupExtensions() {
            this.extensions.forEach((e => {
                var t;
                this.editor.extensionStorage[e.name] = e.storage;
                const n = {
                    name: e.name,
                    options: e.options,
                    storage: e.storage,
                    editor: this.editor,
                    type: Gi(e.name, this.schema)
                };
                if ("mark" === e.type) {
                    (null === (t = Fi(Ii(e, "keepOnSplit", n))) || void 0 === t || t) && this.splittableMarks.push(e.name)
                }
                const r = Ii(e, "onBeforeCreate", n)
                    , o = Ii(e, "onCreate", n)
                    , i = Ii(e, "onUpdate", n)
                    , s = Ii(e, "onSelectionUpdate", n)
                    , a = Ii(e, "onTransaction", n)
                    , l = Ii(e, "onFocus", n)
                    , c = Ii(e, "onBlur", n)
                    , d = Ii(e, "onDestroy", n);
                r && this.editor.on("beforeCreate", r),
                    o && this.editor.on("create", o),
                    i && this.editor.on("update", i),
                    s && this.editor.on("selectionUpdate", s),
                    a && this.editor.on("transaction", a),
                    l && this.editor.on("focus", l),
                    c && this.editor.on("blur", c),
                    d && this.editor.on("destroy", d)
            }
            ))
        }
    }
    class as {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.type = "extension",
                this.name = "extension",
                this.parent = null,
                this.child = null,
                this.config = {
                    name: this.name,
                    defaultOptions: {}
                },
                this.config = {
                    ...this.config,
                    ...e
                },
                this.name = this.config.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
                this.options = this.config.defaultOptions,
                this.config.addOptions && (this.options = Fi(Ii(this, "addOptions", {
                    name: this.name
                }))),
                this.storage = Fi(Ii(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
        }
        static create() {
            return new as(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
        }
        configure() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = this.extend({
                ...this.config,
                addOptions: () => es(this.options, e)
            });
            return t.name = this.name,
                t.parent = this.parent,
                t
        }
        extend() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = new as({
                ...this.config,
                ...e
            });
            return t.parent = this,
                this.child = t,
                t.name = e.name ? e.name : t.parent.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),
                t.options = Fi(Ii(t, "addOptions", {
                    name: t.name
                })),
                t.storage = Fi(Ii(t, "addStorage", {
                    name: t.name,
                    options: t.options
                })),
                t
        }
    }
    function ls(e, t, n) {
        const { from: r, to: o } = t
            , { blockSeparator: i = "\n\n", textSerializers: s = {} } = n || {};
        let a = "";
        return e.nodesBetween(r, o, ((e, n, l, c) => {
            var d;
            e.isBlock && n > r && (a += i);
            const u = null === s || void 0 === s ? void 0 : s[e.type.name];
            if (u)
                return l && (a += u({
                    node: e,
                    pos: n,
                    parent: l,
                    index: c,
                    range: t
                })),
                    !1;
            e.isText && (a += null === (d = null === e || void 0 === e ? void 0 : e.text) || void 0 === d ? void 0 : d.slice(Math.max(r, n) - n, o - n))
        }
        )),
            a
    }
    function cs(e) {
        return Object.fromEntries(Object.entries(e.nodes).filter((e => {
            let [, t] = e;
            return t.spec.toText
        }
        )).map((e => {
            let [t, n] = e;
            return [t, n.spec.toText]
        }
        )))
    }
    const ds = as.create({
        name: "clipboardTextSerializer",
        addOptions: () => ({
            blockSeparator: void 0
        }),
        addProseMirrorPlugins() {
            return [new Mt({
                key: new _t("clipboardTextSerializer"),
                props: {
                    clipboardTextSerializer: () => {
                        const { editor: e } = this
                            , { state: t, schema: n } = e
                            , { doc: r, selection: o } = t
                            , { ranges: i } = o
                            , s = Math.min(...i.map((e => e.$from.pos)))
                            , a = Math.max(...i.map((e => e.$to.pos)))
                            , l = cs(n);
                        return ls(r, {
                            from: s,
                            to: a
                        }, {
                            ...void 0 !== this.options.blockSeparator ? {
                                blockSeparator: this.options.blockSeparator
                            } : {},
                            textSerializers: l
                        })
                    }
                }
            })]
        }
    });
    function us(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
            strict: !0
        };
        const r = Object.keys(t);
        return !r.length || r.every((r => n.strict ? t[r] === e[r] : Ji(t[r]) ? t[r].test(e[r]) : t[r] === e[r]))
    }
    function hs(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return e.find((e => e.type === t && us(e.attrs, n)))
    }
    function ps(e, t) {
        return !!hs(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {})
    }
    function fs(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!e || !t)
            return;
        let r = e.parent.childAfter(e.parentOffset);
        if (r.node && r.node.marks.some((e => e.type === t)) || (r = e.parent.childBefore(e.parentOffset)),
            !r.node || !r.node.marks.some((e => e.type === t)))
            return;
        const o = hs([...r.node.marks], t, n);
        if (!o)
            return;
        let i = r.index
            , s = e.start() + r.offset
            , a = i + 1
            , l = s + r.node.nodeSize;
        for (hs([...r.node.marks], t, n); i > 0 && o.isInSet(e.parent.child(i - 1).marks);)
            i -= 1,
                s -= e.parent.child(i).nodeSize;
        for (; a < e.parent.childCount && ps([...e.parent.child(a).marks], t, n);)
            l += e.parent.child(a).nodeSize,
                a += 1;
        return {
            from: s,
            to: l
        }
    }
    function ms(e, t) {
        if ("string" === typeof e) {
            if (!t.marks[e])
                throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
            return t.marks[e]
        }
        return e
    }
    function gs(e) {
        return e instanceof ut
    }
    function bs() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
            , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
            , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Math.min(Math.max(e, t), n)
    }
    function ys(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        if (!t)
            return null;
        const n = at.atStart(e)
            , r = at.atEnd(e);
        if ("start" === t || !0 === t)
            return n;
        if ("end" === t)
            return r;
        const o = n.from
            , i = r.to;
        return "all" === t ? ut.create(e, bs(0, o, i), bs(e.content.size, o, i)) : ut.create(e, bs(t, o, i), bs(t, o, i))
    }
    function vs() {
        return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
    }
    const ws = e => {
        const t = e.childNodes;
        for (let n = t.length - 1; n >= 0; n -= 1) {
            const r = t[n];
            3 === r.nodeType && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : 1 === r.nodeType && ws(r)
        }
        return e
    }
        ;
    function ks(e) {
        const t = `<body>${e}</body>`
            , n = (new window.DOMParser).parseFromString(t, "text/html").body;
        return ws(n)
    }
    function Cs(e, t, n) {
        n = {
            slice: !0,
            parseOptions: {},
            ...n
        };
        const r = "string" === typeof e;
        if ("object" === typeof e && null !== e)
            try {
                if (Array.isArray(e) && e.length > 0)
                    return d.fromArray(e.map((e => t.nodeFromJSON(e))));
                const r = t.nodeFromJSON(e);
                return n.errorOnInvalidContent && r.check(),
                    r
            } catch (o) {
                if (n.errorOnInvalidContent)
                    throw new Error("[tiptap error]: Invalid JSON content", {
                        cause: o
                    });
                return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", o),
                    Cs("", t, n)
            }
        if (r) {
            if (n.errorOnInvalidContent) {
                let r = !1
                    , o = "";
                const i = new Y({
                    topNode: t.spec.topNode,
                    marks: t.spec.marks,
                    nodes: t.spec.nodes.append({
                        __tiptap__private__unknown__catch__all__node: {
                            content: "inline*",
                            group: "block",
                            parseDOM: [{
                                tag: "*",
                                getAttrs: e => (r = !0,
                                    o = "string" === typeof e ? e : e.outerHTML,
                                    null)
                            }]
                        }
                    })
                });
                if (n.slice ? te.fromSchema(i).parseSlice(ks(e), n.parseOptions) : te.fromSchema(i).parse(ks(e), n.parseOptions),
                    n.errorOnInvalidContent && r)
                    throw new Error("[tiptap error]: Invalid HTML content", {
                        cause: new Error(`Invalid element found: ${o}`)
                    })
            }
            const r = te.fromSchema(t);
            return n.slice ? r.parseSlice(ks(e), n.parseOptions).content : r.parse(ks(e), n.parseOptions)
        }
        return Cs("", t, n)
    }
    function Ss(e, t, n) {
        const r = e.steps.length - 1;
        if (r < t)
            return;
        const o = e.steps[r];
        if (!(o instanceof Ae || o instanceof Pe))
            return;
        const i = e.mapping.maps[r];
        let s = 0;
        i.forEach(((e, t, n, r) => {
            0 === s && (s = r)
        }
        )),
            e.setSelection(at.near(e.doc.resolve(s), n))
    }
    function xs() {
        return "undefined" !== typeof navigator && /Mac/.test(navigator.platform)
    }
    function Es(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        const { from: r, to: o, empty: i } = e.selection
            , s = t ? zi(t, e.schema) : null
            , a = [];
        e.doc.nodesBetween(r, o, ((e, t) => {
            if (e.isText)
                return;
            const n = Math.max(r, t)
                , i = Math.min(o, t + e.nodeSize);
            a.push({
                node: e,
                from: n,
                to: i
            })
        }
        ));
        const l = o - r
            , c = a.filter((e => !s || s.name === e.node.type.name)).filter((e => us(e.node.attrs, n, {
                strict: !1
            })));
        if (i)
            return !!c.length;
        return c.reduce(((e, t) => e + t.to - t.from), 0) >= l
    }
    function Ms(e, t) {
        return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null
    }
    function Ts(e, t) {
        const n = "string" === typeof t ? [t] : t;
        return Object.keys(e).reduce(((t, r) => (n.includes(r) || (t[r] = e[r]),
            t)), {})
    }
    function Ns(e, t) {
        return Cs(e, t, {
            slice: !1,
            parseOptions: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            errorOnInvalidContent: (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}).errorOnInvalidContent
        })
    }
    function _s(e, t) {
        const n = ms(t, e.schema)
            , { from: r, to: o, empty: i } = e.selection
            , s = [];
        i ? (e.storedMarks && s.push(...e.storedMarks),
            s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, o, (e => {
                s.push(...e.marks)
            }
            ));
        const a = s.find((e => e.type.name === n.name));
        return a ? {
            ...a.attrs
        } : {}
    }
    function Os(e, t) {
        const n = new it(e);
        return t.forEach((e => {
            e.steps.forEach((e => {
                n.step(e)
            }
            ))
        }
        )),
            n
    }
    function As(e, t) {
        const n = [];
        return e.descendants(((e, r) => {
            t(e) && n.push({
                node: e,
                pos: r
            })
        }
        )),
            n
    }
    function Ps(e, t, n) {
        const r = [];
        return e.nodesBetween(t.from, t.to, ((e, t) => {
            n(e) && r.push({
                node: e,
                pos: t
            })
        }
        )),
            r
    }
    function Ls(e) {
        return t => function (e, t) {
            for (let n = e.depth; n > 0; n -= 1) {
                const r = e.node(n);
                if (t(r))
                    return {
                        pos: n > 0 ? e.before(n) : 0,
                        start: e.start(n),
                        depth: n,
                        node: r
                    }
            }
        }(t.$from, e)
    }
    function Rs(e, t) {
        const n = ue.fromSchema(t).serializeFragment(e)
            , r = document.implementation.createHTMLDocument().createElement("div");
        return r.appendChild(n),
            r.innerHTML
    }
    function Ds(e, t) {
        return qi(ss.resolve(e), t)
    }
    function Is(e, t) {
        return ls(e, {
            from: 0,
            to: e.content.size
        }, t)
    }
    function js(e, t) {
        const n = Ms("string" === typeof t ? t : t.name, e.schema);
        return "node" === n ? function (e, t) {
            const n = zi(t, e.schema)
                , { from: r, to: o } = e.selection
                , i = [];
            e.doc.nodesBetween(r, o, (e => {
                i.push(e)
            }
            ));
            const s = i.reverse().find((e => e.type.name === n.name));
            return s ? {
                ...s.attrs
            } : {}
        }(e, t) : "mark" === n ? _s(e, t) : {}
    }
    function Hs(e) {
        const t = function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : JSON.stringify;
            const n = {};
            return e.filter((e => {
                const r = t(e);
                return !Object.prototype.hasOwnProperty.call(n, r) && (n[r] = !0)
            }
            ))
        }(e);
        return 1 === t.length ? t : t.filter(((e, n) => {
            const r = t.filter(((e, t) => t !== n));
            return !r.some((t => e.oldRange.from >= t.oldRange.from && e.oldRange.to <= t.oldRange.to && e.newRange.from >= t.newRange.from && e.newRange.to <= t.newRange.to))
        }
        ))
    }
    function zs(e) {
        const { mapping: t, steps: n } = e
            , r = [];
        return t.maps.forEach(((e, o) => {
            const i = [];
            if (e.ranges.length)
                e.forEach(((e, t) => {
                    i.push({
                        from: e,
                        to: t
                    })
                }
                ));
            else {
                const { from: e, to: t } = n[o];
                if (void 0 === e || void 0 === t)
                    return;
                i.push({
                    from: e,
                    to: t
                })
            }
            i.forEach((e => {
                let { from: n, to: i } = e;
                const s = t.slice(o).map(n, -1)
                    , a = t.slice(o).map(i)
                    , l = t.invert().map(s, -1)
                    , c = t.invert().map(a);
                r.push({
                    oldRange: {
                        from: l,
                        to: c
                    },
                    newRange: {
                        from: s,
                        to: a
                    }
                })
            }
            ))
        }
        )),
            Hs(r)
    }
    function $s(e, t, n) {
        const r = [];
        return e === t ? n.resolve(e).marks().forEach((t => {
            const o = fs(n.resolve(e), t.type);
            o && r.push({
                mark: t,
                ...o
            })
        }
        )) : n.nodesBetween(e, t, ((e, t) => {
            e && void 0 !== (null === e || void 0 === e ? void 0 : e.nodeSize) && r.push(...e.marks.map((n => ({
                from: t,
                to: t + e.nodeSize,
                mark: n
            }))))
        }
        )),
            r
    }
    function Bs(e, t, n) {
        return Object.fromEntries(Object.entries(n).filter((n => {
            let [r] = n;
            const o = e.find((e => e.type === t && e.name === r));
            return !!o && o.attribute.keepOnSplit
        }
        )))
    }
    function Vs(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        const { empty: r, ranges: o } = e.selection
            , i = t ? ms(t, e.schema) : null;
        if (r)
            return !!(e.storedMarks || e.selection.$from.marks()).filter((e => !i || i.name === e.type.name)).find((e => us(e.attrs, n, {
                strict: !1
            })));
        let s = 0;
        const a = [];
        if (o.forEach((t => {
            let { $from: n, $to: r } = t;
            const o = n.pos
                , i = r.pos;
            e.doc.nodesBetween(o, i, ((e, t) => {
                if (!e.isText && !e.marks.length)
                    return;
                const n = Math.max(o, t)
                    , r = Math.min(i, t + e.nodeSize);
                s += r - n,
                    a.push(...e.marks.map((e => ({
                        mark: e,
                        from: n,
                        to: r
                    }))))
            }
            ))
        }
        )),
            0 === s)
            return !1;
        const l = a.filter((e => !i || i.name === e.mark.type.name)).filter((e => us(e.mark.attrs, n, {
            strict: !1
        }))).reduce(((e, t) => e + t.to - t.from), 0)
            , c = a.filter((e => !i || e.mark.type !== i && e.mark.type.excludes(i))).reduce(((e, t) => e + t.to - t.from), 0);
        return (l > 0 ? l + c : l) >= s
    }
    function Fs(e, t) {
        const { nodeExtensions: n } = ji(t)
            , r = n.find((t => t.name === e));
        if (!r)
            return !1;
        const o = Fi(Ii(r, "group", {
            name: r.name,
            options: r.options,
            storage: r.storage
        }));
        return "string" === typeof o && o.split(" ").includes("list")
    }
    function Us(e) {
        let { checkChildren: t = !0, ignoreWhitespace: n = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var r;
        if (n) {
            if ("hardBreak" === e.type.name)
                return !0;
            if (e.isText)
                return /^\s*$/m.test(null !== (r = e.text) && void 0 !== r ? r : "")
        }
        if (e.isText)
            return !e.text;
        if (e.isAtom || e.isLeaf)
            return !1;
        if (0 === e.content.childCount)
            return !0;
        if (t) {
            let r = !0;
            return e.content.forEach((e => {
                !1 !== r && (Us(e, {
                    ignoreWhitespace: n,
                    checkChildren: t
                }) || (r = !1))
            }
            )),
                r
        }
        return !1
    }
    function Ws(e) {
        return e instanceof pt
    }
    function qs(e, t, n) {
        const r = e.state.doc.content.size
            , o = bs(t, 0, r)
            , i = bs(n, 0, r)
            , s = e.coordsAtPos(o)
            , a = e.coordsAtPos(i, -1)
            , l = Math.min(s.top, a.top)
            , c = Math.max(s.bottom, a.bottom)
            , d = Math.min(s.left, a.left)
            , u = Math.max(s.right, a.right)
            , h = {
                top: l,
                bottom: c,
                left: d,
                right: u,
                width: u - d,
                height: c - l,
                x: d,
                y: l
            };
        return {
            ...h,
            toJSON: () => h
        }
    }
    function Gs(e, t) {
        const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
        if (n) {
            const r = n.filter((e => null === t || void 0 === t ? void 0 : t.includes(e.type.name)));
            e.tr.ensureMarks(r)
        }
    }
    const Ks = (e, t) => {
        const n = Ls((e => e.type === t))(e.selection);
        if (!n)
            return !0;
        const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
        if (void 0 === r)
            return !0;
        const o = e.doc.nodeAt(r);
        return n.node.type !== (null === o || void 0 === o ? void 0 : o.type) || !Ve(e.doc, n.pos) || (e.join(n.pos),
            !0)
    }
        , Js = (e, t) => {
            const n = Ls((e => e.type === t))(e.selection);
            if (!n)
                return !0;
            const r = e.doc.resolve(n.start).after(n.depth);
            if (void 0 === r)
                return !0;
            const o = e.doc.nodeAt(r);
            return n.node.type !== (null === o || void 0 === o ? void 0 : o.type) || !Ve(e.doc, r) || (e.join(r),
                !0)
        }
        ;
    var Zs = Object.freeze({
        __proto__: null,
        blur: () => e => {
            let { editor: t, view: n } = e;
            return requestAnimationFrame((() => {
                var e;
                t.isDestroyed || (n.dom.blur(),
                    null === (e = null === window || void 0 === window ? void 0 : window.getSelection()) || void 0 === e || e.removeAllRanges())
            }
            )),
                !0
        }
        ,
        clearContent: function () {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return t => {
                let { commands: n } = t;
                return n.setContent("", e)
            }
        },
        clearNodes: () => e => {
            let { state: t, tr: n, dispatch: r } = e;
            const { selection: o } = n
                , { ranges: i } = o;
            return !r || (i.forEach((e => {
                let { $from: r, $to: o } = e;
                t.doc.nodesBetween(r.pos, o.pos, ((e, t) => {
                    if (e.type.isText)
                        return;
                    const { doc: r, mapping: o } = n
                        , i = r.resolve(o.map(t))
                        , s = r.resolve(o.map(t + e.nodeSize))
                        , a = i.blockRange(s);
                    if (!a)
                        return;
                    const l = Ie(a);
                    if (e.type.isTextblock) {
                        const { defaultType: e } = i.parent.contentMatchAt(i.index());
                        n.setNodeMarkup(a.start, e)
                    }
                    (l || 0 === l) && n.lift(a, l)
                }
                ))
            }
            )),
                !0)
        }
        ,
        command: e => t => e(t),
        createParagraphNear: () => e => {
            let { state: t, dispatch: n } = e;
            return bi(t, n)
        }
        ,
        cut: (e, t) => n => {
            let { editor: r, tr: o } = n;
            const { state: i } = r
                , s = i.doc.slice(e.from, e.to);
            o.deleteRange(e.from, e.to);
            const a = o.mapping.map(t);
            return o.insert(a, s.content),
                o.setSelection(new ut(o.doc.resolve(a - 1))),
                !0
        }
        ,
        deleteCurrentNode: () => e => {
            let { tr: t, dispatch: n } = e;
            const { selection: r } = t
                , o = r.$anchor.node();
            if (o.content.size > 0)
                return !1;
            const i = t.selection.$anchor;
            for (let s = i.depth; s > 0; s -= 1) {
                if (i.node(s).type === o.type) {
                    if (n) {
                        const e = i.before(s)
                            , n = i.after(s);
                        t.delete(e, n).scrollIntoView()
                    }
                    return !0
                }
            }
            return !1
        }
        ,
        deleteNode: e => t => {
            let { tr: n, state: r, dispatch: o } = t;
            const i = zi(e, r.schema)
                , s = n.selection.$anchor;
            for (let e = s.depth; e > 0; e -= 1) {
                if (s.node(e).type === i) {
                    if (o) {
                        const t = s.before(e)
                            , r = s.after(e);
                        n.delete(t, r).scrollIntoView()
                    }
                    return !0
                }
            }
            return !1
        }
        ,
        deleteRange: e => t => {
            let { tr: n, dispatch: r } = t;
            const { from: o, to: i } = e;
            return r && n.delete(o, i),
                !0
        }
        ,
        deleteSelection: () => e => {
            let { state: t, dispatch: n } = e;
            return ri(t, n)
        }
        ,
        enter: () => e => {
            let { commands: t } = e;
            return t.keyboardShortcut("Enter")
        }
        ,
        exitCode: () => e => {
            let { state: t, dispatch: n } = e;
            return gi(t, n)
        }
        ,
        extendMarkRange: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { tr: r, state: o, dispatch: i } = n;
                const s = ms(e, o.schema)
                    , { doc: a, selection: l } = r
                    , { $from: c, from: d, to: u } = l;
                if (i) {
                    const e = fs(c, s, t);
                    if (e && e.from <= d && e.to >= u) {
                        const t = ut.create(a, e.from, e.to);
                        r.setSelection(t)
                    }
                }
                return !0
            }
        },
        first: e => t => {
            const n = "function" === typeof e ? e(t) : e;
            for (let e = 0; e < n.length; e += 1)
                if (n[e](t))
                    return !0;
            return !1
        }
        ,
        focus: function () {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { editor: r, view: o, tr: i, dispatch: s } = n;
                t = {
                    scrollIntoView: !0,
                    ...t
                };
                const a = () => {
                    vs() && o.dom.focus(),
                        requestAnimationFrame((() => {
                            r.isDestroyed || (o.focus(),
                                (null === t || void 0 === t ? void 0 : t.scrollIntoView) && r.commands.scrollIntoView())
                        }
                        ))
                }
                    ;
                if (o.hasFocus() && null === e || !1 === e)
                    return !0;
                if (s && null === e && !gs(r.state.selection))
                    return a(),
                        !0;
                const l = ys(i.doc, e) || r.state.selection
                    , c = r.state.selection.eq(l);
                return s && (c || i.setSelection(l),
                    c && i.storedMarks && i.setStoredMarks(i.storedMarks),
                    a()),
                    !0
            }
        },
        forEach: (e, t) => n => e.every(((e, r) => t(e, {
            ...n,
            index: r
        }))),
        insertContent: (e, t) => n => {
            let { tr: r, commands: o } = n;
            return o.insertContentAt({
                from: r.selection.from,
                to: r.selection.to
            }, e, t)
        }
        ,
        insertContentAt: (e, t, n) => r => {
            let { tr: o, dispatch: i, editor: s } = r;
            var a;
            if (i) {
                let r;
                n = {
                    parseOptions: s.options.parseOptions,
                    updateSelection: !0,
                    applyInputRules: !1,
                    applyPasteRules: !1,
                    ...n
                };
                try {
                    r = Cs(t, s.schema, {
                        parseOptions: {
                            preserveWhitespace: "full",
                            ...n.parseOptions
                        },
                        errorOnInvalidContent: null !== (a = n.errorOnInvalidContent) && void 0 !== a ? a : s.options.enableContentCheck
                    })
                } catch (l) {
                    return s.emit("contentError", {
                        editor: s,
                        error: l,
                        disableCollaboration: () => {
                            s.storage.collaboration && (s.storage.collaboration.isDisabled = !0)
                        }
                    }),
                        !1
                }
                let { from: i, to: c } = "number" === typeof e ? {
                    from: e,
                    to: e
                } : {
                    from: e.from,
                    to: e.to
                }
                    , d = !0
                    , u = !0;
                if (("type" in r ? [r] : r).forEach((e => {
                    e.check(),
                        d = !!d && (e.isText && 0 === e.marks.length),
                        u = !!u && e.isBlock
                }
                )),
                    i === c && u) {
                    const { parent: e } = o.doc.resolve(i);
                    e.isTextblock && !e.type.spec.code && !e.childCount && (i -= 1,
                        c += 1)
                }
                let h;
                d ? (h = Array.isArray(t) ? t.map((e => e.text || "")).join("") : "object" === typeof t && t && t.text ? t.text : t,
                    o.insertText(h, i, c)) : (h = r,
                        o.replaceWith(i, c, h)),
                    n.updateSelection && Ss(o, o.steps.length - 1, -1),
                    n.applyInputRules && o.setMeta("applyInputRules", {
                        from: i,
                        text: h
                    }),
                    n.applyPasteRules && o.setMeta("applyPasteRules", {
                        from: i,
                        text: h
                    })
            }
            return !0
        }
        ,
        joinBackward: () => e => {
            let { state: t, dispatch: n } = e;
            return ii(t, n)
        }
        ,
        joinDown: () => e => {
            let { state: t, dispatch: n } = e;
            return ((e, t) => {
                let n, r = e.selection;
                if (r instanceof pt) {
                    if (r.node.isTextblock || !Ve(e.doc, r.to))
                        return !1;
                    n = r.to
                } else if (n = Ue(e.doc, r.to, 1),
                    null == n)
                    return !1;
                return t && t(e.tr.join(n).scrollIntoView()),
                    !0
            }
            )(t, n)
        }
        ,
        joinForward: () => e => {
            let { state: t, dispatch: n } = e;
            return ui(t, n)
        }
        ,
        joinItemBackward: () => e => {
            let { state: t, dispatch: n, tr: r } = e;
            try {
                const e = Ue(t.doc, t.selection.$from.pos, -1);
                return null !== e && void 0 !== e && (r.join(e, 2),
                    n && n(r),
                    !0)
            } catch (o) {
                return !1
            }
        }
        ,
        joinItemForward: () => e => {
            let { state: t, dispatch: n, tr: r } = e;
            try {
                const e = Ue(t.doc, t.selection.$from.pos, 1);
                return null !== e && void 0 !== e && (r.join(e, 2),
                    n && n(r),
                    !0)
            } catch (o) {
                return !1
            }
        }
        ,
        joinTextblockBackward: () => e => {
            let { state: t, dispatch: n } = e;
            return ((e, t, n) => {
                let r = oi(e, n);
                if (!r)
                    return !1;
                let o = ci(r);
                return !!o && si(e, o, t)
            }
            )(t, n)
        }
        ,
        joinTextblockForward: () => e => {
            let { state: t, dispatch: n } = e;
            return ((e, t, n) => {
                let r = di(e, n);
                if (!r)
                    return !1;
                let o = pi(r);
                return !!o && si(e, o, t)
            }
            )(t, n)
        }
        ,
        joinUp: () => e => {
            let { state: t, dispatch: n } = e;
            return ((e, t) => {
                let n, r = e.selection, o = r instanceof pt;
                if (o) {
                    if (r.node.isTextblock || !Ve(e.doc, r.from))
                        return !1;
                    n = r.from
                } else if (n = Ue(e.doc, r.from, -1),
                    null == n)
                    return !1;
                if (t) {
                    let r = e.tr.join(n);
                    o && r.setSelection(pt.create(r.doc, n - e.doc.resolve(n).nodeBefore.nodeSize)),
                        t(r.scrollIntoView())
                }
                return !0
            }
            )(t, n)
        }
        ,
        keyboardShortcut: e => t => {
            let { editor: n, view: r, tr: o, dispatch: i } = t;
            const s = function (e) {
                const t = e.split(/-(?!$)/);
                let n, r, o, i, s = t[t.length - 1];
                "Space" === s && (s = " ");
                for (let a = 0; a < t.length - 1; a += 1) {
                    const e = t[a];
                    if (/^(cmd|meta|m)$/i.test(e))
                        i = !0;
                    else if (/^a(lt)?$/i.test(e))
                        n = !0;
                    else if (/^(c|ctrl|control)$/i.test(e))
                        r = !0;
                    else if (/^s(hift)?$/i.test(e))
                        o = !0;
                    else {
                        if (!/^mod$/i.test(e))
                            throw new Error(`Unrecognized modifier name: ${e}`);
                        vs() || xs() ? i = !0 : r = !0
                    }
                }
                return n && (s = `Alt-${s}`),
                    r && (s = `Ctrl-${s}`),
                    i && (s = `Meta-${s}`),
                    o && (s = `Shift-${s}`),
                    s
            }(e).split(/-(?!$)/)
                , a = s.find((e => !["Alt", "Ctrl", "Meta", "Shift"].includes(e)))
                , l = new KeyboardEvent("keydown", {
                    key: "Space" === a ? " " : a,
                    altKey: s.includes("Alt"),
                    ctrlKey: s.includes("Ctrl"),
                    metaKey: s.includes("Meta"),
                    shiftKey: s.includes("Shift"),
                    bubbles: !0,
                    cancelable: !0
                })
                , c = n.captureTransaction((() => {
                    r.someProp("handleKeyDown", (e => e(r, l)))
                }
                ));
            return null === c || void 0 === c || c.steps.forEach((e => {
                const t = e.map(o.mapping);
                t && i && o.maybeStep(t)
            }
            )),
                !0
        }
        ,
        lift: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { state: r, dispatch: o } = n;
                return !!Es(r, zi(e, r.schema), t) && ((e, t) => {
                    let { $from: n, $to: r } = e.selection
                        , o = n.blockRange(r)
                        , i = o && Ie(o);
                    return null != i && (t && t(e.tr.lift(o, i).scrollIntoView()),
                        !0)
                }
                )(r, o)
            }
        },
        liftEmptyBlock: () => e => {
            let { state: t, dispatch: n } = e;
            return yi(t, n)
        }
        ,
        liftListItem: e => t => {
            let { state: n, dispatch: r } = t;
            return Pi(zi(e, n.schema))(n, r)
        }
        ,
        newlineInCode: () => e => {
            let { state: t, dispatch: n } = e;
            return fi(t, n)
        }
        ,
        resetAttributes: (e, t) => n => {
            let { tr: r, state: o, dispatch: i } = n
                , s = null
                , a = null;
            const l = Ms("string" === typeof e ? e : e.name, o.schema);
            return !!l && ("node" === l && (s = zi(e, o.schema)),
                "mark" === l && (a = ms(e, o.schema)),
                i && r.selection.ranges.forEach((e => {
                    o.doc.nodesBetween(e.$from.pos, e.$to.pos, ((e, n) => {
                        s && s === e.type && r.setNodeMarkup(n, void 0, Ts(e.attrs, t)),
                            a && e.marks.length && e.marks.forEach((o => {
                                a === o.type && r.addMark(n, n + e.nodeSize, a.create(Ts(o.attrs, t)))
                            }
                            ))
                    }
                    ))
                }
                )),
                !0)
        }
        ,
        scrollIntoView: () => e => {
            let { tr: t, dispatch: n } = e;
            return n && t.scrollIntoView(),
                !0
        }
        ,
        selectAll: () => e => {
            let { tr: t, commands: n } = e;
            return n.setTextSelection({
                from: 0,
                to: t.doc.content.size
            })
        }
        ,
        selectNodeBackward: () => e => {
            let { state: t, dispatch: n } = e;
            return li(t, n)
        }
        ,
        selectNodeForward: () => e => {
            let { state: t, dispatch: n } = e;
            return hi(t, n)
        }
        ,
        selectParentNode: () => e => {
            let { state: t, dispatch: n } = e;
            return ((e, t) => {
                let n, { $from: r, to: o } = e.selection, i = r.sharedDepth(o);
                return 0 != i && (n = r.before(i),
                    t && t(e.tr.setSelection(pt.create(e.doc, n))),
                    !0)
            }
            )(t, n)
        }
        ,
        selectTextblockEnd: () => e => {
            let { state: t, dispatch: n } = e;
            return xi(t, n)
        }
        ,
        selectTextblockStart: () => e => {
            let { state: t, dispatch: n } = e;
            return Si(t, n)
        }
        ,
        setContent: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            return o => {
                let { editor: i, tr: s, dispatch: a, commands: l } = o;
                var c, d;
                const { doc: u } = s;
                if ("full" !== n.preserveWhitespace) {
                    const o = Ns(e, i.schema, n, {
                        errorOnInvalidContent: null !== (c = r.errorOnInvalidContent) && void 0 !== c ? c : i.options.enableContentCheck
                    });
                    return a && s.replaceWith(0, u.content.size, o).setMeta("preventUpdate", !t),
                        !0
                }
                return a && s.setMeta("preventUpdate", !t),
                    l.insertContentAt({
                        from: 0,
                        to: u.content.size
                    }, e, {
                        parseOptions: n,
                        errorOnInvalidContent: null !== (d = r.errorOnInvalidContent) && void 0 !== d ? d : i.options.enableContentCheck
                    })
            }
        },
        setMark: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { tr: r, state: o, dispatch: i } = n;
                const { selection: s } = r
                    , { empty: a, ranges: l } = s
                    , c = ms(e, o.schema);
                if (i)
                    if (a) {
                        const e = _s(o, c);
                        r.addStoredMark(c.create({
                            ...e,
                            ...t
                        }))
                    } else
                        l.forEach((e => {
                            const n = e.$from.pos
                                , i = e.$to.pos;
                            o.doc.nodesBetween(n, i, ((e, o) => {
                                const s = Math.max(o, n)
                                    , a = Math.min(o + e.nodeSize, i);
                                e.marks.find((e => e.type === c)) ? e.marks.forEach((e => {
                                    c === e.type && r.addMark(s, a, c.create({
                                        ...e.attrs,
                                        ...t
                                    }))
                                }
                                )) : r.addMark(s, a, c.create(t))
                            }
                            ))
                        }
                        ));
                return function (e, t, n) {
                    var r;
                    const { selection: o } = t;
                    let i = null;
                    if (gs(o) && (i = o.$cursor),
                        i) {
                        const t = null !== (r = e.storedMarks) && void 0 !== r ? r : i.marks();
                        return !!n.isInSet(t) || !t.some((e => e.type.excludes(n)))
                    }
                    const { ranges: s } = o;
                    return s.some((t => {
                        let { $from: r, $to: o } = t
                            , i = 0 === r.depth && e.doc.inlineContent && e.doc.type.allowsMarkType(n);
                        return e.doc.nodesBetween(r.pos, o.pos, ((e, t, r) => {
                            if (i)
                                return !1;
                            if (e.isInline) {
                                const t = !r || r.type.allowsMarkType(n)
                                    , o = !!n.isInSet(e.marks) || !e.marks.some((e => e.type.excludes(n)));
                                i = t && o
                            }
                            return !i
                        }
                        )),
                            i
                    }
                    ))
                }(o, r, c)
            }
        },
        setMeta: (e, t) => n => {
            let { tr: r } = n;
            return r.setMeta(e, t),
                !0
        }
        ,
        setNode: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { state: r, dispatch: o, chain: i } = n;
                const s = zi(e, r.schema);
                return s.isTextblock ? i().command((e => {
                    let { commands: n } = e;
                    return !!Ei(s, t)(r) || n.clearNodes()
                }
                )).command((e => {
                    let { state: n } = e;
                    return Ei(s, t)(n, o)
                }
                )).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
                    !1)
            }
        },
        setNodeSelection: e => t => {
            let { tr: n, dispatch: r } = t;
            if (r) {
                const { doc: t } = n
                    , r = bs(e, 0, t.content.size)
                    , o = pt.create(t, r);
                n.setSelection(o)
            }
            return !0
        }
        ,
        setTextSelection: e => t => {
            let { tr: n, dispatch: r } = t;
            if (r) {
                const { doc: t } = n
                    , { from: r, to: o } = "number" === typeof e ? {
                        from: e,
                        to: e
                    } : e
                    , i = ut.atStart(t).from
                    , s = ut.atEnd(t).to
                    , a = bs(r, i, s)
                    , l = bs(o, i, s)
                    , c = ut.create(t, a, l);
                n.setSelection(c)
            }
            return !0
        }
        ,
        sinkListItem: e => t => {
            let { state: n, dispatch: r } = t;
            const o = zi(e, n.schema);
            return (i = o,
                function (e, t) {
                    let { $from: n, $to: r } = e.selection
                        , o = n.blockRange(r, (e => e.childCount > 0 && e.firstChild.type == i));
                    if (!o)
                        return !1;
                    let s = o.startIndex;
                    if (0 == s)
                        return !1;
                    let a = o.parent
                        , l = a.child(s - 1);
                    if (l.type != i)
                        return !1;
                    if (t) {
                        let n = l.lastChild && l.lastChild.type == a.type
                            , r = d.from(n ? i.create() : null)
                            , s = new g(d.from(i.create(null, d.from(a.type.create(null, r)))), n ? 3 : 1, 0)
                            , c = o.start
                            , u = o.end;
                        t(e.tr.step(new Pe(c - (n ? 3 : 1), u, c, u, s, 1, !0)).scrollIntoView())
                    }
                    return !0
                }
            )(n, r);
            var i
        }
        ,
        splitBlock: function () {
            let { keepMarks: e = !0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return t => {
                let { tr: n, state: r, dispatch: o, editor: i } = t;
                const { selection: s, doc: a } = n
                    , { $from: l, $to: c } = s
                    , d = Bs(i.extensionManager.attributes, l.node().type.name, l.node().attrs);
                if (s instanceof pt && s.node.isBlock)
                    return !(!l.parentOffset || !Be(a, l.pos)) && (o && (e && Gs(r, i.extensionManager.splittableMarks),
                        n.split(l.pos).scrollIntoView()),
                        !0);
                if (!l.parent.isBlock)
                    return !1;
                const u = c.parentOffset === c.parent.content.size
                    , h = 0 === l.depth ? void 0 : function (e) {
                        for (let t = 0; t < e.edgeCount; t += 1) {
                            const { type: n } = e.edge(t);
                            if (n.isTextblock && !n.hasRequiredAttrs())
                                return n
                        }
                        return null
                    }(l.node(-1).contentMatchAt(l.indexAfter(-1)));
                let p = u && h ? [{
                    type: h,
                    attrs: d
                }] : void 0
                    , f = Be(n.doc, n.mapping.map(l.pos), 1, p);
                if (p || f || !Be(n.doc, n.mapping.map(l.pos), 1, h ? [{
                    type: h
                }] : void 0) || (f = !0,
                    p = h ? [{
                        type: h,
                        attrs: d
                    }] : void 0),
                    o) {
                    if (f && (s instanceof ut && n.deleteSelection(),
                        n.split(n.mapping.map(l.pos), 1, p),
                        h && !u && !l.parentOffset && l.parent.type !== h)) {
                        const e = n.mapping.map(l.before())
                            , t = n.doc.resolve(e);
                        l.node(-1).canReplaceWith(t.index(), t.index() + 1, h) && n.setNodeMarkup(n.mapping.map(l.before()), h)
                    }
                    e && Gs(r, i.extensionManager.splittableMarks),
                        n.scrollIntoView()
                }
                return f
            }
        },
        splitListItem: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { tr: r, state: o, dispatch: i, editor: s } = n;
                var a;
                const l = zi(e, o.schema)
                    , { $from: c, $to: u } = o.selection
                    , h = o.selection.node;
                if (h && h.isBlock || c.depth < 2 || !c.sameParent(u))
                    return !1;
                const p = c.node(-1);
                if (p.type !== l)
                    return !1;
                const f = s.extensionManager.attributes;
                if (0 === c.parent.content.size && c.node(-1).childCount === c.indexAfter(-1)) {
                    if (2 === c.depth || c.node(-3).type !== l || c.index(-2) !== c.node(-2).childCount - 1)
                        return !1;
                    if (i) {
                        let e = d.empty;
                        const n = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
                        for (let t = c.depth - n; t >= c.depth - 3; t -= 1)
                            e = d.from(c.node(t).copy(e));
                        const o = c.indexAfter(-1) < c.node(-2).childCount ? 1 : c.indexAfter(-2) < c.node(-3).childCount ? 2 : 3
                            , i = {
                                ...Bs(f, c.node().type.name, c.node().attrs),
                                ...t
                            }
                            , s = (null === (a = l.contentMatch.defaultType) || void 0 === a ? void 0 : a.createAndFill(i)) || void 0;
                        e = e.append(d.from(l.createAndFill(null, s) || void 0));
                        const u = c.before(c.depth - (n - 1));
                        r.replace(u, c.after(-o), new g(e, 4 - n, 0));
                        let h = -1;
                        r.doc.nodesBetween(u, r.doc.content.size, ((e, t) => {
                            if (h > -1)
                                return !1;
                            e.isTextblock && 0 === e.content.size && (h = t + 1)
                        }
                        )),
                            h > -1 && r.setSelection(ut.near(r.doc.resolve(h))),
                            r.scrollIntoView()
                    }
                    return !0
                }
                const m = u.pos === c.end() ? p.contentMatchAt(0).defaultType : null
                    , b = {
                        ...Bs(f, p.type.name, p.attrs),
                        ...t
                    }
                    , y = {
                        ...Bs(f, c.node().type.name, c.node().attrs),
                        ...t
                    };
                r.delete(c.pos, u.pos);
                const v = m ? [{
                    type: l,
                    attrs: b
                }, {
                    type: m,
                    attrs: y
                }] : [{
                    type: l,
                    attrs: b
                }];
                if (!Be(r.doc, c.pos, 2))
                    return !1;
                if (i) {
                    const { selection: e, storedMarks: t } = o
                        , { splittableMarks: n } = s.extensionManager
                        , a = t || e.$to.parentOffset && e.$from.marks();
                    if (r.split(c.pos, 2, v).scrollIntoView(),
                        !a || !i)
                        return !0;
                    const l = a.filter((e => n.includes(e.type.name)));
                    r.ensureMarks(l)
                }
                return !0
            }
        },
        toggleList: function (e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            return o => {
                let { editor: i, tr: s, state: a, dispatch: l, chain: c, commands: d, can: u } = o;
                const { extensions: h, splittableMarks: p } = i.extensionManager
                    , f = zi(e, a.schema)
                    , m = zi(t, a.schema)
                    , { selection: g, storedMarks: b } = a
                    , { $from: y, $to: v } = g
                    , w = y.blockRange(v)
                    , k = b || g.$to.parentOffset && g.$from.marks();
                if (!w)
                    return !1;
                const C = Ls((e => Fs(e.type.name, h)))(g);
                if (w.depth >= 1 && C && w.depth - C.depth <= 1) {
                    if (C.node.type === f)
                        return d.liftListItem(m);
                    if (Fs(C.node.type.name, h) && f.validContent(C.node.content) && l)
                        return c().command((() => (s.setNodeMarkup(C.pos, f),
                            !0))).command((() => Ks(s, f))).command((() => Js(s, f))).run()
                }
                return n && k && l ? c().command((() => {
                    const e = u().wrapInList(f, r)
                        , t = k.filter((e => p.includes(e.type.name)));
                    return s.ensureMarks(t),
                        !!e || d.clearNodes()
                }
                )).wrapInList(f, r).command((() => Ks(s, f))).command((() => Js(s, f))).run() : c().command((() => !!u().wrapInList(f, r) || d.clearNodes())).wrapInList(f, r).command((() => Ks(s, f))).command((() => Js(s, f))).run()
            }
        },
        toggleMark: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r => {
                let { state: o, commands: i } = r;
                const { extendEmptyMarkRange: s = !1 } = n
                    , a = ms(e, o.schema);
                return Vs(o, a, t) ? i.unsetMark(a, {
                    extendEmptyMarkRange: s
                }) : i.setMark(a, t)
            }
        },
        toggleNode: function (e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r => {
                let { state: o, commands: i } = r;
                const s = zi(e, o.schema)
                    , a = zi(t, o.schema)
                    , l = Es(o, s, n);
                let c;
                return o.selection.$anchor.sameParent(o.selection.$head) && (c = o.selection.$anchor.parent.attrs),
                    l ? i.setNode(a, c) : i.setNode(s, {
                        ...c,
                        ...n
                    })
            }
        },
        toggleWrap: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { state: r, commands: o } = n;
                const i = zi(e, r.schema);
                return Es(r, i, t) ? o.lift(i) : o.wrapIn(i, t)
            }
        },
        undoInputRule: () => e => {
            let { state: t, dispatch: n } = e;
            const r = t.plugins;
            for (let o = 0; o < r.length; o += 1) {
                const e = r[o];
                let i;
                if (e.spec.isInputRules && (i = e.getState(t))) {
                    if (n) {
                        const e = t.tr
                            , n = i.transform;
                        for (let t = n.steps.length - 1; t >= 0; t -= 1)
                            e.step(n.steps[t].invert(n.docs[t]));
                        if (i.text) {
                            const n = e.doc.resolve(i.from).marks();
                            e.replaceWith(i.from, i.to, t.schema.text(i.text, n))
                        } else
                            e.delete(i.from, i.to)
                    }
                    return !0
                }
            }
            return !1
        }
        ,
        unsetAllMarks: () => e => {
            let { tr: t, dispatch: n } = e;
            const { selection: r } = t
                , { empty: o, ranges: i } = r;
            return o || n && i.forEach((e => {
                t.removeMark(e.$from.pos, e.$to.pos)
            }
            )),
                !0
        }
        ,
        unsetMark: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { tr: r, state: o, dispatch: i } = n;
                var s;
                const { extendEmptyMarkRange: a = !1 } = t
                    , { selection: l } = r
                    , c = ms(e, o.schema)
                    , { $from: d, empty: u, ranges: h } = l;
                if (!i)
                    return !0;
                if (u && a) {
                    let { from: e, to: t } = l;
                    const n = null === (s = d.marks().find((e => e.type === c))) || void 0 === s ? void 0 : s.attrs
                        , o = fs(d, c, n);
                    o && (e = o.from,
                        t = o.to),
                        r.removeMark(e, t, c)
                } else
                    h.forEach((e => {
                        r.removeMark(e.$from.pos, e.$to.pos, c)
                    }
                    ));
                return r.removeStoredMark(c),
                    !0
            }
        },
        updateAttributes: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { tr: r, state: o, dispatch: i } = n
                    , s = null
                    , a = null;
                const l = Ms("string" === typeof e ? e : e.name, o.schema);
                return !!l && ("node" === l && (s = zi(e, o.schema)),
                    "mark" === l && (a = ms(e, o.schema)),
                    i && r.selection.ranges.forEach((e => {
                        const n = e.$from.pos
                            , i = e.$to.pos;
                        o.doc.nodesBetween(n, i, ((e, o) => {
                            s && s === e.type && r.setNodeMarkup(o, void 0, {
                                ...e.attrs,
                                ...t
                            }),
                                a && e.marks.length && e.marks.forEach((s => {
                                    if (a === s.type) {
                                        const l = Math.max(o, n)
                                            , c = Math.min(o + e.nodeSize, i);
                                        r.addMark(l, c, a.create({
                                            ...s.attrs,
                                            ...t
                                        }))
                                    }
                                }
                                ))
                        }
                        ))
                    }
                    )),
                    !0)
            }
        },
        wrapIn: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { state: r, dispatch: o } = n;
                return function (e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    return function (n, r) {
                        let { $from: o, $to: i } = n.selection
                            , s = o.blockRange(i)
                            , a = s && je(s, e, t);
                        return !!a && (r && r(n.tr.wrap(s, a).scrollIntoView()),
                            !0)
                    }
                }(zi(e, r.schema), t)(r, o)
            }
        },
        wrapInList: function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return n => {
                let { state: r, dispatch: o } = n;
                return Ai(zi(e, r.schema), t)(r, o)
            }
        }
    });
    const Xs = as.create({
        name: "commands",
        addCommands: () => ({
            ...Zs
        })
    })
        , Qs = as.create({
            name: "drop",
            addProseMirrorPlugins() {
                return [new Mt({
                    key: new _t("tiptapDrop"),
                    props: {
                        handleDrop: (e, t, n, r) => {
                            this.editor.emit("drop", {
                                editor: this.editor,
                                event: t,
                                slice: n,
                                moved: r
                            })
                        }
                    }
                })]
            }
        })
        , Ys = as.create({
            name: "editable",
            addProseMirrorPlugins() {
                return [new Mt({
                    key: new _t("editable"),
                    props: {
                        editable: () => this.editor.options.editable
                    }
                })]
            }
        })
        , ea = as.create({
            name: "focusEvents",
            addProseMirrorPlugins() {
                const { editor: e } = this;
                return [new Mt({
                    key: new _t("focusEvents"),
                    props: {
                        handleDOMEvents: {
                            focus: (t, n) => {
                                e.isFocused = !0;
                                const r = e.state.tr.setMeta("focus", {
                                    event: n
                                }).setMeta("addToHistory", !1);
                                return t.dispatch(r),
                                    !1
                            }
                            ,
                            blur: (t, n) => {
                                e.isFocused = !1;
                                const r = e.state.tr.setMeta("blur", {
                                    event: n
                                }).setMeta("addToHistory", !1);
                                return t.dispatch(r),
                                    !1
                            }
                        }
                    }
                })]
            }
        })
        , ta = as.create({
            name: "keymap",
            addKeyboardShortcuts() {
                const e = () => this.editor.commands.first((e => {
                    let { commands: t } = e;
                    return [() => t.undoInputRule(), () => t.command((e => {
                        let { tr: n } = e;
                        const { selection: r, doc: o } = n
                            , { empty: i, $anchor: s } = r
                            , { pos: a, parent: l } = s
                            , c = s.parent.isTextblock && a > 0 ? n.doc.resolve(a - 1) : s
                            , d = c.parent.type.spec.isolating
                            , u = s.pos - s.parentOffset
                            , h = d && 1 === c.parent.childCount ? u === s.pos : at.atStart(o).from === a;
                        return !(!i || !l.type.isTextblock || l.textContent.length || !h || h && "paragraph" === s.parent.type.name) && t.clearNodes()
                    }
                    )), () => t.deleteSelection(), () => t.joinBackward(), () => t.selectNodeBackward()]
                }
                ))
                    , t = () => this.editor.commands.first((e => {
                        let { commands: t } = e;
                        return [() => t.deleteSelection(), () => t.deleteCurrentNode(), () => t.joinForward(), () => t.selectNodeForward()]
                    }
                    ))
                    , n = {
                        Enter: () => this.editor.commands.first((e => {
                            let { commands: t } = e;
                            return [() => t.newlineInCode(), () => t.createParagraphNear(), () => t.liftEmptyBlock(), () => t.splitBlock()]
                        }
                        )),
                        "Mod-Enter": () => this.editor.commands.exitCode(),
                        Backspace: e,
                        "Mod-Backspace": e,
                        "Shift-Backspace": e,
                        Delete: t,
                        "Mod-Delete": t,
                        "Mod-a": () => this.editor.commands.selectAll()
                    }
                    , r = {
                        ...n
                    }
                    , o = {
                        ...n,
                        "Ctrl-h": e,
                        "Alt-Backspace": e,
                        "Ctrl-d": t,
                        "Ctrl-Alt-Backspace": t,
                        "Alt-Delete": t,
                        "Alt-d": t,
                        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
                        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
                    };
                return vs() || xs() ? o : r
            },
            addProseMirrorPlugins() {
                return [new Mt({
                    key: new _t("clearDocument"),
                    appendTransaction: (e, t, n) => {
                        const r = e.some((e => e.docChanged)) && !t.doc.eq(n.doc)
                            , o = e.some((e => e.getMeta("preventClearDocument")));
                        if (!r || o)
                            return;
                        const { empty: i, from: s, to: a } = t.selection
                            , l = at.atStart(t.doc).from
                            , c = at.atEnd(t.doc).to;
                        if (i || !(s === l && a === c))
                            return;
                        if (!Us(n.doc))
                            return;
                        const d = n.tr
                            , u = Li({
                                state: n,
                                transaction: d
                            })
                            , { commands: h } = new Ri({
                                editor: this.editor,
                                state: u
                            });
                        return h.clearNodes(),
                            d.steps.length ? d : void 0
                    }
                })]
            }
        })
        , na = as.create({
            name: "paste",
            addProseMirrorPlugins() {
                return [new Mt({
                    key: new _t("tiptapPaste"),
                    props: {
                        handlePaste: (e, t, n) => {
                            this.editor.emit("paste", {
                                editor: this.editor,
                                event: t,
                                slice: n
                            })
                        }
                    }
                })]
            }
        })
        , ra = as.create({
            name: "tabindex",
            addProseMirrorPlugins() {
                return [new Mt({
                    key: new _t("tabindex"),
                    props: {
                        attributes: () => this.editor.isEditable ? {
                            tabindex: "0"
                        } : {}
                    }
                })]
            }
        });
    var oa = Object.freeze({
        __proto__: null,
        ClipboardTextSerializer: ds,
        Commands: Xs,
        Drop: Qs,
        Editable: Ys,
        FocusEvents: ea,
        Keymap: ta,
        Paste: na,
        Tabindex: ra
    });
    class ia {
        get name() {
            return this.node.type.name
        }
        constructor(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            this.currentNode = null,
                this.actualDepth = null,
                this.isBlock = n,
                this.resolvedPos = e,
                this.editor = t,
                this.currentNode = r
        }
        get node() {
            return this.currentNode || this.resolvedPos.node()
        }
        get element() {
            return this.editor.view.domAtPos(this.pos).node
        }
        get depth() {
            var e;
            return null !== (e = this.actualDepth) && void 0 !== e ? e : this.resolvedPos.depth
        }
        get pos() {
            return this.resolvedPos.pos
        }
        get content() {
            return this.node.content
        }
        set content(e) {
            let t = this.from
                , n = this.to;
            if (this.isBlock) {
                if (0 === this.content.size)
                    return void console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
                t = this.from + 1,
                    n = this.to - 1
            }
            this.editor.commands.insertContentAt({
                from: t,
                to: n
            }, e)
        }
        get attributes() {
            return this.node.attrs
        }
        get textContent() {
            return this.node.textContent
        }
        get size() {
            return this.node.nodeSize
        }
        get from() {
            return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
        }
        get range() {
            return {
                from: this.from,
                to: this.to
            }
        }
        get to() {
            return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
        }
        get parent() {
            if (0 === this.depth)
                return null;
            const e = this.resolvedPos.start(this.resolvedPos.depth - 1)
                , t = this.resolvedPos.doc.resolve(e);
            return new ia(t, this.editor)
        }
        get before() {
            let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
            return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
                new ia(e, this.editor)
        }
        get after() {
            let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
            return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
                new ia(e, this.editor)
        }
        get children() {
            const e = [];
            return this.node.content.forEach(((t, n) => {
                const r = t.isBlock && !t.isTextblock
                    , o = t.isAtom && !t.isText
                    , i = this.pos + n + (o ? 0 : 1)
                    , s = this.resolvedPos.doc.resolve(i);
                if (!r && s.depth <= this.depth)
                    return;
                const a = new ia(s, this.editor, r, r ? t : null);
                r && (a.actualDepth = this.depth + 1),
                    e.push(new ia(s, this.editor, r, r ? t : null))
            }
            )),
                e
        }
        get firstChild() {
            return this.children[0] || null
        }
        get lastChild() {
            const e = this.children;
            return e[e.length - 1] || null
        }
        closest(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = null
                , r = this.parent;
            for (; r && !n;) {
                if (r.node.type.name === e)
                    if (Object.keys(t).length > 0) {
                        const e = r.node.attrs
                            , n = Object.keys(t);
                        for (let r = 0; r < n.length; r += 1) {
                            const o = n[r];
                            if (e[o] !== t[o])
                                break
                        }
                    } else
                        n = r;
                r = r.parent
            }
            return n
        }
        querySelector(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return this.querySelectorAll(e, t, !0)[0] || null
        }
        querySelectorAll(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                , r = [];
            if (!this.children || 0 === this.children.length)
                return r;
            const o = Object.keys(t);
            return this.children.forEach((i => {
                if (!(n && r.length > 0)) {
                    if (i.node.type.name === e) {
                        o.every((e => t[e] === i.node.attrs[e])) && r.push(i)
                    }
                    n && r.length > 0 || (r = r.concat(i.querySelectorAll(e, t, n)))
                }
            }
            )),
                r
        }
        setAttribute(e) {
            const { tr: t } = this.editor.state;
            t.setNodeMarkup(this.from, void 0, {
                ...this.node.attrs,
                ...e
            }),
                this.editor.view.dispatch(t)
        }
    }
    class sa extends Di {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            super(),
                this.isFocused = !1,
                this.isInitialized = !1,
                this.extensionStorage = {},
                this.options = {
                    element: document.createElement("div"),
                    content: "",
                    injectCSS: !0,
                    injectNonce: void 0,
                    extensions: [],
                    autofocus: !1,
                    editable: !0,
                    editorProps: {},
                    parseOptions: {},
                    coreExtensionOptions: {},
                    enableInputRules: !0,
                    enablePasteRules: !0,
                    enableCoreExtensions: !0,
                    enableContentCheck: !1,
                    onBeforeCreate: () => null,
                    onCreate: () => null,
                    onUpdate: () => null,
                    onSelectionUpdate: () => null,
                    onTransaction: () => null,
                    onFocus: () => null,
                    onBlur: () => null,
                    onDestroy: () => null,
                    onContentError: e => {
                        let { error: t } = e;
                        throw t
                    }
                    ,
                    onPaste: () => null,
                    onDrop: () => null
                },
                this.isCapturingTransaction = !1,
                this.capturedTransaction = null,
                this.setOptions(e),
                this.createExtensionManager(),
                this.createCommandManager(),
                this.createSchema(),
                this.on("beforeCreate", this.options.onBeforeCreate),
                this.emit("beforeCreate", {
                    editor: this
                }),
                this.on("contentError", this.options.onContentError),
                this.createView(),
                this.injectCSS(),
                this.on("create", this.options.onCreate),
                this.on("update", this.options.onUpdate),
                this.on("selectionUpdate", this.options.onSelectionUpdate),
                this.on("transaction", this.options.onTransaction),
                this.on("focus", this.options.onFocus),
                this.on("blur", this.options.onBlur),
                this.on("destroy", this.options.onDestroy),
                this.on("drop", (e => {
                    let { event: t, slice: n, moved: r } = e;
                    return this.options.onDrop(t, n, r)
                }
                )),
                this.on("paste", (e => {
                    let { event: t, slice: n } = e;
                    return this.options.onPaste(t, n)
                }
                )),
                window.setTimeout((() => {
                    this.isDestroyed || (this.commands.focus(this.options.autofocus),
                        this.emit("create", {
                            editor: this
                        }),
                        this.isInitialized = !0)
                }
                ), 0)
        }
        get storage() {
            return this.extensionStorage
        }
        get commands() {
            return this.commandManager.commands
        }
        chain() {
            return this.commandManager.chain()
        }
        can() {
            return this.commandManager.can()
        }
        injectCSS() {
            this.options.injectCSS && document && (this.css = function (e, t, n) {
                const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
                if (null !== r)
                    return r;
                const o = document.createElement("style");
                return t && o.setAttribute("nonce", t),
                    o.setAttribute("data-tiptap-style" + (n ? `-${n}` : ""), ""),
                    o.innerHTML = e,
                    document.getElementsByTagName("head")[0].appendChild(o),
                    o
            }('.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}', this.options.injectNonce))
        }
        setOptions() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.options = {
                ...this.options,
                ...e
            },
                this.view && this.state && !this.isDestroyed && (this.options.editorProps && this.view.setProps(this.options.editorProps),
                    this.view.updateState(this.state))
        }
        setEditable(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            this.setOptions({
                editable: e
            }),
                t && this.emit("update", {
                    editor: this,
                    transaction: this.state.tr
                })
        }
        get isEditable() {
            return this.options.editable && this.view && this.view.editable
        }
        get state() {
            return this.view.state
        }
        registerPlugin(e, t) {
            const n = Vi(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e]
                , r = this.state.reconfigure({
                    plugins: n
                });
            return this.view.updateState(r),
                r
        }
        unregisterPlugin(e) {
            if (this.isDestroyed)
                return;
            const t = this.state.plugins;
            let n = t;
            if ([].concat(e).forEach((e => {
                const r = "string" === typeof e ? `${e}$` : e.key;
                n = t.filter((e => !e.key.startsWith(r)))
            }
            )),
                t.length === n.length)
                return;
            const r = this.state.reconfigure({
                plugins: n
            });
            return this.view.updateState(r),
                r
        }
        createExtensionManager() {
            var e, t;
            const n = [...this.options.enableCoreExtensions ? [Ys, ds.configure({
                blockSeparator: null === (t = null === (e = this.options.coreExtensionOptions) || void 0 === e ? void 0 : e.clipboardTextSerializer) || void 0 === t ? void 0 : t.blockSeparator
            }), Xs, ea, ta, ra, Qs, na].filter((e => "object" !== typeof this.options.enableCoreExtensions || !1 !== this.options.enableCoreExtensions[e.name])) : [], ...this.options.extensions].filter((e => ["extension", "node", "mark"].includes(null === e || void 0 === e ? void 0 : e.type)));
            this.extensionManager = new ss(n, this)
        }
        createCommandManager() {
            this.commandManager = new Ri({
                editor: this
            })
        }
        createSchema() {
            this.schema = this.extensionManager.schema
        }
        createView() {
            let e;
            try {
                e = Ns(this.options.content, this.schema, this.options.parseOptions, {
                    errorOnInvalidContent: this.options.enableContentCheck
                })
            } catch (r) {
                if (!(r instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(r.message))
                    throw r;
                this.emit("contentError", {
                    editor: this,
                    error: r,
                    disableCollaboration: () => {
                        this.storage.collaboration && (this.storage.collaboration.isDisabled = !0),
                            this.options.extensions = this.options.extensions.filter((e => "collaboration" !== e.name)),
                            this.createExtensionManager()
                    }
                }),
                    e = Ns(this.options.content, this.schema, this.options.parseOptions, {
                        errorOnInvalidContent: !1
                    })
            }
            const t = ys(e, this.options.autofocus);
            this.view = new Bo(this.options.element, {
                ...this.options.editorProps,
                dispatchTransaction: this.dispatchTransaction.bind(this),
                state: xt.create({
                    doc: e,
                    selection: t || void 0
                })
            }),
                this.view.dom.setAttribute("role", "textbox"),
                this.view.dom.getAttribute("aria-label") || this.view.dom.setAttribute("aria-label", "Rich-Text Editor");
            const n = this.state.reconfigure({
                plugins: this.extensionManager.plugins
            });
            this.view.updateState(n),
                this.createNodeViews(),
                this.prependClass();
            this.view.dom.editor = this
        }
        createNodeViews() {
            this.view.isDestroyed || this.view.setProps({
                nodeViews: this.extensionManager.nodeViews
            })
        }
        prependClass() {
            this.view.dom.className = `tiptap ${this.view.dom.className}`
        }
        captureTransaction(e) {
            this.isCapturingTransaction = !0,
                e(),
                this.isCapturingTransaction = !1;
            const t = this.capturedTransaction;
            return this.capturedTransaction = null,
                t
        }
        dispatchTransaction(e) {
            if (this.view.isDestroyed)
                return;
            if (this.isCapturingTransaction)
                return this.capturedTransaction ? void e.steps.forEach((e => {
                    var t;
                    return null === (t = this.capturedTransaction) || void 0 === t ? void 0 : t.step(e)
                }
                )) : void (this.capturedTransaction = e);
            const t = this.state.apply(e)
                , n = !this.state.selection.eq(t.selection);
            this.emit("beforeTransaction", {
                editor: this,
                transaction: e,
                nextState: t
            }),
                this.view.updateState(t),
                this.emit("transaction", {
                    editor: this,
                    transaction: e
                }),
                n && this.emit("selectionUpdate", {
                    editor: this,
                    transaction: e
                });
            const r = e.getMeta("focus")
                , o = e.getMeta("blur");
            r && this.emit("focus", {
                editor: this,
                event: r.event,
                transaction: e
            }),
                o && this.emit("blur", {
                    editor: this,
                    event: o.event,
                    transaction: e
                }),
                e.docChanged && !e.getMeta("preventUpdate") && this.emit("update", {
                    editor: this,
                    transaction: e
                })
        }
        getAttributes(e) {
            return js(this.state, e)
        }
        isActive(e, t) {
            const n = "string" === typeof e ? e : null
                , r = "string" === typeof e ? t : e;
            return function (e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (!t)
                    return Es(e, null, n) || Vs(e, null, n);
                const r = Ms(t, e.schema);
                return "node" === r ? Es(e, t, n) : "mark" === r && Vs(e, t, n)
            }(this.state, n, r)
        }
        getJSON() {
            return this.state.doc.toJSON()
        }
        getHTML() {
            return Rs(this.state.doc.content, this.schema)
        }
        getText(e) {
            const { blockSeparator: t = "\n\n", textSerializers: n = {} } = e || {};
            return Is(this.state.doc, {
                blockSeparator: t,
                textSerializers: {
                    ...cs(this.schema),
                    ...n
                }
            })
        }
        get isEmpty() {
            return Us(this.state.doc)
        }
        getCharacterCount() {
            return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'),
                this.state.doc.content.size - 2
        }
        destroy() {
            if (this.emit("destroy"),
                this.view) {
                const e = this.view.dom;
                e && e.editor && delete e.editor,
                    this.view.destroy()
            }
            this.removeAllListeners()
        }
        get isDestroyed() {
            var e;
            return !(null === (e = this.view) || void 0 === e ? void 0 : e.docView)
        }
        $node(e, t) {
            var n;
            return (null === (n = this.$doc) || void 0 === n ? void 0 : n.querySelector(e, t)) || null
        }
        $nodes(e, t) {
            var n;
            return (null === (n = this.$doc) || void 0 === n ? void 0 : n.querySelectorAll(e, t)) || null
        }
        $pos(e) {
            const t = this.state.doc.resolve(e);
            return new ia(t, this)
        }
        get $doc() {
            return this.$pos(0)
        }
    }
    function aa(e) {
        return new Zi({
            find: e.find,
            handler: t => {
                let { state: n, range: r, match: o } = t;
                const i = Fi(e.getAttributes, void 0, o);
                if (!1 === i || null === i)
                    return null;
                const { tr: s } = n
                    , a = o[o.length - 1]
                    , l = o[0];
                if (a) {
                    const t = l.search(/\S/)
                        , o = r.from + l.indexOf(a)
                        , c = o + a.length;
                    if ($s(r.from, r.to, n.doc).filter((t => t.mark.type.excluded.find((n => n === e.type && n !== t.mark.type)))).filter((e => e.to > o)).length)
                        return null;
                    c < r.to && s.delete(c, r.to),
                        o > r.from && s.delete(r.from + t, o);
                    const d = r.from + t + a.length;
                    s.addMark(r.from + t, d, e.type.create(i || {})),
                        s.removeStoredMark(e.type)
                }
            }
        })
    }
    class la {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.type = "node",
                this.name = "node",
                this.parent = null,
                this.child = null,
                this.config = {
                    name: this.name,
                    defaultOptions: {}
                },
                this.config = {
                    ...this.config,
                    ...e
                },
                this.name = this.config.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
                this.options = this.config.defaultOptions,
                this.config.addOptions && (this.options = Fi(Ii(this, "addOptions", {
                    name: this.name
                }))),
                this.storage = Fi(Ii(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
        }
        static create() {
            return new la(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
        }
        configure() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = this.extend({
                ...this.config,
                addOptions: () => es(this.options, e)
            });
            return t.name = this.name,
                t.parent = this.parent,
                t
        }
        extend() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = new la(e);
            return t.parent = this,
                this.child = t,
                t.name = e.name ? e.name : t.parent.name,
                e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),
                t.options = Fi(Ii(t, "addOptions", {
                    name: t.name
                })),
                t.storage = Fi(Ii(t, "addStorage", {
                    name: t.name,
                    options: t.options
                })),
                t
        }
    }
    class ca {
        constructor(e, t, n) {
            this.isDragging = !1,
                this.component = e,
                this.editor = t.editor,
                this.options = {
                    stopEvent: null,
                    ignoreMutation: null,
                    ...n
                },
                this.extension = t.extension,
                this.node = t.node,
                this.decorations = t.decorations,
                this.innerDecorations = t.innerDecorations,
                this.view = t.view,
                this.HTMLAttributes = t.HTMLAttributes,
                this.getPos = t.getPos,
                this.mount()
        }
        mount() { }
        get dom() {
            return this.editor.view.dom
        }
        get contentDOM() {
            return null
        }
        onDragStart(e) {
            var t, n, r, o, i, s, a;
            const { view: l } = this.editor
                , c = e.target
                , d = 3 === c.nodeType ? null === (t = c.parentElement) || void 0 === t ? void 0 : t.closest("[data-drag-handle]") : c.closest("[data-drag-handle]");
            if (!this.dom || (null === (n = this.contentDOM) || void 0 === n ? void 0 : n.contains(c)) || !d)
                return;
            let u = 0
                , h = 0;
            if (this.dom !== d) {
                const t = this.dom.getBoundingClientRect()
                    , n = d.getBoundingClientRect()
                    , a = null !== (r = e.offsetX) && void 0 !== r ? r : null === (o = e.nativeEvent) || void 0 === o ? void 0 : o.offsetX
                    , l = null !== (i = e.offsetY) && void 0 !== i ? i : null === (s = e.nativeEvent) || void 0 === s ? void 0 : s.offsetY;
                u = n.x - t.x + a,
                    h = n.y - t.y + l
            }
            null === (a = e.dataTransfer) || void 0 === a || a.setDragImage(this.dom, u, h);
            const p = this.getPos();
            if ("number" !== typeof p)
                return;
            const f = pt.create(l.state.doc, p)
                , m = l.state.tr.setSelection(f);
            l.dispatch(m)
        }
        stopEvent(e) {
            var t;
            if (!this.dom)
                return !1;
            if ("function" === typeof this.options.stopEvent)
                return this.options.stopEvent({
                    event: e
                });
            const n = e.target;
            if (!(this.dom.contains(n) && !(null === (t = this.contentDOM) || void 0 === t ? void 0 : t.contains(n))))
                return !1;
            const r = e.type.startsWith("drag")
                , o = "drop" === e.type;
            if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !o && !r)
                return !0;
            const { isEditable: i } = this.editor
                , { isDragging: s } = this
                , a = !!this.node.type.spec.draggable
                , l = pt.isSelectable(this.node)
                , c = "copy" === e.type
                , d = "paste" === e.type
                , u = "cut" === e.type
                , h = "mousedown" === e.type;
            if (!a && l && r && e.preventDefault(),
                a && r && !s)
                return e.preventDefault(),
                    !1;
            if (a && i && !s && h) {
                const e = n.closest("[data-drag-handle]");
                e && (this.dom === e || this.dom.contains(e)) && (this.isDragging = !0,
                    document.addEventListener("dragend", (() => {
                        this.isDragging = !1
                    }
                    ), {
                        once: !0
                    }),
                    document.addEventListener("drop", (() => {
                        this.isDragging = !1
                    }
                    ), {
                        once: !0
                    }),
                    document.addEventListener("mouseup", (() => {
                        this.isDragging = !1
                    }
                    ), {
                        once: !0
                    }))
            }
            return !(s || o || c || d || u || h && l)
        }
        ignoreMutation(e) {
            if (!this.dom || !this.contentDOM)
                return !0;
            if ("function" === typeof this.options.ignoreMutation)
                return this.options.ignoreMutation({
                    mutation: e
                });
            if (this.node.isLeaf || this.node.isAtom)
                return !0;
            if ("selection" === e.type)
                return !1;
            if (this.dom.contains(e.target) && "childList" === e.type && (vs() || "Android" === navigator.platform || /android/i.test(navigator.userAgent)) && this.editor.isFocused) {
                if ([...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every((e => e.isContentEditable)))
                    return !1
            }
            return this.contentDOM === e.target && "attributes" === e.type || !this.contentDOM.contains(e.target)
        }
        updateAttributes(e) {
            this.editor.commands.command((t => {
                let { tr: n } = t;
                const r = this.getPos();
                return "number" === typeof r && (n.setNodeMarkup(r, void 0, {
                    ...this.node.attrs,
                    ...e
                }),
                    !0)
            }
            ))
        }
        deleteNode() {
            const e = this.getPos();
            if ("number" !== typeof e)
                return;
            const t = e + this.node.nodeSize;
            this.editor.commands.deleteRange({
                from: e,
                to: t
            })
        }
    }
    function da(e) {
        return new ns({
            find: e.find,
            handler: t => {
                let { state: n, range: r, match: o, pasteEvent: i } = t;
                const s = Fi(e.getAttributes, void 0, o, i);
                if (!1 === s || null === s)
                    return null;
                const { tr: a } = n
                    , l = o[o.length - 1]
                    , c = o[0];
                let d = r.to;
                if (l) {
                    const t = c.search(/\S/)
                        , o = r.from + c.indexOf(l)
                        , i = o + l.length;
                    if ($s(r.from, r.to, n.doc).filter((t => t.mark.type.excluded.find((n => n === e.type && n !== t.mark.type)))).filter((e => e.to > o)).length)
                        return null;
                    i < r.to && a.delete(i, r.to),
                        o > r.from && a.delete(r.from + t, o),
                        d = r.from + t + l.length,
                        a.addMark(r.from + t, d, e.type.create(s || {})),
                        a.removeStoredMark(e.type)
                }
            }
        })
    }
    var ua, ha = new Uint8Array(16);
    function pa() {
        if (!ua && !(ua = "undefined" !== typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" !== typeof msCrypto && "function" === typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto)))
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return ua(ha)
    }
    const fa = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    const ma = function (e) {
        return "string" === typeof e && fa.test(e)
    };
    for (var ga = [], ba = 0; ba < 256; ++ba)
        ga.push((ba + 256).toString(16).substr(1));
    const ya = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
            , n = (ga[e[t + 0]] + ga[e[t + 1]] + ga[e[t + 2]] + ga[e[t + 3]] + "-" + ga[e[t + 4]] + ga[e[t + 5]] + "-" + ga[e[t + 6]] + ga[e[t + 7]] + "-" + ga[e[t + 8]] + ga[e[t + 9]] + "-" + ga[e[t + 10]] + ga[e[t + 11]] + ga[e[t + 12]] + ga[e[t + 13]] + ga[e[t + 14]] + ga[e[t + 15]]).toLowerCase();
        if (!ma(n))
            throw TypeError("Stringified UUID is invalid");
        return n
    };
    const va = function (e, t, n) {
        var r = (e = e || {}).random || (e.rng || pa)();
        if (r[6] = 15 & r[6] | 64,
            r[8] = 63 & r[8] | 128,
            t) {
            n = n || 0;
            for (var o = 0; o < 16; ++o)
                t[n + o] = r[o];
            return t
        }
        return ya(r)
    };
    var wa = class e {
        constructor(e) {
            this.cache = new Map(e)
        }
        get(e) {
            return this.cache.get(e)
        }
        set(e, t, n) {
            e < 0 || this.cache.set(e, [t, n])
        }
        replace(e, t, n, r) {
            this.remove(e),
                this.set(t, n, r)
        }
        remove(e) {
            this.cache.delete(e)
        }
        invalidate(t) {
            const n = new e(this.cache)
                , r = t.mapping;
            return this.cache.forEach(((e, o) => {
                let [i, s] = e;
                if (o < 0)
                    return;
                const a = r.mapResult(o)
                    , l = t.doc.nodeAt(a.pos);
                if (a.deleted || !(null == l ? void 0 : l.eq(i)))
                    n.remove(o);
                else if (o !== a.pos) {
                    const e = s.map((e => e.map(r, 0, 0))).filter((e => null != e));
                    n.replace(o, a.pos, l, e)
                }
            }
            )),
                n
        }
    }
        ;
    function ka(e) {
        let { parser: t, nodeTypes: n = ["code_block"], languageExtractor: r = e => e.attrs.language } = e;
        const o = new _t;
        return new Mt({
            key: o,
            state: {
                init(e, o) {
                    const i = new wa
                        , [s, a] = Ca(o.doc, t, n, r, i);
                    return {
                        cache: i,
                        decorations: s,
                        promises: a
                    }
                },
                apply: (e, o) => {
                    const i = o.cache.invalidate(e)
                        , s = !!e.getMeta("prosemirror-highlight-refresh");
                    if (!e.docChanged && !s) {
                        return {
                            cache: i,
                            decorations: o.decorations.map(e.mapping, e.doc),
                            promises: o.promises
                        }
                    }
                    const [a, l] = Ca(e.doc, t, n, r, i);
                    return {
                        cache: i,
                        decorations: a,
                        promises: l
                    }
                }
            },
            view: e => {
                const t = new Set
                    , n = () => {
                        if (t.size > 0)
                            return;
                        const n = e.state.tr.setMeta("prosemirror-highlight-refresh", !0);
                        e.dispatch(n)
                    }
                    , r = () => {
                        var r;
                        const i = o.getState(e.state);
                        for (const e of null != (r = null == i ? void 0 : i.promises) ? r : [])
                            t.add(e),
                                e.then((() => {
                                    t.delete(e),
                                        n()
                                }
                                )).catch((() => {
                                    t.delete(e)
                                }
                                ))
                    }
                    ;
                return r(),
                {
                    update: () => {
                        r()
                    }
                }
            }
            ,
            props: {
                decorations(e) {
                    var t;
                    return null == (t = this.getState(e)) ? void 0 : t.decorations
                }
            }
        })
    }
    function Ca(e, t, n, r, o) {
        const i = []
            , s = [];
        return e.descendants(((e, a) => {
            if (!e.type.isTextblock)
                return !0;
            if (n.includes(e.type.name)) {
                const n = r(e)
                    , l = o.get(a);
                if (l) {
                    const [e, t] = l;
                    i.push(...t)
                } else {
                    const r = t({
                        content: e.textContent,
                        language: n || void 0,
                        pos: a
                    });
                    r && Array.isArray(r) ? (o.set(a, e, r),
                        i.push(...r)) : r instanceof Promise && (o.remove(a),
                            s.push(r))
                }
            }
            return !1
        }
        )),
            [mo.create(e, i), s]
    }
    const Sa = [{
        id: "abap",
        name: "ABAP",
        import: () => n.e(8855).then(n.bind(n, 8855))
    }, {
        id: "actionscript-3",
        name: "ActionScript",
        import: () => n.e(9386).then(n.bind(n, 9386))
    }, {
        id: "ada",
        name: "Ada",
        import: () => n.e(9199).then(n.bind(n, 9199))
    }, {
        id: "angular-html",
        name: "Angular HTML",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(829)]).then(n.bind(n, 829))
    }, {
        id: "angular-ts",
        name: "Angular TypeScript",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5053), n.e(6400)]).then(n.bind(n, 6400))
    }, {
        id: "apache",
        name: "Apache Conf",
        import: () => n.e(3943).then(n.bind(n, 3943))
    }, {
        id: "apex",
        name: "Apex",
        import: () => n.e(7973).then(n.bind(n, 7973))
    }, {
        id: "apl",
        name: "APL",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(3798)]).then(n.bind(n, 3798))
    }, {
        id: "applescript",
        name: "AppleScript",
        import: () => n.e(1814).then(n.bind(n, 1814))
    }, {
        id: "ara",
        name: "Ara",
        import: () => n.e(7413).then(n.bind(n, 7413))
    }, {
        id: "asciidoc",
        name: "AsciiDoc",
        aliases: ["adoc"],
        import: () => n.e(3284).then(n.bind(n, 3284))
    }, {
        id: "asm",
        name: "Assembly",
        import: () => n.e(9662).then(n.bind(n, 9662))
    }, {
        id: "astro",
        name: "Astro",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(5088), n.e(3378)]).then(n.bind(n, 3378))
    }, {
        id: "awk",
        name: "AWK",
        import: () => n.e(5588).then(n.bind(n, 5588))
    }, {
        id: "ballerina",
        name: "Ballerina",
        import: () => n.e(4951).then(n.bind(n, 4951))
    }, {
        id: "bat",
        name: "Batch File",
        aliases: ["batch"],
        import: () => n.e(2406).then(n.bind(n, 2406))
    }, {
        id: "beancount",
        name: "Beancount",
        import: () => n.e(1668).then(n.bind(n, 1668))
    }, {
        id: "berry",
        name: "Berry",
        aliases: ["be"],
        import: () => n.e(2187).then(n.bind(n, 2187))
    }, {
        id: "bibtex",
        name: "BibTeX",
        import: () => n.e(8931).then(n.bind(n, 8931))
    }, {
        id: "bicep",
        name: "Bicep",
        import: () => n.e(3998).then(n.bind(n, 3998))
    }, {
        id: "blade",
        name: "Blade",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(4949)]).then(n.bind(n, 4949))
    }, {
        id: "c",
        name: "C",
        import: () => n.e(6e3).then(n.bind(n, 6e3))
    }, {
        id: "cadence",
        name: "Cadence",
        aliases: ["cdc"],
        import: () => n.e(6322).then(n.bind(n, 6322))
    }, {
        id: "clarity",
        name: "Clarity",
        import: () => n.e(363).then(n.bind(n, 363))
    }, {
        id: "clojure",
        name: "Clojure",
        aliases: ["clj"],
        import: () => n.e(1639).then(n.bind(n, 1639))
    }, {
        id: "cmake",
        name: "CMake",
        import: () => n.e(9878).then(n.bind(n, 9878))
    }, {
        id: "cobol",
        name: "COBOL",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(3930)]).then(n.bind(n, 3930))
    }, {
        id: "codeowners",
        name: "CODEOWNERS",
        import: () => n.e(942).then(n.bind(n, 942))
    }, {
        id: "codeql",
        name: "CodeQL",
        aliases: ["ql"],
        import: () => n.e(9293).then(n.bind(n, 9293))
    }, {
        id: "coffee",
        name: "CoffeeScript",
        aliases: ["coffeescript"],
        import: () => Promise.all([n.e(3816), n.e(4213)]).then(n.bind(n, 4213))
    }, {
        id: "common-lisp",
        name: "Common Lisp",
        aliases: ["lisp"],
        import: () => n.e(3451).then(n.bind(n, 3451))
    }, {
        id: "coq",
        name: "Coq",
        import: () => n.e(3232).then(n.bind(n, 3232))
    }, {
        id: "cpp",
        name: "C++",
        aliases: ["c++"],
        import: () => Promise.all([n.e(2779), n.e(6e3), n.e(3218)]).then(n.bind(n, 3218))
    }, {
        id: "crystal",
        name: "Crystal",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(2779), n.e(6e3), n.e(5972), n.e(253)]).then(n.bind(n, 253))
    }, {
        id: "csharp",
        name: "C#",
        aliases: ["c#", "cs"],
        import: () => n.e(4304).then(n.bind(n, 4304))
    }, {
        id: "css",
        name: "CSS",
        import: () => n.e(2478).then(n.bind(n, 2478))
    }, {
        id: "csv",
        name: "CSV",
        import: () => n.e(5995).then(n.bind(n, 5995))
    }, {
        id: "cue",
        name: "CUE",
        import: () => n.e(2078).then(n.bind(n, 2078))
    }, {
        id: "cypher",
        name: "Cypher",
        aliases: ["cql"],
        import: () => n.e(1304).then(n.bind(n, 1304))
    }, {
        id: "d",
        name: "D",
        import: () => n.e(7031).then(n.bind(n, 7031))
    }, {
        id: "dart",
        name: "Dart",
        import: () => n.e(4774).then(n.bind(n, 4774))
    }, {
        id: "dax",
        name: "DAX",
        import: () => n.e(1752).then(n.bind(n, 1752))
    }, {
        id: "desktop",
        name: "Desktop",
        import: () => n.e(6743).then(n.bind(n, 6743))
    }, {
        id: "diff",
        name: "Diff",
        import: () => n.e(456).then(n.bind(n, 456))
    }, {
        id: "docker",
        name: "Dockerfile",
        aliases: ["dockerfile"],
        import: () => n.e(7945).then(n.bind(n, 7945))
    }, {
        id: "dotenv",
        name: "dotEnv",
        import: () => n.e(795).then(n.bind(n, 795))
    }, {
        id: "dream-maker",
        name: "Dream Maker",
        import: () => n.e(2573).then(n.bind(n, 2573))
    }, {
        id: "edge",
        name: "Edge",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5088), n.e(1330)]).then(n.bind(n, 1330))
    }, {
        id: "elixir",
        name: "Elixir",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(232)]).then(n.bind(n, 232))
    }, {
        id: "elm",
        name: "Elm",
        import: () => Promise.all([n.e(6e3), n.e(6303)]).then(n.bind(n, 6303))
    }, {
        id: "emacs-lisp",
        name: "Emacs Lisp",
        aliases: ["elisp"],
        import: () => n.e(215).then(n.bind(n, 215))
    }, {
        id: "erb",
        name: "ERB",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(6e3), n.e(5972), n.e(6345), n.e(1394)]).then(n.bind(n, 1394))
    }, {
        id: "erlang",
        name: "Erlang",
        aliases: ["erl"],
        import: () => n.e(6200).then(n.bind(n, 6200))
    }, {
        id: "fennel",
        name: "Fennel",
        import: () => n.e(269).then(n.bind(n, 269))
    }, {
        id: "fish",
        name: "Fish",
        import: () => n.e(7591).then(n.bind(n, 7591))
    }, {
        id: "fluent",
        name: "Fluent",
        aliases: ["ftl"],
        import: () => n.e(271).then(n.bind(n, 271))
    }, {
        id: "fortran-fixed-form",
        name: "Fortran (Fixed Form)",
        aliases: ["f", "for", "f77"],
        import: () => Promise.all([n.e(2327), n.e(6339)]).then(n.bind(n, 6339))
    }, {
        id: "fortran-free-form",
        name: "Fortran (Free Form)",
        aliases: ["f90", "f95", "f03", "f08", "f18"],
        import: () => n.e(2327).then(n.bind(n, 2327))
    }, {
        id: "fsharp",
        name: "F#",
        aliases: ["f#", "fs"],
        import: () => Promise.all([n.e(4645), n.e(9399)]).then(n.bind(n, 9399))
    }, {
        id: "gdresource",
        name: "GDResource",
        import: () => n.e(9476).then(n.bind(n, 9476))
    }, {
        id: "gdscript",
        name: "GDScript",
        import: () => n.e(2609).then(n.bind(n, 2609))
    }, {
        id: "gdshader",
        name: "GDShader",
        import: () => n.e(5755).then(n.bind(n, 5755))
    }, {
        id: "genie",
        name: "Genie",
        import: () => n.e(119).then(n.bind(n, 119))
    }, {
        id: "gherkin",
        name: "Gherkin",
        import: () => n.e(6889).then(n.bind(n, 6889))
    }, {
        id: "git-commit",
        name: "Git Commit Message",
        import: () => n.e(5131).then(n.bind(n, 5131))
    }, {
        id: "git-rebase",
        name: "Git Rebase Message",
        import: () => Promise.all([n.e(5972), n.e(7152)]).then(n.bind(n, 7152))
    }, {
        id: "gleam",
        name: "Gleam",
        import: () => n.e(1667).then(n.bind(n, 1667))
    }, {
        id: "glimmer-js",
        name: "Glimmer JS",
        aliases: ["gjs"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5088), n.e(590)]).then(n.bind(n, 590))
    }, {
        id: "glimmer-ts",
        name: "Glimmer TS",
        aliases: ["gts"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5088), n.e(280)]).then(n.bind(n, 280))
    }, {
        id: "glsl",
        name: "GLSL",
        import: () => Promise.all([n.e(6e3), n.e(6117)]).then(n.bind(n, 6117))
    }, {
        id: "gnuplot",
        name: "Gnuplot",
        import: () => n.e(5318).then(n.bind(n, 5318))
    }, {
        id: "go",
        name: "Go",
        import: () => n.e(431).then(n.bind(n, 431))
    }, {
        id: "graphql",
        name: "GraphQL",
        aliases: ["gql"],
        import: () => Promise.all([n.e(3816), n.e(5088), n.e(8860), n.e(9654), n.e(7016)]).then(n.bind(n, 7016))
    }, {
        id: "groovy",
        name: "Groovy",
        import: () => n.e(2667).then(n.bind(n, 2667))
    }, {
        id: "hack",
        name: "Hack",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(2779), n.e(6550)]).then(n.bind(n, 6550))
    }, {
        id: "haml",
        name: "Ruby Haml",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(4247)]).then(n.bind(n, 4247))
    }, {
        id: "handlebars",
        name: "Handlebars",
        aliases: ["hbs"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(3353)]).then(n.bind(n, 3353))
    }, {
        id: "haskell",
        name: "Haskell",
        aliases: ["hs"],
        import: () => n.e(483).then(n.bind(n, 483))
    }, {
        id: "haxe",
        name: "Haxe",
        import: () => n.e(2101).then(n.bind(n, 2101))
    }, {
        id: "hcl",
        name: "HashiCorp HCL",
        import: () => n.e(8014).then(n.bind(n, 8014))
    }, {
        id: "hjson",
        name: "Hjson",
        import: () => n.e(8513).then(n.bind(n, 8513))
    }, {
        id: "hlsl",
        name: "HLSL",
        import: () => n.e(6996).then(n.bind(n, 6996))
    }, {
        id: "html",
        name: "HTML",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726)]).then(n.bind(n, 3726))
    }, {
        id: "html-derivative",
        name: "HTML (Derivative)",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(6404)]).then(n.bind(n, 6404))
    }, {
        id: "http",
        name: "HTTP",
        import: () => Promise.all([n.e(3816), n.e(1057), n.e(5088), n.e(5972), n.e(8860), n.e(9654), n.e(3569)]).then(n.bind(n, 3569))
    }, {
        id: "hxml",
        name: "HXML",
        import: () => n.e(762).then(n.bind(n, 762))
    }, {
        id: "hy",
        name: "Hy",
        import: () => n.e(5992).then(n.bind(n, 5992))
    }, {
        id: "imba",
        name: "Imba",
        import: () => Promise.all([n.e(5088), n.e(5796)]).then(n.bind(n, 5796))
    }, {
        id: "ini",
        name: "INI",
        aliases: ["properties"],
        import: () => n.e(7329).then(n.bind(n, 7329))
    }, {
        id: "java",
        name: "Java",
        import: () => n.e(1057).then(n.bind(n, 1057))
    }, {
        id: "javascript",
        name: "JavaScript",
        aliases: ["js"],
        import: () => n.e(3816).then(n.bind(n, 3816))
    }, {
        id: "jinja",
        name: "Jinja",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(383)]).then(n.bind(n, 383))
    }, {
        id: "jison",
        name: "Jison",
        import: () => Promise.all([n.e(3816), n.e(3254)]).then(n.bind(n, 3254))
    }, {
        id: "json",
        name: "JSON",
        import: () => n.e(8055).then(n.bind(n, 8055))
    }, {
        id: "json5",
        name: "JSON5",
        import: () => n.e(8512).then(n.bind(n, 8512))
    }, {
        id: "jsonc",
        name: "JSON with Comments",
        import: () => n.e(894).then(n.bind(n, 894))
    }, {
        id: "jsonl",
        name: "JSON Lines",
        import: () => n.e(5769).then(n.bind(n, 5769))
    }, {
        id: "jsonnet",
        name: "Jsonnet",
        import: () => n.e(332).then(n.bind(n, 332))
    }, {
        id: "jssm",
        name: "JSSM",
        aliases: ["fsl"],
        import: () => n.e(9184).then(n.bind(n, 9184))
    }, {
        id: "jsx",
        name: "JSX",
        import: () => n.e(8860).then(n.bind(n, 8860))
    }, {
        id: "julia",
        name: "Julia",
        aliases: ["jl"],
        import: () => Promise.all([n.e(3816), n.e(2779), n.e(6e3), n.e(5747), n.e(289), n.e(3218), n.e(9480)]).then(n.bind(n, 9480))
    }, {
        id: "kotlin",
        name: "Kotlin",
        aliases: ["kt", "kts"],
        import: () => n.e(1922).then(n.bind(n, 1922))
    }, {
        id: "kusto",
        name: "Kusto",
        aliases: ["kql"],
        import: () => n.e(4859).then(n.bind(n, 4859))
    }, {
        id: "latex",
        name: "LaTeX",
        import: () => Promise.all([n.e(289), n.e(2879)]).then(n.bind(n, 2879))
    }, {
        id: "lean",
        name: "Lean 4",
        aliases: ["lean4"],
        import: () => n.e(7065).then(n.bind(n, 7065))
    }, {
        id: "less",
        name: "Less",
        import: () => n.e(8806).then(n.bind(n, 8806))
    }, {
        id: "liquid",
        name: "Liquid",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(2393)]).then(n.bind(n, 2393))
    }, {
        id: "log",
        name: "Log file",
        import: () => n.e(4853).then(n.bind(n, 4853))
    }, {
        id: "logo",
        name: "Logo",
        import: () => n.e(7499).then(n.bind(n, 9880))
    }, {
        id: "lua",
        name: "Lua",
        import: () => Promise.all([n.e(6e3), n.e(2069)]).then(n.bind(n, 2069))
    }, {
        id: "luau",
        name: "Luau",
        import: () => n.e(1474).then(n.bind(n, 1474))
    }, {
        id: "make",
        name: "Makefile",
        aliases: ["makefile"],
        import: () => n.e(9483).then(n.bind(n, 9483))
    }, {
        id: "markdown",
        name: "Markdown",
        aliases: ["md"],
        import: () => n.e(4645).then(n.bind(n, 7026))
    }, {
        id: "marko",
        name: "Marko",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(5053), n.e(8806), n.e(2969)]).then(n.bind(n, 2969))
    }, {
        id: "matlab",
        name: "MATLAB",
        import: () => n.e(2482).then(n.bind(n, 2482))
    }, {
        id: "mdc",
        name: "MDC",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(4645), n.e(4433)]).then(n.bind(n, 4433))
    }, {
        id: "mdx",
        name: "MDX",
        import: () => n.e(6893).then(n.bind(n, 9274))
    }, {
        id: "mermaid",
        name: "Mermaid",
        aliases: ["mmd"],
        import: () => n.e(9134).then(n.bind(n, 9134))
    }, {
        id: "mipsasm",
        name: "MIPS Assembly",
        aliases: ["mips"],
        import: () => n.e(8897).then(n.bind(n, 8897))
    }, {
        id: "mojo",
        name: "Mojo",
        import: () => n.e(9724).then(n.bind(n, 9724))
    }, {
        id: "move",
        name: "Move",
        import: () => n.e(522).then(n.bind(n, 522))
    }, {
        id: "narrat",
        name: "Narrat Language",
        aliases: ["nar"],
        import: () => n.e(874).then(n.bind(n, 8493))
    }, {
        id: "nextflow",
        name: "Nextflow",
        aliases: ["nf"],
        import: () => n.e(7902).then(n.bind(n, 7902))
    }, {
        id: "nginx",
        name: "Nginx",
        import: () => Promise.all([n.e(6e3), n.e(6491)]).then(n.bind(n, 6491))
    }, {
        id: "nim",
        name: "Nim",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(6e3), n.e(4645), n.e(3355)]).then(n.bind(n, 3355))
    }, {
        id: "nix",
        name: "Nix",
        import: () => n.e(2062).then(n.bind(n, 2062))
    }, {
        id: "nushell",
        name: "nushell",
        aliases: ["nu"],
        import: () => n.e(9828).then(n.bind(n, 9828))
    }, {
        id: "objective-c",
        name: "Objective-C",
        aliases: ["objc"],
        import: () => n.e(1082).then(n.bind(n, 1082))
    }, {
        id: "objective-cpp",
        name: "Objective-C++",
        import: () => n.e(9130).then(n.bind(n, 9130))
    }, {
        id: "ocaml",
        name: "OCaml",
        import: () => n.e(711).then(n.bind(n, 711))
    }, {
        id: "pascal",
        name: "Pascal",
        import: () => n.e(2673).then(n.bind(n, 2673))
    }, {
        id: "perl",
        name: "Perl",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(7670)]).then(n.bind(n, 7670))
    }, {
        id: "php",
        name: "PHP",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(187), n.e(9068)]).then(n.bind(n, 187))
    }, {
        id: "plsql",
        name: "PL/SQL",
        import: () => n.e(8775).then(n.bind(n, 8775))
    }, {
        id: "po",
        name: "Gettext PO",
        aliases: ["pot", "potx"],
        import: () => n.e(1918).then(n.bind(n, 1918))
    }, {
        id: "postcss",
        name: "PostCSS",
        import: () => n.e(3848).then(n.bind(n, 3848))
    }, {
        id: "powerquery",
        name: "PowerQuery",
        import: () => n.e(5768).then(n.bind(n, 3387))
    }, {
        id: "powershell",
        name: "PowerShell",
        aliases: ["ps", "ps1"],
        import: () => n.e(6262).then(n.bind(n, 6262))
    }, {
        id: "prisma",
        name: "Prisma",
        import: () => n.e(8493).then(n.bind(n, 874))
    }, {
        id: "prolog",
        name: "Prolog",
        import: () => n.e(1064).then(n.bind(n, 1064))
    }, {
        id: "proto",
        name: "Protocol Buffer 3",
        aliases: ["protobuf"],
        import: () => n.e(9125).then(n.bind(n, 9125))
    }, {
        id: "pug",
        name: "Pug",
        aliases: ["jade"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(6959)]).then(n.bind(n, 6959))
    }, {
        id: "puppet",
        name: "Puppet",
        import: () => n.e(7051).then(n.bind(n, 7051))
    }, {
        id: "purescript",
        name: "PureScript",
        import: () => n.e(3082).then(n.bind(n, 3082))
    }, {
        id: "python",
        name: "Python",
        aliases: ["py"],
        import: () => n.e(5747).then(n.bind(n, 5747))
    }, {
        id: "qml",
        name: "QML",
        import: () => Promise.all([n.e(3816), n.e(7673)]).then(n.bind(n, 7673))
    }, {
        id: "qmldir",
        name: "QML Directory",
        import: () => n.e(1650).then(n.bind(n, 1650))
    }, {
        id: "qss",
        name: "Qt Style Sheets",
        import: () => n.e(120).then(n.bind(n, 120))
    }, {
        id: "r",
        name: "R",
        import: () => n.e(289).then(n.bind(n, 289))
    }, {
        id: "racket",
        name: "Racket",
        import: () => n.e(3607).then(n.bind(n, 3607))
    }, {
        id: "raku",
        name: "Raku",
        aliases: ["perl6"],
        import: () => n.e(6782).then(n.bind(n, 6782))
    }, {
        id: "razor",
        name: "ASP.NET Razor",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(4304), n.e(251)]).then(n.bind(n, 251))
    }, {
        id: "reg",
        name: "Windows Registry Script",
        import: () => n.e(9233).then(n.bind(n, 9233))
    }, {
        id: "regexp",
        name: "RegExp",
        aliases: ["regex"],
        import: () => n.e(1926).then(n.bind(n, 1926))
    }, {
        id: "rel",
        name: "Rel",
        import: () => n.e(154).then(n.bind(n, 154))
    }, {
        id: "riscv",
        name: "RISC-V",
        import: () => n.e(3234).then(n.bind(n, 3234))
    }, {
        id: "rst",
        name: "reStructuredText",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(6e3), n.e(5972), n.e(5747), n.e(6345), n.e(3218), n.e(2080)]).then(n.bind(n, 2080))
    }, {
        id: "ruby",
        name: "Ruby",
        aliases: ["rb"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(6e3), n.e(5972), n.e(6345)]).then(n.bind(n, 6345))
    }, {
        id: "rust",
        name: "Rust",
        aliases: ["rs"],
        import: () => n.e(4243).then(n.bind(n, 4243))
    }, {
        id: "sas",
        name: "SAS",
        import: () => Promise.all([n.e(2779), n.e(4228)]).then(n.bind(n, 4228))
    }, {
        id: "sass",
        name: "Sass",
        import: () => n.e(5331).then(n.bind(n, 5331))
    }, {
        id: "scala",
        name: "Scala",
        import: () => n.e(7817).then(n.bind(n, 7817))
    }, {
        id: "scheme",
        name: "Scheme",
        import: () => n.e(2048).then(n.bind(n, 2048))
    }, {
        id: "scss",
        name: "SCSS",
        import: () => Promise.all([n.e(2478), n.e(5053)]).then(n.bind(n, 5053))
    }, {
        id: "shaderlab",
        name: "ShaderLab",
        aliases: ["shader"],
        import: () => n.e(75).then(n.bind(n, 75))
    }, {
        id: "shellscript",
        name: "Shell",
        aliases: ["bash", "sh", "shell", "zsh"],
        import: () => n.e(5972).then(n.bind(n, 5972))
    }, {
        id: "shellsession",
        name: "Shell Session",
        aliases: ["console"],
        import: () => Promise.all([n.e(5972), n.e(8231)]).then(n.bind(n, 8231))
    }, {
        id: "smalltalk",
        name: "Smalltalk",
        import: () => n.e(9736).then(n.bind(n, 9736))
    }, {
        id: "solidity",
        name: "Solidity",
        import: () => n.e(3934).then(n.bind(n, 3934))
    }, {
        id: "soy",
        name: "Closure Templates",
        aliases: ["closure-templates"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(7352)]).then(n.bind(n, 7352))
    }, {
        id: "sparql",
        name: "SPARQL",
        import: () => n.e(4606).then(n.bind(n, 4606))
    }, {
        id: "splunk",
        name: "Splunk Query Language",
        aliases: ["spl"],
        import: () => n.e(7088).then(n.bind(n, 7088))
    }, {
        id: "sql",
        name: "SQL",
        import: () => n.e(2779).then(n.bind(n, 2779))
    }, {
        id: "ssh-config",
        name: "SSH Config",
        import: () => n.e(992).then(n.bind(n, 992))
    }, {
        id: "stata",
        name: "Stata",
        import: () => Promise.all([n.e(2779), n.e(8611)]).then(n.bind(n, 8611))
    }, {
        id: "stylus",
        name: "Stylus",
        aliases: ["styl"],
        import: () => n.e(4027).then(n.bind(n, 4027))
    }, {
        id: "svelte",
        name: "Svelte",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(5088), n.e(6320)]).then(n.bind(n, 6320))
    }, {
        id: "swift",
        name: "Swift",
        import: () => n.e(1366).then(n.bind(n, 1366))
    }, {
        id: "system-verilog",
        name: "SystemVerilog",
        import: () => n.e(3731).then(n.bind(n, 3731))
    }, {
        id: "systemd",
        name: "Systemd Units",
        import: () => n.e(3398).then(n.bind(n, 3398))
    }, {
        id: "tasl",
        name: "Tasl",
        import: () => n.e(7469).then(n.bind(n, 7469))
    }, {
        id: "tcl",
        name: "Tcl",
        import: () => n.e(6141).then(n.bind(n, 8522))
    }, {
        id: "templ",
        name: "Templ",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(431), n.e(4421)]).then(n.bind(n, 4421))
    }, {
        id: "terraform",
        name: "Terraform",
        aliases: ["tf", "tfvars"],
        import: () => n.e(227).then(n.bind(n, 227))
    }, {
        id: "tex",
        name: "TeX",
        import: () => Promise.all([n.e(289), n.e(5220)]).then(n.bind(n, 5220))
    }, {
        id: "toml",
        name: "TOML",
        import: () => n.e(2881).then(n.bind(n, 2881))
    }, {
        id: "ts-tags",
        name: "TypeScript with Tags",
        aliases: ["lit"],
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(6e3), n.e(5088), n.e(9852)]).then(n.bind(n, 9852))
    }, {
        id: "tsv",
        name: "TSV",
        import: () => n.e(6416).then(n.bind(n, 6416))
    }, {
        id: "tsx",
        name: "TSX",
        import: () => n.e(9654).then(n.bind(n, 9654))
    }, {
        id: "turtle",
        name: "Turtle",
        import: () => n.e(8379).then(n.bind(n, 8379))
    }, {
        id: "twig",
        name: "Twig",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(1057), n.e(2779), n.e(6e3), n.e(5972), n.e(5747), n.e(6345), n.e(5053), n.e(187), n.e(2454)]).then(n.bind(n, 73))
    }, {
        id: "typescript",
        name: "TypeScript",
        aliases: ["ts"],
        import: () => n.e(5088).then(n.bind(n, 2707))
    }, {
        id: "typespec",
        name: "TypeSpec",
        aliases: ["tsp"],
        import: () => n.e(5468).then(n.bind(n, 5468))
    }, {
        id: "typst",
        name: "Typst",
        aliases: ["typ"],
        import: () => n.e(585).then(n.bind(n, 585))
    }, {
        id: "v",
        name: "V",
        import: () => n.e(845).then(n.bind(n, 845))
    }, {
        id: "vala",
        name: "Vala",
        import: () => n.e(3267).then(n.bind(n, 3267))
    }, {
        id: "vb",
        name: "Visual Basic",
        aliases: ["cmd"],
        import: () => n.e(1189).then(n.bind(n, 1189))
    }, {
        id: "verilog",
        name: "Verilog",
        import: () => n.e(4377).then(n.bind(n, 4377))
    }, {
        id: "vhdl",
        name: "VHDL",
        import: () => n.e(5599).then(n.bind(n, 5599))
    }, {
        id: "viml",
        name: "Vim Script",
        aliases: ["vim", "vimscript"],
        import: () => n.e(3397).then(n.bind(n, 3397))
    }, {
        id: "vue",
        name: "Vue",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5088), n.e(1763)]).then(n.bind(n, 1763))
    }, {
        id: "vue-html",
        name: "Vue HTML",
        import: () => Promise.all([n.e(3816), n.e(2478), n.e(3726), n.e(5088), n.e(2835)]).then(n.bind(n, 2835))
    }, {
        id: "vyper",
        name: "Vyper",
        aliases: ["vy"],
        import: () => n.e(4099).then(n.bind(n, 4099))
    }, {
        id: "wasm",
        name: "WebAssembly",
        import: () => n.e(3161).then(n.bind(n, 3161))
    }, {
        id: "wenyan",
        name: "Wenyan",
        aliases: ["\u6587\u8a00"],
        import: () => n.e(7223).then(n.bind(n, 7223))
    }, {
        id: "wgsl",
        name: "WGSL",
        import: () => n.e(9962).then(n.bind(n, 9962))
    }, {
        id: "wikitext",
        name: "Wikitext",
        aliases: ["mediawiki", "wiki"],
        import: () => n.e(2464).then(n.bind(n, 2464))
    }, {
        id: "wolfram",
        name: "Wolfram",
        aliases: ["wl"],
        import: () => n.e(7219).then(n.bind(n, 7219))
    }, {
        id: "xml",
        name: "XML",
        import: () => Promise.all([n.e(1057), n.e(9068)]).then(n.bind(n, 9068))
    }, {
        id: "xsl",
        name: "XSL",
        import: () => Promise.all([n.e(1057), n.e(5710)]).then(n.bind(n, 5710))
    }, {
        id: "yaml",
        name: "YAML",
        aliases: ["yml"],
        import: () => n.e(2484).then(n.bind(n, 2484))
    }, {
        id: "zenscript",
        name: "ZenScript",
        import: () => n.e(8221).then(n.bind(n, 8221))
    }, {
        id: "zig",
        name: "Zig",
        import: () => n.e(2757).then(n.bind(n, 2757))
    }]
        , xa = Object.fromEntries(Sa.map((e => [e.id, e.import])))
        , Ea = Object.fromEntries(Sa.flatMap((e => e.aliases?.map((t => [t, e.import])) || [])))
        , Ma = {
            ...xa,
            ...Ea
        }
        , Ta = [{
            id: "andromeeda",
            displayName: "Andromeeda",
            type: "dark",
            import: () => n.e(8984).then(n.bind(n, 8984))
        }, {
            id: "aurora-x",
            displayName: "Aurora X",
            type: "dark",
            import: () => n.e(9207).then(n.bind(n, 9207))
        }, {
            id: "ayu-dark",
            displayName: "Ayu Dark",
            type: "dark",
            import: () => n.e(6236).then(n.bind(n, 6236))
        }, {
            id: "catppuccin-frappe",
            displayName: "Catppuccin Frapp\xe9",
            type: "dark",
            import: () => n.e(4997).then(n.bind(n, 4997))
        }, {
            id: "catppuccin-latte",
            displayName: "Catppuccin Latte",
            type: "light",
            import: () => n.e(4891).then(n.bind(n, 4891))
        }, {
            id: "catppuccin-macchiato",
            displayName: "Catppuccin Macchiato",
            type: "dark",
            import: () => n.e(6764).then(n.bind(n, 6764))
        }, {
            id: "catppuccin-mocha",
            displayName: "Catppuccin Mocha",
            type: "dark",
            import: () => n.e(9367).then(n.bind(n, 9367))
        }, {
            id: "dark-plus",
            displayName: "Dark Plus",
            type: "dark",
            import: () => n.e(561).then(n.bind(n, 561))
        }, {
            id: "dracula",
            displayName: "Dracula Theme",
            type: "dark",
            import: () => n.e(7026).then(n.bind(n, 4645))
        }, {
            id: "dracula-soft",
            displayName: "Dracula Theme Soft",
            type: "dark",
            import: () => n.e(3083).then(n.bind(n, 3083))
        }, {
            id: "everforest-dark",
            displayName: "Everforest Dark",
            type: "dark",
            import: () => n.e(4112).then(n.bind(n, 4112))
        }, {
            id: "everforest-light",
            displayName: "Everforest Light",
            type: "light",
            import: () => n.e(800).then(n.bind(n, 800))
        }, {
            id: "github-dark",
            displayName: "GitHub Dark",
            type: "dark",
            import: () => n.e(6346).then(n.bind(n, 6346))
        }, {
            id: "github-dark-default",
            displayName: "GitHub Dark Default",
            type: "dark",
            import: () => n.e(1106).then(n.bind(n, 1106))
        }, {
            id: "github-dark-dimmed",
            displayName: "GitHub Dark Dimmed",
            type: "dark",
            import: () => n.e(4415).then(n.bind(n, 4415))
        }, {
            id: "github-dark-high-contrast",
            displayName: "GitHub Dark High Contrast",
            type: "dark",
            import: () => n.e(7730).then(n.bind(n, 7730))
        }, {
            id: "github-light",
            displayName: "GitHub Light",
            type: "light",
            import: () => n.e(9730).then(n.bind(n, 9730))
        }, {
            id: "github-light-default",
            displayName: "GitHub Light Default",
            type: "light",
            import: () => n.e(2010).then(n.bind(n, 2010))
        }, {
            id: "github-light-high-contrast",
            displayName: "GitHub Light High Contrast",
            type: "light",
            import: () => n.e(8522).then(n.bind(n, 6141))
        }, {
            id: "houston",
            displayName: "Houston",
            type: "dark",
            import: () => n.e(9274).then(n.bind(n, 6893))
        }, {
            id: "kanagawa-dragon",
            displayName: "Kanagawa Dragon",
            type: "dark",
            import: () => n.e(2477).then(n.bind(n, 2477))
        }, {
            id: "kanagawa-lotus",
            displayName: "Kanagawa Lotus",
            type: "light",
            import: () => n.e(2317).then(n.bind(n, 2317))
        }, {
            id: "kanagawa-wave",
            displayName: "Kanagawa Wave",
            type: "dark",
            import: () => n.e(9371).then(n.bind(n, 9371))
        }, {
            id: "laserwave",
            displayName: "LaserWave",
            type: "dark",
            import: () => n.e(8834).then(n.bind(n, 8834))
        }, {
            id: "light-plus",
            displayName: "Light Plus",
            type: "light",
            import: () => n.e(7153).then(n.bind(n, 7153))
        }, {
            id: "material-theme",
            displayName: "Material Theme",
            type: "dark",
            import: () => n.e(2551).then(n.bind(n, 2551))
        }, {
            id: "material-theme-darker",
            displayName: "Material Theme Darker",
            type: "dark",
            import: () => n.e(9173).then(n.bind(n, 9173))
        }, {
            id: "material-theme-lighter",
            displayName: "Material Theme Lighter",
            type: "light",
            import: () => n.e(4349).then(n.bind(n, 4349))
        }, {
            id: "material-theme-ocean",
            displayName: "Material Theme Ocean",
            type: "dark",
            import: () => n.e(4054).then(n.bind(n, 4054))
        }, {
            id: "material-theme-palenight",
            displayName: "Material Theme Palenight",
            type: "dark",
            import: () => n.e(9226).then(n.bind(n, 9226))
        }, {
            id: "min-dark",
            displayName: "Min Dark",
            type: "dark",
            import: () => n.e(8425).then(n.bind(n, 8425))
        }, {
            id: "min-light",
            displayName: "Min Light",
            type: "light",
            import: () => n.e(4947).then(n.bind(n, 4947))
        }, {
            id: "monokai",
            displayName: "Monokai",
            type: "dark",
            import: () => n.e(8954).then(n.bind(n, 8954))
        }, {
            id: "night-owl",
            displayName: "Night Owl",
            type: "dark",
            import: () => n.e(1631).then(n.bind(n, 1631))
        }, {
            id: "nord",
            displayName: "Nord",
            type: "dark",
            import: () => n.e(5735).then(n.bind(n, 5735))
        }, {
            id: "one-dark-pro",
            displayName: "One Dark Pro",
            type: "dark",
            import: () => n.e(9579).then(n.bind(n, 9579))
        }, {
            id: "one-light",
            displayName: "One Light",
            type: "light",
            import: () => n.e(8567).then(n.bind(n, 8567))
        }, {
            id: "plastic",
            displayName: "Plastic",
            type: "dark",
            import: () => n.e(9880).then(n.bind(n, 7499))
        }, {
            id: "poimandres",
            displayName: "Poimandres",
            type: "dark",
            import: () => n.e(2998).then(n.bind(n, 2998))
        }, {
            id: "red",
            displayName: "Red",
            type: "dark",
            import: () => n.e(4217).then(n.bind(n, 4217))
        }, {
            id: "rose-pine",
            displayName: "Ros\xe9 Pine",
            type: "dark",
            import: () => n.e(2768).then(n.bind(n, 2768))
        }, {
            id: "rose-pine-dawn",
            displayName: "Ros\xe9 Pine Dawn",
            type: "light",
            import: () => n.e(5531).then(n.bind(n, 5531))
        }, {
            id: "rose-pine-moon",
            displayName: "Ros\xe9 Pine Moon",
            type: "dark",
            import: () => n.e(7830).then(n.bind(n, 7830))
        }, {
            id: "slack-dark",
            displayName: "Slack Dark",
            type: "dark",
            import: () => n.e(469).then(n.bind(n, 469))
        }, {
            id: "slack-ochin",
            displayName: "Slack Ochin",
            type: "light",
            import: () => n.e(9568).then(n.bind(n, 9568))
        }, {
            id: "snazzy-light",
            displayName: "Snazzy Light",
            type: "light",
            import: () => n.e(6078).then(n.bind(n, 6078))
        }, {
            id: "solarized-dark",
            displayName: "Solarized Dark",
            type: "dark",
            import: () => n.e(7318).then(n.bind(n, 7318))
        }, {
            id: "solarized-light",
            displayName: "Solarized Light",
            type: "light",
            import: () => n.e(1174).then(n.bind(n, 1174))
        }, {
            id: "synthwave-84",
            displayName: "Synthwave '84",
            type: "dark",
            import: () => n.e(5942).then(n.bind(n, 5942))
        }, {
            id: "tokyo-night",
            displayName: "Tokyo Night",
            type: "dark",
            import: () => n.e(2799).then(n.bind(n, 2799))
        }, {
            id: "vesper",
            displayName: "Vesper",
            type: "dark",
            import: () => n.e(5551).then(n.bind(n, 5551))
        }, {
            id: "vitesse-black",
            displayName: "Vitesse Black",
            type: "dark",
            import: () => n.e(4619).then(n.bind(n, 4619))
        }, {
            id: "vitesse-dark",
            displayName: "Vitesse Dark",
            type: "dark",
            import: () => n.e(3566).then(n.bind(n, 3566))
        }, {
            id: "vitesse-light",
            displayName: "Vitesse Light",
            type: "light",
            import: () => n.e(3454).then(n.bind(n, 3454))
        }]
        , Na = Object.fromEntries(Ta.map((e => [e.id, e.import])));
    class _a extends Error {
        constructor(e) {
            super(e),
                this.name = "ShikiError"
        }
    }
    class Oa extends Error {
        constructor(e) {
            super(e),
                this.name = "ShikiError"
        }
    }
    function Aa() {
        return "undefined" !== typeof performance ? performance.now() : Date.now()
    }
    async function Pa(e) {
        let t, n;
        const r = {};
        function o(e) {
            n = e,
                r.HEAPU8 = new Uint8Array(e),
                r.HEAPU32 = new Uint32Array(e)
        }
        function i(e) {
            try {
                return t.grow(e - n.byteLength + 65535 >>> 16),
                    o(t.buffer),
                    1
            } catch { }
        }
        const s = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function a(e, t) {
            return e ? function (e, t) {
                const n = t + (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1024);
                let r = t;
                for (; e[r] && !(r >= n);)
                    ++r;
                if (r - t > 16 && e.buffer && s)
                    return s.decode(e.subarray(t, r));
                let o = "";
                for (; t < r;) {
                    let n = e[t++];
                    if (!(128 & n)) {
                        o += String.fromCharCode(n);
                        continue
                    }
                    const r = 63 & e[t++];
                    if (192 === (224 & n)) {
                        o += String.fromCharCode((31 & n) << 6 | r);
                        continue
                    }
                    const i = 63 & e[t++];
                    if (n = 224 === (240 & n) ? (15 & n) << 12 | r << 6 | i : (7 & n) << 18 | r << 12 | i << 6 | 63 & e[t++],
                        n < 65536)
                        o += String.fromCharCode(n);
                    else {
                        const e = n - 65536;
                        o += String.fromCharCode(55296 | e >> 10, 56320 | 1023 & e)
                    }
                }
                return o
            }(r.HEAPU8, e, t) : ""
        }
        const l = {
            emscripten_get_now: Aa,
            emscripten_memcpy_big: function (e, t, n) {
                r.HEAPU8.copyWithin(e, t, t + n)
            },
            emscripten_resize_heap: function (e) {
                const t = r.HEAPU8.length
                    , n = 2147483648;
                if ((e >>>= 0) > n)
                    return !1;
                for (let r = 1; r <= 4; r *= 2) {
                    let a = t * (1 + .2 / r);
                    a = Math.min(a, e + 100663296);
                    if (i(Math.min(n, (o = Math.max(e, a)) + ((s = 65536) - o % s) % s)))
                        return !0
                }
                var o, s;
                return !1
            },
            fd_write: () => 0
        };
        return await async function () {
            const n = {
                env: l,
                wasi_snapshot_preview1: l
            }
                , i = await e(n);
            t = i.memory,
                o(t.buffer),
                Object.assign(r, i),
                r.UTF8ToString = a
        }(),
            r
    }
    let La, Ra, Da = null;
    class Ia {
        static _utf8ByteLength(e) {
            let t = 0;
            for (let n = 0, r = e.length; n < r; n++) {
                const o = e.charCodeAt(n);
                let i = o
                    , s = !1;
                if (o >= 55296 && o <= 56319 && n + 1 < r) {
                    const t = e.charCodeAt(n + 1);
                    t >= 56320 && t <= 57343 && (i = 65536 + (o - 55296 << 10) | t - 56320,
                        s = !0)
                }
                t += i <= 127 ? 1 : i <= 2047 ? 2 : i <= 65535 ? 3 : 4,
                    s && n++
            }
            return t
        }
        utf16Length;
        utf8Length;
        utf16Value;
        utf8Value;
        utf16OffsetToUtf8;
        utf8OffsetToUtf16;
        constructor(e) {
            const t = e.length
                , n = Ia._utf8ByteLength(e)
                , r = n !== t
                , o = r ? new Uint32Array(t + 1) : null;
            r && (o[t] = n);
            const i = r ? new Uint32Array(n + 1) : null;
            r && (i[n] = t);
            const s = new Uint8Array(n);
            let a = 0;
            for (let l = 0; l < t; l++) {
                const n = e.charCodeAt(l);
                let c = n
                    , d = !1;
                if (n >= 55296 && n <= 56319 && l + 1 < t) {
                    const t = e.charCodeAt(l + 1);
                    t >= 56320 && t <= 57343 && (c = 65536 + (n - 55296 << 10) | t - 56320,
                        d = !0)
                }
                r && (o[l] = a,
                    d && (o[l + 1] = a),
                    c <= 127 ? i[a + 0] = l : c <= 2047 ? (i[a + 0] = l,
                        i[a + 1] = l) : c <= 65535 ? (i[a + 0] = l,
                            i[a + 1] = l,
                            i[a + 2] = l) : (i[a + 0] = l,
                                i[a + 1] = l,
                                i[a + 2] = l,
                                i[a + 3] = l)),
                    c <= 127 ? s[a++] = c : c <= 2047 ? (s[a++] = 192 | (1984 & c) >>> 6,
                        s[a++] = 128 | (63 & c) >>> 0) : c <= 65535 ? (s[a++] = 224 | (61440 & c) >>> 12,
                            s[a++] = 128 | (4032 & c) >>> 6,
                            s[a++] = 128 | (63 & c) >>> 0) : (s[a++] = 240 | (1835008 & c) >>> 18,
                                s[a++] = 128 | (258048 & c) >>> 12,
                                s[a++] = 128 | (4032 & c) >>> 6,
                                s[a++] = 128 | (63 & c) >>> 0),
                    d && l++
            }
            this.utf16Length = t,
                this.utf8Length = n,
                this.utf16Value = e,
                this.utf8Value = s,
                this.utf16OffsetToUtf8 = o,
                this.utf8OffsetToUtf16 = i
        }
        createString(e) {
            const t = e.omalloc(this.utf8Length);
            return e.HEAPU8.set(this.utf8Value, t),
                t
        }
    }
    class ja {
        static LAST_ID = 0;
        static _sharedPtr = 0;
        static _sharedPtrInUse = !1;
        id = (() => ++ja.LAST_ID)();
        _onigBinding;
        content;
        utf16Length;
        utf8Length;
        utf16OffsetToUtf8;
        utf8OffsetToUtf16;
        ptr;
        constructor(e) {
            if (!Da)
                throw new Oa("Must invoke loadWasm first.");
            this._onigBinding = Da,
                this.content = e;
            const t = new Ia(e);
            this.utf16Length = t.utf16Length,
                this.utf8Length = t.utf8Length,
                this.utf16OffsetToUtf8 = t.utf16OffsetToUtf8,
                this.utf8OffsetToUtf16 = t.utf8OffsetToUtf16,
                this.utf8Length < 1e4 && !ja._sharedPtrInUse ? (ja._sharedPtr || (ja._sharedPtr = Da.omalloc(1e4)),
                    ja._sharedPtrInUse = !0,
                    Da.HEAPU8.set(t.utf8Value, ja._sharedPtr),
                    this.ptr = ja._sharedPtr) : this.ptr = t.createString(Da)
        }
        convertUtf8OffsetToUtf16(e) {
            return this.utf8OffsetToUtf16 ? e < 0 ? 0 : e > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[e] : e
        }
        convertUtf16OffsetToUtf8(e) {
            return this.utf16OffsetToUtf8 ? e < 0 ? 0 : e > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[e] : e
        }
        dispose() {
            this.ptr === ja._sharedPtr ? ja._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr)
        }
    }
    class Ha {
        _onigBinding;
        _ptr;
        constructor(e) {
            if (!Da)
                throw new Oa("Must invoke loadWasm first.");
            const t = []
                , n = [];
            for (let s = 0, a = e.length; s < a; s++) {
                const r = new Ia(e[s]);
                t[s] = r.createString(Da),
                    n[s] = r.utf8Length
            }
            const r = Da.omalloc(4 * e.length);
            Da.HEAPU32.set(t, r / 4);
            const o = Da.omalloc(4 * e.length);
            Da.HEAPU32.set(n, o / 4);
            const i = Da.createOnigScanner(r, o, e.length);
            for (let s = 0, a = e.length; s < a; s++)
                Da.ofree(t[s]);
            Da.ofree(o),
                Da.ofree(r),
                0 === i && function (e) {
                    throw new Oa(e.UTF8ToString(e.getLastOnigError()))
                }(Da),
                this._onigBinding = Da,
                this._ptr = i
        }
        dispose() {
            this._onigBinding.freeOnigScanner(this._ptr)
        }
        findNextMatchSync(e, t, n) {
            let r = 0;
            if ("number" === typeof n && (r = n),
                "string" === typeof e) {
                e = new ja(e);
                const n = this._findNextMatchSync(e, t, !1, r);
                return e.dispose(),
                    n
            }
            return this._findNextMatchSync(e, t, !1, r)
        }
        _findNextMatchSync(e, t, n, r) {
            const o = this._onigBinding
                , i = o.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(t), r);
            if (0 === i)
                return null;
            const s = o.HEAPU32;
            let a = i / 4;
            const l = s[a++]
                , c = s[a++]
                , d = [];
            for (let u = 0; u < c; u++) {
                const t = e.convertUtf8OffsetToUtf16(s[a++])
                    , n = e.convertUtf8OffsetToUtf16(s[a++]);
                d[u] = {
                    start: t,
                    end: n,
                    length: n - t
                }
            }
            return {
                index: l,
                captureIndices: d
            }
        }
    }
    function za(e) {
        if (La)
            return La;
        return La = async function () {
            Da = await Pa((async t => {
                let n = e;
                var r;
                return n = await n,
                    "function" === typeof n && (n = await n(t)),
                    "function" === typeof n && (n = await n(t)),
                    "function" === typeof n.instantiator ? n = await n.instantiator(t) : !function (e) {
                        return "function" === typeof e.default
                    }(n) ? (function (e) {
                        return "undefined" !== typeof e.data
                    }(n) && (n = n.data),
                        !function (e) {
                            return "undefined" !== typeof Response && e instanceof Response
                        }(n) ? !function (e) {
                            return "undefined" !== typeof ArrayBuffer && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || "undefined" !== typeof Buffer && Buffer.isBuffer?.(e) || "undefined" !== typeof SharedArrayBuffer && e instanceof SharedArrayBuffer || "undefined" !== typeof Uint32Array && e instanceof Uint32Array
                        }(n) ? n instanceof WebAssembly.Module ? n = await $a(n)(t) : "default" in n && n.default instanceof WebAssembly.Module && (n = await $a(n.default)(t)) : n = await $a(n)(t) : n = "function" === typeof WebAssembly.instantiateStreaming ? await (r = n,
                            e => WebAssembly.instantiateStreaming(r, e))(t) : await function (e) {
                                return async t => {
                                    const n = await e.arrayBuffer();
                                    return WebAssembly.instantiate(n, t)
                                }
                            }(n)(t)) : n = await n.default(t),
                    "instance" in n && (n = n.instance),
                    "exports" in n && (n = n.exports),
                    n
            }
            ))
        }(),
            La
    }
    function $a(e) {
        return t => WebAssembly.instantiate(e, t)
    }
    async function Ba(e) {
        return e && await za(e),
        {
            createScanner: e => new Ha(e),
            createString: e => new ja(e)
        }
    }
    let Va = !1;
    function Fa(e) {
        Va && console.trace(`[SHIKI DEPRECATE]: ${e}`)
    }
    function Ua(e) {
        return Array.isArray(e) ? function (e) {
            let t = [];
            for (let n = 0, r = e.length; n < r; n++)
                t[n] = Ua(e[n]);
            return t
        }(e) : "object" === typeof e ? function (e) {
            let t = {};
            for (let n in e)
                t[n] = Ua(e[n]);
            return t
        }(e) : e
    }
    function Wa(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
            n[r - 1] = arguments[r];
        return n.forEach((t => {
            for (let n in t)
                e[n] = t[n]
        }
        )),
            e
    }
    function qa(e) {
        const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
        return 0 === t ? e : ~t === e.length - 1 ? qa(e.substring(0, e.length - 1)) : e.substr(1 + ~t)
    }
    var Ga = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g
        , Ka = class {
            static hasCaptures(e) {
                return null !== e && (Ga.lastIndex = 0,
                    Ga.test(e))
            }
            static replaceCaptures(e, t, n) {
                return e.replace(Ga, ((e, r, o, i) => {
                    let s = n[parseInt(r || o, 10)];
                    if (!s)
                        return e;
                    {
                        let e = t.substring(s.start, s.end);
                        for (; "." === e[0];)
                            e = e.substring(1);
                        switch (i) {
                            case "downcase":
                                return e.toLowerCase();
                            case "upcase":
                                return e.toUpperCase();
                            default:
                                return e
                        }
                    }
                }
                ))
            }
        }
        ;
    function Ja(e, t) {
        return e < t ? -1 : e > t ? 1 : 0
    }
    function Za(e, t) {
        if (null === e && null === t)
            return 0;
        if (!e)
            return -1;
        if (!t)
            return 1;
        let n = e.length
            , r = t.length;
        if (n === r) {
            for (let r = 0; r < n; r++) {
                let n = Ja(e[r], t[r]);
                if (0 !== n)
                    return n
            }
            return 0
        }
        return n - r
    }
    function Xa(e) {
        return !!/^#[0-9a-f]{6}$/i.test(e) || (!!/^#[0-9a-f]{8}$/i.test(e) || (!!/^#[0-9a-f]{3}$/i.test(e) || !!/^#[0-9a-f]{4}$/i.test(e)))
    }
    function Qa(e) {
        return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&")
    }
    var Ya = class {
        constructor(e) {
            this.fn = e,
                this.cache = new Map
        }
        get(e) {
            if (this.cache.has(e))
                return this.cache.get(e);
            const t = this.fn(e);
            return this.cache.set(e, t),
                t
        }
    }
        , el = class {
            constructor(e, t, n) {
                this._colorMap = e,
                    this._defaults = t,
                    this._root = n,
                    this._cachedMatchRoot = new Ya((e => this._root.match(e)))
            }
            static createFromRawTheme(e, t) {
                return this.createFromParsedTheme(function (e) {
                    if (!e)
                        return [];
                    if (!e.settings || !Array.isArray(e.settings))
                        return [];
                    let t = e.settings
                        , n = []
                        , r = 0;
                    for (let o = 0, i = t.length; o < i; o++) {
                        let e, i = t[o];
                        if (!i.settings)
                            continue;
                        if ("string" === typeof i.scope) {
                            let t = i.scope;
                            t = t.replace(/^[,]+/, ""),
                                t = t.replace(/[,]+$/, ""),
                                e = t.split(",")
                        } else
                            e = Array.isArray(i.scope) ? i.scope : [""];
                        let s = -1;
                        if ("string" === typeof i.settings.fontStyle) {
                            s = 0;
                            let e = i.settings.fontStyle.split(" ");
                            for (let t = 0, n = e.length; t < n; t++) {
                                switch (e[t]) {
                                    case "italic":
                                        s |= 1;
                                        break;
                                    case "bold":
                                        s |= 2;
                                        break;
                                    case "underline":
                                        s |= 4;
                                        break;
                                    case "strikethrough":
                                        s |= 8
                                }
                            }
                        }
                        let a = null;
                        "string" === typeof i.settings.foreground && Xa(i.settings.foreground) && (a = i.settings.foreground);
                        let l = null;
                        "string" === typeof i.settings.background && Xa(i.settings.background) && (l = i.settings.background);
                        for (let t = 0, c = e.length; t < c; t++) {
                            let i = e[t].trim().split(" ")
                                , c = i[i.length - 1]
                                , d = null;
                            i.length > 1 && (d = i.slice(0, i.length - 1),
                                d.reverse()),
                                n[r++] = new ol(c, d, o, s, a, l)
                        }
                    }
                    return n
                }(e), t)
            }
            static createFromParsedTheme(e, t) {
                return function (e, t) {
                    e.sort(((e, t) => {
                        let n = Ja(e.scope, t.scope);
                        return 0 !== n ? n : (n = Za(e.parentScopes, t.parentScopes),
                            0 !== n ? n : e.index - t.index)
                    }
                    ));
                    let n = 0
                        , r = "#000000"
                        , o = "#ffffff";
                    for (; e.length >= 1 && "" === e[0].scope;) {
                        let t = e.shift();
                        -1 !== t.fontStyle && (n = t.fontStyle),
                            null !== t.foreground && (r = t.foreground),
                            null !== t.background && (o = t.background)
                    }
                    let i = new sl(t)
                        , s = new rl(n, i.getId(r), i.getId(o))
                        , a = new cl(new ll(0, null, -1, 0, 0), []);
                    for (let l = 0, c = e.length; l < c; l++) {
                        let t = e[l];
                        a.insert(0, t.scope, t.parentScopes, t.fontStyle, i.getId(t.foreground), i.getId(t.background))
                    }
                    return new el(i, s, a)
                }(e, t)
            }
            getColorMap() {
                return this._colorMap.getColorMap()
            }
            getDefaults() {
                return this._defaults
            }
            match(e) {
                if (null === e)
                    return this._defaults;
                const t = e.scopeName
                    , n = this._cachedMatchRoot.get(t).find((t => function (e, t) {
                        if (0 === t.length)
                            return !0;
                        for (let n = 0; n < t.length; n++) {
                            let r = t[n]
                                , o = !1;
                            if (">" === r) {
                                if (n === t.length - 1)
                                    return !1;
                                r = t[++n],
                                    o = !0
                            }
                            for (; e && !nl(e.scopeName, r);) {
                                if (o)
                                    return !1;
                                e = e.parent
                            }
                            if (!e)
                                return !1;
                            e = e.parent
                        }
                        return !0
                    }(e.parent, t.parentScopes)));
                return n ? new rl(n.fontStyle, n.foreground, n.background) : null
            }
        }
        , tl = class e {
            constructor(e, t) {
                this.parent = e,
                    this.scopeName = t
            }
            static push(t, n) {
                for (const r of n)
                    t = new e(t, r);
                return t
            }
            static from() {
                let t = null;
                for (let n = 0; n < arguments.length; n++)
                    t = new e(t, n < 0 || arguments.length <= n ? void 0 : arguments[n]);
                return t
            }
            push(t) {
                return new e(this, t)
            }
            getSegments() {
                let e = this;
                const t = [];
                for (; e;)
                    t.push(e.scopeName),
                        e = e.parent;
                return t.reverse(),
                    t
            }
            toString() {
                return this.getSegments().join(" ")
            }
            extends(e) {
                return this === e || null !== this.parent && this.parent.extends(e)
            }
            getExtensionIfDefined(e) {
                const t = [];
                let n = this;
                for (; n && n !== e;)
                    t.push(n.scopeName),
                        n = n.parent;
                return n === e ? t.reverse() : void 0
            }
        }
        ;
    function nl(e, t) {
        return t === e || e.startsWith(t) && "." === e[t.length]
    }
    var rl = class {
        constructor(e, t, n) {
            this.fontStyle = e,
                this.foregroundId = t,
                this.backgroundId = n
        }
    }
        ;
    var ol = class {
        constructor(e, t, n, r, o, i) {
            this.scope = e,
                this.parentScopes = t,
                this.index = n,
                this.fontStyle = r,
                this.foreground = o,
                this.background = i
        }
    }
        , il = (e => (e[e.NotSet = -1] = "NotSet",
            e[e.None = 0] = "None",
            e[e.Italic = 1] = "Italic",
            e[e.Bold = 2] = "Bold",
            e[e.Underline = 4] = "Underline",
            e[e.Strikethrough = 8] = "Strikethrough",
            e))(il || {});
    var sl = class {
        constructor(e) {
            if (this._lastColorId = 0,
                this._id2color = [],
                this._color2id = Object.create(null),
                Array.isArray(e)) {
                this._isFrozen = !0;
                for (let t = 0, n = e.length; t < n; t++)
                    this._color2id[e[t]] = t,
                        this._id2color[t] = e[t]
            } else
                this._isFrozen = !1
        }
        getId(e) {
            if (null === e)
                return 0;
            e = e.toUpperCase();
            let t = this._color2id[e];
            if (t)
                return t;
            if (this._isFrozen)
                throw new Error(`Missing color in color map - ${e}`);
            return t = ++this._lastColorId,
                this._color2id[e] = t,
                this._id2color[t] = e,
                t
        }
        getColorMap() {
            return this._id2color.slice(0)
        }
    }
        , al = Object.freeze([])
        , ll = class e {
            constructor(e, t, n, r, o) {
                this.scopeDepth = e,
                    this.parentScopes = t || al,
                    this.fontStyle = n,
                    this.foreground = r,
                    this.background = o
            }
            clone() {
                return new e(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background)
            }
            static cloneArr(e) {
                let t = [];
                for (let n = 0, r = e.length; n < r; n++)
                    t[n] = e[n].clone();
                return t
            }
            acceptOverwrite(e, t, n, r) {
                this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e,
                    -1 !== t && (this.fontStyle = t),
                    0 !== n && (this.foreground = n),
                    0 !== r && (this.background = r)
            }
        }
        , cl = class e {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                    , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this._mainRule = e,
                    this._children = n,
                    this._rulesWithParentScopes = t
            }
            static _cmpBySpecificity(e, t) {
                if (e.scopeDepth !== t.scopeDepth)
                    return t.scopeDepth - e.scopeDepth;
                let n = 0
                    , r = 0;
                for (; ">" === e.parentScopes[n] && n++,
                    ">" === t.parentScopes[r] && r++,
                    !(n >= e.parentScopes.length || r >= t.parentScopes.length);) {
                    const o = t.parentScopes[r].length - e.parentScopes[n].length;
                    if (0 !== o)
                        return o;
                    n++,
                        r++
                }
                return t.parentScopes.length - e.parentScopes.length
            }
            match(t) {
                if ("" !== t) {
                    let e, n, r = t.indexOf(".");
                    if (-1 === r ? (e = t,
                        n = "") : (e = t.substring(0, r),
                            n = t.substring(r + 1)),
                        this._children.hasOwnProperty(e))
                        return this._children[e].match(n)
                }
                const n = this._rulesWithParentScopes.concat(this._mainRule);
                return n.sort(e._cmpBySpecificity),
                    n
            }
            insert(t, n, r, o, i, s) {
                if ("" === n)
                    return void this._doInsertHere(t, r, o, i, s);
                let a, l, c, d = n.indexOf(".");
                -1 === d ? (a = n,
                    l = "") : (a = n.substring(0, d),
                        l = n.substring(d + 1)),
                    this._children.hasOwnProperty(a) ? c = this._children[a] : (c = new e(this._mainRule.clone(), ll.cloneArr(this._rulesWithParentScopes)),
                        this._children[a] = c),
                    c.insert(t + 1, l, r, o, i, s)
            }
            _doInsertHere(e, t, n, r, o) {
                if (null !== t) {
                    for (let i = 0, s = this._rulesWithParentScopes.length; i < s; i++) {
                        let s = this._rulesWithParentScopes[i];
                        if (0 === Za(s.parentScopes, t))
                            return void s.acceptOverwrite(e, n, r, o)
                    }
                    -1 === n && (n = this._mainRule.fontStyle),
                        0 === r && (r = this._mainRule.foreground),
                        0 === o && (o = this._mainRule.background),
                        this._rulesWithParentScopes.push(new ll(e, t, n, r, o))
                } else
                    this._mainRule.acceptOverwrite(e, n, r, o)
            }
        }
        , dl = class e {
            static toBinaryStr(e) {
                return e.toString(2).padStart(32, "0")
            }
            static print(t) {
                const n = e.getLanguageId(t)
                    , r = e.getTokenType(t)
                    , o = e.getFontStyle(t)
                    , i = e.getForeground(t)
                    , s = e.getBackground(t);
                console.log({
                    languageId: n,
                    tokenType: r,
                    fontStyle: o,
                    foreground: i,
                    background: s
                })
            }
            static getLanguageId(e) {
                return (255 & e) >>> 0
            }
            static getTokenType(e) {
                return (768 & e) >>> 8
            }
            static containsBalancedBrackets(e) {
                return 0 !== (1024 & e)
            }
            static getFontStyle(e) {
                return (30720 & e) >>> 11
            }
            static getForeground(e) {
                return (16744448 & e) >>> 15
            }
            static getBackground(e) {
                return (4278190080 & e) >>> 24
            }
            static set(t, n, r, o, i, s, a) {
                let l = e.getLanguageId(t)
                    , c = e.getTokenType(t)
                    , d = e.containsBalancedBrackets(t) ? 1 : 0
                    , u = e.getFontStyle(t)
                    , h = e.getForeground(t)
                    , p = e.getBackground(t);
                return 0 !== n && (l = n),
                    8 !== r && (c = r),
                    null !== o && (d = o ? 1 : 0),
                    -1 !== i && (u = i),
                    0 !== s && (h = s),
                    0 !== a && (p = a),
                    (l | c << 8 | d << 10 | u << 11 | h << 15 | p << 24) >>> 0
            }
        }
        ;
    function ul(e, t) {
        const n = []
            , r = function (e) {
                let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g
                    , n = t.exec(e);
                return {
                    next: () => {
                        if (!n)
                            return null;
                        const r = n[0];
                        return n = t.exec(e),
                            r
                    }
                }
            }(e);
        let o = r.next();
        for (; null !== o;) {
            let e = 0;
            if (2 === o.length && ":" === o.charAt(1)) {
                switch (o.charAt(0)) {
                    case "R":
                        e = 1;
                        break;
                    case "L":
                        e = -1;
                        break;
                    default:
                        console.log(`Unknown priority ${o} in scope selector`)
                }
                o = r.next()
            }
            let t = s();
            if (n.push({
                matcher: t,
                priority: e
            }),
                "," !== o)
                break;
            o = r.next()
        }
        return n;
        function i() {
            if ("-" === o) {
                o = r.next();
                const e = i();
                return t => !!e && !e(t)
            }
            if ("(" === o) {
                o = r.next();
                const e = function () {
                    const e = [];
                    let t = s();
                    for (; t && (e.push(t),
                        "|" === o || "," === o);) {
                        do {
                            o = r.next()
                        } while ("|" === o || "," === o);
                        t = s()
                    }
                    return t => e.some((e => e(t)))
                }();
                return ")" === o && (o = r.next()),
                    e
            }
            if (hl(o)) {
                const e = [];
                do {
                    e.push(o),
                        o = r.next()
                } while (hl(o));
                return n => t(e, n)
            }
            return null
        }
        function s() {
            const e = [];
            let t = i();
            for (; t;)
                e.push(t),
                    t = i();
            return t => e.every((e => e(t)))
        }
    }
    function hl(e) {
        return !!e && !!e.match(/[\w\.:]+/)
    }
    function pl(e) {
        "function" === typeof e.dispose && e.dispose()
    }
    var fl = class {
        constructor(e) {
            this.scopeName = e
        }
        toKey() {
            return this.scopeName
        }
    }
        , ml = class {
            constructor(e, t) {
                this.scopeName = e,
                    this.ruleName = t
            }
            toKey() {
                return `${this.scopeName}#${this.ruleName}`
            }
        }
        , gl = class {
            constructor() {
                this._references = [],
                    this._seenReferenceKeys = new Set,
                    this.visitedRule = new Set
            }
            get references() {
                return this._references
            }
            add(e) {
                const t = e.toKey();
                this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t),
                    this._references.push(e))
            }
        }
        , bl = class {
            constructor(e, t) {
                this.repo = e,
                    this.initialScopeName = t,
                    this.seenFullScopeRequests = new Set,
                    this.seenPartialScopeRequests = new Set,
                    this.seenFullScopeRequests.add(this.initialScopeName),
                    this.Q = [new fl(this.initialScopeName)]
            }
            processQueue() {
                const e = this.Q;
                this.Q = [];
                const t = new gl;
                for (const n of e)
                    yl(n, this.initialScopeName, this.repo, t);
                for (const n of t.references)
                    if (n instanceof fl) {
                        if (this.seenFullScopeRequests.has(n.scopeName))
                            continue;
                        this.seenFullScopeRequests.add(n.scopeName),
                            this.Q.push(n)
                    } else {
                        if (this.seenFullScopeRequests.has(n.scopeName))
                            continue;
                        if (this.seenPartialScopeRequests.has(n.toKey()))
                            continue;
                        this.seenPartialScopeRequests.add(n.toKey()),
                            this.Q.push(n)
                    }
            }
        }
        ;
    function yl(e, t, n, r) {
        const o = n.lookup(e.scopeName);
        if (!o) {
            if (e.scopeName === t)
                throw new Error(`No grammar provided for <${t}>`);
            return
        }
        const i = n.lookup(t);
        e instanceof fl ? wl({
            baseGrammar: i,
            selfGrammar: o
        }, r) : vl(e.ruleName, {
            baseGrammar: i,
            selfGrammar: o,
            repository: o.repository
        }, r);
        const s = n.injections(e.scopeName);
        if (s)
            for (const a of s)
                r.add(new fl(a))
    }
    function vl(e, t, n) {
        if (t.repository && t.repository[e]) {
            kl([t.repository[e]], t, n)
        }
    }
    function wl(e, t) {
        e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && kl(e.selfGrammar.patterns, {
            ...e,
            repository: e.selfGrammar.repository
        }, t),
            e.selfGrammar.injections && kl(Object.values(e.selfGrammar.injections), {
                ...e,
                repository: e.selfGrammar.repository
            }, t)
    }
    function kl(e, t, n) {
        for (const r of e) {
            if (n.visitedRule.has(r))
                continue;
            n.visitedRule.add(r);
            const e = r.repository ? Wa({}, t.repository, r.repository) : t.repository;
            Array.isArray(r.patterns) && kl(r.patterns, {
                ...t,
                repository: e
            }, n);
            const o = r.include;
            if (!o)
                continue;
            const i = Tl(o);
            switch (i.kind) {
                case 0:
                    wl({
                        ...t,
                        selfGrammar: t.baseGrammar
                    }, n);
                    break;
                case 1:
                    wl(t, n);
                    break;
                case 2:
                    vl(i.ruleName, {
                        ...t,
                        repository: e
                    }, n);
                    break;
                case 3:
                case 4:
                    const r = i.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : i.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
                    if (r) {
                        const o = {
                            baseGrammar: t.baseGrammar,
                            selfGrammar: r,
                            repository: e
                        };
                        4 === i.kind ? vl(i.ruleName, o, n) : wl(o, n)
                    } else
                        4 === i.kind ? n.add(new ml(i.scopeName, i.ruleName)) : n.add(new fl(i.scopeName))
            }
        }
    }
    var Cl = class {
        constructor() {
            this.kind = 0
        }
    }
        , Sl = class {
            constructor() {
                this.kind = 1
            }
        }
        , xl = class {
            constructor(e) {
                this.ruleName = e,
                    this.kind = 2
            }
        }
        , El = class {
            constructor(e) {
                this.scopeName = e,
                    this.kind = 3
            }
        }
        , Ml = class {
            constructor(e, t) {
                this.scopeName = e,
                    this.ruleName = t,
                    this.kind = 4
            }
        }
        ;
    function Tl(e) {
        if ("$base" === e)
            return new Cl;
        if ("$self" === e)
            return new Sl;
        const t = e.indexOf("#");
        if (-1 === t)
            return new El(e);
        if (0 === t)
            return new xl(e.substring(1));
        {
            const n = e.substring(0, t)
                , r = e.substring(t + 1);
            return new Ml(n, r)
        }
    }
    var Nl = /\\(\d+)/
        , _l = /\\(\d+)/g;
    Symbol("RuleId");
    var Ol = class {
        constructor(e, t, n, r) {
            this.$location = e,
                this.id = t,
                this._name = n || null,
                this._nameIsCapturing = Ka.hasCaptures(this._name),
                this._contentName = r || null,
                this._contentNameIsCapturing = Ka.hasCaptures(this._contentName)
        }
        get debugName() {
            const e = this.$location ? `${qa(this.$location.filename)}:${this.$location.line}` : "unknown";
            return `${this.constructor.name}#${this.id} @ ${e}`
        }
        getName(e, t) {
            return this._nameIsCapturing && null !== this._name && null !== e && null !== t ? Ka.replaceCaptures(this._name, e, t) : this._name
        }
        getContentName(e, t) {
            return this._contentNameIsCapturing && null !== this._contentName ? Ka.replaceCaptures(this._contentName, e, t) : this._contentName
        }
    }
        , Al = class extends Ol {
            constructor(e, t, n, r, o) {
                super(e, t, n, r),
                    this.retokenizeCapturedWithRuleId = o
            }
            dispose() { }
            collectPatterns(e, t) {
                throw new Error("Not supported!")
            }
            compile(e, t) {
                throw new Error("Not supported!")
            }
            compileAG(e, t, n, r) {
                throw new Error("Not supported!")
            }
        }
        , Pl = class extends Ol {
            constructor(e, t, n, r, o) {
                super(e, t, n, null),
                    this._match = new jl(r, this.id),
                    this.captures = o,
                    this._cachedCompiledPatterns = null
            }
            dispose() {
                this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
                    this._cachedCompiledPatterns = null)
            }
            get debugMatchRegExp() {
                return `${this._match.source}`
            }
            collectPatterns(e, t) {
                t.push(this._match)
            }
            compile(e, t) {
                return this._getCachedCompiledPatterns(e).compile(e)
            }
            compileAG(e, t, n, r) {
                return this._getCachedCompiledPatterns(e).compileAG(e, n, r)
            }
            _getCachedCompiledPatterns(e) {
                return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Hl,
                    this.collectPatterns(e, this._cachedCompiledPatterns)),
                    this._cachedCompiledPatterns
            }
        }
        , Ll = class extends Ol {
            constructor(e, t, n, r, o) {
                super(e, t, n, r),
                    this.patterns = o.patterns,
                    this.hasMissingPatterns = o.hasMissingPatterns,
                    this._cachedCompiledPatterns = null
            }
            dispose() {
                this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
                    this._cachedCompiledPatterns = null)
            }
            collectPatterns(e, t) {
                for (const n of this.patterns) {
                    e.getRule(n).collectPatterns(e, t)
                }
            }
            compile(e, t) {
                return this._getCachedCompiledPatterns(e).compile(e)
            }
            compileAG(e, t, n, r) {
                return this._getCachedCompiledPatterns(e).compileAG(e, n, r)
            }
            _getCachedCompiledPatterns(e) {
                return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Hl,
                    this.collectPatterns(e, this._cachedCompiledPatterns)),
                    this._cachedCompiledPatterns
            }
        }
        , Rl = class extends Ol {
            constructor(e, t, n, r, o, i, s, a, l, c) {
                super(e, t, n, r),
                    this._begin = new jl(o, this.id),
                    this.beginCaptures = i,
                    this._end = new jl(s || "\uffff", -1),
                    this.endHasBackReferences = this._end.hasBackReferences,
                    this.endCaptures = a,
                    this.applyEndPatternLast = l || !1,
                    this.patterns = c.patterns,
                    this.hasMissingPatterns = c.hasMissingPatterns,
                    this._cachedCompiledPatterns = null
            }
            dispose() {
                this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
                    this._cachedCompiledPatterns = null)
            }
            get debugBeginRegExp() {
                return `${this._begin.source}`
            }
            get debugEndRegExp() {
                return `${this._end.source}`
            }
            getEndWithResolvedBackReferences(e, t) {
                return this._end.resolveBackReferences(e, t)
            }
            collectPatterns(e, t) {
                t.push(this._begin)
            }
            compile(e, t) {
                return this._getCachedCompiledPatterns(e, t).compile(e)
            }
            compileAG(e, t, n, r) {
                return this._getCachedCompiledPatterns(e, t).compileAG(e, n, r)
            }
            _getCachedCompiledPatterns(e, t) {
                if (!this._cachedCompiledPatterns) {
                    this._cachedCompiledPatterns = new Hl;
                    for (const t of this.patterns) {
                        e.getRule(t).collectPatterns(e, this._cachedCompiledPatterns)
                    }
                    this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)
                }
                return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t) : this._cachedCompiledPatterns.setSource(0, t)),
                    this._cachedCompiledPatterns
            }
        }
        , Dl = class extends Ol {
            constructor(e, t, n, r, o, i, s, a, l) {
                super(e, t, n, r),
                    this._begin = new jl(o, this.id),
                    this.beginCaptures = i,
                    this.whileCaptures = a,
                    this._while = new jl(s, -2),
                    this.whileHasBackReferences = this._while.hasBackReferences,
                    this.patterns = l.patterns,
                    this.hasMissingPatterns = l.hasMissingPatterns,
                    this._cachedCompiledPatterns = null,
                    this._cachedCompiledWhilePatterns = null
            }
            dispose() {
                this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
                    this._cachedCompiledPatterns = null),
                    this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(),
                        this._cachedCompiledWhilePatterns = null)
            }
            get debugBeginRegExp() {
                return `${this._begin.source}`
            }
            get debugWhileRegExp() {
                return `${this._while.source}`
            }
            getWhileWithResolvedBackReferences(e, t) {
                return this._while.resolveBackReferences(e, t)
            }
            collectPatterns(e, t) {
                t.push(this._begin)
            }
            compile(e, t) {
                return this._getCachedCompiledPatterns(e).compile(e)
            }
            compileAG(e, t, n, r) {
                return this._getCachedCompiledPatterns(e).compileAG(e, n, r)
            }
            _getCachedCompiledPatterns(e) {
                if (!this._cachedCompiledPatterns) {
                    this._cachedCompiledPatterns = new Hl;
                    for (const t of this.patterns) {
                        e.getRule(t).collectPatterns(e, this._cachedCompiledPatterns)
                    }
                }
                return this._cachedCompiledPatterns
            }
            compileWhile(e, t) {
                return this._getCachedCompiledWhilePatterns(e, t).compile(e)
            }
            compileWhileAG(e, t, n, r) {
                return this._getCachedCompiledWhilePatterns(e, t).compileAG(e, n, r)
            }
            _getCachedCompiledWhilePatterns(e, t) {
                return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Hl,
                    this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)),
                    this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t || "\uffff"),
                    this._cachedCompiledWhilePatterns
            }
        }
        , Il = class e {
            static createCaptureRule(e, t, n, r, o) {
                return e.registerRule((e => new Al(t, e, n, r, o)))
            }
            static getCompiledRuleId(t, n, r) {
                return t.id || n.registerRule((o => {
                    if (t.id = o,
                        t.match)
                        return new Pl(t.$vscodeTextmateLocation, t.id, t.name, t.match, e._compileCaptures(t.captures, n, r));
                    if ("undefined" === typeof t.begin) {
                        t.repository && (r = Wa({}, r, t.repository));
                        let o = t.patterns;
                        return "undefined" === typeof o && t.include && (o = [{
                            include: t.include
                        }]),
                            new Ll(t.$vscodeTextmateLocation, t.id, t.name, t.contentName, e._compilePatterns(o, n, r))
                    }
                    return t.while ? new Dl(t.$vscodeTextmateLocation, t.id, t.name, t.contentName, t.begin, e._compileCaptures(t.beginCaptures || t.captures, n, r), t.while, e._compileCaptures(t.whileCaptures || t.captures, n, r), e._compilePatterns(t.patterns, n, r)) : new Rl(t.$vscodeTextmateLocation, t.id, t.name, t.contentName, t.begin, e._compileCaptures(t.beginCaptures || t.captures, n, r), t.end, e._compileCaptures(t.endCaptures || t.captures, n, r), t.applyEndPatternLast, e._compilePatterns(t.patterns, n, r))
                }
                )),
                    t.id
            }
            static _compileCaptures(t, n, r) {
                let o = [];
                if (t) {
                    let i = 0;
                    for (const e in t) {
                        if ("$vscodeTextmateLocation" === e)
                            continue;
                        const t = parseInt(e, 10);
                        t > i && (i = t)
                    }
                    for (let e = 0; e <= i; e++)
                        o[e] = null;
                    for (const s in t) {
                        if ("$vscodeTextmateLocation" === s)
                            continue;
                        const i = parseInt(s, 10);
                        let a = 0;
                        t[s].patterns && (a = e.getCompiledRuleId(t[s], n, r)),
                            o[i] = e.createCaptureRule(n, t[s].$vscodeTextmateLocation, t[s].name, t[s].contentName, a)
                    }
                }
                return o
            }
            static _compilePatterns(t, n, r) {
                let o = [];
                if (t)
                    for (let i = 0, s = t.length; i < s; i++) {
                        const s = t[i];
                        let a = -1;
                        if (s.include) {
                            const t = Tl(s.include);
                            switch (t.kind) {
                                case 0:
                                case 1:
                                    a = e.getCompiledRuleId(r[s.include], n, r);
                                    break;
                                case 2:
                                    let o = r[t.ruleName];
                                    o && (a = e.getCompiledRuleId(o, n, r));
                                    break;
                                case 3:
                                case 4:
                                    const i = t.scopeName
                                        , l = 4 === t.kind ? t.ruleName : null
                                        , c = n.getExternalGrammar(i, r);
                                    if (c)
                                        if (l) {
                                            let t = c.repository[l];
                                            t && (a = e.getCompiledRuleId(t, n, c.repository))
                                        } else
                                            a = e.getCompiledRuleId(c.repository.$self, n, c.repository)
                            }
                        } else
                            a = e.getCompiledRuleId(s, n, r);
                        if (-1 !== a) {
                            const e = n.getRule(a);
                            let t = !1;
                            if ((e instanceof Ll || e instanceof Rl || e instanceof Dl) && e.hasMissingPatterns && 0 === e.patterns.length && (t = !0),
                                t)
                                continue;
                            o.push(a)
                        }
                    }
                return {
                    patterns: o,
                    hasMissingPatterns: (t ? t.length : 0) !== o.length
                }
            }
        }
        , jl = class e {
            constructor(e, t) {
                if (e) {
                    const t = e.length;
                    let n = 0
                        , r = []
                        , o = !1;
                    for (let i = 0; i < t; i++) {
                        if ("\\" === e.charAt(i) && i + 1 < t) {
                            const t = e.charAt(i + 1);
                            "z" === t ? (r.push(e.substring(n, i)),
                                r.push("$(?!\\n)(?<!\\n)"),
                                n = i + 2) : "A" !== t && "G" !== t || (o = !0),
                                i++
                        }
                    }
                    this.hasAnchor = o,
                        0 === n ? this.source = e : (r.push(e.substring(n, t)),
                            this.source = r.join(""))
                } else
                    this.hasAnchor = !1,
                        this.source = e;
                this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null,
                    this.ruleId = t,
                    this.hasBackReferences = Nl.test(this.source)
            }
            clone() {
                return new e(this.source, this.ruleId)
            }
            setSource(e) {
                this.source !== e && (this.source = e,
                    this.hasAnchor && (this._anchorCache = this._buildAnchorCache()))
            }
            resolveBackReferences(e, t) {
                let n = t.map((t => e.substring(t.start, t.end)));
                return _l.lastIndex = 0,
                    this.source.replace(_l, ((e, t) => Qa(n[parseInt(t, 10)] || "")))
            }
            _buildAnchorCache() {
                let e, t, n, r, o = [], i = [], s = [], a = [];
                for (e = 0,
                    t = this.source.length; e < t; e++)
                    n = this.source.charAt(e),
                        o[e] = n,
                        i[e] = n,
                        s[e] = n,
                        a[e] = n,
                        "\\" === n && e + 1 < t && (r = this.source.charAt(e + 1),
                            "A" === r ? (o[e + 1] = "\uffff",
                                i[e + 1] = "\uffff",
                                s[e + 1] = "A",
                                a[e + 1] = "A") : "G" === r ? (o[e + 1] = "\uffff",
                                    i[e + 1] = "G",
                                    s[e + 1] = "\uffff",
                                    a[e + 1] = "G") : (o[e + 1] = r,
                                        i[e + 1] = r,
                                        s[e + 1] = r,
                                        a[e + 1] = r),
                            e++);
                return {
                    A0_G0: o.join(""),
                    A0_G1: i.join(""),
                    A1_G0: s.join(""),
                    A1_G1: a.join("")
                }
            }
            resolveAnchors(e, t) {
                return this.hasAnchor && this._anchorCache ? e ? t ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : t ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source
            }
        }
        , Hl = class {
            constructor() {
                this._items = [],
                    this._hasAnchors = !1,
                    this._cached = null,
                    this._anchorCache = {
                        A0_G0: null,
                        A0_G1: null,
                        A1_G0: null,
                        A1_G1: null
                    }
            }
            dispose() {
                this._disposeCaches()
            }
            _disposeCaches() {
                this._cached && (this._cached.dispose(),
                    this._cached = null),
                    this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(),
                        this._anchorCache.A0_G0 = null),
                    this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(),
                        this._anchorCache.A0_G1 = null),
                    this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(),
                        this._anchorCache.A1_G0 = null),
                    this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(),
                        this._anchorCache.A1_G1 = null)
            }
            push(e) {
                this._items.push(e),
                    this._hasAnchors = this._hasAnchors || e.hasAnchor
            }
            unshift(e) {
                this._items.unshift(e),
                    this._hasAnchors = this._hasAnchors || e.hasAnchor
            }
            length() {
                return this._items.length
            }
            setSource(e, t) {
                this._items[e].source !== t && (this._disposeCaches(),
                    this._items[e].setSource(t))
            }
            compile(e) {
                if (!this._cached) {
                    let t = this._items.map((e => e.source));
                    this._cached = new zl(e, t, this._items.map((e => e.ruleId)))
                }
                return this._cached
            }
            compileAG(e, t, n) {
                return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)),
                    this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)),
                        this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)),
                            this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)),
                                this._anchorCache.A0_G0) : this.compile(e)
            }
            _resolveAnchors(e, t, n) {
                let r = this._items.map((e => e.resolveAnchors(t, n)));
                return new zl(e, r, this._items.map((e => e.ruleId)))
            }
        }
        , zl = class {
            constructor(e, t, n) {
                this.regExps = t,
                    this.rules = n,
                    this.scanner = e.createOnigScanner(t)
            }
            dispose() {
                "function" === typeof this.scanner.dispose && this.scanner.dispose()
            }
            toString() {
                const e = [];
                for (let t = 0, n = this.rules.length; t < n; t++)
                    e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
                return e.join("\n")
            }
            findNextMatchSync(e, t, n) {
                const r = this.scanner.findNextMatchSync(e, t, n);
                return r ? {
                    ruleId: this.rules[r.index],
                    captureIndices: r.captureIndices
                } : null
            }
        }
        , $l = class {
            constructor(e, t) {
                this.languageId = e,
                    this.tokenType = t
            }
        }
        , Bl = class e {
            constructor(e, t) {
                this._getBasicScopeAttributes = new Ya((e => {
                    const t = this._scopeToLanguage(e)
                        , n = this._toStandardTokenType(e);
                    return new $l(t, n)
                }
                )),
                    this._defaultAttributes = new $l(e, 8),
                    this._embeddedLanguagesMatcher = new Fl(Object.entries(t || {}))
            }
            getDefaultAttributes() {
                return this._defaultAttributes
            }
            getBasicScopeAttributes(t) {
                return null === t ? e._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t)
            }
            _scopeToLanguage(e) {
                return this._embeddedLanguagesMatcher.match(e) || 0
            }
            _toStandardTokenType(t) {
                const n = t.match(e.STANDARD_TOKEN_TYPE_REGEXP);
                if (!n)
                    return 8;
                switch (n[1]) {
                    case "comment":
                        return 1;
                    case "string":
                        return 2;
                    case "regex":
                        return 3;
                    case "meta.embedded":
                        return 0
                }
                throw new Error("Unexpected match for standard token type!")
            }
        }
        ;
    Bl._NULL_SCOPE_METADATA = new $l(0, 0),
        Bl.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
    var Vl = Bl
        , Fl = class {
            constructor(e) {
                if (0 === e.length)
                    this.values = null,
                        this.scopesRegExp = null;
                else {
                    this.values = new Map(e);
                    const t = e.map((e => {
                        let [t, n] = e;
                        return Qa(t)
                    }
                    ));
                    t.sort(),
                        t.reverse(),
                        this.scopesRegExp = new RegExp(`^((${t.join(")|(")}))($|\\.)`, "")
                }
            }
            match(e) {
                if (!this.scopesRegExp)
                    return;
                const t = e.match(this.scopesRegExp);
                return t ? this.values.get(t[1]) : void 0
            }
        }
        , Ul = class {
            constructor(e, t) {
                this.stack = e,
                    this.stoppedEarly = t
            }
        }
        ;
    function Wl(e, t, n, r, o, i, s, a) {
        const l = t.content.length;
        let c = !1
            , d = -1;
        if (s) {
            const s = function (e, t, n, r, o, i) {
                let s = o.beginRuleCapturedEOL ? 0 : -1;
                const a = [];
                for (let l = o; l; l = l.pop()) {
                    const t = l.getRule(e);
                    t instanceof Dl && a.push({
                        rule: t,
                        stack: l
                    })
                }
                for (let l = a.pop(); l; l = a.pop()) {
                    const { ruleScanner: a, findOptions: c } = Gl(l.rule, e, l.stack.endRule, n, r === s)
                        , d = a.findNextMatchSync(t, r, c);
                    if (!d) {
                        0,
                            o = l.stack.pop();
                        break
                    }
                    if (-2 !== d.ruleId) {
                        o = l.stack.pop();
                        break
                    }
                    d.captureIndices && d.captureIndices.length && (i.produce(l.stack, d.captureIndices[0].start),
                        Kl(e, t, n, l.stack, i, l.rule.whileCaptures, d.captureIndices),
                        i.produce(l.stack, d.captureIndices[0].end),
                        s = d.captureIndices[0].end,
                        d.captureIndices[0].end > r && (r = d.captureIndices[0].end,
                            n = !1))
                }
                return {
                    stack: o,
                    linePos: r,
                    anchorPosition: s,
                    isFirstLine: n
                }
            }(e, t, n, r, o, i);
            o = s.stack,
                r = s.linePos,
                n = s.isFirstLine,
                d = s.anchorPosition
        }
        const u = Date.now();
        for (; !c;) {
            if (0 !== a) {
                if (Date.now() - u > a)
                    return new Ul(o, !0)
            }
            h()
        }
        return new Ul(o, !1);
        function h() {
            const s = function (e, t, n, r, o, i) {
                const s = function (e, t, n, r, o, i) {
                    const s = o.getRule(e)
                        , { ruleScanner: a, findOptions: l } = ql(s, e, o.endRule, n, r === i)
                        , c = a.findNextMatchSync(t, r, l);
                    if (c)
                        return {
                            captureIndices: c.captureIndices,
                            matchedRuleId: c.ruleId
                        };
                    return null
                }(e, t, n, r, o, i)
                    , a = e.getInjections();
                if (0 === a.length)
                    return s;
                const l = function (e, t, n, r, o, i, s) {
                    let a, l = Number.MAX_VALUE, c = null, d = 0;
                    const u = i.contentNameScopesList.getScopeNames();
                    for (let h = 0, p = e.length; h < p; h++) {
                        const i = e[h];
                        if (!i.matcher(u))
                            continue;
                        const p = t.getRule(i.ruleId)
                            , { ruleScanner: f, findOptions: m } = ql(p, t, null, r, o === s)
                            , g = f.findNextMatchSync(n, o, m);
                        if (!g)
                            continue;
                        0;
                        const b = g.captureIndices[0].start;
                        if (!(b >= l) && (l = b,
                            c = g.captureIndices,
                            a = g.ruleId,
                            d = i.priority,
                            l === o))
                            break
                    }
                    if (c)
                        return {
                            priorityMatch: -1 === d,
                            captureIndices: c,
                            matchedRuleId: a
                        };
                    return null
                }(a, e, t, n, r, o, i);
                if (!l)
                    return s;
                if (!s)
                    return l;
                const c = s.captureIndices[0].start
                    , d = l.captureIndices[0].start;
                if (d < c || l.priorityMatch && d === c)
                    return l;
                return s
            }(e, t, n, r, o, d);
            if (!s)
                return i.produce(o, l),
                    void (c = !0);
            const a = s.captureIndices
                , u = s.matchedRuleId
                , h = !!(a && a.length > 0) && a[0].end > r;
            if (-1 === u) {
                const s = o.getRule(e);
                0,
                    i.produce(o, a[0].start),
                    o = o.withContentNameScopesList(o.nameScopesList),
                    Kl(e, t, n, o, i, s.endCaptures, a),
                    i.produce(o, a[0].end);
                const u = o;
                if (o = o.parent,
                    d = u.getAnchorPos(),
                    !h && u.getEnterPos() === r)
                    return o = u,
                        i.produce(o, l),
                        void (c = !0)
            } else {
                const s = e.getRule(u);
                i.produce(o, a[0].start);
                const p = o
                    , f = s.getName(t.content, a)
                    , m = o.contentNameScopesList.pushAttributed(f, e);
                if (o = o.push(u, r, d, a[0].end === l, null, m, m),
                    s instanceof Rl) {
                    const r = s;
                    0,
                        Kl(e, t, n, o, i, r.beginCaptures, a),
                        i.produce(o, a[0].end),
                        d = a[0].end;
                    const u = r.getContentName(t.content, a)
                        , f = m.pushAttributed(u, e);
                    if (o = o.withContentNameScopesList(f),
                        r.endHasBackReferences && (o = o.withEndRule(r.getEndWithResolvedBackReferences(t.content, a))),
                        !h && p.hasSameRuleAs(o))
                        return o = o.pop(),
                            i.produce(o, l),
                            void (c = !0)
                } else if (s instanceof Dl) {
                    const r = s;
                    0,
                        Kl(e, t, n, o, i, r.beginCaptures, a),
                        i.produce(o, a[0].end),
                        d = a[0].end;
                    const u = r.getContentName(t.content, a)
                        , f = m.pushAttributed(u, e);
                    if (o = o.withContentNameScopesList(f),
                        r.whileHasBackReferences && (o = o.withEndRule(r.getWhileWithResolvedBackReferences(t.content, a))),
                        !h && p.hasSameRuleAs(o))
                        return o = o.pop(),
                            i.produce(o, l),
                            void (c = !0)
                } else {
                    if (Kl(e, t, n, o, i, s.captures, a),
                        i.produce(o, a[0].end),
                        o = o.pop(),
                        !h)
                        return o = o.safePop(),
                            i.produce(o, l),
                            void (c = !0)
                }
            }
            a[0].end > r && (r = a[0].end,
                n = !1)
        }
    }
    function ql(e, t, n, r, o) {
        return {
            ruleScanner: e.compileAG(t, n, r, o),
            findOptions: 0
        }
    }
    function Gl(e, t, n, r, o) {
        return {
            ruleScanner: e.compileWhileAG(t, n, r, o),
            findOptions: 0
        }
    }
    function Kl(e, t, n, r, o, i, s) {
        if (0 === i.length)
            return;
        const a = t.content
            , l = Math.min(i.length, s.length)
            , c = []
            , d = s[0].end;
        for (let u = 0; u < l; u++) {
            const t = i[u];
            if (null === t)
                continue;
            const l = s[u];
            if (0 === l.length)
                continue;
            if (l.start > d)
                break;
            for (; c.length > 0 && c[c.length - 1].endPos <= l.start;)
                o.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos),
                    c.pop();
            if (c.length > 0 ? o.produceFromScopes(c[c.length - 1].scopes, l.start) : o.produce(r, l.start),
                t.retokenizeCapturedWithRuleId) {
                const i = t.getName(a, s)
                    , c = r.contentNameScopesList.pushAttributed(i, e)
                    , d = t.getContentName(a, s)
                    , u = c.pushAttributed(d, e)
                    , h = r.push(t.retokenizeCapturedWithRuleId, l.start, -1, !1, null, c, u)
                    , p = e.createOnigString(a.substring(0, l.end));
                Wl(e, p, n && 0 === l.start, l.start, h, o, !1, 0),
                    pl(p);
                continue
            }
            const h = t.getName(a, s);
            if (null !== h) {
                const t = (c.length > 0 ? c[c.length - 1].scopes : r.contentNameScopesList).pushAttributed(h, e);
                c.push(new Jl(t, l.end))
            }
        }
        for (; c.length > 0;)
            o.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos),
                c.pop()
    }
    var Jl = class {
        constructor(e, t) {
            this.scopes = e,
                this.endPos = t
        }
    }
        ;
    function Zl(e, t, n, r, o) {
        const i = ul(t, Xl)
            , s = Il.getCompiledRuleId(n, r, o.repository);
        for (const a of i)
            e.push({
                debugSelector: t,
                matcher: a.matcher,
                ruleId: s,
                grammar: o,
                priority: a.priority
            })
    }
    function Xl(e, t) {
        if (t.length < e.length)
            return !1;
        let n = 0;
        return e.every((e => {
            for (let r = n; r < t.length; r++)
                if (Ql(t[r], e))
                    return n = r + 1,
                        !0;
            return !1
        }
        ))
    }
    function Ql(e, t) {
        if (!e)
            return !1;
        if (e === t)
            return !0;
        const n = t.length;
        return e.length > n && e.substr(0, n) === t && "." === e[n]
    }
    var Yl = class {
        constructor(e, t, n, r, o, i, s, a) {
            if (this._rootScopeName = e,
                this.balancedBracketSelectors = i,
                this._onigLib = a,
                this._basicScopeAttributesProvider = new Vl(n, r),
                this._rootId = -1,
                this._lastRuleId = 0,
                this._ruleId2desc = [null],
                this._includedGrammars = {},
                this._grammarRepository = s,
                this._grammar = ec(t, null),
                this._injections = null,
                this._tokenTypeMatchers = [],
                o)
                for (const l of Object.keys(o)) {
                    const e = ul(l, Xl);
                    for (const t of e)
                        this._tokenTypeMatchers.push({
                            matcher: t.matcher,
                            type: o[l]
                        })
                }
        }
        get themeProvider() {
            return this._grammarRepository
        }
        dispose() {
            for (const e of this._ruleId2desc)
                e && e.dispose()
        }
        createOnigScanner(e) {
            return this._onigLib.createOnigScanner(e)
        }
        createOnigString(e) {
            return this._onigLib.createOnigString(e)
        }
        getMetadataForScope(e) {
            return this._basicScopeAttributesProvider.getBasicScopeAttributes(e)
        }
        _collectInjections() {
            const e = e => e === this._rootScopeName ? this._grammar : this.getExternalGrammar(e)
                , t = []
                , n = this._rootScopeName
                , r = e(n);
            if (r) {
                const e = r.injections;
                if (e)
                    for (let n in e)
                        Zl(t, n, e[n], this, r);
                const o = this._grammarRepository.injections(n);
                o && o.forEach((e => {
                    const n = this.getExternalGrammar(e);
                    if (n) {
                        const e = n.injectionSelector;
                        e && Zl(t, e, n, this, n)
                    }
                }
                ))
            }
            return t.sort(((e, t) => e.priority - t.priority)),
                t
        }
        getInjections() {
            return null === this._injections && (this._injections = this._collectInjections()),
                this._injections
        }
        registerRule(e) {
            const t = ++this._lastRuleId
                , n = e(t);
            return this._ruleId2desc[t] = n,
                n
        }
        getRule(e) {
            return this._ruleId2desc[e]
        }
        getExternalGrammar(e, t) {
            if (this._includedGrammars[e])
                return this._includedGrammars[e];
            if (this._grammarRepository) {
                const n = this._grammarRepository.lookup(e);
                if (n)
                    return this._includedGrammars[e] = ec(n, t && t.$base),
                        this._includedGrammars[e]
            }
        }
        tokenizeLine(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = this._tokenize(e, t, !1, n);
            return {
                tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
                ruleStack: r.ruleStack,
                stoppedEarly: r.stoppedEarly
            }
        }
        tokenizeLine2(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = this._tokenize(e, t, !0, n);
            return {
                tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
                ruleStack: r.ruleStack,
                stoppedEarly: r.stoppedEarly
            }
        }
        _tokenize(e, t, n, r) {
            let o;
            if (-1 === this._rootId && (this._rootId = Il.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository),
                this.getInjections()),
                t && t !== rc.NULL)
                o = !1,
                    t.reset();
            else {
                o = !0;
                const e = this._basicScopeAttributesProvider.getDefaultAttributes()
                    , n = this.themeProvider.getDefaults()
                    , r = dl.set(0, e.languageId, e.tokenType, null, n.fontStyle, n.foregroundId, n.backgroundId)
                    , i = this.getRule(this._rootId).getName(null, null);
                let s;
                s = i ? tc.createRootAndLookUpScopeName(i, r, this) : tc.createRoot("unknown", r),
                    t = new rc(null, this._rootId, -1, -1, !1, null, s, s)
            }
            e += "\n";
            const i = this.createOnigString(e)
                , s = i.content.length
                , a = new ic(n, e, this._tokenTypeMatchers, this.balancedBracketSelectors)
                , l = Wl(this, i, o, 0, t, a, !0, r);
            return pl(i),
            {
                lineLength: s,
                lineTokens: a,
                ruleStack: l.stack,
                stoppedEarly: l.stoppedEarly
            }
        }
    }
        ;
    function ec(e, t) {
        return (e = Ua(e)).repository = e.repository || {},
            e.repository.$self = {
                $vscodeTextmateLocation: e.$vscodeTextmateLocation,
                patterns: e.patterns,
                name: e.scopeName
            },
            e.repository.$base = t || e.repository.$self,
            e
    }
    var tc = class e {
        constructor(e, t, n) {
            this.parent = e,
                this.scopePath = t,
                this.tokenAttributes = n
        }
        static fromExtension(t, n) {
            let r = t
                , o = t?.scopePath ?? null;
            for (const i of n)
                o = tl.push(o, i.scopeNames),
                    r = new e(r, o, i.encodedTokenAttributes);
            return r
        }
        static createRoot(t, n) {
            return new e(null, new tl(null, t), n)
        }
        static createRootAndLookUpScopeName(t, n, r) {
            const o = r.getMetadataForScope(t)
                , i = new tl(null, t)
                , s = r.themeProvider.themeMatch(i)
                , a = e.mergeAttributes(n, o, s);
            return new e(null, i, a)
        }
        get scopeName() {
            return this.scopePath.scopeName
        }
        toString() {
            return this.getScopeNames().join(" ")
        }
        equals(t) {
            return e.equals(this, t)
        }
        static equals(e, t) {
            for (; ;) {
                if (e === t)
                    return !0;
                if (!e && !t)
                    return !0;
                if (!e || !t)
                    return !1;
                if (e.scopeName !== t.scopeName || e.tokenAttributes !== t.tokenAttributes)
                    return !1;
                e = e.parent,
                    t = t.parent
            }
        }
        static mergeAttributes(e, t, n) {
            let r = -1
                , o = 0
                , i = 0;
            return null !== n && (r = n.fontStyle,
                o = n.foregroundId,
                i = n.backgroundId),
                dl.set(e, t.languageId, t.tokenType, null, r, o, i)
        }
        pushAttributed(t, n) {
            if (null === t)
                return this;
            if (-1 === t.indexOf(" "))
                return e._pushAttributed(this, t, n);
            const r = t.split(/ /g);
            let o = this;
            for (const i of r)
                o = e._pushAttributed(o, i, n);
            return o
        }
        static _pushAttributed(t, n, r) {
            const o = r.getMetadataForScope(n)
                , i = t.scopePath.push(n)
                , s = r.themeProvider.themeMatch(i)
                , a = e.mergeAttributes(t.tokenAttributes, o, s);
            return new e(t, i, a)
        }
        getScopeNames() {
            return this.scopePath.getSegments()
        }
        getExtensionIfDefined(e) {
            const t = [];
            let n = this;
            for (; n && n !== e;)
                t.push({
                    encodedTokenAttributes: n.tokenAttributes,
                    scopeNames: n.scopePath.getExtensionIfDefined(n.parent?.scopePath ?? null)
                }),
                    n = n.parent;
            return n === e ? t.reverse() : void 0
        }
    }
        , nc = class e {
            constructor(e, t, n, r, o, i, s, a) {
                this.parent = e,
                    this.ruleId = t,
                    this.beginRuleCapturedEOL = o,
                    this.endRule = i,
                    this.nameScopesList = s,
                    this.contentNameScopesList = a,
                    this._stackElementBrand = void 0,
                    this.depth = this.parent ? this.parent.depth + 1 : 1,
                    this._enterPos = n,
                    this._anchorPos = r
            }
            equals(t) {
                return null !== t && e._equals(this, t)
            }
            static _equals(e, t) {
                return e === t || !!this._structuralEquals(e, t) && tc.equals(e.contentNameScopesList, t.contentNameScopesList)
            }
            static _structuralEquals(e, t) {
                for (; ;) {
                    if (e === t)
                        return !0;
                    if (!e && !t)
                        return !0;
                    if (!e || !t)
                        return !1;
                    if (e.depth !== t.depth || e.ruleId !== t.ruleId || e.endRule !== t.endRule)
                        return !1;
                    e = e.parent,
                        t = t.parent
                }
            }
            clone() {
                return this
            }
            static _reset(e) {
                for (; e;)
                    e._enterPos = -1,
                        e._anchorPos = -1,
                        e = e.parent
            }
            reset() {
                e._reset(this)
            }
            pop() {
                return this.parent
            }
            safePop() {
                return this.parent ? this.parent : this
            }
            push(t, n, r, o, i, s, a) {
                return new e(this, t, n, r, o, i, s, a)
            }
            getEnterPos() {
                return this._enterPos
            }
            getAnchorPos() {
                return this._anchorPos
            }
            getRule(e) {
                return e.getRule(this.ruleId)
            }
            toString() {
                const e = [];
                return this._writeString(e, 0),
                    "[" + e.join(",") + "]"
            }
            _writeString(e, t) {
                return this.parent && (t = this.parent._writeString(e, t)),
                    e[t++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`,
                    t
            }
            withContentNameScopesList(e) {
                return this.contentNameScopesList === e ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e)
            }
            withEndRule(t) {
                return this.endRule === t ? this : new e(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, t, this.nameScopesList, this.contentNameScopesList)
            }
            hasSameRuleAs(e) {
                let t = this;
                for (; t && t._enterPos === e._enterPos;) {
                    if (t.ruleId === e.ruleId)
                        return !0;
                    t = t.parent
                }
                return !1
            }
            toStateStackFrame() {
                return {
                    ruleId: this.ruleId,
                    beginRuleCapturedEOL: this.beginRuleCapturedEOL,
                    endRule: this.endRule,
                    nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
                    contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
                }
            }
            static pushFrame(t, n) {
                const r = tc.fromExtension(t?.nameScopesList ?? null, n.nameScopesList);
                return new e(t, n.ruleId, n.enterPos ?? -1, n.anchorPos ?? -1, n.beginRuleCapturedEOL, n.endRule, r, tc.fromExtension(r, n.contentNameScopesList))
            }
        }
        ;
    nc.NULL = new nc(null, 0, 0, 0, !1, null, null, null);
    var rc = nc
        , oc = class {
            constructor(e, t) {
                this.allowAny = !1,
                    this.balancedBracketScopes = e.flatMap((e => "*" === e ? (this.allowAny = !0,
                        []) : ul(e, Xl).map((e => e.matcher)))),
                    this.unbalancedBracketScopes = t.flatMap((e => ul(e, Xl).map((e => e.matcher))))
            }
            get matchesAlways() {
                return this.allowAny && 0 === this.unbalancedBracketScopes.length
            }
            get matchesNever() {
                return 0 === this.balancedBracketScopes.length && !this.allowAny
            }
            match(e) {
                for (const t of this.unbalancedBracketScopes)
                    if (t(e))
                        return !1;
                for (const t of this.balancedBracketScopes)
                    if (t(e))
                        return !0;
                return this.allowAny
            }
        }
        , ic = class {
            constructor(e, t, n, r) {
                this.balancedBracketSelectors = r,
                    this._emitBinaryTokens = e,
                    this._tokenTypeOverrides = n,
                    this._lineText = null,
                    this._tokens = [],
                    this._binaryTokens = [],
                    this._lastTokenEndIndex = 0
            }
            produce(e, t) {
                this.produceFromScopes(e.contentNameScopesList, t)
            }
            produceFromScopes(e, t) {
                if (this._lastTokenEndIndex >= t)
                    return;
                if (this._emitBinaryTokens) {
                    let n = e?.tokenAttributes ?? 0
                        , r = !1;
                    if (this.balancedBracketSelectors?.matchesAlways && (r = !0),
                        this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
                        const t = e?.getScopeNames() ?? [];
                        for (const e of this._tokenTypeOverrides)
                            e.matcher(t) && (n = dl.set(n, 0, e.type, null, -1, 0, 0));
                        this.balancedBracketSelectors && (r = this.balancedBracketSelectors.match(t))
                    }
                    return r && (n = dl.set(n, 0, 8, r, -1, 0, 0)),
                        this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n ? void (this._lastTokenEndIndex = t) : (this._binaryTokens.push(this._lastTokenEndIndex),
                            this._binaryTokens.push(n),
                            void (this._lastTokenEndIndex = t))
                }
                const n = e?.getScopeNames() ?? [];
                this._tokens.push({
                    startIndex: this._lastTokenEndIndex,
                    endIndex: t,
                    scopes: n
                }),
                    this._lastTokenEndIndex = t
            }
            getResult(e, t) {
                return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(),
                    0 === this._tokens.length && (this._lastTokenEndIndex = -1,
                        this.produce(e, t),
                        this._tokens[this._tokens.length - 1].startIndex = 0),
                    this._tokens
            }
            getBinaryResult(e, t) {
                this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(),
                    this._binaryTokens.pop()),
                    0 === this._binaryTokens.length && (this._lastTokenEndIndex = -1,
                        this.produce(e, t),
                        this._binaryTokens[this._binaryTokens.length - 2] = 0);
                const n = new Uint32Array(this._binaryTokens.length);
                for (let r = 0, o = this._binaryTokens.length; r < o; r++)
                    n[r] = this._binaryTokens[r];
                return n
            }
        }
        , sc = class {
            constructor(e, t) {
                this._onigLib = t,
                    this._grammars = new Map,
                    this._rawGrammars = new Map,
                    this._injectionGrammars = new Map,
                    this._theme = e
            }
            dispose() {
                for (const e of this._grammars.values())
                    e.dispose()
            }
            setTheme(e) {
                this._theme = e
            }
            getColorMap() {
                return this._theme.getColorMap()
            }
            addGrammar(e, t) {
                this._rawGrammars.set(e.scopeName, e),
                    t && this._injectionGrammars.set(e.scopeName, t)
            }
            lookup(e) {
                return this._rawGrammars.get(e)
            }
            injections(e) {
                return this._injectionGrammars.get(e)
            }
            getDefaults() {
                return this._theme.getDefaults()
            }
            themeMatch(e) {
                return this._theme.match(e)
            }
            grammarForScopeName(e, t, n, r, o) {
                if (!this._grammars.has(e)) {
                    let i = this._rawGrammars.get(e);
                    if (!i)
                        return null;
                    this._grammars.set(e, function (e, t, n, r, o, i, s, a) {
                        return new Yl(e, t, n, r, o, i, s, a)
                    }(e, i, t, n, r, o, this, this._onigLib))
                }
                return this._grammars.get(e)
            }
        }
        , ac = class {
            constructor(e) {
                this._options = e,
                    this._syncRegistry = new sc(el.createFromRawTheme(e.theme, e.colorMap), e.onigLib),
                    this._ensureGrammarCache = new Map
            }
            dispose() {
                this._syncRegistry.dispose()
            }
            setTheme(e, t) {
                this._syncRegistry.setTheme(el.createFromRawTheme(e, t))
            }
            getColorMap() {
                return this._syncRegistry.getColorMap()
            }
            loadGrammarWithEmbeddedLanguages(e, t, n) {
                return this.loadGrammarWithConfiguration(e, t, {
                    embeddedLanguages: n
                })
            }
            loadGrammarWithConfiguration(e, t, n) {
                return this._loadGrammar(e, t, n.embeddedLanguages, n.tokenTypes, new oc(n.balancedBracketSelectors || [], n.unbalancedBracketSelectors || []))
            }
            loadGrammar(e) {
                return this._loadGrammar(e, 0, null, null, null)
            }
            _loadGrammar(e, t, n, r, o) {
                const i = new bl(this._syncRegistry, e);
                for (; i.Q.length > 0;)
                    i.Q.map((e => this._loadSingleGrammar(e.scopeName))),
                        i.processQueue();
                return this._grammarForScopeName(e, t, n, r, o)
            }
            _loadSingleGrammar(e) {
                this._ensureGrammarCache.has(e) || (this._doLoadSingleGrammar(e),
                    this._ensureGrammarCache.set(e, !0))
            }
            _doLoadSingleGrammar(e) {
                const t = this._options.loadGrammar(e);
                if (t) {
                    const n = "function" === typeof this._options.getInjections ? this._options.getInjections(e) : void 0;
                    this._syncRegistry.addGrammar(t, n)
                }
            }
            addGrammar(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                    , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                    , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                return this._syncRegistry.addGrammar(e, t),
                    this._grammarForScopeName(e.scopeName, n, r)
            }
            _grammarForScopeName(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                    , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                    , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                    , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
                return this._syncRegistry.grammarForScopeName(e, t, n, r, o)
            }
        }
        , lc = rc.NULL;
    const cc = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
    var dc = n(3573)
        , uc = n(3780)
        , hc = n(9917);
    const pc = /^>|^->|<!--|-->|--!>|<!-$/g
        , fc = [">"]
        , mc = ["<", ">"];
    var gc = n(3781)
        , bc = n(2259)
        , yc = n(3944)
        , vc = n(4168)
        , wc = n(478);
    const kc = xc(1)
        , Cc = xc(-1)
        , Sc = [];
    function xc(e) {
        return function (t, n, r) {
            const o = t ? t.children : Sc;
            let i = (n || 0) + e
                , s = o[i];
            if (!r)
                for (; s && (0,
                    wc.m)(s);)
                    i += e,
                        s = o[i];
            return s
        }
    }
    const Ec = {}.hasOwnProperty;
    function Mc(e) {
        return function (t, n, r) {
            return Ec.call(e, t.tagName) && e[t.tagName](t, n, r)
        }
    }
    const Tc = Mc({
        body: function (e, t, n) {
            const r = kc(n, t);
            return !r || "comment" !== r.type
        },
        caption: Nc,
        colgroup: Nc,
        dd: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && ("dt" === r.tagName || "dd" === r.tagName)
        },
        dt: function (e, t, n) {
            const r = kc(n, t);
            return Boolean(r && "element" === r.type && ("dt" === r.tagName || "dd" === r.tagName))
        },
        head: Nc,
        html: function (e, t, n) {
            const r = kc(n, t);
            return !r || "comment" !== r.type
        },
        li: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && "li" === r.tagName
        },
        optgroup: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && "optgroup" === r.tagName
        },
        option: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && ("option" === r.tagName || "optgroup" === r.tagName)
        },
        p: function (e, t, n) {
            const r = kc(n, t);
            return r ? "element" === r.type && ("address" === r.tagName || "article" === r.tagName || "aside" === r.tagName || "blockquote" === r.tagName || "details" === r.tagName || "div" === r.tagName || "dl" === r.tagName || "fieldset" === r.tagName || "figcaption" === r.tagName || "figure" === r.tagName || "footer" === r.tagName || "form" === r.tagName || "h1" === r.tagName || "h2" === r.tagName || "h3" === r.tagName || "h4" === r.tagName || "h5" === r.tagName || "h6" === r.tagName || "header" === r.tagName || "hgroup" === r.tagName || "hr" === r.tagName || "main" === r.tagName || "menu" === r.tagName || "nav" === r.tagName || "ol" === r.tagName || "p" === r.tagName || "pre" === r.tagName || "section" === r.tagName || "table" === r.tagName || "ul" === r.tagName) : !n || !("element" === n.type && ("a" === n.tagName || "audio" === n.tagName || "del" === n.tagName || "ins" === n.tagName || "map" === n.tagName || "noscript" === n.tagName || "video" === n.tagName))
        },
        rp: _c,
        rt: _c,
        tbody: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName)
        },
        td: Oc,
        tfoot: function (e, t, n) {
            return !kc(n, t)
        },
        th: Oc,
        thead: function (e, t, n) {
            const r = kc(n, t);
            return Boolean(r && "element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName))
        },
        tr: function (e, t, n) {
            const r = kc(n, t);
            return !r || "element" === r.type && "tr" === r.tagName
        }
    });
    function Nc(e, t, n) {
        const r = kc(n, t, !0);
        return !r || "comment" !== r.type && !("text" === r.type && (0,
            wc.m)(r.value.charAt(0)))
    }
    function _c(e, t, n) {
        const r = kc(n, t);
        return !r || "element" === r.type && ("rp" === r.tagName || "rt" === r.tagName)
    }
    function Oc(e, t, n) {
        const r = kc(n, t);
        return !r || "element" === r.type && ("td" === r.tagName || "th" === r.tagName)
    }
    const Ac = Mc({
        body: function (e) {
            const t = kc(e, -1, !0);
            return !t || "comment" !== t.type && !("text" === t.type && (0,
                wc.m)(t.value.charAt(0))) && !("element" === t.type && ("meta" === t.tagName || "link" === t.tagName || "script" === t.tagName || "style" === t.tagName || "template" === t.tagName))
        },
        colgroup: function (e, t, n) {
            const r = Cc(n, t)
                , o = kc(e, -1, !0);
            if (n && r && "element" === r.type && "colgroup" === r.tagName && Tc(r, n.children.indexOf(r), n))
                return !1;
            return Boolean(o && "element" === o.type && "col" === o.tagName)
        },
        head: function (e) {
            const t = new Set;
            for (const r of e.children)
                if ("element" === r.type && ("base" === r.tagName || "title" === r.tagName)) {
                    if (t.has(r.tagName))
                        return !1;
                    t.add(r.tagName)
                }
            const n = e.children[0];
            return !n || "element" === n.type
        },
        html: function (e) {
            const t = kc(e, -1);
            return !t || "comment" !== t.type
        },
        tbody: function (e, t, n) {
            const r = Cc(n, t)
                , o = kc(e, -1);
            if (n && r && "element" === r.type && ("thead" === r.tagName || "tbody" === r.tagName) && Tc(r, n.children.indexOf(r), n))
                return !1;
            return Boolean(o && "element" === o.type && "tr" === o.tagName)
        }
    });
    const Pc = {
        name: [["\t\n\f\r &/=>".split(""), "\t\n\f\r \"&'/=>`".split("")], ["\0\t\n\f\r \"&'/<=>".split(""), "\0\t\n\f\r \"&'/<=>`".split("")]],
        unquoted: [["\t\n\f\r &>".split(""), "\0\t\n\f\r \"&'<=>`".split("")], ["\0\t\n\f\r \"&'<=>`".split(""), "\0\t\n\f\r \"&'<=>`".split("")]],
        single: [["&'".split(""), "\"&'`".split("")], ["\0&'".split(""), "\0\"&'`".split("")]],
        double: [['"&'.split(""), "\"&'`".split("")], ['\0"&'.split(""), "\0\"&'`".split("")]]
    };
    function Lc(e, t, n) {
        const r = (0,
            yc.I)(e.schema, t)
            , o = e.settings.allowParseErrors && "html" === e.schema.space ? 0 : 1
            , i = e.settings.allowDangerousCharacters ? 0 : 1;
        let s, a = e.quote;
        if (!r.overloadedBoolean || n !== r.attribute && "" !== n ? (r.boolean || r.overloadedBoolean && "string" !== typeof n) && (n = Boolean(n)) : n = !0,
            null === n || void 0 === n || !1 === n || "number" === typeof n && Number.isNaN(n))
            return "";
        const l = (0,
            hc.l)(r.attribute, Object.assign({}, e.settings.characterReferences, {
                subset: Pc.name[o][i]
            }));
        return !0 === n ? l : (n = Array.isArray(n) ? (r.commaSeparated ? bc.A : vc.A)(n, {
            padLeft: !e.settings.tightCommaSeparatedLists
        }) : String(n),
            e.settings.collapseEmptyAttributes && !n ? l : (e.settings.preferUnquoted && (s = (0,
                hc.l)(n, Object.assign({}, e.settings.characterReferences, {
                    attribute: !0,
                    subset: Pc.unquoted[o][i]
                }))),
                s !== n && (e.settings.quoteSmart && (0,
                    gc.D)(n, a) > (0,
                        gc.D)(n, e.alternative) && (a = e.alternative),
                    s = a + (0,
                        hc.l)(n, Object.assign({}, e.settings.characterReferences, {
                            subset: ("'" === a ? Pc.single : Pc.double)[o][i],
                            attribute: !0
                        })) + a),
                l + (s ? "=" + s : s)))
    }
    const Rc = ["<", "&"];
    function Dc(e, t, n, r) {
        return !n || "element" !== n.type || "script" !== n.tagName && "style" !== n.tagName ? (0,
            hc.l)(e.value, Object.assign({}, r.settings.characterReferences, {
                subset: Rc
            })) : e.value
    }
    const Ic = (0,
        uc.A)("type", {
            invalid: function (e) {
                throw new Error("Expected node, not `" + e + "`")
            },
            unknown: function (e) {
                throw new Error("Cannot compile unknown node `" + e.type + "`")
            },
            handlers: {
                comment: function (e, t, n, r) {
                    return r.settings.bogusComments ? "<?" + (0,
                        hc.l)(e.value, Object.assign({}, r.settings.characterReferences, {
                            subset: fc
                        })) + ">" : "\x3c!--" + e.value.replace(pc, (function (e) {
                            return (0,
                                hc.l)(e, Object.assign({}, r.settings.characterReferences, {
                                    subset: mc
                                }))
                        }
                        )) + "--\x3e"
                },
                doctype: function (e, t, n, r) {
                    return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>"
                },
                element: function (e, t, n, r) {
                    const o = r.schema
                        , i = "svg" !== o.space && r.settings.omitOptionalTags;
                    let s = "svg" === o.space ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
                    const a = [];
                    let l;
                    "html" === o.space && "svg" === e.tagName && (r.schema = dc.JW);
                    const c = function (e, t) {
                        const n = [];
                        let r, o = -1;
                        if (t)
                            for (r in t)
                                if (null !== t[r] && void 0 !== t[r]) {
                                    const o = Lc(e, r, t[r]);
                                    o && n.push(o)
                                }
                        for (; ++o < n.length;) {
                            const t = e.settings.tightAttributes ? n[o].charAt(n[o].length - 1) : void 0;
                            o !== n.length - 1 && '"' !== t && "'" !== t && (n[o] += " ")
                        }
                        return n.join("")
                    }(r, e.properties)
                        , d = r.all("html" === o.space && "template" === e.tagName ? e.content : e);
                    return r.schema = o,
                        d && (s = !1),
                        !c && i && Ac(e, t, n) || (a.push("<", e.tagName, c ? " " + c : ""),
                            s && ("svg" === o.space || r.settings.closeSelfClosing) && (l = c.charAt(c.length - 1),
                                (!r.settings.tightSelfClosing || "/" === l || l && '"' !== l && "'" !== l) && a.push(" "),
                                a.push("/")),
                            a.push(">")),
                        a.push(d),
                        s || i && Tc(e, t, n) || a.push("</" + e.tagName + ">"),
                        a.join("")
                },
                raw: function (e, t, n, r) {
                    return r.settings.allowDangerousHtml ? e.value : Dc(e, 0, n, r)
                },
                root: function (e, t, n, r) {
                    return r.all(e)
                },
                text: Dc
            }
        });
    const jc = {}
        , Hc = {}
        , zc = [];
    function $c(e, t, n) {
        return Ic(e, t, n, this)
    }
    function Bc(e) {
        const t = []
            , n = e && e.children || zc;
        let r = -1;
        for (; ++r < n.length;)
            t[r] = this.one(n[r], r, e);
        return t.join("")
    }
    function Vc(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const n = e.split(/(\r?\n)/g);
        let r = 0;
        const o = [];
        for (let i = 0; i < n.length; i += 2) {
            const e = t ? n[i] + (n[i + 1] || "") : n[i];
            o.push([e, r]),
                r += n[i].length,
                r += n[i + 1]?.length || 0
        }
        return o
    }
    function Fc(e) {
        return !e || ["plaintext", "txt", "text", "plain"].includes(e)
    }
    function Uc(e) {
        return "ansi" === e || Fc(e)
    }
    function Wc(e) {
        return "none" === e
    }
    function qc(e) {
        return Wc(e)
    }
    function Gc(e, t) {
        var n;
        if (!t)
            return e;
        e.properties || (e.properties = {}),
            (n = e.properties).class || (n.class = []),
            "string" === typeof e.properties.class && (e.properties.class = e.properties.class.split(/\s+/g)),
            Array.isArray(e.properties.class) || (e.properties.class = []);
        const r = Array.isArray(t) ? t : t.split(/\s+/g);
        for (const o of r)
            o && !e.properties.class.includes(o) && e.properties.class.push(o);
        return e
    }
    async function Kc(e) {
        return Promise.resolve("function" === typeof e ? e() : e).then((e => e.default || e))
    }
    function Jc(e, t) {
        const n = "string" === typeof e ? {} : {
            ...e.colorReplacements
        }
            , r = "string" === typeof e ? e : e.name;
        for (const [o, i] of Object.entries(t?.colorReplacements || {}))
            "string" === typeof i ? n[o] = i : o === r && Object.assign(n, i);
        return n
    }
    function Zc(e, t) {
        return e && t?.[e?.toLowerCase()] || e
    }
    function Xc(e) {
        const t = {};
        return e.color && (t.color = e.color),
            e.bgColor && (t["background-color"] = e.bgColor),
            e.fontStyle && (e.fontStyle & il.Italic && (t["font-style"] = "italic"),
                e.fontStyle & il.Bold && (t["font-weight"] = "bold"),
                e.fontStyle & il.Underline && (t["text-decoration"] = "underline")),
            t
    }
    function Qc(e) {
        return "string" === typeof e ? e : Object.entries(e).map((e => {
            let [t, n] = e;
            return `${t}:${n}`
        }
        )).join(";")
    }
    class Yc extends Error {
        constructor(e) {
            super(e),
                this.name = "ShikiError"
        }
    }
    var ed = Object.defineProperty
        , td = (e, t, n) => (((e, t, n) => {
            t in e ? ed(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : e[t] = n
        }
        )(e, "symbol" !== typeof t ? t + "" : t, n),
            n);
    const nd = new WeakMap;
    function rd(e, t) {
        nd.set(e, t)
    }
    function od(e) {
        return nd.get(e)
    }
    class id {
        constructor() {
            td(this, "_stacks", {}),
                td(this, "lang");
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            if (2 === t.length) {
                const [e, n] = t;
                this.lang = n,
                    this._stacks = e
            } else {
                const [e, n, r] = t;
                this.lang = n,
                    this._stacks = {
                        [r]: e
                    }
            }
        }
        get themes() {
            return Object.keys(this._stacks)
        }
        get theme() {
            return this.themes[0]
        }
        get _stack() {
            return this._stacks[this.theme]
        }
        static initial(e, t) {
            return new id(Object.fromEntries((n = t,
                Array.isArray(n) ? n : [n]).map((e => [e, lc]))), e);
            var n
        }
        getInternalStack() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.theme;
            return this._stacks[e]
        }
        get scopes() {
            return sd(this._stacks[this.theme])
        }
        getScopes() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.theme;
            return sd(this._stacks[e])
        }
        toJSON() {
            return {
                lang: this.lang,
                theme: this.theme,
                themes: this.themes,
                scopes: this.scopes
            }
        }
    }
    function sd(e) {
        const t = []
            , n = new Set;
        return function e(r) {
            if (n.has(r))
                return;
            n.add(r);
            const o = r?.nameScopesList?.scopeName;
            o && t.push(o),
                r.parent && e(r.parent)
        }(e),
            t
    }
    function ad() {
        const e = new WeakMap;
        function t(t) {
            if (!e.has(t.meta)) {
                let n = function (e) {
                    if ("number" === typeof e) {
                        if (e < 0 || e > t.source.length)
                            throw new Yc(`Invalid decoration offset: ${e}. Code length: ${t.source.length}`);
                        return {
                            ...r.indexToPos(e),
                            offset: e
                        }
                    }
                    {
                        const t = r.lines[e.line];
                        if (void 0 === t)
                            throw new Yc(`Invalid decoration position ${JSON.stringify(e)}. Lines length: ${r.lines.length}`);
                        if (e.character < 0 || e.character > t.length)
                            throw new Yc(`Invalid decoration position ${JSON.stringify(e)}. Line ${e.line} length: ${t.length}`);
                        return {
                            ...e,
                            offset: r.posToIndex(e.line, e.character)
                        }
                    }
                };
                const r = function (e) {
                    const t = Vc(e, !0).map((e => {
                        let [t] = e;
                        return t
                    }
                    ));
                    return {
                        lines: t,
                        indexToPos: function (n) {
                            if (n === e.length)
                                return {
                                    line: t.length - 1,
                                    character: t[t.length - 1].length
                                };
                            let r = n
                                , o = 0;
                            for (const e of t) {
                                if (r < e.length)
                                    break;
                                r -= e.length,
                                    o++
                            }
                            return {
                                line: o,
                                character: r
                            }
                        },
                        posToIndex: function (e, n) {
                            let r = 0;
                            for (let o = 0; o < e; o++)
                                r += t[o].length;
                            return r += n,
                                r
                        }
                    }
                }(t.source)
                    , o = (t.options.decorations || []).map((e => ({
                        ...e,
                        start: n(e.start),
                        end: n(e.end)
                    })));
                !function (e) {
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        if (n.start.offset > n.end.offset)
                            throw new Yc(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
                        for (let r = t + 1; r < e.length; r++) {
                            const t = e[r]
                                , o = n.start.offset < t.start.offset && t.start.offset < n.end.offset
                                , i = n.start.offset < t.end.offset && t.end.offset < n.end.offset
                                , s = t.start.offset < n.start.offset && n.start.offset < t.end.offset
                                , a = t.start.offset < n.end.offset && n.end.offset < t.end.offset;
                            if (o || i || s || a) {
                                if (i && i)
                                    continue;
                                if (s && a)
                                    continue;
                                throw new Yc(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(t.start)} intersect.`)
                            }
                        }
                    }
                }(o),
                    e.set(t.meta, {
                        decorations: o,
                        converter: r,
                        source: t.source
                    })
            }
            return e.get(t.meta)
        }
        return {
            name: "shiki:decorations",
            tokens(e) {
                if (!this.options.decorations?.length)
                    return;
                const n = function (e, t) {
                    const n = Array.from(t instanceof Set ? t : new Set(t)).sort(((e, t) => e - t));
                    return n.length ? e.map((e => e.flatMap((e => {
                        const t = n.filter((t => e.offset < t && t < e.offset + e.content.length)).map((t => t - e.offset)).sort(((e, t) => e - t));
                        return t.length ? function (e, t) {
                            let n = 0;
                            const r = [];
                            for (const o of t)
                                o > n && r.push({
                                    ...e,
                                    content: e.content.slice(n, o),
                                    offset: e.offset + n
                                }),
                                    n = o;
                            return n < e.content.length && r.push({
                                ...e,
                                content: e.content.slice(n),
                                offset: e.offset + n
                            }),
                                r
                        }(e, t) : e
                    }
                    )))) : e
                }(e, t(this).decorations.flatMap((e => [e.start.offset, e.end.offset])));
                return n
            },
            code(e) {
                if (!this.options.decorations?.length)
                    return;
                const n = t(this)
                    , r = Array.from(e.children).filter((e => "element" === e.type && "span" === e.tagName));
                if (r.length !== n.converter.lines.length)
                    throw new Yc(`Number of lines in code element (${r.length}) does not match the number of lines in the source (${n.converter.lines.length}). Failed to apply decorations.`);
                function o(e, t, n, o) {
                    const i = r[e];
                    let a = ""
                        , l = -1
                        , c = -1;
                    if (0 === t && (l = 0),
                        0 === n && (c = 0),
                        n === Number.POSITIVE_INFINITY && (c = i.children.length),
                        -1 === l || -1 === c)
                        for (let r = 0; r < i.children.length; r++)
                            a += ld(i.children[r]),
                                -1 === l && a.length === t && (l = r + 1),
                                -1 === c && a.length === n && (c = r + 1);
                    if (-1 === l)
                        throw new Yc(`Failed to find start index for decoration ${JSON.stringify(o.start)}`);
                    if (-1 === c)
                        throw new Yc(`Failed to find end index for decoration ${JSON.stringify(o.end)}`);
                    const d = i.children.slice(l, c);
                    if (o.alwaysWrap || d.length !== i.children.length)
                        if (o.alwaysWrap || 1 !== d.length || "element" !== d[0].type) {
                            const e = {
                                type: "element",
                                tagName: "span",
                                properties: {},
                                children: d
                            };
                            s(e, o, "wrapper"),
                                i.children.splice(l, d.length, e)
                        } else
                            s(d[0], o, "token");
                    else
                        s(i, o, "line")
                }
                function i(e, t) {
                    r[e] = s(r[e], t, "line")
                }
                function s(e, t, n) {
                    const r = t.properties || {}
                        , o = t.transform || (e => e);
                    return e.tagName = t.tagName || "span",
                        e.properties = {
                            ...e.properties,
                            ...r,
                            class: e.properties.class
                        },
                        t.properties?.class && Gc(e, t.properties.class),
                        e = o(e, n) || e
                }
                const a = []
                    , l = n.decorations.sort(((e, t) => t.start.offset - e.start.offset));
                for (const t of l) {
                    const { start: e, end: n } = t;
                    if (e.line === n.line)
                        o(e.line, e.character, n.character, t);
                    else if (e.line < n.line) {
                        o(e.line, e.character, Number.POSITIVE_INFINITY, t);
                        for (let r = e.line + 1; r < n.line; r++)
                            a.unshift((() => i(r, t)));
                        o(n.line, 0, n.character, t)
                    }
                }
                a.forEach((e => e()))
            }
        }
    }
    function ld(e) {
        return "text" === e.type ? e.value : "element" === e.type ? e.children.map(ld).join("") : ""
    }
    const cd = [ad()];
    function dd(e) {
        return [...e.transformers || [], ...cd]
    }
    var ud = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "brightBlack", "brightRed", "brightGreen", "brightYellow", "brightBlue", "brightMagenta", "brightCyan", "brightWhite"]
        , hd = {
            1: "bold",
            2: "dim",
            3: "italic",
            4: "underline",
            7: "reverse",
            9: "strikethrough"
        };
    function pd(e, t) {
        const n = e.indexOf("\x1b[", t);
        if (-1 !== n) {
            const t = e.indexOf("m", n);
            return {
                sequence: e.substring(n + 2, t).split(";"),
                startPosition: n,
                position: t + 1
            }
        }
        return {
            position: e.length
        }
    }
    function fd(e, t) {
        let n = 1;
        const r = e[t + n++];
        let o;
        if ("2" === r) {
            const r = [e[t + n++], e[t + n++], e[t + n]].map((e => Number.parseInt(e)));
            3 !== r.length || r.some((e => Number.isNaN(e))) || (o = {
                type: "rgb",
                rgb: r
            })
        } else if ("5" === r) {
            const r = Number.parseInt(e[t + n]);
            Number.isNaN(r) || (o = {
                type: "table",
                index: Number(r)
            })
        }
        return [n, o]
    }
    function md(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
                , o = Number.parseInt(r);
            if (!Number.isNaN(o))
                if (0 === o)
                    t.push({
                        type: "resetAll"
                    });
                else if (o <= 9) {
                    hd[o] && t.push({
                        type: "setDecoration",
                        value: hd[o]
                    })
                } else if (o <= 29) {
                    const e = hd[o - 20];
                    e && t.push({
                        type: "resetDecoration",
                        value: e
                    })
                } else if (o <= 37)
                    t.push({
                        type: "setForegroundColor",
                        value: {
                            type: "named",
                            name: ud[o - 30]
                        }
                    });
                else if (38 === o) {
                    const [r, o] = fd(e, n);
                    o && t.push({
                        type: "setForegroundColor",
                        value: o
                    }),
                        n += r
                } else if (39 === o)
                    t.push({
                        type: "resetForegroundColor"
                    });
                else if (o <= 47)
                    t.push({
                        type: "setBackgroundColor",
                        value: {
                            type: "named",
                            name: ud[o - 40]
                        }
                    });
                else if (48 === o) {
                    const [r, o] = fd(e, n);
                    o && t.push({
                        type: "setBackgroundColor",
                        value: o
                    }),
                        n += r
                } else
                    49 === o ? t.push({
                        type: "resetBackgroundColor"
                    }) : o >= 90 && o <= 97 ? t.push({
                        type: "setForegroundColor",
                        value: {
                            type: "named",
                            name: ud[o - 90 + 8]
                        }
                    }) : o >= 100 && o <= 107 && t.push({
                        type: "setBackgroundColor",
                        value: {
                            type: "named",
                            name: ud[o - 100 + 8]
                        }
                    })
        }
        return t
    }
    var gd = {
        black: "#000000",
        red: "#bb0000",
        green: "#00bb00",
        yellow: "#bbbb00",
        blue: "#0000bb",
        magenta: "#ff00ff",
        cyan: "#00bbbb",
        white: "#eeeeee",
        brightBlack: "#555555",
        brightRed: "#ff5555",
        brightGreen: "#00ff00",
        brightYellow: "#ffff55",
        brightBlue: "#5555ff",
        brightMagenta: "#ff55ff",
        brightCyan: "#55ffff",
        brightWhite: "#ffffff"
    };
    function bd() {
        let e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gd;
        function n(e) {
            return t[e]
        }
        function r(e) {
            return `#${e.map((e => Math.max(0, Math.min(e, 255)).toString(16).padStart(2, "0"))).join("")}`
        }
        function o(t) {
            return function () {
                if (e)
                    return e;
                e = [];
                for (let r = 0; r < ud.length; r++)
                    e.push(n(ud[r]));
                let t = [0, 95, 135, 175, 215, 255];
                for (let n = 0; n < 6; n++)
                    for (let o = 0; o < 6; o++)
                        for (let i = 0; i < 6; i++)
                            e.push(r([t[n], t[o], t[i]]));
                let o = 8;
                for (let n = 0; n < 24; n++,
                    o += 10)
                    e.push(r([o, o, o]));
                return e
            }()[t]
        }
        return {
            value: function (e) {
                switch (e.type) {
                    case "named":
                        return n(e.name);
                    case "rgb":
                        return r(e.rgb);
                    case "table":
                        return o(e.index)
                }
            }
        }
    }
    function yd(e, t, n) {
        const r = Jc(e, n)
            , o = Vc(t)
            , i = bd(Object.fromEntries(ud.map((t => [t, e.colors?.[`terminal.ansi${t[0].toUpperCase()}${t.substring(1)}`]]))))
            , s = function () {
                let e = null
                    , t = null
                    , n = new Set;
                return {
                    parse(r) {
                        const o = [];
                        let i = 0;
                        do {
                            const s = pd(r, i)
                                , a = s.sequence ? r.substring(i, s.startPosition) : r.substring(i);
                            if (a.length > 0 && o.push({
                                value: a,
                                foreground: e,
                                background: t,
                                decorations: new Set(n)
                            }),
                                s.sequence) {
                                const r = md(s.sequence);
                                for (const o of r)
                                    "resetAll" === o.type ? (e = null,
                                        t = null,
                                        n.clear()) : "resetForegroundColor" === o.type ? e = null : "resetBackgroundColor" === o.type ? t = null : "resetDecoration" === o.type && n.delete(o.value);
                                for (const o of r)
                                    "setForegroundColor" === o.type ? e = o.value : "setBackgroundColor" === o.type ? t = o.value : "setDecoration" === o.type && n.add(o.value)
                            }
                            i = s.position
                        } while (i < r.length);
                        return o
                    }
                }
            }();
        return o.map((t => s.parse(t[0]).map((n => {
            let o, s;
            n.decorations.has("reverse") ? (o = n.background ? i.value(n.background) : e.bg,
                s = n.foreground ? i.value(n.foreground) : e.fg) : (o = n.foreground ? i.value(n.foreground) : e.fg,
                    s = n.background ? i.value(n.background) : void 0),
                o = Zc(o, r),
                s = Zc(s, r),
                n.decorations.has("dim") && (o = function (e) {
                    const t = e.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
                    if (t) {
                        if (t[3]) {
                            const e = Math.round(Number.parseInt(t[3], 16) / 2).toString(16).padStart(2, "0");
                            return `#${t[1]}${t[2]}${e}`
                        }
                        return t[2] ? `#${t[1]}${t[2]}80` : `#${Array.from(t[1]).map((e => `${e}${e}`)).join("")}80`
                    }
                    const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
                    return n ? `var(${n[1]}-dim)` : e
                }(o));
            let a = il.None;
            return n.decorations.has("bold") && (a |= il.Bold),
                n.decorations.has("italic") && (a |= il.Italic),
                n.decorations.has("underline") && (a |= il.Underline),
            {
                content: n.value,
                offset: t[1],
                color: o,
                bgColor: s,
                fontStyle: a
            }
        }
        ))))
    }
    function vd(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        const { lang: r = "text", theme: o = e.getLoadedThemes()[0] } = n;
        if (Fc(r) || Wc(o))
            return Vc(t).map((e => [{
                content: e[0],
                offset: e[1]
            }]));
        const { theme: i, colorMap: s } = e.setTheme(o);
        if ("ansi" === r)
            return yd(i, t, n);
        const a = e.getLanguage(r);
        if (n.grammarState) {
            if (n.grammarState.lang !== a.name)
                throw new _a(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`);
            if (!n.grammarState.themes.includes(i.name))
                throw new _a(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${i.name}"`)
        }
        return function (e, t, n, r, o) {
            const i = kd(e, t, n, r, o)
                , s = new id(kd(e, t, n, r, o).stateStack, t.name, n.name);
            return rd(i.tokens, s),
                i.tokens
        }(t, a, i, s, n)
    }
    function wd() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        if (2 === t.length)
            return od(t[1]);
        const [r, o, i = {}] = t
            , { lang: s = "text", theme: a = r.getLoadedThemes()[0] } = i;
        if (Fc(s) || Wc(a))
            throw new _a("Plain language does not have grammar state");
        if ("ansi" === s)
            throw new _a("ANSI language does not have grammar state");
        const { theme: l, colorMap: c } = r.setTheme(a)
            , d = r.getLanguage(s);
        return new id(kd(o, d, l, c, i).stateStack, d.name, l.name)
    }
    function kd(e, t, n, r, o) {
        const i = Jc(n, o)
            , { tokenizeMaxLineLength: s = 0, tokenizeTimeLimit: a = 500 } = o
            , l = Vc(e);
        let c = o.grammarState ? function (e, t) {
            if (!(e instanceof id))
                throw new Yc("Invalid grammar state");
            return e.getInternalStack(t)
        }(o.grammarState, n.name) ?? lc : null != o.grammarContextCode ? kd(o.grammarContextCode, t, n, r, {
            ...o,
            grammarState: void 0,
            grammarContextCode: void 0
        }).stateStack : lc
            , d = [];
        const u = [];
        for (let p = 0, f = l.length; p < f; p++) {
            const [e, f] = l[p];
            if ("" === e) {
                d = [],
                    u.push([]);
                continue
            }
            if (s > 0 && e.length >= s) {
                d = [],
                    u.push([{
                        content: e,
                        offset: f,
                        color: "",
                        fontStyle: 0
                    }]);
                continue
            }
            let m, g, b;
            o.includeExplanation && (m = t.tokenizeLine(e, c),
                g = m.tokens,
                b = 0);
            const y = t.tokenizeLine2(e, c, a)
                , v = y.tokens.length / 2;
            for (let t = 0; t < v; t++) {
                const s = y.tokens[2 * t]
                    , a = t + 1 < v ? y.tokens[2 * t + 2] : e.length;
                if (s === a)
                    continue;
                const l = y.tokens[2 * t + 1]
                    , c = Zc(r[dl.getForeground(l)], i)
                    , u = dl.getFontStyle(l)
                    , p = {
                        content: e.substring(s, a),
                        offset: f + s,
                        color: c,
                        fontStyle: u
                    };
                if (o.includeExplanation) {
                    const t = [];
                    if ("scopeName" !== o.includeExplanation)
                        for (const e of n.settings) {
                            let n;
                            switch (typeof e.scope) {
                                case "string":
                                    n = e.scope.split(/,/).map((e => e.trim()));
                                    break;
                                case "object":
                                    n = e.scope;
                                    break;
                                default:
                                    continue
                            }
                            t.push({
                                settings: e,
                                selectors: n.map((e => e.split(/ /)))
                            })
                        }
                    p.explanation = [];
                    let r = 0;
                    for (; s + r < a;) {
                        const n = g[b]
                            , i = e.substring(n.startIndex, n.endIndex);
                        r += i.length,
                            p.explanation.push({
                                content: i,
                                scopes: "scopeName" === o.includeExplanation ? (h = n.scopes,
                                    h.map((e => ({
                                        scopeName: e
                                    })))) : Cd(t, n.scopes)
                            }),
                            b += 1
                    }
                }
                d.push(p)
            }
            u.push(d),
                d = [],
                c = y.ruleStack
        }
        var h;
        return {
            tokens: u,
            stateStack: c
        }
    }
    function Cd(e, t) {
        const n = [];
        for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r];
            n[r] = {
                scopeName: o,
                themeMatches: Ed(e, o, t.slice(0, r))
            }
        }
        return n
    }
    function Sd(e, t) {
        return e === t || t.substring(0, e.length) === e && "." === t[e.length]
    }
    function xd(e, t, n) {
        if (!Sd(e[e.length - 1], t))
            return !1;
        let r = e.length - 2
            , o = n.length - 1;
        for (; r >= 0 && o >= 0;)
            Sd(e[r], n[o]) && (r -= 1),
                o -= 1;
        return -1 === r
    }
    function Ed(e, t, n) {
        const r = [];
        for (const { selectors: o, settings: i } of e)
            for (const e of o)
                if (xd(e, t, n)) {
                    r.push(i);
                    break
                }
        return r
    }
    function Md(e, t, n) {
        const r = Object.entries(n.themes).filter((e => e[1])).map((e => ({
            color: e[0],
            theme: e[1]
        })))
            , o = r.map((r => {
                const o = vd(e, t, {
                    ...n,
                    theme: r.theme
                });
                return {
                    tokens: o,
                    state: od(o),
                    theme: "string" === typeof r.theme ? r.theme : r.theme.name
                }
            }
            ))
            , i = function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                const r = t.map((() => []))
                    , o = t.length;
                for (let i = 0; i < t[0].length; i++) {
                    const e = t.map((e => e[i]))
                        , n = r.map((() => []));
                    r.forEach(((e, t) => e.push(n[t])));
                    const s = e.map((() => 0))
                        , a = e.map((e => e[0]));
                    for (; a.every((e => e));) {
                        const t = Math.min(...a.map((e => e.content.length)));
                        for (let r = 0; r < o; r++) {
                            const o = a[r];
                            o.content.length === t ? (n[r].push(o),
                                s[r] += 1,
                                a[r] = e[r][s[r]]) : (n[r].push({
                                    ...o,
                                    content: o.content.slice(0, t)
                                }),
                                    a[r] = {
                                        ...o,
                                        content: o.content.slice(t),
                                        offset: o.offset + t
                                    })
                        }
                    }
                }
                return r
            }(...o.map((e => e.tokens)))
            , s = i[0].map(((e, t) => e.map(((e, o) => {
                const s = {
                    content: e.content,
                    variants: {},
                    offset: e.offset
                };
                return "includeExplanation" in n && n.includeExplanation && (s.explanation = e.explanation),
                    i.forEach(((e, n) => {
                        const { content: i, explanation: a, offset: l, ...c } = e[t][o];
                        s.variants[r[n].color] = c
                    }
                    )),
                    s
            }
            ))))
            , a = o[0].state ? new id(Object.fromEntries(o.map((e => [e.theme, e.state?.getInternalStack(e.theme)]))), o[0].state.lang) : void 0;
        return a && rd(s, a),
            s
    }
    function Td(e, t, n) {
        let r, o, i, s, a, l;
        if ("themes" in n) {
            const { defaultColor: c = "light", cssVariablePrefix: d = "--shiki-" } = n
                , u = Object.entries(n.themes).filter((e => e[1])).map((e => ({
                    color: e[0],
                    theme: e[1]
                }))).sort(((e, t) => e.color === c ? -1 : t.color === c ? 1 : 0));
            if (0 === u.length)
                throw new _a("`themes` option must not be empty");
            const h = Md(e, t, n);
            if (l = od(h),
                c && !u.find((e => e.color === c)))
                throw new _a(`\`themes\` option must contain the defaultColor key \`${c}\``);
            const p = u.map((t => e.getTheme(t.theme)))
                , f = u.map((e => e.color));
            i = h.map((e => e.map((e => function (e, t, n, r) {
                const o = {
                    content: e.content,
                    explanation: e.explanation,
                    offset: e.offset
                }
                    , i = t.map((t => Xc(e.variants[t])))
                    , s = new Set(i.flatMap((e => Object.keys(e))))
                    , a = {};
                return i.forEach(((e, o) => {
                    for (const i of s) {
                        const s = e[i] || "inherit";
                        if (0 === o && r)
                            a[i] = s;
                        else {
                            const e = "color" === i ? "" : "background-color" === i ? "-bg" : `-${i}`
                                , r = n + t[o] + ("color" === i ? "" : e);
                            a[r] = s
                        }
                    }
                }
                )),
                    o.htmlStyle = a,
                    o
            }(e, f, d, c))))),
                l && rd(i, l);
            const m = u.map((e => Jc(e.theme, n)));
            o = u.map(((e, t) => (0 === t && c ? "" : `${d + e.color}:`) + (Zc(p[t].fg, m[t]) || "inherit"))).join(";"),
                r = u.map(((e, t) => (0 === t && c ? "" : `${d + e.color}-bg:`) + (Zc(p[t].bg, m[t]) || "inherit"))).join(";"),
                s = `shiki-themes ${p.map((e => e.name)).join(" ")}`,
                a = c ? void 0 : [o, r].join(";")
        } else {
            if (!("theme" in n))
                throw new _a("Invalid options, either `theme` or `themes` must be provided");
            {
                const a = Jc(n.theme, n);
                i = vd(e, t, n);
                const c = e.getTheme(n.theme);
                r = Zc(c.bg, a),
                    o = Zc(c.fg, a),
                    s = c.name,
                    l = od(i)
            }
        }
        return {
            tokens: i,
            fg: o,
            bg: r,
            themeName: s,
            rootStyle: a,
            grammarState: l
        }
    }
    function Nd(e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
            meta: {},
            options: n,
            codeToHast: (t, n) => Nd(e, t, n),
            codeToTokens: (t, n) => Td(e, t, n)
        }
            , o = t;
        for (const p of dd(n))
            o = p.preprocess?.call(r, o, n) || o;
        let { tokens: i, fg: s, bg: a, themeName: l, rootStyle: c, grammarState: d } = Td(e, o, n);
        const { mergeWhitespaces: u = !0 } = n;
        !0 === u ? i = function (e) {
            return e.map((e => {
                const t = [];
                let n = ""
                    , r = 0;
                return e.forEach(((o, i) => {
                    const s = !(o.fontStyle && o.fontStyle & il.Underline);
                    s && o.content.match(/^\s+$/) && e[i + 1] ? (r || (r = o.offset),
                        n += o.content) : n ? (s ? t.push({
                            ...o,
                            offset: r,
                            content: n + o.content
                        }) : t.push({
                            content: n,
                            offset: r
                        }, o),
                            r = 0,
                            n = "") : t.push(o)
                }
                )),
                    t
            }
            ))
        }(i) : "never" === u && (i = function (e) {
            return e.map((e => e.flatMap((e => {
                if (e.content.match(/^\s+$/))
                    return e;
                const t = e.content.match(/^(\s*)(.*?)(\s*)$/);
                if (!t)
                    return e;
                const [, n, r, o] = t;
                if (!n && !o)
                    return e;
                const i = [{
                    ...e,
                    offset: e.offset + n.length,
                    content: r
                }];
                return n && i.unshift({
                    content: n,
                    offset: e.offset
                }),
                    o && i.push({
                        content: o,
                        offset: e.offset + n.length + r.length
                    }),
                    i
            }
            ))))
        }(i));
        const h = {
            ...r,
            get source() {
                return o
            }
        };
        for (const p of dd(n))
            i = p.tokens?.call(h, i) || i;
        return function (e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : od(e);
            const o = dd(t)
                , i = []
                , s = {
                    type: "root",
                    children: []
                }
                , { structure: a = "classic", tabindex: l = "0" } = t;
            let c = {
                type: "element",
                tagName: "pre",
                properties: {
                    class: `shiki ${t.themeName || ""}`,
                    style: t.rootStyle || `background-color:${t.bg};color:${t.fg}`,
                    ...!1 !== l && null != l ? {
                        tabindex: l.toString()
                    } : {},
                    ...Object.fromEntries(Array.from(Object.entries(t.meta || {})).filter((e => {
                        let [t] = e;
                        return !t.startsWith("_")
                    }
                    )))
                },
                children: []
            }
                , d = {
                    type: "element",
                    tagName: "code",
                    properties: {},
                    children: i
                };
            const u = []
                , h = {
                    ...n,
                    structure: a,
                    addClassToHast: Gc,
                    get source() {
                        return n.source
                    },
                    get tokens() {
                        return e
                    },
                    get options() {
                        return t
                    },
                    get root() {
                        return s
                    },
                    get pre() {
                        return c
                    },
                    get code() {
                        return d
                    },
                    get lines() {
                        return u
                    }
                };
            if (e.forEach(((e, t) => {
                t && ("inline" === a ? s.children.push({
                    type: "element",
                    tagName: "br",
                    properties: {},
                    children: []
                }) : "classic" === a && i.push({
                    type: "text",
                    value: "\n"
                }));
                let n = {
                    type: "element",
                    tagName: "span",
                    properties: {
                        class: "line"
                    },
                    children: []
                }
                    , r = 0;
                for (const i of e) {
                    let e = {
                        type: "element",
                        tagName: "span",
                        properties: {
                            ...i.htmlAttrs
                        },
                        children: [{
                            type: "text",
                            value: i.content
                        }]
                    };
                    "string" === typeof i.htmlStyle && Fa("`htmlStyle` as a string is deprecated. Use an object instead.");
                    const l = Qc(i.htmlStyle || Xc(i));
                    l && (e.properties.style = l);
                    for (const s of o)
                        e = s?.span?.call(h, e, t + 1, r, n, i) || e;
                    "inline" === a ? s.children.push(e) : "classic" === a && n.children.push(e),
                        r += i.content.length
                }
                if ("classic" === a) {
                    for (const e of o)
                        n = e?.line?.call(h, n, t + 1) || n;
                    u.push(n),
                        i.push(n)
                }
            }
            )),
                "classic" === a) {
                for (const e of o)
                    d = e?.code?.call(h, d) || d;
                c.children.push(d);
                for (const e of o)
                    c = e?.pre?.call(h, c) || c;
                s.children.push(c)
            }
            let p = s;
            for (const f of o)
                p = f?.root?.call(h, p) || p;
            r && rd(p, r);
            return p
        }(i, {
            ...n,
            fg: s,
            bg: a,
            themeName: l,
            rootStyle: c
        }, h, d)
    }
    function _d(e, t, n) {
        const r = {
            meta: {},
            options: n,
            codeToHast: (t, n) => Nd(e, t, n),
            codeToTokens: (t, n) => Td(e, t, n)
        };
        let o = function (e, t) {
            const n = t || jc
                , r = n.quote || '"'
                , o = '"' === r ? "'" : '"';
            if ('"' !== r && "'" !== r)
                throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
            return {
                one: $c,
                all: Bc,
                settings: {
                    omitOptionalTags: n.omitOptionalTags || !1,
                    allowParseErrors: n.allowParseErrors || !1,
                    allowDangerousCharacters: n.allowDangerousCharacters || !1,
                    quoteSmart: n.quoteSmart || !1,
                    preferUnquoted: n.preferUnquoted || !1,
                    tightAttributes: n.tightAttributes || !1,
                    upperDoctype: n.upperDoctype || !1,
                    tightDoctype: n.tightDoctype || !1,
                    bogusComments: n.bogusComments || !1,
                    tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
                    tightSelfClosing: n.tightSelfClosing || !1,
                    collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
                    allowDangerousHtml: n.allowDangerousHtml || !1,
                    voids: n.voids || cc,
                    characterReferences: n.characterReferences || Hc,
                    closeSelfClosing: n.closeSelfClosing || !1,
                    closeEmptyElements: n.closeEmptyElements || !1
                },
                schema: "svg" === n.space ? dc.JW : dc.qy,
                quote: r,
                alternative: o
            }.one(Array.isArray(e) ? {
                type: "root",
                children: e
            } : e, void 0, void 0)
        }(Nd(e, t, n, r));
        for (const i of dd(n))
            o = i.postprocess?.call(r, o, n) || o;
        return o
    }
    const Od = "#333333"
        , Ad = "#bbbbbb"
        , Pd = "#fffffe"
        , Ld = "#1e1e1e"
        , Rd = "__shiki_resolved";
    function Dd(e) {
        if (e?.[Rd])
            return e;
        const t = {
            ...e
        };
        t.tokenColors && !t.settings && (t.settings = t.tokenColors,
            delete t.tokenColors),
            t.type || (t.type = "dark"),
            t.colorReplacements = {
                ...t.colorReplacements
            },
            t.settings || (t.settings = []);
        let { bg: n, fg: r } = t;
        if (!n || !r) {
            const e = t.settings ? t.settings.find((e => !e.name && !e.scope)) : void 0;
            e?.settings?.foreground && (r = e.settings.foreground),
                e?.settings?.background && (n = e.settings.background),
                !r && t?.colors?.["editor.foreground"] && (r = t.colors["editor.foreground"]),
                !n && t?.colors?.["editor.background"] && (n = t.colors["editor.background"]),
                r || (r = "light" === t.type ? Od : Ad),
                n || (n = "light" === t.type ? Pd : Ld),
                t.fg = r,
                t.bg = n
        }
        t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
            settings: {
                foreground: t.fg,
                background: t.bg
            }
        });
        let o = 0;
        const i = new Map;
        function s(e) {
            if (i.has(e))
                return i.get(e);
            o += 1;
            const n = `#${o.toString(16).padStart(8, "0").toLowerCase()}`;
            return t.colorReplacements?.[`#${n}`] ? s(e) : (i.set(e, n),
                n)
        }
        t.settings = t.settings.map((e => {
            const n = e.settings?.foreground && !e.settings.foreground.startsWith("#")
                , r = e.settings?.background && !e.settings.background.startsWith("#");
            if (!n && !r)
                return e;
            const o = {
                ...e,
                settings: {
                    ...e.settings
                }
            };
            if (n) {
                const n = s(e.settings.foreground);
                t.colorReplacements[n] = e.settings.foreground,
                    o.settings.foreground = n
            }
            if (r) {
                const n = s(e.settings.background);
                t.colorReplacements[n] = e.settings.background,
                    o.settings.background = n
            }
            return o
        }
        ));
        for (const a of Object.keys(t.colors || {}))
            if (("editor.foreground" === a || "editor.background" === a || a.startsWith("terminal.ansi")) && !t.colors[a]?.startsWith("#")) {
                const e = s(t.colors[a]);
                t.colorReplacements[e] = t.colors[a],
                    t.colors[a] = e
            }
        return Object.defineProperty(t, Rd, {
            enumerable: !1,
            writable: !1,
            value: !0
        }),
            t
    }
    async function Id(e) {
        return Array.from(new Set((await Promise.all(e.filter((e => !Uc(e))).map((async e => await Kc(e).then((e => Array.isArray(e) ? e : [e])))))).flat()))
    }
    async function jd(e) {
        return (await Promise.all(e.map((async e => qc(e) ? null : Dd(await Kc(e)))))).filter((e => !!e))
    }
    var Hd = Object.defineProperty
        , zd = (e, t, n) => (((e, t, n) => {
            t in e ? Hd(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : e[t] = n
        }
        )(e, "symbol" !== typeof t ? t + "" : t, n),
            n);
    class $d extends ac {
        constructor(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            super(e),
                this._resolver = e,
                this._themes = t,
                this._langs = n,
                this._alias = r,
                zd(this, "_resolvedThemes", new Map),
                zd(this, "_resolvedGrammars", new Map),
                zd(this, "_langMap", new Map),
                zd(this, "_langGraph", new Map),
                zd(this, "_textmateThemeCache", new WeakMap),
                zd(this, "_loadedThemesCache", null),
                zd(this, "_loadedLanguagesCache", null),
                this._themes.map((e => this.loadTheme(e))),
                this.loadLanguages(this._langs)
        }
        getTheme(e) {
            return "string" === typeof e ? this._resolvedThemes.get(e) : this.loadTheme(e)
        }
        loadTheme(e) {
            const t = Dd(e);
            return t.name && (this._resolvedThemes.set(t.name, t),
                this._loadedThemesCache = null),
                t
        }
        getLoadedThemes() {
            return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]),
                this._loadedThemesCache
        }
        setTheme(e) {
            let t = this._textmateThemeCache.get(e);
            t || (t = el.createFromRawTheme(e),
                this._textmateThemeCache.set(e, t)),
                this._syncRegistry.setTheme(t)
        }
        getGrammar(e) {
            if (this._alias[e]) {
                const t = new Set([e]);
                for (; this._alias[e];) {
                    if (e = this._alias[e],
                        t.has(e))
                        throw new Yc(`Circular alias \`${Array.from(t).join(" -> ")} -> ${e}\``);
                    t.add(e)
                }
            }
            return this._resolvedGrammars.get(e)
        }
        loadLanguage(e) {
            if (this.getGrammar(e.name))
                return;
            const t = new Set([...this._langMap.values()].filter((t => t.embeddedLangsLazy?.includes(e.name))));
            this._resolver.addLanguage(e);
            const n = {
                balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
                unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
            };
            this._syncRegistry._rawGrammars.set(e.scopeName, e);
            const r = this.loadGrammarWithConfiguration(e.scopeName, 1, n);
            if (r.name = e.name,
                this._resolvedGrammars.set(e.name, r),
                e.aliases && e.aliases.forEach((t => {
                    this._alias[t] = e.name
                }
                )),
                this._loadedLanguagesCache = null,
                t.size)
                for (const o of t)
                    this._resolvedGrammars.delete(o.name),
                        this._loadedLanguagesCache = null,
                        this._syncRegistry?._injectionGrammars?.delete(o.scopeName),
                        this._syncRegistry?._grammars?.delete(o.scopeName),
                        this.loadLanguage(this._langMap.get(o.name))
        }
        dispose() {
            super.dispose(),
                this._resolvedThemes.clear(),
                this._resolvedGrammars.clear(),
                this._langMap.clear(),
                this._langGraph.clear(),
                this._loadedThemesCache = null
        }
        loadLanguages(e) {
            for (const r of e)
                this.resolveEmbeddedLanguages(r);
            const t = Array.from(this._langGraph.entries())
                , n = t.filter((e => {
                    let [t, n] = e;
                    return !n
                }
                ));
            if (n.length) {
                const e = t.filter((e => {
                    let [t, r] = e;
                    return r && r.embeddedLangs?.some((e => n.map((e => {
                        let [t] = e;
                        return t
                    }
                    )).includes(e)))
                }
                )).filter((e => !n.includes(e)));
                throw new Yc(`Missing languages ${n.map((e => {
                    let [t] = e;
                    return `\`${t}\``
                }
                )).join(", ")}, required by ${e.map((e => {
                    let [t] = e;
                    return `\`${t}\``
                }
                )).join(", ")}`)
            }
            for (const [r, o] of t)
                this._resolver.addLanguage(o);
            for (const [r, o] of t)
                this.loadLanguage(o)
        }
        getLoadedLanguages() {
            return this._loadedLanguagesCache || (this._loadedLanguagesCache = [...new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])]),
                this._loadedLanguagesCache
        }
        resolveEmbeddedLanguages(e) {
            if (this._langMap.set(e.name, e),
                this._langGraph.set(e.name, e),
                e.embeddedLangs)
                for (const t of e.embeddedLangs)
                    this._langGraph.set(t, this._langMap.get(t))
        }
    }
    var Bd = Object.defineProperty
        , Vd = (e, t, n) => (((e, t, n) => {
            t in e ? Bd(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : e[t] = n
        }
        )(e, "symbol" !== typeof t ? t + "" : t, n),
            n);
    class Fd {
        constructor(e, t) {
            Vd(this, "_langs", new Map),
                Vd(this, "_scopeToLang", new Map),
                Vd(this, "_injections", new Map),
                Vd(this, "_onigLib"),
                this._onigLib = {
                    createOnigScanner: t => e.createScanner(t),
                    createOnigString: t => e.createString(t)
                },
                t.forEach((e => this.addLanguage(e)))
        }
        get onigLib() {
            return this._onigLib
        }
        getLangRegistration(e) {
            return this._langs.get(e)
        }
        loadGrammar(e) {
            return this._scopeToLang.get(e)
        }
        addLanguage(e) {
            this._langs.set(e.name, e),
                e.aliases && e.aliases.forEach((t => {
                    this._langs.set(t, e)
                }
                )),
                this._scopeToLang.set(e.scopeName, e),
                e.injectTo && e.injectTo.forEach((t => {
                    this._injections.get(t) || this._injections.set(t, []),
                        this._injections.get(t).push(e.scopeName)
                }
                ))
        }
        getInjections(e) {
            const t = e.split(".");
            let n = [];
            for (let r = 1; r <= t.length; r++) {
                const e = t.slice(0, r).join(".");
                n = [...n, ...this._injections.get(e) || []]
            }
            return n
        }
    }
    let Ud = 0;
    function Wd(e) {
        Ud += 1,
            !1 !== e.warnings && Ud >= 10 && Ud % 10 === 0 && console.warn(`[Shiki] ${Ud} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
        let t = !1;
        if (!e.engine)
            throw new Yc("`engine` option is required for synchronous mode");
        const n = (e.langs || []).flat(1)
            , r = (e.themes || []).flat(1).map(Dd)
            , o = new Fd(e.engine, n)
            , i = new $d(o, r, n, e.langAlias);
        let s;
        function a(e) {
            if ("none" === e)
                return {
                    bg: "",
                    fg: "",
                    name: "none",
                    settings: [],
                    type: "dark"
                };
            d();
            const t = i.getTheme(e);
            if (!t)
                throw new Yc(`Theme \`${e}\` not found, you may need to load it first`);
            return t
        }
        function l() {
            d();
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            i.loadLanguages(t.flat(1))
        }
        function c() {
            d();
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            for (const r of t.flat(1))
                i.loadTheme(r)
        }
        function d() {
            if (t)
                throw new Yc("Shiki instance has been disposed")
        }
        function u() {
            t || (t = !0,
                i.dispose(),
                Ud -= 1)
        }
        return {
            setTheme: function (e) {
                d();
                const t = a(e);
                return s !== e && (i.setTheme(t),
                    s = e),
                {
                    theme: t,
                    colorMap: i.getColorMap()
                }
            },
            getTheme: a,
            getLanguage: function (e) {
                d();
                const t = i.getGrammar("string" === typeof e ? e : e.name);
                if (!t)
                    throw new Yc(`Language \`${e}\` not found, you may need to load it first`);
                return t
            },
            getLoadedThemes: function () {
                return d(),
                    i.getLoadedThemes()
            },
            getLoadedLanguages: function () {
                return d(),
                    i.getLoadedLanguages()
            },
            loadLanguage: async function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return l(await Id(t))
            },
            loadLanguageSync: l,
            loadTheme: async function () {
                d();
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return c(await jd(t))
            },
            loadThemeSync: c,
            dispose: u,
            [Symbol.dispose]: u
        }
    }
    async function qd() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        e.loadWasm && Fa("`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.");
        const [t, n, r] = await Promise.all([jd(e.themes || []), Id(e.langs || []), e.engine || Ba(e.loadWasm || Ra)]);
        return Wd({
            ...e,
            loadWasm: void 0,
            themes: t,
            langs: n,
            engine: r
        })
    }
    async function Gd() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t = await qd(e);
        return {
            getLastGrammarState: function () {
                for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                    n[r] = arguments[r];
                return wd(t, ...n)
            },
            codeToTokensBase: (e, n) => vd(t, e, n),
            codeToTokensWithThemes: (e, n) => Md(t, e, n),
            codeToTokens: (e, n) => Td(t, e, n),
            codeToHast: (e, n) => Nd(t, e, n),
            codeToHtml: (e, n) => _d(t, e, n),
            ...t,
            getInternalContext: () => t
        }
    }
    function Kd(e, t, n) {
        let r, o, i;
        if (t)
            Fa("`createdBundledHighlighter` signature with `bundledLanguages` and `bundledThemes` is deprecated. Use the options object signature instead."),
                r = e,
                o = t,
                i = () => function (e) {
                    return Fa("import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead"),
                        Ba(e)
                }(n);
        else {
            const t = e;
            r = t.langs,
                o = t.themes,
                i = t.engine
        }
        return async function (e) {
            function t(e) {
                if ("string" === typeof e) {
                    if (Uc(e))
                        return [];
                    const t = r[e];
                    if (!t)
                        throw new _a(`Language \`${e}\` is not included in this bundle. You may want to load it from external source.`);
                    return t
                }
                return e
            }
            function n(e) {
                if (qc(e))
                    return "none";
                if ("string" === typeof e) {
                    const t = o[e];
                    if (!t)
                        throw new _a(`Theme \`${e}\` is not included in this bundle. You may want to load it from external source.`);
                    return t
                }
                return e
            }
            const s = (e.themes ?? []).map((e => n(e)))
                , a = (e.langs ?? []).map((e => t(e)))
                , l = await Gd({
                    engine: e.engine ?? i(),
                    ...e,
                    themes: s,
                    langs: a
                });
            return {
                ...l,
                loadLanguage() {
                    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                        n[r] = arguments[r];
                    return l.loadLanguage(...n.map(t))
                },
                loadTheme() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                        t[r] = arguments[r];
                    return l.loadTheme(...t.map(n))
                }
            }
        }
    }
    function Jd(e) {
        const t = function (e) {
            let t;
            return async function () {
                let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (t) {
                    const e = await t;
                    return await Promise.all([e.loadTheme(...n.themes || []), e.loadLanguage(...n.langs || [])]),
                        e
                }
                return t = e({
                    ...n,
                    themes: n.themes || [],
                    langs: n.langs || []
                }),
                    t
            }
        }(e);
        return {
            getSingletonHighlighter: e => t(e),
            codeToHtml: async (e, n) => (await t({
                langs: [n.lang],
                themes: "theme" in n ? [n.theme] : Object.values(n.themes)
            })).codeToHtml(e, n),
            codeToHast: async (e, n) => (await t({
                langs: [n.lang],
                themes: "theme" in n ? [n.theme] : Object.values(n.themes)
            })).codeToHast(e, n),
            codeToTokens: async (e, n) => (await t({
                langs: [n.lang],
                themes: "theme" in n ? [n.theme] : Object.values(n.themes)
            })).codeToTokens(e, n),
            codeToTokensBase: async (e, n) => (await t({
                langs: [n.lang],
                themes: [n.theme]
            })).codeToTokensBase(e, n),
            codeToTokensWithThemes: async (e, n) => (await t({
                langs: [n.lang],
                themes: Object.values(n.themes).filter(Boolean)
            })).codeToTokensWithThemes(e, n),
            getLastGrammarState: async (e, n) => (await t({
                langs: [n.lang],
                themes: [n.theme]
            })).getLastGrammarState(e, n)
        }
    }
    const Zd = Kd({
        langs: Ma,
        themes: Na,
        engine: () => Ba(n.e(9335).then(n.bind(n, 9335)))
    })
        , { codeToHtml: Xd, codeToHast: Qd, codeToTokens: Yd, codeToTokensBase: eu, codeToTokensWithThemes: tu, getSingletonHighlighter: nu, getLastGrammarState: ru } = Jd(Zd)
        , ou = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/
        , iu = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g
        , su = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/
        , au = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g
        , lu = ts.create({
            name: "bold",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            parseHTML() {
                return [{
                    tag: "strong"
                }, {
                    tag: "b",
                    getAttrs: e => "normal" !== e.style.fontWeight && null
                }, {
                    style: "font-weight=400",
                    clearMark: e => e.type.name === this.name
                }, {
                    style: "font-weight",
                    getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["strong", $i(this.options.HTMLAttributes, t), 0]
            },
            addCommands() {
                return {
                    setBold: () => e => {
                        let { commands: t } = e;
                        return t.setMark(this.name)
                    }
                    ,
                    toggleBold: () => e => {
                        let { commands: t } = e;
                        return t.toggleMark(this.name)
                    }
                    ,
                    unsetBold: () => e => {
                        let { commands: t } = e;
                        return t.unsetMark(this.name)
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-b": () => this.editor.commands.toggleBold(),
                    "Mod-B": () => this.editor.commands.toggleBold()
                }
            },
            addInputRules() {
                return [aa({
                    find: ou,
                    type: this.type
                }), aa({
                    find: su,
                    type: this.type
                })]
            },
            addPasteRules() {
                return [da({
                    find: iu,
                    type: this.type
                }), da({
                    find: au,
                    type: this.type
                })]
            }
        })
        , cu = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/
        , du = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g
        , uu = ts.create({
            name: "code",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            excludes: "_",
            code: !0,
            exitable: !0,
            parseHTML: () => [{
                tag: "code"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["code", $i(this.options.HTMLAttributes, t), 0]
            },
            addCommands() {
                return {
                    setCode: () => e => {
                        let { commands: t } = e;
                        return t.setMark(this.name)
                    }
                    ,
                    toggleCode: () => e => {
                        let { commands: t } = e;
                        return t.toggleMark(this.name)
                    }
                    ,
                    unsetCode: () => e => {
                        let { commands: t } = e;
                        return t.unsetMark(this.name)
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-e": () => this.editor.commands.toggleCode()
                }
            },
            addInputRules() {
                return [aa({
                    find: cu,
                    type: this.type
                })]
            },
            addPasteRules() {
                return [da({
                    find: du,
                    type: this.type
                })]
            }
        })
        , hu = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/
        , pu = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g
        , fu = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/
        , mu = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g
        , gu = ts.create({
            name: "italic",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            parseHTML() {
                return [{
                    tag: "em"
                }, {
                    tag: "i",
                    getAttrs: e => "normal" !== e.style.fontStyle && null
                }, {
                    style: "font-style=normal",
                    clearMark: e => e.type.name === this.name
                }, {
                    style: "font-style=italic"
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["em", $i(this.options.HTMLAttributes, t), 0]
            },
            addCommands() {
                return {
                    setItalic: () => e => {
                        let { commands: t } = e;
                        return t.setMark(this.name)
                    }
                    ,
                    toggleItalic: () => e => {
                        let { commands: t } = e;
                        return t.toggleMark(this.name)
                    }
                    ,
                    unsetItalic: () => e => {
                        let { commands: t } = e;
                        return t.unsetMark(this.name)
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-i": () => this.editor.commands.toggleItalic(),
                    "Mod-I": () => this.editor.commands.toggleItalic()
                }
            },
            addInputRules() {
                return [aa({
                    find: hu,
                    type: this.type
                }), aa({
                    find: fu,
                    type: this.type
                })]
            },
            addPasteRules() {
                return [da({
                    find: pu,
                    type: this.type
                }), da({
                    find: mu,
                    type: this.type
                })]
            }
        })
        , bu = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/
        , yu = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g
        , vu = ts.create({
            name: "strike",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            parseHTML: () => [{
                tag: "s"
            }, {
                tag: "del"
            }, {
                tag: "strike"
            }, {
                style: "text-decoration",
                consuming: !1,
                getAttrs: e => !!e.includes("line-through") && {}
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["s", $i(this.options.HTMLAttributes, t), 0]
            },
            addCommands() {
                return {
                    setStrike: () => e => {
                        let { commands: t } = e;
                        return t.setMark(this.name)
                    }
                    ,
                    toggleStrike: () => e => {
                        let { commands: t } = e;
                        return t.toggleMark(this.name)
                    }
                    ,
                    unsetStrike: () => e => {
                        let { commands: t } = e;
                        return t.unsetMark(this.name)
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-Shift-s": () => this.editor.commands.toggleStrike()
                }
            },
            addInputRules() {
                return [aa({
                    find: bu,
                    type: this.type
                })]
            },
            addPasteRules() {
                return [da({
                    find: yu,
                    type: this.type
                })]
            }
        })
        , wu = ts.create({
            name: "underline",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            parseHTML: () => [{
                tag: "u"
            }, {
                style: "text-decoration",
                consuming: !1,
                getAttrs: e => !!e.includes("underline") && {}
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["u", $i(this.options.HTMLAttributes, t), 0]
            },
            addCommands() {
                return {
                    setUnderline: () => e => {
                        let { commands: t } = e;
                        return t.setMark(this.name)
                    }
                    ,
                    toggleUnderline: () => e => {
                        let { commands: t } = e;
                        return t.toggleMark(this.name)
                    }
                    ,
                    unsetUnderline: () => e => {
                        let { commands: t } = e;
                        return t.unsetMark(this.name)
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-u": () => this.editor.commands.toggleUnderline(),
                    "Mod-U": () => this.editor.commands.toggleUnderline()
                }
            }
        })
        , ku = la.create({
            name: "tableCell",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            content: "block+",
            addAttributes: () => ({
                colspan: {
                    default: 1
                },
                rowspan: {
                    default: 1
                },
                colwidth: {
                    default: null,
                    parseHTML: e => {
                        const t = e.getAttribute("colwidth");
                        return t ? t.split(",").map((e => parseInt(e, 10))) : null
                    }
                }
            }),
            tableRole: "cell",
            isolating: !0,
            parseHTML: () => [{
                tag: "td"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["td", $i(this.options.HTMLAttributes, t), 0]
            }
        })
        , Cu = la.create({
            name: "tableHeader",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            content: "block+",
            addAttributes: () => ({
                colspan: {
                    default: 1
                },
                rowspan: {
                    default: 1
                },
                colwidth: {
                    default: null,
                    parseHTML: e => {
                        const t = e.getAttribute("colwidth");
                        return t ? t.split(",").map((e => parseInt(e, 10))) : null
                    }
                }
            }),
            tableRole: "header_cell",
            isolating: !0,
            parseHTML: () => [{
                tag: "th"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["th", $i(this.options.HTMLAttributes, t), 0]
            }
        })
        , Su = la.create({
            name: "tableRow",
            addOptions: () => ({
                HTMLAttributes: {}
            }),
            content: "(tableCell | tableHeader)*",
            tableRole: "row",
            parseHTML: () => [{
                tag: "tr"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["tr", $i(this.options.HTMLAttributes, t), 0]
            }
        });
    var xu, Eu;
    if ("undefined" != typeof WeakMap) {
        let e = new WeakMap;
        xu = t => e.get(t),
            Eu = (t, n) => (e.set(t, n),
                n)
    } else {
        const e = []
            , t = 10;
        let n = 0;
        xu = t => {
            for (let n = 0; n < e.length; n += 2)
                if (e[n] == t)
                    return e[n + 1]
        }
            ,
            Eu = (r, o) => (n == t && (n = 0),
                e[n++] = r,
                e[n++] = o)
    }
    var Mu = class {
        constructor(e, t, n, r) {
            this.width = e,
                this.height = t,
                this.map = n,
                this.problems = r
        }
        findCell(e) {
            for (let t = 0; t < this.map.length; t++) {
                const n = this.map[t];
                if (n != e)
                    continue;
                const r = t % this.width
                    , o = t / this.width | 0;
                let i = r + 1
                    , s = o + 1;
                for (let e = 1; i < this.width && this.map[t + e] == n; e++)
                    i++;
                for (let e = 1; s < this.height && this.map[t + this.width * e] == n; e++)
                    s++;
                return {
                    left: r,
                    top: o,
                    right: i,
                    bottom: s
                }
            }
            throw new RangeError(`No cell with offset ${e} found`)
        }
        colCount(e) {
            for (let t = 0; t < this.map.length; t++)
                if (this.map[t] == e)
                    return t % this.width;
            throw new RangeError(`No cell with offset ${e} found`)
        }
        nextCell(e, t, n) {
            const { left: r, right: o, top: i, bottom: s } = this.findCell(e);
            return "horiz" == t ? (n < 0 ? 0 == r : o == this.width) ? null : this.map[i * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? 0 == i : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i - 1 : s)]
        }
        rectBetween(e, t) {
            const { left: n, right: r, top: o, bottom: i } = this.findCell(e)
                , { left: s, right: a, top: l, bottom: c } = this.findCell(t);
            return {
                left: Math.min(n, s),
                top: Math.min(o, l),
                right: Math.max(r, a),
                bottom: Math.max(i, c)
            }
        }
        cellsInRect(e) {
            const t = []
                , n = {};
            for (let r = e.top; r < e.bottom; r++)
                for (let o = e.left; o < e.right; o++) {
                    const i = r * this.width + o
                        , s = this.map[i];
                    n[s] || (n[s] = !0,
                        o == e.left && o && this.map[i - 1] == s || r == e.top && r && this.map[i - this.width] == s || t.push(s))
                }
            return t
        }
        positionAt(e, t, n) {
            for (let r = 0, o = 0; ; r++) {
                const i = o + n.child(r).nodeSize;
                if (r == e) {
                    let n = t + e * this.width;
                    const r = (e + 1) * this.width;
                    for (; n < r && this.map[n] < o;)
                        n++;
                    return n == r ? i - 1 : this.map[n]
                }
                o = i
            }
        }
        static get(e) {
            return xu(e) || Eu(e, function (e) {
                if ("table" != e.type.spec.tableRole)
                    throw new RangeError("Not a table node: " + e.type.name);
                const t = function (e) {
                    let t = -1
                        , n = !1;
                    for (let r = 0; r < e.childCount; r++) {
                        const o = e.child(r);
                        let i = 0;
                        if (n)
                            for (let t = 0; t < r; t++) {
                                const n = e.child(t);
                                for (let e = 0; e < n.childCount; e++) {
                                    const o = n.child(e);
                                    t + o.attrs.rowspan > r && (i += o.attrs.colspan)
                                }
                            }
                        for (let e = 0; e < o.childCount; e++) {
                            const t = o.child(e);
                            i += t.attrs.colspan,
                                t.attrs.rowspan > 1 && (n = !0)
                        }
                        -1 == t ? t = i : t != i && (t = Math.max(t, i))
                    }
                    return t
                }(e)
                    , n = e.childCount
                    , r = [];
                let o = 0
                    , i = null;
                const s = [];
                for (let c = 0, d = t * n; c < d; c++)
                    r[c] = 0;
                for (let c = 0, d = 0; c < n; c++) {
                    const a = e.child(c);
                    d++;
                    for (let e = 0; ; e++) {
                        for (; o < r.length && 0 != r[o];)
                            o++;
                        if (e == a.childCount)
                            break;
                        const l = a.child(e)
                            , { colspan: u, rowspan: h, colwidth: p } = l.attrs;
                        for (let e = 0; e < h; e++) {
                            if (e + c >= n) {
                                (i || (i = [])).push({
                                    type: "overlong_rowspan",
                                    pos: d,
                                    n: h - e
                                });
                                break
                            }
                            const a = o + e * t;
                            for (let e = 0; e < u; e++) {
                                0 == r[a + e] ? r[a + e] = d : (i || (i = [])).push({
                                    type: "collision",
                                    row: c,
                                    pos: d,
                                    n: u - e
                                });
                                const n = p && p[e];
                                if (n) {
                                    const r = (a + e) % t * 2
                                        , o = s[r];
                                    null == o || o != n && 1 == s[r + 1] ? (s[r] = n,
                                        s[r + 1] = 1) : o == n && s[r + 1]++
                                }
                            }
                        }
                        o += u,
                            d += l.nodeSize
                    }
                    const l = (c + 1) * t;
                    let u = 0;
                    for (; o < l;)
                        0 == r[o++] && u++;
                    u && (i || (i = [])).push({
                        type: "missing",
                        row: c,
                        n: u
                    }),
                        d++
                }
                const a = new Mu(t, n, r, i);
                let l = !1;
                for (let c = 0; !l && c < s.length; c += 2)
                    null != s[c] && s[c + 1] < n && (l = !0);
                l && function (e, t, n) {
                    e.problems || (e.problems = []);
                    const r = {};
                    for (let o = 0; o < e.map.length; o++) {
                        const i = e.map[o];
                        if (r[i])
                            continue;
                        r[i] = !0;
                        const s = n.nodeAt(i);
                        if (!s)
                            throw new RangeError(`No cell with offset ${i} found`);
                        let a = null;
                        const l = s.attrs;
                        for (let n = 0; n < l.colspan; n++) {
                            const r = t[2 * ((o + n) % e.width)];
                            null == r || l.colwidth && l.colwidth[n] == r || ((a || (a = Tu(l)))[n] = r)
                        }
                        a && e.problems.unshift({
                            type: "colwidth mismatch",
                            pos: i,
                            colwidth: a
                        })
                    }
                }(a, s, e);
                return a
            }(e))
        }
    }
        ;
    function Tu(e) {
        if (e.colwidth)
            return e.colwidth.slice();
        const t = [];
        for (let n = 0; n < e.colspan; n++)
            t.push(0);
        return t
    }
    function Nu(e) {
        let t = e.cached.tableNodeTypes;
        if (!t) {
            t = e.cached.tableNodeTypes = {};
            for (const n in e.nodes) {
                const r = e.nodes[n]
                    , o = r.spec.tableRole;
                o && (t[o] = r)
            }
        }
        return t
    }
    var _u = new _t("selectingCells");
    function Ou(e) {
        for (let t = e.depth - 1; t > 0; t--)
            if ("row" == e.node(t).type.spec.tableRole)
                return e.node(0).resolve(e.before(t + 1));
        return null
    }
    function Au(e) {
        const t = e.selection.$head;
        for (let n = t.depth; n > 0; n--)
            if ("row" == t.node(n).type.spec.tableRole)
                return !0;
        return !1
    }
    function Pu(e) {
        const t = e.selection;
        if ("$anchorCell" in t && t.$anchorCell)
            return t.$anchorCell.pos > t.$headCell.pos ? t.$anchorCell : t.$headCell;
        if ("node" in t && t.node && "cell" == t.node.type.spec.tableRole)
            return t.$anchor;
        const n = Ou(t.$head) || function (e) {
            for (let t = e.nodeAfter, n = e.pos; t; t = t.firstChild,
                n++) {
                const r = t.type.spec.tableRole;
                if ("cell" == r || "header_cell" == r)
                    return e.doc.resolve(n)
            }
            for (let t = e.nodeBefore, n = e.pos; t; t = t.lastChild,
                n--) {
                const r = t.type.spec.tableRole;
                if ("cell" == r || "header_cell" == r)
                    return e.doc.resolve(n - t.nodeSize)
            }
        }(t.$head);
        if (n)
            return n;
        throw new RangeError(`No cell found around position ${t.head}`)
    }
    function Lu(e) {
        return "row" == e.parent.type.spec.tableRole && !!e.nodeAfter
    }
    function Ru(e, t) {
        return e.depth == t.depth && e.pos >= t.start(-1) && e.pos <= t.end(-1)
    }
    function Du(e, t, n) {
        const r = e.node(-1)
            , o = Mu.get(r)
            , i = e.start(-1)
            , s = o.nextCell(e.pos - i, t, n);
        return null == s ? null : e.node(0).resolve(i + s)
    }
    function Iu(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        const r = {
            ...e,
            colspan: e.colspan - n
        };
        return r.colwidth && (r.colwidth = r.colwidth.slice(),
            r.colwidth.splice(t, n),
            r.colwidth.some((e => e > 0)) || (r.colwidth = null)),
            r
    }
    var ju = class e extends at {
        constructor(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e;
            const n = e.node(-1)
                , r = Mu.get(n)
                , o = e.start(-1)
                , i = r.rectBetween(e.pos - o, t.pos - o)
                , s = e.node(0)
                , a = r.cellsInRect(i).filter((e => e != t.pos - o));
            a.unshift(t.pos - o);
            const l = a.map((e => {
                const t = n.nodeAt(e);
                if (!t)
                    throw RangeError(`No cell with offset ${e} found`);
                const r = o + e + 1;
                return new lt(s.resolve(r), s.resolve(r + t.content.size))
            }
            ));
            super(l[0].$from, l[0].$to, l),
                this.$anchorCell = e,
                this.$headCell = t
        }
        map(t, n) {
            const r = t.resolve(n.map(this.$anchorCell.pos))
                , o = t.resolve(n.map(this.$headCell.pos));
            if (Lu(r) && Lu(o) && Ru(r, o)) {
                const t = this.$anchorCell.node(-1) != r.node(-1);
                return t && this.isRowSelection() ? e.rowSelection(r, o) : t && this.isColSelection() ? e.colSelection(r, o) : new e(r, o)
            }
            return ut.between(r, o)
        }
        content() {
            const e = this.$anchorCell.node(-1)
                , t = Mu.get(e)
                , n = this.$anchorCell.start(-1)
                , r = t.rectBetween(this.$anchorCell.pos - n, this.$headCell.pos - n)
                , o = {}
                , i = [];
            for (let a = r.top; a < r.bottom; a++) {
                const n = [];
                for (let i = a * t.width + r.left, s = r.left; s < r.right; s++,
                    i++) {
                    const s = t.map[i];
                    if (o[s])
                        continue;
                    o[s] = !0;
                    const a = t.findCell(s);
                    let l = e.nodeAt(s);
                    if (!l)
                        throw RangeError(`No cell with offset ${s} found`);
                    const c = r.left - a.left
                        , d = a.right - r.right;
                    if (c > 0 || d > 0) {
                        let e = l.attrs;
                        if (c > 0 && (e = Iu(e, 0, c)),
                            d > 0 && (e = Iu(e, e.colspan - d, d)),
                            a.left < r.left) {
                            if (l = l.type.createAndFill(e),
                                !l)
                                throw RangeError(`Could not create cell with attrs ${JSON.stringify(e)}`)
                        } else
                            l = l.type.create(e, l.content)
                    }
                    if (a.top < r.top || a.bottom > r.bottom) {
                        const e = {
                            ...l.attrs,
                            rowspan: Math.min(a.bottom, r.bottom) - Math.max(a.top, r.top)
                        };
                        l = a.top < r.top ? l.type.createAndFill(e) : l.type.create(e, l.content)
                    }
                    n.push(l)
                }
                i.push(e.child(a).copy(d.from(n)))
            }
            const s = this.isColSelection() && this.isRowSelection() ? e : i;
            return new g(d.from(s), 1, 1)
        }
        replace(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.empty;
            const n = e.steps.length
                , r = this.ranges;
            for (let i = 0; i < r.length; i++) {
                const { $from: o, $to: s } = r[i]
                    , a = e.mapping.slice(n);
                e.replace(a.map(o.pos), a.map(s.pos), i ? g.empty : t)
            }
            const o = at.findFrom(e.doc.resolve(e.mapping.slice(n).map(this.to)), -1);
            o && e.setSelection(o)
        }
        replaceWith(e, t) {
            this.replace(e, new g(d.from(t), 0, 0))
        }
        forEachCell(e) {
            const t = this.$anchorCell.node(-1)
                , n = Mu.get(t)
                , r = this.$anchorCell.start(-1)
                , o = n.cellsInRect(n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r));
            for (let i = 0; i < o.length; i++)
                e(t.nodeAt(o[i]), r + o[i])
        }
        isColSelection() {
            const e = this.$anchorCell.index(-1)
                , t = this.$headCell.index(-1);
            if (Math.min(e, t) > 0)
                return !1;
            const n = e + this.$anchorCell.nodeAfter.attrs.rowspan
                , r = t + this.$headCell.nodeAfter.attrs.rowspan;
            return Math.max(n, r) == this.$headCell.node(-1).childCount
        }
        static colSelection(t) {
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t;
            const r = t.node(-1)
                , o = Mu.get(r)
                , i = t.start(-1)
                , s = o.findCell(t.pos - i)
                , a = o.findCell(n.pos - i)
                , l = t.node(0);
            return s.top <= a.top ? (s.top > 0 && (t = l.resolve(i + o.map[s.left])),
                a.bottom < o.height && (n = l.resolve(i + o.map[o.width * (o.height - 1) + a.right - 1]))) : (a.top > 0 && (n = l.resolve(i + o.map[a.left])),
                    s.bottom < o.height && (t = l.resolve(i + o.map[o.width * (o.height - 1) + s.right - 1]))),
                new e(t, n)
        }
        isRowSelection() {
            const e = this.$anchorCell.node(-1)
                , t = Mu.get(e)
                , n = this.$anchorCell.start(-1)
                , r = t.colCount(this.$anchorCell.pos - n)
                , o = t.colCount(this.$headCell.pos - n);
            if (Math.min(r, o) > 0)
                return !1;
            const i = r + this.$anchorCell.nodeAfter.attrs.colspan
                , s = o + this.$headCell.nodeAfter.attrs.colspan;
            return Math.max(i, s) == t.width
        }
        eq(t) {
            return t instanceof e && t.$anchorCell.pos == this.$anchorCell.pos && t.$headCell.pos == this.$headCell.pos
        }
        static rowSelection(t) {
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t;
            const r = t.node(-1)
                , o = Mu.get(r)
                , i = t.start(-1)
                , s = o.findCell(t.pos - i)
                , a = o.findCell(n.pos - i)
                , l = t.node(0);
            return s.left <= a.left ? (s.left > 0 && (t = l.resolve(i + o.map[s.top * o.width])),
                a.right < o.width && (n = l.resolve(i + o.map[o.width * (a.top + 1) - 1]))) : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])),
                    s.right < o.width && (t = l.resolve(i + o.map[o.width * (s.top + 1) - 1]))),
                new e(t, n)
        }
        toJSON() {
            return {
                type: "cell",
                anchor: this.$anchorCell.pos,
                head: this.$headCell.pos
            }
        }
        static fromJSON(t, n) {
            return new e(t.resolve(n.anchor), t.resolve(n.head))
        }
        static create(t, n) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : n;
            return new e(t.resolve(n), t.resolve(r))
        }
        getBookmark() {
            return new Hu(this.$anchorCell.pos, this.$headCell.pos)
        }
    }
        ;
    ju.prototype.visible = !1,
        at.jsonID("cell", ju);
    var Hu = class e {
        constructor(e, t) {
            this.anchor = e,
                this.head = t
        }
        map(t) {
            return new e(t.map(this.anchor), t.map(this.head))
        }
        resolve(e) {
            const t = e.resolve(this.anchor)
                , n = e.resolve(this.head);
            return "row" == t.parent.type.spec.tableRole && "row" == n.parent.type.spec.tableRole && t.index() < t.parent.childCount && n.index() < n.parent.childCount && Ru(t, n) ? new ju(t, n) : at.near(n, 1)
        }
    }
        ;
    function zu(e) {
        if (!(e.selection instanceof ju))
            return null;
        const t = [];
        return e.selection.forEachCell(((e, n) => {
            t.push(ho.node(n, n + e.nodeSize, {
                class: "selectedCell"
            }))
        }
        )),
            mo.create(e.doc, t)
    }
    var $u = new _t("fix-tables");
    function Bu(e, t, n, r) {
        const o = e.childCount
            , i = t.childCount;
        e: for (let s = 0, a = 0; s < i; s++) {
            const i = t.child(s);
            for (let t = a, r = Math.min(o, s + 3); t < r; t++)
                if (e.child(t) == i) {
                    a = t + 1,
                        n += i.nodeSize;
                    continue e
                }
            r(i, n),
                a < o && e.child(a).sameMarkup(i) ? Bu(e.child(a), i, n + 1, r) : i.nodesBetween(0, i.content.size, r, n + 1),
                n += i.nodeSize
        }
    }
    function Vu(e, t) {
        let n;
        const r = (t, r) => {
            "table" == t.type.spec.tableRole && (n = function (e, t, n, r) {
                const o = Mu.get(t);
                if (!o.problems)
                    return r;
                r || (r = e.tr);
                const i = [];
                for (let l = 0; l < o.height; l++)
                    i.push(0);
                for (let l = 0; l < o.problems.length; l++) {
                    const e = o.problems[l];
                    if ("collision" == e.type) {
                        const o = t.nodeAt(e.pos);
                        if (!o)
                            continue;
                        const s = o.attrs;
                        for (let t = 0; t < s.rowspan; t++)
                            i[e.row + t] += e.n;
                        r.setNodeMarkup(r.mapping.map(n + 1 + e.pos), null, Iu(s, s.colspan - e.n, e.n))
                    } else if ("missing" == e.type)
                        i[e.row] += e.n;
                    else if ("overlong_rowspan" == e.type) {
                        const o = t.nodeAt(e.pos);
                        if (!o)
                            continue;
                        r.setNodeMarkup(r.mapping.map(n + 1 + e.pos), null, {
                            ...o.attrs,
                            rowspan: o.attrs.rowspan - e.n
                        })
                    } else if ("colwidth mismatch" == e.type) {
                        const o = t.nodeAt(e.pos);
                        if (!o)
                            continue;
                        r.setNodeMarkup(r.mapping.map(n + 1 + e.pos), null, {
                            ...o.attrs,
                            colwidth: e.colwidth
                        })
                    }
                }
                let s, a;
                for (let l = 0; l < i.length; l++)
                    i[l] && (null == s && (s = l),
                        a = l);
                for (let l = 0, c = n + 1; l < o.height; l++) {
                    const n = t.child(l)
                        , o = c + n.nodeSize
                        , d = i[l];
                    if (d > 0) {
                        let t = "cell";
                        n.firstChild && (t = n.firstChild.type.spec.tableRole);
                        const i = [];
                        for (let n = 0; n < d; n++) {
                            const n = Nu(e.schema)[t].createAndFill();
                            n && i.push(n)
                        }
                        const u = 0 != l && s != l - 1 || a != l ? o - 1 : c + 1;
                        r.insert(r.mapping.map(u), i)
                    }
                    c = o
                }
                return r.setMeta($u, {
                    fixTables: !0
                })
            }(e, t, r, n))
        }
            ;
        return t ? t.doc != e.doc && Bu(t.doc, e.doc, 0, r) : e.doc.descendants(r),
            n
    }
    function Fu(e) {
        const t = e.selection
            , n = Pu(e)
            , r = n.node(-1)
            , o = n.start(-1)
            , i = Mu.get(r);
        return {
            ...t instanceof ju ? i.rectBetween(t.$anchorCell.pos - o, t.$headCell.pos - o) : i.findCell(n.pos - o),
            tableStart: o,
            map: i,
            table: r
        }
    }
    function Uu(e, t, n) {
        const r = t.map.cellsInRect({
            left: 0,
            top: 0,
            right: "row" == e ? t.map.width : 1,
            bottom: "column" == e ? t.map.height : 1
        });
        for (let o = 0; o < r.length; o++) {
            const e = t.table.nodeAt(r[o]);
            if (e && e.type !== n.header_cell)
                return !1
        }
        return !0
    }
    function Wu(e, t) {
        return (t = t || {
            useDeprecatedLogic: !1
        }).useDeprecatedLogic ? function (e) {
            return function (t, n) {
                if (!Au(t))
                    return !1;
                if (n) {
                    const r = Nu(t.schema)
                        , o = Fu(t)
                        , i = t.tr
                        , s = o.map.cellsInRect("column" == e ? {
                            left: o.left,
                            top: 0,
                            right: o.right,
                            bottom: o.map.height
                        } : "row" == e ? {
                            left: 0,
                            top: o.top,
                            right: o.map.width,
                            bottom: o.bottom
                        } : o)
                        , a = s.map((e => o.table.nodeAt(e)));
                    for (let e = 0; e < s.length; e++)
                        a[e].type == r.header_cell && i.setNodeMarkup(o.tableStart + s[e], r.cell, a[e].attrs);
                    if (0 == i.steps.length)
                        for (let e = 0; e < s.length; e++)
                            i.setNodeMarkup(o.tableStart + s[e], r.header_cell, a[e].attrs);
                    n(i)
                }
                return !0
            }
        }(e) : function (t, n) {
            if (!Au(t))
                return !1;
            if (n) {
                const r = Nu(t.schema)
                    , o = Fu(t)
                    , i = t.tr
                    , s = Uu("row", o, r)
                    , a = Uu("column", o, r)
                    , l = ("column" === e ? s : "row" === e && a) ? 1 : 0
                    , c = "column" == e ? {
                        left: 0,
                        top: l,
                        right: 1,
                        bottom: o.map.height
                    } : "row" == e ? {
                        left: l,
                        top: 0,
                        right: o.map.width,
                        bottom: 1
                    } : o
                    , d = "column" == e ? a ? r.cell : r.header_cell : "row" == e ? s ? r.cell : r.header_cell : r.cell;
                o.map.cellsInRect(c).forEach((e => {
                    const t = e + o.tableStart
                        , n = i.doc.nodeAt(t);
                    n && i.setNodeMarkup(t, d, n.attrs)
                }
                )),
                    n(i)
            }
            return !0
        }
    }
    Wu("row", {
        useDeprecatedLogic: !0
    }),
        Wu("column", {
            useDeprecatedLogic: !0
        }),
        Wu("cell", {
            useDeprecatedLogic: !0
        });
    function qu(e, t) {
        const n = e.selection;
        if (!(n instanceof ju))
            return !1;
        if (t) {
            const r = e.tr
                , o = Nu(e.schema).cell.createAndFill().content;
            n.forEachCell(((e, t) => {
                e.content.eq(o) || r.replace(r.mapping.map(t + 1), r.mapping.map(t + e.nodeSize - 1), new g(o, 0, 0))
            }
            )),
                r.docChanged && t(r)
        }
        return !0
    }
    function Gu(e) {
        if (!e.size)
            return null;
        let { content: t, openStart: n, openEnd: r } = e;
        for (; 1 == t.childCount && (n > 0 && r > 0 || "table" == t.child(0).type.spec.tableRole);)
            n--,
                r--,
                t = t.child(0).content;
        const o = t.child(0)
            , i = o.type.spec.tableRole
            , s = o.type.schema
            , a = [];
        if ("row" == i)
            for (let l = 0; l < t.childCount; l++) {
                let e = t.child(l).content;
                const o = l ? 0 : Math.max(0, n - 1)
                    , i = l < t.childCount - 1 ? 0 : Math.max(0, r - 1);
                (o || i) && (e = Ku(Nu(s).row, new g(e, o, i)).content),
                    a.push(e)
            }
        else {
            if ("cell" != i && "header_cell" != i)
                return null;
            a.push(n || r ? Ku(Nu(s).row, new g(t, n, r)).content : t)
        }
        return function (e, t) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
                const e = t[o];
                for (let t = e.childCount - 1; t >= 0; t--) {
                    const { rowspan: r, colspan: i } = e.child(t).attrs;
                    for (let e = o; e < o + r; e++)
                        n[e] = (n[e] || 0) + i
                }
            }
            let r = 0;
            for (let o = 0; o < n.length; o++)
                r = Math.max(r, n[o]);
            for (let o = 0; o < n.length; o++)
                if (o >= t.length && t.push(d.empty),
                    n[o] < r) {
                    const i = Nu(e).cell.createAndFill()
                        , s = [];
                    for (let e = n[o]; e < r; e++)
                        s.push(i);
                    t[o] = t[o].append(d.from(s))
                }
            return {
                height: t.length,
                width: r,
                rows: t
            }
        }(s, a)
    }
    function Ku(e, t) {
        const n = e.createAndFill();
        return new it(n).replace(0, n.content.size, t).doc
    }
    function Ju(e, t, n, r, o, i, s, a) {
        if (0 == s || s == t.height)
            return !1;
        let l = !1;
        for (let c = o; c < i; c++) {
            const o = s * t.width + c
                , i = t.map[o];
            if (t.map[o - t.width] == i) {
                l = !0;
                const o = n.nodeAt(i)
                    , { top: d, left: u } = t.findCell(i);
                e.setNodeMarkup(e.mapping.slice(a).map(i + r), null, {
                    ...o.attrs,
                    rowspan: s - d
                }),
                    e.insert(e.mapping.slice(a).map(t.positionAt(s, u, n)), o.type.createAndFill({
                        ...o.attrs,
                        rowspan: d + o.attrs.rowspan - s
                    })),
                    c += o.attrs.colspan - 1
            }
        }
        return l
    }
    function Zu(e, t, n, r, o, i, s, a) {
        if (0 == s || s == t.width)
            return !1;
        let l = !1;
        for (let c = o; c < i; c++) {
            const o = c * t.width + s
                , i = t.map[o];
            if (t.map[o - 1] == i) {
                l = !0;
                const o = n.nodeAt(i)
                    , d = t.colCount(i)
                    , u = e.mapping.slice(a).map(i + r);
                e.setNodeMarkup(u, null, Iu(o.attrs, s - d, o.attrs.colspan - (s - d))),
                    e.insert(u + o.nodeSize, o.type.createAndFill(Iu(o.attrs, 0, s - d))),
                    c += o.attrs.rowspan - 1
            }
        }
        return l
    }
    function Xu(e, t, n, r, o) {
        let i = n ? e.doc.nodeAt(n - 1) : e.doc;
        if (!i)
            throw new Error("No table found");
        let s = Mu.get(i);
        const { top: a, left: l } = r
            , c = l + o.width
            , u = a + o.height
            , h = e.tr;
        let p = 0;
        function f() {
            if (i = n ? h.doc.nodeAt(n - 1) : h.doc,
                !i)
                throw new Error("No table found");
            s = Mu.get(i),
                p = h.mapping.maps.length
        }
        (function (e, t, n, r, o, i, s) {
            const a = Nu(e.doc.type.schema);
            let l, c;
            if (o > t.width)
                for (let d = 0, u = 0; d < t.height; d++) {
                    const i = n.child(d);
                    u += i.nodeSize;
                    const h = [];
                    let p;
                    p = null == i.lastChild || i.lastChild.type == a.cell ? l || (l = a.cell.createAndFill()) : c || (c = a.header_cell.createAndFill());
                    for (let e = t.width; e < o; e++)
                        h.push(p);
                    e.insert(e.mapping.slice(s).map(u - 1 + r), h)
                }
            if (i > t.height) {
                const u = [];
                for (let e = 0, r = (t.height - 1) * t.width; e < Math.max(t.width, o); e++) {
                    const o = !(e >= t.width) && n.nodeAt(t.map[r + e]).type == a.header_cell;
                    u.push(o ? c || (c = a.header_cell.createAndFill()) : l || (l = a.cell.createAndFill()))
                }
                const h = a.row.create(null, d.from(u))
                    , p = [];
                for (let e = t.height; e < i; e++)
                    p.push(h);
                e.insert(e.mapping.slice(s).map(r + n.nodeSize - 2), p)
            }
            return !(!l && !c)
        }
        )(h, s, i, n, c, u, p) && f(),
            Ju(h, s, i, n, l, c, a, p) && f(),
            Ju(h, s, i, n, l, c, u, p) && f(),
            Zu(h, s, i, n, a, u, l, p) && f(),
            Zu(h, s, i, n, a, u, c, p) && f();
        for (let d = a; d < u; d++) {
            const e = s.positionAt(d, l, i)
                , t = s.positionAt(d, c, i);
            h.replace(h.mapping.slice(p).map(e + n), h.mapping.slice(p).map(t + n), new g(o.rows[d - a], 0, 0))
        }
        f(),
            h.setSelection(new ju(h.doc.resolve(n + s.positionAt(a, l, i)), h.doc.resolve(n + s.positionAt(u - 1, c - 1, i)))),
            t(h)
    }
    var Qu = ni({
        ArrowLeft: eh("horiz", -1),
        ArrowRight: eh("horiz", 1),
        ArrowUp: eh("vert", -1),
        ArrowDown: eh("vert", 1),
        "Shift-ArrowLeft": th("horiz", -1),
        "Shift-ArrowRight": th("horiz", 1),
        "Shift-ArrowUp": th("vert", -1),
        "Shift-ArrowDown": th("vert", 1),
        Backspace: qu,
        "Mod-Backspace": qu,
        Delete: qu,
        "Mod-Delete": qu
    });
    function Yu(e, t, n) {
        return !n.eq(e.selection) && (t && t(e.tr.setSelection(n).scrollIntoView()),
            !0)
    }
    function eh(e, t) {
        return (n, r, o) => {
            if (!o)
                return !1;
            const i = n.selection;
            if (i instanceof ju)
                return Yu(n, r, at.near(i.$headCell, t));
            if ("horiz" != e && !i.empty)
                return !1;
            const s = ih(o, e, t);
            if (null == s)
                return !1;
            if ("horiz" == e)
                return Yu(n, r, at.near(n.doc.resolve(i.head + t), t));
            {
                const o = n.doc.resolve(s)
                    , i = Du(o, e, t);
                let a;
                return a = i ? at.near(i, 1) : t < 0 ? at.near(n.doc.resolve(o.before(-1)), -1) : at.near(n.doc.resolve(o.after(-1)), 1),
                    Yu(n, r, a)
            }
        }
    }
    function th(e, t) {
        return (n, r, o) => {
            if (!o)
                return !1;
            const i = n.selection;
            let s;
            if (i instanceof ju)
                s = i;
            else {
                const r = ih(o, e, t);
                if (null == r)
                    return !1;
                s = new ju(n.doc.resolve(r))
            }
            const a = Du(s.$headCell, e, t);
            return !!a && Yu(n, r, new ju(s.$anchorCell, a))
        }
    }
    function nh(e, t) {
        const n = Ou(e.state.doc.resolve(t));
        return !!n && (e.dispatch(e.state.tr.setSelection(new ju(n))),
            !0)
    }
    function rh(e, t, n) {
        if (!Au(e.state))
            return !1;
        let r = Gu(n);
        const o = e.state.selection;
        if (o instanceof ju) {
            r || (r = {
                width: 1,
                height: 1,
                rows: [d.from(Ku(Nu(e.state.schema).cell, n))]
            });
            const t = o.$anchorCell.node(-1)
                , i = o.$anchorCell.start(-1)
                , s = Mu.get(t).rectBetween(o.$anchorCell.pos - i, o.$headCell.pos - i);
            return r = function (e, t, n) {
                let { width: r, height: o, rows: i } = e;
                if (r != t) {
                    const e = []
                        , n = [];
                    for (let r = 0; r < i.length; r++) {
                        const o = i[r]
                            , s = [];
                        for (let n = e[r] || 0, i = 0; n < t; i++) {
                            let a = o.child(i % o.childCount);
                            n + a.attrs.colspan > t && (a = a.type.createChecked(Iu(a.attrs, a.attrs.colspan, n + a.attrs.colspan - t), a.content)),
                                s.push(a),
                                n += a.attrs.colspan;
                            for (let t = 1; t < a.attrs.rowspan; t++)
                                e[r + t] = (e[r + t] || 0) + a.attrs.colspan
                        }
                        n.push(d.from(s))
                    }
                    i = n,
                        r = t
                }
                if (o != n) {
                    const e = [];
                    for (let t = 0, r = 0; t < n; t++,
                        r++) {
                        const s = []
                            , a = i[r % o];
                        for (let e = 0; e < a.childCount; e++) {
                            let r = a.child(e);
                            t + r.attrs.rowspan > n && (r = r.type.create({
                                ...r.attrs,
                                rowspan: Math.max(1, n - r.attrs.rowspan)
                            }, r.content)),
                                s.push(r)
                        }
                        e.push(d.from(s))
                    }
                    i = e,
                        o = n
                }
                return {
                    width: r,
                    height: o,
                    rows: i
                }
            }(r, s.right - s.left, s.bottom - s.top),
                Xu(e.state, e.dispatch, i, s, r),
                !0
        }
        if (r) {
            const t = Pu(e.state)
                , n = t.start(-1);
            return Xu(e.state, e.dispatch, n, Mu.get(t.node(-1)).findCell(t.pos - n), r),
                !0
        }
        return !1
    }
    function oh(e, t) {
        var n;
        if (t.ctrlKey || t.metaKey)
            return;
        const r = sh(e, t.target);
        let o;
        if (t.shiftKey && e.state.selection instanceof ju)
            i(e.state.selection.$anchorCell, t),
                t.preventDefault();
        else if (t.shiftKey && r && null != (o = Ou(e.state.selection.$anchor)) && (null == (n = ah(e, t)) ? void 0 : n.pos) != o.pos)
            i(o, t),
                t.preventDefault();
        else if (!r)
            return;
        function i(t, n) {
            let r = ah(e, n);
            const o = null == _u.getState(e.state);
            if (!r || !Ru(t, r)) {
                if (!o)
                    return;
                r = t
            }
            const i = new ju(t, r);
            if (o || !e.state.selection.eq(i)) {
                const n = e.state.tr.setSelection(i);
                o && n.setMeta(_u, t.pos),
                    e.dispatch(n)
            }
        }
        function s() {
            e.root.removeEventListener("mouseup", s),
                e.root.removeEventListener("dragstart", s),
                e.root.removeEventListener("mousemove", a),
                null != _u.getState(e.state) && e.dispatch(e.state.tr.setMeta(_u, -1))
        }
        function a(n) {
            const o = n
                , a = _u.getState(e.state);
            let l;
            if (null != a)
                l = e.state.doc.resolve(a);
            else if (sh(e, o.target) != r && (l = ah(e, t),
                !l))
                return s();
            l && i(l, o)
        }
        e.root.addEventListener("mouseup", s),
            e.root.addEventListener("dragstart", s),
            e.root.addEventListener("mousemove", a)
    }
    function ih(e, t, n) {
        if (!(e.state.selection instanceof ut))
            return null;
        const { $head: r } = e.state.selection;
        for (let o = r.depth - 1; o >= 0; o--) {
            const i = r.node(o);
            if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount))
                return null;
            if ("cell" == i.type.spec.tableRole || "header_cell" == i.type.spec.tableRole) {
                const i = r.before(o)
                    , s = "vert" == t ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
                return e.endOfTextblock(s) ? i : null
            }
        }
        return null
    }
    function sh(e, t) {
        for (; t && t != e.dom; t = t.parentNode)
            if ("TD" == t.nodeName || "TH" == t.nodeName)
                return t;
        return null
    }
    function ah(e, t) {
        const n = e.posAtCoords({
            left: t.clientX,
            top: t.clientY
        });
        return n && n ? Ou(e.state.doc.resolve(n.pos)) : null
    }
    var lh = class {
        constructor(e, t) {
            this.node = e,
                this.defaultCellMinWidth = t,
                this.dom = document.createElement("div"),
                this.dom.className = "tableWrapper",
                this.table = this.dom.appendChild(document.createElement("table")),
                this.table.style.setProperty("--default-cell-min-width", `${t}px`),
                this.colgroup = this.table.appendChild(document.createElement("colgroup")),
                ch(e, this.colgroup, this.table, t),
                this.contentDOM = this.table.appendChild(document.createElement("tbody"))
        }
        update(e) {
            return e.type == this.node.type && (this.node = e,
                ch(e, this.colgroup, this.table, this.defaultCellMinWidth),
                !0)
        }
        ignoreMutation(e) {
            return "attributes" == e.type && (e.target == this.table || this.colgroup.contains(e.target))
        }
    }
        ;
    function ch(e, t, n, r, o, i) {
        var s;
        let a = 0
            , l = !0
            , c = t.firstChild;
        const d = e.firstChild;
        if (d) {
            for (let e = 0, n = 0; e < d.childCount; e++) {
                const { colspan: s, colwidth: u } = d.child(e).attrs;
                for (let e = 0; e < s; e++,
                    n++) {
                    const s = o == n ? i : u && u[e]
                        , d = s ? s + "px" : "";
                    if (a += s || r,
                        s || (l = !1),
                        c)
                        c.style.width != d && (c.style.width = d),
                            c = c.nextSibling;
                    else {
                        const e = document.createElement("col");
                        e.style.width = d,
                            t.appendChild(e)
                    }
                }
            }
            for (; c;) {
                const e = c.nextSibling;
                null == (s = c.parentNode) || s.removeChild(c),
                    c = e
            }
            l ? (n.style.width = a + "px",
                n.style.minWidth = "") : (n.style.width = "",
                    n.style.minWidth = a + "px")
        }
    }
    var dh = new _t("tableColumnResizing");
    function uh() {
        let { handleWidth: e = 5, cellMinWidth: t = 25, defaultCellMinWidth: n = 100, View: r = lh, lastColumnResizable: o = !0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const i = new Mt({
            key: dh,
            state: {
                init(e, t) {
                    var o, s;
                    const a = null == (s = null == (o = i.spec) ? void 0 : o.props) ? void 0 : s.nodeViews
                        , l = Nu(t.schema).table.name;
                    return r && a && (a[l] = (e, t) => new r(e, n, t)),
                        new hh(-1, !1)
                },
                apply: (e, t) => t.apply(e)
            },
            props: {
                attributes: e => {
                    const t = dh.getState(e);
                    return t && t.activeHandle > -1 ? {
                        class: "resize-cursor"
                    } : {}
                }
                ,
                handleDOMEvents: {
                    mousemove: (t, n) => {
                        !function (e, t, n, r) {
                            const o = dh.getState(e.state);
                            if (!o)
                                return;
                            if (!o.dragging) {
                                const i = function (e) {
                                    for (; e && "TD" != e.nodeName && "TH" != e.nodeName;)
                                        e = e.classList && e.classList.contains("ProseMirror") ? null : e.parentNode;
                                    return e
                                }(t.target);
                                let s = -1;
                                if (i) {
                                    const { left: r, right: o } = i.getBoundingClientRect();
                                    t.clientX - r <= n ? s = ph(e, t, "left", n) : o - t.clientX <= n && (s = ph(e, t, "right", n))
                                }
                                if (s != o.activeHandle) {
                                    if (!r && -1 !== s) {
                                        const t = e.state.doc.resolve(s)
                                            , n = t.node(-1)
                                            , r = Mu.get(n)
                                            , o = t.start(-1);
                                        if (r.colCount(t.pos - o) + t.nodeAfter.attrs.colspan - 1 == r.width - 1)
                                            return
                                    }
                                    mh(e, s)
                                }
                            }
                        }(t, n, e, o)
                    }
                    ,
                    mouseleave: e => {
                        !function (e) {
                            const t = dh.getState(e.state);
                            t && t.activeHandle > -1 && !t.dragging && mh(e, -1)
                        }(e)
                    }
                    ,
                    mousedown: (e, r) => {
                        !function (e, t, n, r) {
                            var o;
                            const i = null != (o = e.dom.ownerDocument.defaultView) ? o : window
                                , s = dh.getState(e.state);
                            if (!s || -1 == s.activeHandle || s.dragging)
                                return !1;
                            const a = e.state.doc.nodeAt(s.activeHandle)
                                , l = function (e, t, n) {
                                    let { colspan: r, colwidth: o } = n;
                                    const i = o && o[o.length - 1];
                                    if (i)
                                        return i;
                                    const s = e.domAtPos(t);
                                    let a = s.node.childNodes[s.offset].offsetWidth
                                        , l = r;
                                    if (o)
                                        for (let c = 0; c < r; c++)
                                            o[c] && (a -= o[c],
                                                l--);
                                    return a / l
                                }(e, s.activeHandle, a.attrs);
                            function c(t) {
                                i.removeEventListener("mouseup", c),
                                    i.removeEventListener("mousemove", d);
                                const r = dh.getState(e.state);
                                (null == r ? void 0 : r.dragging) && (!function (e, t, n) {
                                    const r = e.state.doc.resolve(t)
                                        , o = r.node(-1)
                                        , i = Mu.get(o)
                                        , s = r.start(-1)
                                        , a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1
                                        , l = e.state.tr;
                                    for (let c = 0; c < i.height; c++) {
                                        const e = c * i.width + a;
                                        if (c && i.map[e] == i.map[e - i.width])
                                            continue;
                                        const t = i.map[e]
                                            , r = o.nodeAt(t).attrs
                                            , d = 1 == r.colspan ? 0 : a - i.colCount(t);
                                        if (r.colwidth && r.colwidth[d] == n)
                                            continue;
                                        const u = r.colwidth ? r.colwidth.slice() : bh(r.colspan);
                                        u[d] = n,
                                            l.setNodeMarkup(s + t, null, {
                                                ...r,
                                                colwidth: u
                                            })
                                    }
                                    l.docChanged && e.dispatch(l)
                                }(e, r.activeHandle, fh(r.dragging, t, n)),
                                    e.dispatch(e.state.tr.setMeta(dh, {
                                        setDragging: null
                                    })))
                            }
                            function d(t) {
                                if (!t.which)
                                    return c(t);
                                const o = dh.getState(e.state);
                                if (o && o.dragging) {
                                    const i = fh(o.dragging, t, n);
                                    gh(e, o.activeHandle, i, r)
                                }
                            }
                            e.dispatch(e.state.tr.setMeta(dh, {
                                setDragging: {
                                    startX: t.clientX,
                                    startWidth: l
                                }
                            })),
                                gh(e, s.activeHandle, l, r),
                                i.addEventListener("mouseup", c),
                                i.addEventListener("mousemove", d),
                                t.preventDefault()
                        }(e, r, t, n)
                    }
                },
                decorations: e => {
                    const t = dh.getState(e);
                    if (t && t.activeHandle > -1)
                        return function (e, t) {
                            var n;
                            const r = []
                                , o = e.doc.resolve(t)
                                , i = o.node(-1);
                            if (!i)
                                return mo.empty;
                            const s = Mu.get(i)
                                , a = o.start(-1)
                                , l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
                            for (let c = 0; c < s.height; c++) {
                                const t = l + c * s.width;
                                if ((l == s.width - 1 || s.map[t] != s.map[t + 1]) && (0 == c || s.map[t] != s.map[t - s.width])) {
                                    const o = s.map[t]
                                        , l = a + o + i.nodeAt(o).nodeSize - 1
                                        , c = document.createElement("div");
                                    c.className = "column-resize-handle",
                                        (null == (n = dh.getState(e)) ? void 0 : n.dragging) && r.push(ho.node(a + o, a + o + i.nodeAt(o).nodeSize, {
                                            class: "column-resize-dragging"
                                        })),
                                        r.push(ho.widget(l, c))
                                }
                            }
                            return mo.create(e.doc, r)
                        }(e, t.activeHandle)
                }
                ,
                nodeViews: {}
            }
        });
        return i
    }
    var hh = class e {
        constructor(e, t) {
            this.activeHandle = e,
                this.dragging = t
        }
        apply(t) {
            const n = this
                , r = t.getMeta(dh);
            if (r && null != r.setHandle)
                return new e(r.setHandle, !1);
            if (r && void 0 !== r.setDragging)
                return new e(n.activeHandle, r.setDragging);
            if (n.activeHandle > -1 && t.docChanged) {
                let r = t.mapping.map(n.activeHandle, -1);
                return Lu(t.doc.resolve(r)) || (r = -1),
                    new e(r, n.dragging)
            }
            return n
        }
    }
        ;
    function ph(e, t, n, r) {
        const o = "right" == n ? -r : r
            , i = e.posAtCoords({
                left: t.clientX + o,
                top: t.clientY
            });
        if (!i)
            return -1;
        const { pos: s } = i
            , a = Ou(e.state.doc.resolve(s));
        if (!a)
            return -1;
        if ("right" == n)
            return a.pos;
        const l = Mu.get(a.node(-1))
            , c = a.start(-1)
            , d = l.map.indexOf(a.pos - c);
        return d % l.width == 0 ? -1 : c + l.map[d - 1]
    }
    function fh(e, t, n) {
        const r = t.clientX - e.startX;
        return Math.max(n, e.startWidth + r)
    }
    function mh(e, t) {
        e.dispatch(e.state.tr.setMeta(dh, {
            setHandle: t
        }))
    }
    function gh(e, t, n, r) {
        const o = e.state.doc.resolve(t)
            , i = o.node(-1)
            , s = o.start(-1)
            , a = Mu.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
        let l = e.domAtPos(o.start(-1)).node;
        for (; l && "TABLE" != l.nodeName;)
            l = l.parentNode;
        l && ch(i, l.firstChild, l, r, a, n)
    }
    function bh(e) {
        return Array(e).fill(0)
    }
    function yh() {
        let { allowTableNodeSelection: e = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return new Mt({
            key: _u,
            state: {
                init: () => null,
                apply(e, t) {
                    const n = e.getMeta(_u);
                    if (null != n)
                        return -1 == n ? null : n;
                    if (null == t || !e.docChanged)
                        return t;
                    const { deleted: r, pos: o } = e.mapping.mapResult(t);
                    return r ? null : o
                }
            },
            props: {
                decorations: zu,
                handleDOMEvents: {
                    mousedown: oh
                },
                createSelectionBetween: e => null != _u.getState(e.state) ? e.state.selection : null,
                handleTripleClick: nh,
                handleKeyDown: Qu,
                handlePaste: rh
            },
            appendTransaction: (t, n, r) => function (e, t, n) {
                const r = (t || e).selection
                    , o = (t || e).doc;
                let i, s;
                if (r instanceof pt && (s = r.node.type.spec.tableRole)) {
                    if ("cell" == s || "header_cell" == s)
                        i = ju.create(o, r.from);
                    else if ("row" == s) {
                        const e = o.resolve(r.from + 1);
                        i = ju.rowSelection(e, e)
                    } else if (!n) {
                        const e = Mu.get(r.node)
                            , t = r.from + 1
                            , n = t + e.map[e.width * e.height - 1];
                        i = ju.create(o, t + 1, n)
                    }
                } else
                    r instanceof ut && function (e) {
                        let { $from: t, $to: n } = e;
                        if (t.pos == n.pos || t.pos < n.pos - 6)
                            return !1;
                        let r = t.pos
                            , o = n.pos
                            , i = t.depth;
                        for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--,
                            r++)
                            ;
                        for (let s = n.depth; s >= 0 && !(n.before(s + 1) > n.start(s)); s--,
                            o--)
                            ;
                        return r == o && /row|table/.test(t.node(i).type.spec.tableRole)
                    }(r) ? i = ut.create(o, r.from) : r instanceof ut && function (e) {
                        let t, n, { $from: r, $to: o } = e;
                        for (let i = r.depth; i > 0; i--) {
                            const e = r.node(i);
                            if ("cell" === e.type.spec.tableRole || "header_cell" === e.type.spec.tableRole) {
                                t = e;
                                break
                            }
                        }
                        for (let i = o.depth; i > 0; i--) {
                            const e = o.node(i);
                            if ("cell" === e.type.spec.tableRole || "header_cell" === e.type.spec.tableRole) {
                                n = e;
                                break
                            }
                        }
                        return t !== n && 0 === o.parentOffset
                    }(r) && (i = ut.create(o, r.$from.start(), r.$from.end()));
                return i && (t || (t = e.tr)).setSelection(i),
                    t
            }(r, Vu(r, n), e)
        })
    }
    const vh = new _t("y-sync")
        , wh = new _t("y-undo")
        , kh = new _t("yjs-cursor")
        , Ch = Math.floor
        , Sh = (Math.ceil,
            Math.abs)
        , xh = (Math.imul,
            Math.round,
            Math.log10,
            Math.log2,
            Math.log,
            Math.sqrt,
            (e, t) => e < t ? e : t)
        , Eh = (e, t) => e > t ? e : t
        , Mh = (Number.isNaN,
            Math.pow,
            Math.sign,
            e => 0 !== e ? e < 0 : 1 / e < 0)
        , Th = Object.assign
        , Nh = Object.keys
        , _h = e => Nh(e).length
        , Oh = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        , Ah = Object.freeze
        , Ph = e => {
            for (const t in e) {
                const n = e[t];
                "object" !== typeof n && "function" !== typeof n || Ph(e[t])
            }
            return Ah(e)
        }
        , Lh = () => new Set
        , Rh = /[\uD800-\uDBFF]/
        , Dh = /[\uDC00-\uDFFF]/
        , Ih = (e, t) => {
            let n = 0
                , r = 0;
            for (; n < e.length && n < t.length && e[n] === t[n];)
                n++;
            for (n > 0 && Rh.test(e[n - 1]) && n--; r + n < e.length && r + n < t.length && e[e.length - r - 1] === t[t.length - r - 1];)
                r++;
            return r > 0 && Dh.test(e[e.length - r]) && r--,
            {
                index: n,
                remove: e.length - n - r,
                insert: t.slice(n, t.length - r)
            }
        }
        , jh = e => new Error(e)
        , Hh = () => {
            throw jh("Method unimplemented")
        }
        , zh = () => {
            throw jh("Unexpected case")
        }
        , $h = () => new Map
        , Bh = e => {
            const t = $h();
            return e.forEach(((e, n) => {
                t.set(n, e)
            }
            )),
                t
        }
        , Vh = (e, t, n) => {
            let r = e.get(t);
            return void 0 === r && e.set(t, r = n()),
                r
        }
        , Fh = e => e[e.length - 1]
        , Uh = (e, t) => {
            for (let n = 0; n < t.length; n++)
                e.push(t[n])
        }
        , Wh = Array.from
        , qh = Array.isArray;
    class Gh {
        constructor() {
            this._observers = $h()
        }
        on(e, t) {
            return Vh(this._observers, e, Lh).add(t),
                t
        }
        once(e, t) {
            var n = this;
            const r = function () {
                n.off(e, r),
                    t(...arguments)
            };
            this.on(e, r)
        }
        off(e, t) {
            const n = this._observers.get(e);
            void 0 !== n && (n.delete(t),
                0 === n.size && this._observers.delete(e))
        }
        emit(e, t) {
            return Wh((this._observers.get(e) || $h()).values()).forEach((e => e(...t)))
        }
        destroy() {
            this._observers = $h()
        }
    }
    const Kh = 64
        , Jh = 128
        , Zh = 127
        , Xh = 2147483647
        , Qh = Number.MAX_SAFE_INTEGER
        , Yh = (Number.MIN_SAFE_INTEGER,
            Number.isInteger || (e => "number" === typeof e && isFinite(e) && Ch(e) === e))
        , ep = (Number.isNaN,
            Number.parseInt,
            String.fromCharCode)
        , tp = (String.fromCodePoint,
            ep(65535),
            /^\s*/g)
        , np = /([A-Z])/g
        , rp = (e, t) => (e => e.replace(tp, ""))(e.replace(np, (e => `${t}${(e => e.toLowerCase())(e)}`)))
        , op = "undefined" !== typeof TextEncoder ? new TextEncoder : null
        , ip = op ? e => op.encode(e) : e => {
            const t = unescape(encodeURIComponent(e))
                , n = t.length
                , r = new Uint8Array(n);
            for (let o = 0; o < n; o++)
                r[o] = t.codePointAt(o);
            return r
        }
        ;
    let sp = "undefined" === typeof TextDecoder ? null : new TextDecoder("utf-8", {
        fatal: !0,
        ignoreBOM: !0
    });
    sp && 1 === sp.decode(new Uint8Array).length && (sp = null);
    class ap {
        constructor() {
            this.cpos = 0,
                this.cbuf = new Uint8Array(100),
                this.bufs = []
        }
    }
    const lp = () => new ap
        , cp = e => {
            const t = new Uint8Array((e => {
                let t = e.cpos;
                for (let n = 0; n < e.bufs.length; n++)
                    t += e.bufs[n].length;
                return t
            }
            )(e));
            let n = 0;
            for (let r = 0; r < e.bufs.length; r++) {
                const o = e.bufs[r];
                t.set(o, n),
                    n += o.length
            }
            return t.set(new Uint8Array(e.cbuf.buffer, 0, e.cpos), n),
                t
        }
        , dp = (e, t) => {
            const n = e.cbuf.length;
            e.cpos === n && (e.bufs.push(e.cbuf),
                e.cbuf = new Uint8Array(2 * n),
                e.cpos = 0),
                e.cbuf[e.cpos++] = t
        }
        , up = dp
        , hp = (e, t) => {
            for (; t > Zh;)
                dp(e, Jh | Zh & t),
                    t = Ch(t / 128);
            dp(e, Zh & t)
        }
        , pp = (e, t) => {
            const n = Mh(t);
            for (n && (t = -t),
                dp(e, (t > 63 ? Jh : 0) | (n ? Kh : 0) | 63 & t),
                t = Ch(t / 64); t > 0;)
                dp(e, (t > Zh ? Jh : 0) | Zh & t),
                    t = Ch(t / 128)
        }
        , fp = new Uint8Array(3e4)
        , mp = fp.length / 3
        , gp = op && op.encodeInto ? (e, t) => {
            if (t.length < mp) {
                const n = op.encodeInto(t, fp).written || 0;
                hp(e, n);
                for (let t = 0; t < n; t++)
                    dp(e, fp[t])
            } else
                yp(e, ip(t))
        }
            : (e, t) => {
                const n = unescape(encodeURIComponent(t))
                    , r = n.length;
                hp(e, r);
                for (let o = 0; o < r; o++)
                    dp(e, n.codePointAt(o))
            }
        , bp = (e, t) => {
            const n = e.cbuf.length
                , r = e.cpos
                , o = xh(n - r, t.length)
                , i = t.length - o;
            e.cbuf.set(t.subarray(0, o), r),
                e.cpos += o,
                i > 0 && (e.bufs.push(e.cbuf),
                    e.cbuf = new Uint8Array(Eh(2 * n, i)),
                    e.cbuf.set(t.subarray(o)),
                    e.cpos = i)
        }
        , yp = (e, t) => {
            hp(e, t.byteLength),
                bp(e, t)
        }
        , vp = (e, t) => {
            ((e, t) => {
                const n = e.cbuf.length;
                n - e.cpos < t && (e.bufs.push(new Uint8Array(e.cbuf.buffer, 0, e.cpos)),
                    e.cbuf = new Uint8Array(2 * Eh(n, t)),
                    e.cpos = 0)
            }
            )(e, t);
            const n = new DataView(e.cbuf.buffer, e.cpos, t);
            return e.cpos += t,
                n
        }
        , wp = new DataView(new ArrayBuffer(4))
        , kp = (e, t) => {
            switch (typeof t) {
                case "string":
                    dp(e, 119),
                        gp(e, t);
                    break;
                case "number":
                    Yh(t) && Sh(t) <= Xh ? (dp(e, 125),
                        pp(e, t)) : (n = t,
                            wp.setFloat32(0, n),
                            wp.getFloat32(0) === n ? (dp(e, 124),
                                ((e, t) => {
                                    vp(e, 4).setFloat32(0, t, !1)
                                }
                                )(e, t)) : (dp(e, 123),
                                    ((e, t) => {
                                        vp(e, 8).setFloat64(0, t, !1)
                                    }
                                    )(e, t)));
                    break;
                case "bigint":
                    dp(e, 122),
                        ((e, t) => {
                            vp(e, 8).setBigInt64(0, t, !1)
                        }
                        )(e, t);
                    break;
                case "object":
                    if (null === t)
                        dp(e, 126);
                    else if (qh(t)) {
                        dp(e, 117),
                            hp(e, t.length);
                        for (let n = 0; n < t.length; n++)
                            kp(e, t[n])
                    } else if (t instanceof Uint8Array)
                        dp(e, 116),
                            yp(e, t);
                    else {
                        dp(e, 118);
                        const n = Object.keys(t);
                        hp(e, n.length);
                        for (let r = 0; r < n.length; r++) {
                            const o = n[r];
                            gp(e, o),
                                kp(e, t[o])
                        }
                    }
                    break;
                case "boolean":
                    dp(e, t ? 120 : 121);
                    break;
                default:
                    dp(e, 127)
            }
            var n
        }
        ;
    class Cp extends ap {
        constructor(e) {
            super(),
                this.w = e,
                this.s = null,
                this.count = 0
        }
        write(e) {
            this.s === e ? this.count++ : (this.count > 0 && hp(this, this.count - 1),
                this.count = 1,
                this.w(this, e),
                this.s = e)
        }
    }
    const Sp = e => {
        e.count > 0 && (pp(e.encoder, 1 === e.count ? e.s : -e.s),
            e.count > 1 && hp(e.encoder, e.count - 2))
    }
        ;
    class xp {
        constructor() {
            this.encoder = new ap,
                this.s = 0,
                this.count = 0
        }
        write(e) {
            this.s === e ? this.count++ : (Sp(this),
                this.count = 1,
                this.s = e)
        }
        toUint8Array() {
            return Sp(this),
                cp(this.encoder)
        }
    }
    const Ep = e => {
        if (e.count > 0) {
            const t = 2 * e.diff + (1 === e.count ? 0 : 1);
            pp(e.encoder, t),
                e.count > 1 && hp(e.encoder, e.count - 2)
        }
    }
        ;
    class Mp {
        constructor() {
            this.encoder = new ap,
                this.s = 0,
                this.count = 0,
                this.diff = 0
        }
        write(e) {
            this.diff === e - this.s ? (this.s = e,
                this.count++) : (Ep(this),
                    this.count = 1,
                    this.diff = e - this.s,
                    this.s = e)
        }
        toUint8Array() {
            return Ep(this),
                cp(this.encoder)
        }
    }
    class Tp {
        constructor() {
            this.sarr = [],
                this.s = "",
                this.lensE = new xp
        }
        write(e) {
            this.s += e,
                this.s.length > 19 && (this.sarr.push(this.s),
                    this.s = ""),
                this.lensE.write(e.length)
        }
        toUint8Array() {
            const e = new ap;
            return this.sarr.push(this.s),
                this.s = "",
                gp(e, this.sarr.join("")),
                bp(e, this.lensE.toUint8Array()),
                cp(e)
        }
    }
    const Np = jh("Unexpected end of array")
        , _p = jh("Integer out of Range");
    class Op {
        constructor(e) {
            this.arr = e,
                this.pos = 0
        }
    }
    const Ap = e => new Op(e)
        , Pp = e => e.pos !== e.arr.length
        , Lp = (e, t) => {
            const n = new Uint8Array(e.arr.buffer, e.pos + e.arr.byteOffset, t);
            return e.pos += t,
                n
        }
        , Rp = e => Lp(e, Ip(e))
        , Dp = e => e.arr[e.pos++]
        , Ip = e => {
            let t = 0
                , n = 1;
            const r = e.arr.length;
            for (; e.pos < r;) {
                const r = e.arr[e.pos++];
                if (t += (r & Zh) * n,
                    n *= 128,
                    r < Jh)
                    return t;
                if (t > Qh)
                    throw _p
            }
            throw Np
        }
        , jp = e => {
            let t = e.arr[e.pos++]
                , n = 63 & t
                , r = 64;
            const o = (t & Kh) > 0 ? -1 : 1;
            if (0 === (t & Jh))
                return o * n;
            const i = e.arr.length;
            for (; e.pos < i;) {
                if (t = e.arr[e.pos++],
                    n += (t & Zh) * r,
                    r *= 128,
                    t < Jh)
                    return o * n;
                if (n > Qh)
                    throw _p
            }
            throw Np
        }
        , Hp = sp ? e => sp.decode(Rp(e)) : e => {
            let t = Ip(e);
            if (0 === t)
                return "";
            {
                let n = String.fromCodePoint(Dp(e));
                if (--t < 100)
                    for (; t--;)
                        n += String.fromCodePoint(Dp(e));
                else
                    for (; t > 0;) {
                        const r = t < 1e4 ? t : 1e4
                            , o = e.arr.subarray(e.pos, e.pos + r);
                        e.pos += r,
                            n += String.fromCodePoint.apply(null, o),
                            t -= r
                    }
                return decodeURIComponent(escape(n))
            }
        }
        , zp = (e, t) => {
            const n = new DataView(e.arr.buffer, e.arr.byteOffset + e.pos, t);
            return e.pos += t,
                n
        }
        , $p = [e => { }
            , e => null, jp, e => zp(e, 4).getFloat32(0, !1), e => zp(e, 8).getFloat64(0, !1), e => zp(e, 8).getBigInt64(0, !1), e => !1, e => !0, Hp, e => {
                const t = Ip(e)
                    , n = {};
                for (let r = 0; r < t; r++) {
                    n[Hp(e)] = Bp(e)
                }
                return n
            }
            , e => {
                const t = Ip(e)
                    , n = [];
                for (let r = 0; r < t; r++)
                    n.push(Bp(e));
                return n
            }
            , Rp]
        , Bp = e => $p[127 - Dp(e)](e);
    class Vp extends Op {
        constructor(e, t) {
            super(e),
                this.reader = t,
                this.s = null,
                this.count = 0
        }
        read() {
            return 0 === this.count && (this.s = this.reader(this),
                Pp(this) ? this.count = Ip(this) + 1 : this.count = -1),
                this.count--,
                this.s
        }
    }
    class Fp extends Op {
        constructor(e) {
            super(e),
                this.s = 0,
                this.count = 0
        }
        read() {
            if (0 === this.count) {
                this.s = jp(this);
                const e = Mh(this.s);
                this.count = 1,
                    e && (this.s = -this.s,
                        this.count = Ip(this) + 2)
            }
            return this.count--,
                this.s
        }
    }
    class Up extends Op {
        constructor(e) {
            super(e),
                this.s = 0,
                this.count = 0,
                this.diff = 0
        }
        read() {
            if (0 === this.count) {
                const e = jp(this)
                    , t = 1 & e;
                this.diff = Ch(e / 2),
                    this.count = 1,
                    t && (this.count = Ip(this) + 2)
            }
            return this.s += this.diff,
                this.count--,
                this.s
        }
    }
    class Wp {
        constructor(e) {
            this.decoder = new Fp(e),
                this.str = Hp(this.decoder),
                this.spos = 0
        }
        read() {
            const e = this.spos + this.decoder.read()
                , t = this.str.slice(this.spos, e);
            return this.spos = e,
                t
        }
    }
    crypto.subtle;
    const qp = crypto.getRandomValues.bind(crypto)
        , Gp = Math.random
        , Kp = () => qp(new Uint32Array(1))[0]
        , Jp = [1e7] + -1e3 + -4e3 + -8e3 + -1e11
        , Zp = () => Jp.replace(/[018]/g, (e => (e ^ Kp() & 15 >> e / 4).toString(16)))
        , Xp = e => new Promise(e)
        , Qp = (Promise.all.bind(Promise),
            function (e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                try {
                    for (; n < e.length; n++)
                        e[n](...t)
                } finally {
                    n < e.length && Qp(e, t, n + 1)
                }
            }
        )
        , Yp = e => void 0 === e ? null : e;
    let ef = new class {
        constructor() {
            this.map = new Map
        }
        setItem(e, t) {
            this.map.set(e, t)
        }
        getItem(e) {
            return this.map.get(e)
        }
    }
        , tf = !0;
    try {
        "undefined" !== typeof localStorage && localStorage && (ef = localStorage,
            tf = !1)
    } catch (pj) { }
    const nf = ef
        , rf = "undefined" !== typeof process && process.release && /node|io\.js/.test(process.release.name) && "[object process]" === Object.prototype.toString.call("undefined" !== typeof process ? process : 0)
        , of = "undefined" !== typeof window && "undefined" !== typeof document && !rf;
    "undefined" !== typeof navigator && /Mac/.test(navigator.platform);
    let sf;
    const af = []
        , lf = () => {
            if (void 0 === sf)
                if (rf) {
                    sf = $h();
                    const e = process.argv;
                    let t = null;
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        "-" === r[0] ? (null !== t && sf.set(t, ""),
                            t = r) : null !== t ? (sf.set(t, r),
                                t = null) : af.push(r)
                    }
                    null !== t && sf.set(t, "")
                } else
                    "object" === typeof location ? (sf = $h(),
                        (location.search || "?").slice(1).split("&").forEach((e => {
                            if (0 !== e.length) {
                                const [t, n] = e.split("=");
                                sf.set(`--${rp(t, "-")}`, n),
                                    sf.set(`-${rp(t, "-")}`, n)
                            }
                        }
                        ))) : sf = $h();
            return sf
        }
        , cf = e => lf().has(e)
        , df = e => Yp(rf ? {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0
        }[e.toUpperCase().replaceAll("-", "_")] : nf.getItem(e))
        , uf = e => cf("--" + e) || null !== df(e)
        , hf = (uf("production"),
            rf && ((e, t) => t.includes(e))({
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0
            }.FORCE_COLOR, ["true", "1", "2"]))
        , pf = hf || !cf("--no-colors") && !uf("no-color") && (!rf || process.stdout.isTTY) && (!rf || cf("--color") || null !== df("COLORTERM") || (df("TERM") || "").includes("color"));
    class ff {
        constructor(e, t) {
            this.left = e,
                this.right = t
        }
    }
    const mf = (e, t) => new ff(e, t)
        , gf = "undefined" !== typeof document ? document : {}
        , bf = ("undefined" !== typeof DOMParser && new DOMParser,
            e => ((e, t) => {
                const n = [];
                for (const [r, o] of e)
                    n.push(t(o, r));
                return n
            }
            )(e, ((e, t) => `${t}:${e};`)).join(""))
        , yf = (gf.ELEMENT_NODE,
            gf.TEXT_NODE,
            gf.CDATA_SECTION_NODE,
            gf.COMMENT_NODE,
            gf.DOCUMENT_NODE,
            gf.DOCUMENT_TYPE_NODE,
            gf.DOCUMENT_FRAGMENT_NODE,
            Symbol)
        , vf = Date.now
        , wf = yf()
        , kf = yf()
        , Cf = yf()
        , Sf = yf()
        , xf = yf()
        , Ef = yf()
        , Mf = yf()
        , Tf = yf()
        , Nf = yf();
    vf();
    const _f = {
        [wf]: mf("font-weight", "bold"),
        [kf]: mf("font-weight", "normal"),
        [Cf]: mf("color", "blue"),
        [xf]: mf("color", "green"),
        [Sf]: mf("color", "grey"),
        [Ef]: mf("color", "red"),
        [Mf]: mf("color", "purple"),
        [Tf]: mf("color", "orange"),
        [Nf]: mf("color", "black")
    }
        , Of = pf ? e => {
            1 === e.length && e[0]?.constructor === Function && (e = e[0]());
            const t = []
                , n = []
                , r = $h();
            let o = []
                , i = 0;
            for (; i < e.length; i++) {
                const o = e[i]
                    , s = _f[o];
                if (void 0 !== s)
                    r.set(s.left, s.right);
                else {
                    if (void 0 === o)
                        break;
                    if (o.constructor !== String && o.constructor !== Number)
                        break;
                    {
                        const e = bf(r);
                        i > 0 || e.length > 0 ? (t.push("%c" + o),
                            n.push(e)) : t.push(o)
                    }
                }
            }
            for (i > 0 && (o = n,
                o.unshift(t.join(""))); i < e.length; i++) {
                const t = e[i];
                t instanceof Symbol || o.push(t)
            }
            return o
        }
            : e => {
                1 === e.length && e[0]?.constructor === Function && (e = e[0]());
                const t = []
                    , n = [];
                let r = 0;
                for (; r < e.length; r++) {
                    const n = e[r];
                    if (void 0 === n)
                        break;
                    if (n.constructor === String || n.constructor === Number)
                        t.push(n);
                    else if (n.constructor === Object)
                        break
                }
                for (r > 0 && n.push(t.join("")); r < e.length; r++) {
                    const t = e[r];
                    t instanceof Symbol || n.push(t)
                }
                return n
            }
        , Af = function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            console.log(...Of(t)),
                Lf.forEach((e => e.print(t)))
        }
        , Pf = function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            console.warn(...Of(t)),
                t.unshift(Tf),
                Lf.forEach((e => e.print(t)))
        }
        , Lf = Lh();
    const Rf = e => ({
        [Symbol.iterator]() {
            return this
        },
        next: e
    })
        , Df = (e, t) => Rf((() => {
            const { done: n, value: r } = e.next();
            return {
                done: n,
                value: n ? void 0 : t(r)
            }
        }
        ));
    class If {
        constructor(e, t) {
            this.clock = e,
                this.len = t
        }
    }
    class jf {
        constructor() {
            this.clients = new Map
        }
    }
    const Hf = (e, t, n) => t.clients.forEach(((t, r) => {
        const o = e.doc.store.clients.get(r);
        for (let i = 0; i < t.length; i++) {
            const r = t[i];
            Im(e, o, r.clock, r.len, n)
        }
    }
    ))
        , zf = (e, t) => {
            const n = e.clients.get(t.client);
            return void 0 !== n && null !== ((e, t) => {
                let n = 0
                    , r = e.length - 1;
                for (; n <= r;) {
                    const o = Ch((n + r) / 2)
                        , i = e[o]
                        , s = i.clock;
                    if (s <= t) {
                        if (t < s + i.len)
                            return o;
                        n = o + 1
                    } else
                        r = o - 1
                }
                return null
            }
            )(n, t.clock)
        }
        , $f = e => {
            e.clients.forEach((e => {
                let t, n;
                for (e.sort(((e, t) => e.clock - t.clock)),
                    t = 1,
                    n = 1; t < e.length; t++) {
                    const r = e[n - 1]
                        , o = e[t];
                    r.clock + r.len >= o.clock ? r.len = Eh(r.len, o.clock + o.len - r.clock) : (n < t && (e[n] = o),
                        n++)
                }
                e.length = n
            }
            ))
        }
        , Bf = e => {
            const t = new jf;
            for (let n = 0; n < e.length; n++)
                e[n].clients.forEach(((r, o) => {
                    if (!t.clients.has(o)) {
                        const i = r.slice();
                        for (let t = n + 1; t < e.length; t++)
                            Uh(i, e[t].clients.get(o) || []);
                        t.clients.set(o, i)
                    }
                }
                ));
            return $f(t),
                t
        }
        , Vf = (e, t, n, r) => {
            Vh(e.clients, t, (() => [])).push(new If(n, r))
        }
        , Ff = () => new jf
        , Uf = e => {
            const t = Ff();
            return e.clients.forEach(((e, n) => {
                const r = [];
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    if (n.deleted) {
                        const o = n.id.clock;
                        let i = n.length;
                        if (t + 1 < e.length)
                            for (let n = e[t + 1]; t + 1 < e.length && n.deleted; n = e[1 + ++t])
                                i += n.length;
                        r.push(new If(o, i))
                    }
                }
                r.length > 0 && t.clients.set(n, r)
            }
            )),
                t
        }
        , Wf = (e, t) => {
            hp(e.restEncoder, t.clients.size),
                Wh(t.clients.entries()).sort(((e, t) => t[0] - e[0])).forEach((t => {
                    let [n, r] = t;
                    e.resetDsCurVal(),
                        hp(e.restEncoder, n);
                    const o = r.length;
                    hp(e.restEncoder, o);
                    for (let i = 0; i < o; i++) {
                        const t = r[i];
                        e.writeDsClock(t.clock),
                            e.writeDsLen(t.len)
                    }
                }
                ))
        }
        , qf = e => {
            const t = new jf
                , n = Ip(e.restDecoder);
            for (let r = 0; r < n; r++) {
                e.resetDsCurVal();
                const n = Ip(e.restDecoder)
                    , r = Ip(e.restDecoder);
                if (r > 0) {
                    const o = Vh(t.clients, n, (() => []));
                    for (let t = 0; t < r; t++)
                        o.push(new If(e.readDsClock(), e.readDsLen()))
                }
            }
            return t
        }
        , Gf = (e, t, n) => {
            const r = new jf
                , o = Ip(e.restDecoder);
            for (let i = 0; i < o; i++) {
                e.resetDsCurVal();
                const o = Ip(e.restDecoder)
                    , i = Ip(e.restDecoder)
                    , s = n.clients.get(o) || []
                    , a = _m(n, o);
                for (let n = 0; n < i; n++) {
                    const n = e.readDsClock()
                        , i = n + e.readDsLen();
                    if (n < a) {
                        a < i && Vf(r, o, a, i - a);
                        let e = Am(s, n)
                            , l = s[e];
                        for (!l.deleted && l.id.clock < n && (s.splice(e + 1, 0, Eb(t, l, n - l.id.clock)),
                            e++); e < s.length && (l = s[e++],
                                l.id.clock < i);)
                            l.deleted || (i < l.id.clock + l.length && s.splice(e, 0, Eb(t, l, i - l.id.clock)),
                                l.delete(t))
                    } else
                        Vf(r, o, n, i - n)
                }
            }
            if (r.clients.size > 0) {
                const e = new tm;
                return hp(e.restEncoder, 0),
                    Wf(e, r),
                    e.toUint8Array()
            }
            return null
        }
        , Kf = Kp;
    class Jf extends Gh {
        constructor() {
            let { guid: e = Zp(), collectionid: t = null, gc: n = !0, gcFilter: r = () => !0, meta: o = null, autoLoad: i = !1, shouldLoad: s = !0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            super(),
                this.gc = n,
                this.gcFilter = r,
                this.clientID = Kf(),
                this.guid = e,
                this.collectionid = t,
                this.share = new Map,
                this.store = new Tm,
                this._transaction = null,
                this._transactionCleanups = [],
                this.subdocs = new Set,
                this._item = null,
                this.shouldLoad = s,
                this.autoLoad = i,
                this.meta = o,
                this.isLoaded = !1,
                this.isSynced = !1,
                this.isDestroyed = !1,
                this.whenLoaded = Xp((e => {
                    this.on("load", (() => {
                        this.isLoaded = !0,
                            e(this)
                    }
                    ))
                }
                ));
            const a = () => Xp((e => {
                const t = n => {
                    void 0 !== n && !0 !== n || (this.off("sync", t),
                        e())
                }
                    ;
                this.on("sync", t)
            }
            ));
            this.on("sync", (e => {
                !1 === e && this.isSynced && (this.whenSynced = a()),
                    this.isSynced = void 0 === e || !0 === e,
                    this.isSynced && !this.isLoaded && this.emit("load", [this])
            }
            )),
                this.whenSynced = a()
        }
        load() {
            const e = this._item;
            null === e || this.shouldLoad || Um(e.parent.doc, (e => {
                e.subdocsLoaded.add(this)
            }
            ), null, !0),
                this.shouldLoad = !0
        }
        getSubdocs() {
            return this.subdocs
        }
        getSubdocGuids() {
            return new Set(Wh(this.subdocs).map((e => e.guid)))
        }
        transact(e) {
            return Um(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null)
        }
        get(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : hg;
            const n = Vh(this.share, e, (() => {
                const e = new t;
                return e._integrate(this, null),
                    e
            }
            ))
                , r = n.constructor;
            if (t !== hg && r !== t) {
                if (r === hg) {
                    const r = new t;
                    r._map = n._map,
                        n._map.forEach((e => {
                            for (; null !== e; e = e.left)
                                e.parent = r
                        }
                        )),
                        r._start = n._start;
                    for (let e = r._start; null !== e; e = e.right)
                        e.parent = r;
                    return r._length = n._length,
                        this.share.set(e, r),
                        r._integrate(this, null),
                        r
                }
                throw new Error(`Type with the name ${e} has already been defined with a different constructor`)
            }
            return n
        }
        getArray() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return this.get(e, Ag)
        }
        getText() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return this.get(e, Jg)
        }
        getMap() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return this.get(e, Lg)
        }
        getXmlElement() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return this.get(e, Qg)
        }
        getXmlFragment() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return this.get(e, Xg)
        }
        toJSON() {
            const e = {};
            return this.share.forEach(((t, n) => {
                e[n] = t.toJSON()
            }
            )),
                e
        }
        destroy() {
            this.isDestroyed = !0,
                Wh(this.subdocs).forEach((e => e.destroy()));
            const e = this._item;
            if (null !== e) {
                this._item = null;
                const t = e.content;
                t.doc = new Jf({
                    guid: this.guid,
                    ...t.opts,
                    shouldLoad: !1
                }),
                    t.doc._item = e,
                    Um(e.parent.doc, (n => {
                        const r = t.doc;
                        e.deleted || n.subdocsAdded.add(r),
                            n.subdocsRemoved.add(this)
                    }
                    ), null, !0)
            }
            this.emit("destroyed", [!0]),
                this.emit("destroy", [this]),
                super.destroy()
        }
    }
    class Zf {
        constructor(e) {
            this.dsCurrVal = 0,
                this.restDecoder = e
        }
        resetDsCurVal() {
            this.dsCurrVal = 0
        }
        readDsClock() {
            return this.dsCurrVal += Ip(this.restDecoder),
                this.dsCurrVal
        }
        readDsLen() {
            const e = Ip(this.restDecoder) + 1;
            return this.dsCurrVal += e,
                e
        }
    }
    class Xf extends Zf {
        constructor(e) {
            super(e),
                this.keys = [],
                Ip(e),
                this.keyClockDecoder = new Up(Rp(e)),
                this.clientDecoder = new Fp(Rp(e)),
                this.leftClockDecoder = new Up(Rp(e)),
                this.rightClockDecoder = new Up(Rp(e)),
                this.infoDecoder = new Vp(Rp(e), Dp),
                this.stringDecoder = new Wp(Rp(e)),
                this.parentInfoDecoder = new Vp(Rp(e), Dp),
                this.typeRefDecoder = new Fp(Rp(e)),
                this.lenDecoder = new Fp(Rp(e))
        }
        readLeftID() {
            return new dm(this.clientDecoder.read(), this.leftClockDecoder.read())
        }
        readRightID() {
            return new dm(this.clientDecoder.read(), this.rightClockDecoder.read())
        }
        readClient() {
            return this.clientDecoder.read()
        }
        readInfo() {
            return this.infoDecoder.read()
        }
        readString() {
            return this.stringDecoder.read()
        }
        readParentInfo() {
            return 1 === this.parentInfoDecoder.read()
        }
        readTypeRef() {
            return this.typeRefDecoder.read()
        }
        readLen() {
            return this.lenDecoder.read()
        }
        readAny() {
            return Bp(this.restDecoder)
        }
        readBuf() {
            return Rp(this.restDecoder)
        }
        readJSON() {
            return Bp(this.restDecoder)
        }
        readKey() {
            const e = this.keyClockDecoder.read();
            if (e < this.keys.length)
                return this.keys[e];
            {
                const e = this.stringDecoder.read();
                return this.keys.push(e),
                    e
            }
        }
    }
    class Qf {
        constructor() {
            this.restEncoder = lp()
        }
        toUint8Array() {
            return cp(this.restEncoder)
        }
        resetDsCurVal() { }
        writeDsClock(e) {
            hp(this.restEncoder, e)
        }
        writeDsLen(e) {
            hp(this.restEncoder, e)
        }
    }
    class Yf extends Qf {
        writeLeftID(e) {
            hp(this.restEncoder, e.client),
                hp(this.restEncoder, e.clock)
        }
        writeRightID(e) {
            hp(this.restEncoder, e.client),
                hp(this.restEncoder, e.clock)
        }
        writeClient(e) {
            hp(this.restEncoder, e)
        }
        writeInfo(e) {
            up(this.restEncoder, e)
        }
        writeString(e) {
            gp(this.restEncoder, e)
        }
        writeParentInfo(e) {
            hp(this.restEncoder, e ? 1 : 0)
        }
        writeTypeRef(e) {
            hp(this.restEncoder, e)
        }
        writeLen(e) {
            hp(this.restEncoder, e)
        }
        writeAny(e) {
            kp(this.restEncoder, e)
        }
        writeBuf(e) {
            yp(this.restEncoder, e)
        }
        writeJSON(e) {
            gp(this.restEncoder, JSON.stringify(e))
        }
        writeKey(e) {
            gp(this.restEncoder, e)
        }
    }
    class em {
        constructor() {
            this.restEncoder = lp(),
                this.dsCurrVal = 0
        }
        toUint8Array() {
            return cp(this.restEncoder)
        }
        resetDsCurVal() {
            this.dsCurrVal = 0
        }
        writeDsClock(e) {
            const t = e - this.dsCurrVal;
            this.dsCurrVal = e,
                hp(this.restEncoder, t)
        }
        writeDsLen(e) {
            0 === e && zh(),
                hp(this.restEncoder, e - 1),
                this.dsCurrVal += e
        }
    }
    class tm extends em {
        constructor() {
            super(),
                this.keyMap = new Map,
                this.keyClock = 0,
                this.keyClockEncoder = new Mp,
                this.clientEncoder = new xp,
                this.leftClockEncoder = new Mp,
                this.rightClockEncoder = new Mp,
                this.infoEncoder = new Cp(up),
                this.stringEncoder = new Tp,
                this.parentInfoEncoder = new Cp(up),
                this.typeRefEncoder = new xp,
                this.lenEncoder = new xp
        }
        toUint8Array() {
            const e = lp();
            return hp(e, 0),
                yp(e, this.keyClockEncoder.toUint8Array()),
                yp(e, this.clientEncoder.toUint8Array()),
                yp(e, this.leftClockEncoder.toUint8Array()),
                yp(e, this.rightClockEncoder.toUint8Array()),
                yp(e, cp(this.infoEncoder)),
                yp(e, this.stringEncoder.toUint8Array()),
                yp(e, cp(this.parentInfoEncoder)),
                yp(e, this.typeRefEncoder.toUint8Array()),
                yp(e, this.lenEncoder.toUint8Array()),
                bp(e, cp(this.restEncoder)),
                cp(e)
        }
        writeLeftID(e) {
            this.clientEncoder.write(e.client),
                this.leftClockEncoder.write(e.clock)
        }
        writeRightID(e) {
            this.clientEncoder.write(e.client),
                this.rightClockEncoder.write(e.clock)
        }
        writeClient(e) {
            this.clientEncoder.write(e)
        }
        writeInfo(e) {
            this.infoEncoder.write(e)
        }
        writeString(e) {
            this.stringEncoder.write(e)
        }
        writeParentInfo(e) {
            this.parentInfoEncoder.write(e ? 1 : 0)
        }
        writeTypeRef(e) {
            this.typeRefEncoder.write(e)
        }
        writeLen(e) {
            this.lenEncoder.write(e)
        }
        writeAny(e) {
            kp(this.restEncoder, e)
        }
        writeBuf(e) {
            yp(this.restEncoder, e)
        }
        writeJSON(e) {
            kp(this.restEncoder, e)
        }
        writeKey(e) {
            const t = this.keyMap.get(e);
            void 0 === t ? (this.keyClockEncoder.write(this.keyClock++),
                this.stringEncoder.write(e)) : this.keyClockEncoder.write(t)
        }
    }
    const nm = (e, t, n) => {
        const r = new Map;
        n.forEach(((e, n) => {
            _m(t, n) > e && r.set(n, e)
        }
        )),
            Nm(t).forEach(((e, t) => {
                n.has(t) || r.set(t, 0)
            }
            )),
            hp(e.restEncoder, r.size),
            Wh(r.entries()).sort(((e, t) => t[0] - e[0])).forEach((n => {
                let [r, o] = n;
                ((e, t, n, r) => {
                    r = Eh(r, t[0].id.clock);
                    const o = Am(t, r);
                    hp(e.restEncoder, t.length - o),
                        e.writeClient(n),
                        hp(e.restEncoder, r);
                    const i = t[o];
                    i.write(e, r - i.id.clock);
                    for (let s = o + 1; s < t.length; s++)
                        t[s].write(e, 0)
                }
                )(e, t.clients.get(r), r, o)
            }
            ))
    }
        , rm = function (e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Xf(e);
            return Um(t, (e => {
                e.local = !1;
                let t = !1;
                const n = e.doc
                    , o = n.store
                    , i = ((e, t) => {
                        const n = $h()
                            , r = Ip(e.restDecoder);
                        for (let o = 0; o < r; o++) {
                            const r = Ip(e.restDecoder)
                                , o = new Array(r)
                                , i = e.readClient();
                            let s = Ip(e.restDecoder);
                            n.set(i, {
                                i: 0,
                                refs: o
                            });
                            for (let n = 0; n < r; n++) {
                                const r = e.readInfo();
                                switch (31 & r) {
                                    case 0:
                                        {
                                            const t = e.readLen();
                                            o[n] = new rb(hm(i, s), t),
                                                s += t;
                                            break
                                        }
                                    case 10:
                                        {
                                            const t = Ip(e.restDecoder);
                                            o[n] = new Ab(hm(i, s), t),
                                                s += t;
                                            break
                                        }
                                    default:
                                        {
                                            const a = 0 === (192 & r)
                                                , l = new Nb(hm(i, s), null, (r & Jh) === Jh ? e.readLeftID() : null, null, (r & Kh) === Kh ? e.readRightID() : null, a ? e.readParentInfo() ? t.get(e.readString()) : e.readLeftID() : null, a && 32 === (32 & r) ? e.readString() : null, _b(e, r));
                                            o[n] = l,
                                                s += l.length
                                        }
                                }
                            }
                        }
                        return n
                    }
                    )(r, n)
                    , s = ((e, t, n) => {
                        const r = [];
                        let o = Wh(n.keys()).sort(((e, t) => e - t));
                        if (0 === o.length)
                            return null;
                        const i = () => {
                            if (0 === o.length)
                                return null;
                            let e = n.get(o[o.length - 1]);
                            for (; e.refs.length === e.i;) {
                                if (o.pop(),
                                    !(o.length > 0))
                                    return null;
                                e = n.get(o[o.length - 1])
                            }
                            return e
                        }
                            ;
                        let s = i();
                        if (null === s)
                            return null;
                        const a = new Tm
                            , l = new Map
                            , c = (e, t) => {
                                const n = l.get(e);
                                (null == n || n > t) && l.set(e, t)
                            }
                            ;
                        let d = s.refs[s.i++];
                        const u = new Map
                            , h = () => {
                                for (const e of r) {
                                    const t = e.id.client
                                        , r = n.get(t);
                                    r ? (r.i--,
                                        a.clients.set(t, r.refs.slice(r.i)),
                                        n.delete(t),
                                        r.i = 0,
                                        r.refs = []) : a.clients.set(t, [e]),
                                        o = o.filter((e => e !== t))
                                }
                                r.length = 0
                            }
                            ;
                        for (; ;) {
                            if (d.constructor !== Ab) {
                                const o = Vh(u, d.id.client, (() => _m(t, d.id.client))) - d.id.clock;
                                if (o < 0)
                                    r.push(d),
                                        c(d.id.client, d.id.clock - 1),
                                        h();
                                else {
                                    const i = d.getMissing(e, t);
                                    if (null !== i) {
                                        r.push(d);
                                        const e = n.get(i) || {
                                            refs: [],
                                            i: 0
                                        };
                                        if (e.refs.length !== e.i) {
                                            d = e.refs[e.i++];
                                            continue
                                        }
                                        c(i, _m(t, i)),
                                            h()
                                    } else
                                        (0 === o || o < d.length) && (d.integrate(e, o),
                                            u.set(d.id.client, d.id.clock + d.length))
                                }
                            }
                            if (r.length > 0)
                                d = r.pop();
                            else if (null !== s && s.i < s.refs.length)
                                d = s.refs[s.i++];
                            else {
                                if (s = i(),
                                    null === s)
                                    break;
                                d = s.refs[s.i++]
                            }
                        }
                        if (a.clients.size > 0) {
                            const e = new tm;
                            return nm(e, a, new Map),
                                hp(e.restEncoder, 0),
                            {
                                missing: l,
                                update: e.toUint8Array()
                            }
                        }
                        return null
                    }
                    )(e, o, i)
                    , a = o.pendingStructs;
                if (a) {
                    for (const [e, n] of a.missing)
                        if (n < _m(o, e)) {
                            t = !0;
                            break
                        }
                    if (s) {
                        for (const [e, t] of s.missing) {
                            const n = a.missing.get(e);
                            (null == n || n > t) && a.missing.set(e, t)
                        }
                        a.update = Qm([a.update, s.update])
                    }
                } else
                    o.pendingStructs = s;
                const l = Gf(r, e, o);
                if (o.pendingDs) {
                    const t = new Xf(Ap(o.pendingDs));
                    Ip(t.restDecoder);
                    const n = Gf(t, e, o);
                    o.pendingDs = l && n ? Qm([l, n]) : l || n
                } else
                    o.pendingDs = l;
                if (t) {
                    const t = o.pendingStructs.update;
                    o.pendingStructs = null,
                        om(e.doc, t)
                }
            }
            ), n, !1)
        }
        , om = function (e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Xf;
            const o = Ap(t);
            rm(o, e, n, new r(o))
        };
    class im {
        constructor() {
            this.l = []
        }
    }
    const sm = () => new im
        , am = (e, t) => e.l.push(t)
        , lm = (e, t) => {
            const n = e.l
                , r = n.length;
            e.l = n.filter((e => t !== e)),
                r === e.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.")
        }
        , cm = (e, t, n) => Qp(e.l, [t, n]);
    class dm {
        constructor(e, t) {
            this.client = e,
                this.clock = t
        }
    }
    const um = (e, t) => e === t || null !== e && null !== t && e.client === t.client && e.clock === t.clock
        , hm = (e, t) => new dm(e, t)
        , pm = e => {
            for (const [t, n] of e.doc.share.entries())
                if (n === e)
                    return t;
            throw zh()
        }
        , fm = (e, t) => {
            for (; null !== t;) {
                if (t.parent === e)
                    return !0;
                t = t.parent._item
            }
            return !1
        }
        ;
    class mm {
        constructor(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            this.type = e,
                this.tname = t,
                this.item = n,
                this.assoc = r
        }
    }
    const gm = e => new mm(null == e.type ? null : hm(e.type.client, e.type.clock), e.tname ?? null, null == e.item ? null : hm(e.item.client, e.item.clock), null == e.assoc ? 0 : e.assoc);
    class bm {
        constructor(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            this.type = e,
                this.index = t,
                this.assoc = n
        }
    }
    const ym = (e, t, n) => {
        let r = null
            , o = null;
        return null === e._item ? o = pm(e) : r = hm(e._item.id.client, e._item.id.clock),
            new mm(r, o, t, n)
    }
        , vm = function (e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                , r = e._start;
            if (n < 0) {
                if (0 === t)
                    return ym(e, null, n);
                t--
            }
            for (; null !== r;) {
                if (!r.deleted && r.countable) {
                    if (r.length > t)
                        return ym(e, hm(r.id.client, r.id.clock + t), n);
                    t -= r.length
                }
                if (null === r.right && n < 0)
                    return ym(e, r.lastId, n);
                r = r.right
            }
            return ym(e, null, n)
        }
        , wm = function (e, t) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            const r = t.store
                , o = e.item
                , i = e.type
                , s = e.tname
                , a = e.assoc;
            let l = null
                , c = 0;
            if (null !== o) {
                if (_m(r, o.client) <= o.clock)
                    return null;
                const e = n ? Sb(r, o) : {
                    item: Pm(r, o),
                    diff: 0
                }
                    , t = e.item;
                if (!(t instanceof Nb))
                    return null;
                if (l = t.parent,
                    null === l._item || !l._item.deleted) {
                    c = t.deleted || !t.countable ? 0 : e.diff + (a >= 0 ? 0 : 1);
                    let n = t.left;
                    for (; null !== n;)
                        !n.deleted && n.countable && (c += n.length),
                            n = n.left
                }
            } else {
                if (null !== s)
                    l = t.get(s);
                else {
                    if (null === i)
                        throw zh();
                    {
                        if (_m(r, i.client) <= i.clock)
                            return null;
                        const { item: e } = n ? Sb(r, i) : {
                            item: Pm(r, i)
                        };
                        if (!(e instanceof Nb && e.content instanceof Cb))
                            return null;
                        l = e.content.type
                    }
                }
                c = a >= 0 ? l._length : 0
            }
            return function (e, t) {
                return new bm(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0)
            }(l, c, e.assoc)
        }
        , km = (e, t) => e === t || null !== e && null !== t && e.tname === t.tname && um(e.item, t.item) && um(e.type, t.type) && e.assoc === t.assoc;
    class Cm {
        constructor(e, t) {
            this.ds = e,
                this.sv = t
        }
    }
    const Sm = (e, t) => new Cm(e, t)
        , xm = (Sm(Ff(), new Map),
            e => Sm(Uf(e.store), Nm(e.store)))
        , Em = (e, t) => void 0 === t ? !e.deleted : t.sv.has(e.id.client) && (t.sv.get(e.id.client) || 0) > e.id.clock && !zf(t.ds, e.id)
        , Mm = (e, t) => {
            const n = Vh(e.meta, Mm, Lh)
                , r = e.doc.store;
            n.has(t) || (t.sv.forEach(((t, n) => {
                t < _m(r, n) && Rm(e, hm(n, t))
            }
            )),
                Hf(e, t.ds, (e => { }
                )),
                n.add(t))
        }
        ;
    class Tm {
        constructor() {
            this.clients = new Map,
                this.pendingStructs = null,
                this.pendingDs = null
        }
    }
    const Nm = e => {
        const t = new Map;
        return e.clients.forEach(((e, n) => {
            const r = e[e.length - 1];
            t.set(n, r.id.clock + r.length)
        }
        )),
            t
    }
        , _m = (e, t) => {
            const n = e.clients.get(t);
            if (void 0 === n)
                return 0;
            const r = n[n.length - 1];
            return r.id.clock + r.length
        }
        , Om = (e, t) => {
            let n = e.clients.get(t.id.client);
            if (void 0 === n)
                n = [],
                    e.clients.set(t.id.client, n);
            else {
                const e = n[n.length - 1];
                if (e.id.clock + e.length !== t.id.clock)
                    throw zh()
            }
            n.push(t)
        }
        , Am = (e, t) => {
            let n = 0
                , r = e.length - 1
                , o = e[r]
                , i = o.id.clock;
            if (i === t)
                return r;
            let s = Ch(t / (i + o.length - 1) * r);
            for (; n <= r;) {
                if (o = e[s],
                    i = o.id.clock,
                    i <= t) {
                    if (t < i + o.length)
                        return s;
                    n = s + 1
                } else
                    r = s - 1;
                s = Ch((n + r) / 2)
            }
            throw zh()
        }
        , Pm = (e, t) => {
            const n = e.clients.get(t.client);
            return n[Am(n, t.clock)]
        }
        , Lm = (e, t, n) => {
            const r = Am(t, n)
                , o = t[r];
            return o.id.clock < n && o instanceof Nb ? (t.splice(r + 1, 0, Eb(e, o, n - o.id.clock)),
                r + 1) : r
        }
        , Rm = (e, t) => {
            const n = e.doc.store.clients.get(t.client);
            return n[Lm(e, n, t.clock)]
        }
        , Dm = (e, t, n) => {
            const r = t.clients.get(n.client)
                , o = Am(r, n.clock)
                , i = r[o];
            return n.clock !== i.id.clock + i.length - 1 && i.constructor !== rb && r.splice(o + 1, 0, Eb(e, i, n.clock - i.id.clock + 1)),
                i
        }
        , Im = (e, t, n, r, o) => {
            if (0 === r)
                return;
            const i = n + r;
            let s, a = Lm(e, t, n);
            do {
                s = t[a++],
                    i < s.id.clock + s.length && Lm(e, t, i),
                    o(s)
            } while (a < t.length && t[a].id.clock < i)
        }
        ;
    class jm {
        constructor(e, t, n) {
            this.doc = e,
                this.deleteSet = new jf,
                this.beforeState = Nm(e.store),
                this.afterState = new Map,
                this.changed = new Map,
                this.changedParentTypes = new Map,
                this._mergeStructs = [],
                this.origin = t,
                this.meta = new Map,
                this.local = n,
                this.subdocsAdded = new Set,
                this.subdocsRemoved = new Set,
                this.subdocsLoaded = new Set,
                this._needFormattingCleanup = !1
        }
    }
    const Hm = (e, t) => !(0 === t.deleteSet.clients.size && !((e, t) => {
        for (const [n, r] of e)
            if (t(r, n))
                return !0;
        return !1
    }
    )(t.afterState, ((e, n) => t.beforeState.get(n) !== e))) && ($f(t.deleteSet),
        ((e, t) => {
            nm(e, t.doc.store, t.beforeState)
        }
        )(e, t),
        Wf(e, t.deleteSet),
        !0)
        , zm = (e, t, n) => {
            const r = t._item;
            (null === r || r.id.clock < (e.beforeState.get(r.id.client) || 0) && !r.deleted) && Vh(e.changed, t, Lh).add(n)
        }
        , $m = (e, t) => {
            let n = e[t]
                , r = e[t - 1]
                , o = t;
            for (; o > 0 && (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)); n = r,
                r = e[--o - 1])
                n instanceof Nb && null !== n.parentSub && n.parent._map.get(n.parentSub) === n && n.parent._map.set(n.parentSub, r);
            const i = t - o;
            return i && e.splice(t + 1 - i, i),
                i
        }
        , Bm = (e, t, n) => {
            for (const [r, o] of e.clients.entries()) {
                const e = t.clients.get(r);
                for (let r = o.length - 1; r >= 0; r--) {
                    const i = o[r]
                        , s = i.clock + i.len;
                    for (let r = Am(e, i.clock), o = e[r]; r < e.length && o.id.clock < s; o = e[++r]) {
                        const o = e[r];
                        if (i.clock + i.len <= o.id.clock)
                            break;
                        o instanceof Nb && o.deleted && !o.keep && n(o) && o.gc(t, !1)
                    }
                }
            }
        }
        , Vm = (e, t) => {
            e.clients.forEach(((e, n) => {
                const r = t.clients.get(n);
                for (let t = e.length - 1; t >= 0; t--) {
                    const n = e[t];
                    for (let e = xh(r.length - 1, 1 + Am(r, n.clock + n.len - 1)), t = r[e]; e > 0 && t.id.clock >= n.clock; t = r[e])
                        e -= 1 + $m(r, e)
                }
            }
            ))
        }
        , Fm = (e, t) => {
            if (t < e.length) {
                const n = e[t]
                    , r = n.doc
                    , o = r.store
                    , i = n.deleteSet
                    , s = n._mergeStructs;
                try {
                    $f(i),
                        n.afterState = Nm(n.doc.store),
                        r.emit("beforeObserverCalls", [n, r]);
                    const e = [];
                    n.changed.forEach(((t, r) => e.push((() => {
                        null !== r._item && r._item.deleted || r._callObserver(n, t)
                    }
                    )))),
                        e.push((() => {
                            n.changedParentTypes.forEach(((e, t) => {
                                t._dEH.l.length > 0 && (null === t._item || !t._item.deleted) && ((e = e.filter((e => null === e.target._item || !e.target._item.deleted))).forEach((e => {
                                    e.currentTarget = t,
                                        e._path = null
                                }
                                )),
                                    e.sort(((e, t) => e.path.length - t.path.length)),
                                    cm(t._dEH, e, n))
                            }
                            ))
                        }
                        )),
                        e.push((() => r.emit("afterTransaction", [n, r]))),
                        Qp(e, []),
                        n._needFormattingCleanup && qg(n)
                } finally {
                    r.gc && Bm(i, o, r.gcFilter),
                        Vm(i, o),
                        n.afterState.forEach(((e, t) => {
                            const r = n.beforeState.get(t) || 0;
                            if (r !== e) {
                                const e = o.clients.get(t)
                                    , n = Eh(Am(e, r), 1);
                                for (let t = e.length - 1; t >= n;)
                                    t -= 1 + $m(e, t)
                            }
                        }
                        ));
                    for (let e = s.length - 1; e >= 0; e--) {
                        const { client: t, clock: n } = s[e].id
                            , r = o.clients.get(t)
                            , i = Am(r, n);
                        i + 1 < r.length && $m(r, i + 1) > 1 || i > 0 && $m(r, i)
                    }
                    if (n.local || n.afterState.get(r.clientID) === n.beforeState.get(r.clientID) || (Af(Tf, wf, "[yjs] ", kf, Ef, "Changed the client-id because another client seems to be using it."),
                        r.clientID = Kf()),
                        r.emit("afterTransactionCleanup", [n, r]),
                        r._observers.has("update")) {
                        const e = new Yf;
                        Hm(e, n) && r.emit("update", [e.toUint8Array(), n.origin, r, n])
                    }
                    if (r._observers.has("updateV2")) {
                        const e = new tm;
                        Hm(e, n) && r.emit("updateV2", [e.toUint8Array(), n.origin, r, n])
                    }
                    const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
                    (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((e => {
                        e.clientID = r.clientID,
                            null == e.collectionid && (e.collectionid = r.collectionid),
                            r.subdocs.add(e)
                    }
                    )),
                        c.forEach((e => r.subdocs.delete(e))),
                        r.emit("subdocs", [{
                            loaded: l,
                            added: a,
                            removed: c
                        }, r, n]),
                        c.forEach((e => e.destroy()))),
                        e.length <= t + 1 ? (r._transactionCleanups = [],
                            r.emit("afterAllTransactions", [r, e])) : Fm(e, t + 1)
                }
            }
        }
        , Um = function (e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                , r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            const o = e._transactionCleanups;
            let i = !1
                , s = null;
            null === e._transaction && (i = !0,
                e._transaction = new jm(e, n, r),
                o.push(e._transaction),
                1 === o.length && e.emit("beforeAllTransactions", [e]),
                e.emit("beforeTransaction", [e._transaction, e]));
            try {
                s = t(e._transaction)
            } finally {
                if (i) {
                    const t = e._transaction === o[0];
                    e._transaction = null,
                        t && Fm(o, 0)
                }
            }
            return s
        };
    class Wm {
        constructor(e, t) {
            this.insertions = t,
                this.deletions = e,
                this.meta = new Map
        }
    }
    const qm = (e, t, n) => {
        Hf(e, n.deletions, (e => {
            e instanceof Nb && t.scope.some((t => fm(t, e))) && xb(e, !1)
        }
        ))
    }
        , Gm = (e, t, n) => {
            let r = null;
            const o = e.doc
                , i = e.scope;
            Um(o, (n => {
                for (; t.length > 0 && null === e.currStackItem;) {
                    const r = o.store
                        , s = t.pop()
                        , a = new Set
                        , l = [];
                    let c = !1;
                    Hf(n, s.insertions, (e => {
                        if (e instanceof Nb) {
                            if (null !== e.redone) {
                                let { item: t, diff: o } = Sb(r, e.id);
                                o > 0 && (t = Rm(n, hm(t.id.client, t.id.clock + o))),
                                    e = t
                            }
                            !e.deleted && i.some((t => fm(t, e))) && l.push(e)
                        }
                    }
                    )),
                        Hf(n, s.deletions, (e => {
                            e instanceof Nb && i.some((t => fm(t, e))) && !zf(s.insertions, e.id) && a.add(e)
                        }
                        )),
                        a.forEach((t => {
                            c = null !== Tb(n, t, a, s.insertions, e.ignoreRemoteMapChanges, e) || c
                        }
                        ));
                    for (let t = l.length - 1; t >= 0; t--) {
                        const r = l[t];
                        e.deleteFilter(r) && (r.delete(n),
                            c = !0)
                    }
                    e.currStackItem = c ? s : null
                }
                n.changed.forEach(((e, t) => {
                    e.has(null) && t._searchMarker && (t._searchMarker.length = 0)
                }
                )),
                    r = n
            }
            ), e);
            const s = e.currStackItem;
            if (null != s) {
                const t = r.changedParentTypes;
                e.emit("stack-item-popped", [{
                    stackItem: s,
                    type: n,
                    changedParentTypes: t,
                    origin: e
                }, e]),
                    e.currStackItem = null
            }
            return s
        }
        ;
    class Km extends Gh {
        constructor(e) {
            let { captureTimeout: t = 500, captureTransaction: n = e => !0, deleteFilter: r = () => !0, trackedOrigins: o = new Set([null]), ignoreRemoteMapChanges: i = !1, doc: s = (qh(e) ? e[0].doc : e.doc) } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            super(),
                this.scope = [],
                this.doc = s,
                this.addToScope(e),
                this.deleteFilter = r,
                o.add(this),
                this.trackedOrigins = o,
                this.captureTransaction = n,
                this.undoStack = [],
                this.redoStack = [],
                this.undoing = !1,
                this.redoing = !1,
                this.currStackItem = null,
                this.lastChange = 0,
                this.ignoreRemoteMapChanges = i,
                this.captureTimeout = t,
                this.afterTransactionHandler = e => {
                    if (!this.captureTransaction(e) || !this.scope.some((t => e.changedParentTypes.has(t))) || !this.trackedOrigins.has(e.origin) && (!e.origin || !this.trackedOrigins.has(e.origin.constructor)))
                        return;
                    const t = this.undoing
                        , n = this.redoing
                        , r = t ? this.redoStack : this.undoStack;
                    t ? this.stopCapturing() : n || this.clear(!1, !0);
                    const o = new jf;
                    e.afterState.forEach(((t, n) => {
                        const r = e.beforeState.get(n) || 0
                            , i = t - r;
                        i > 0 && Vf(o, n, r, i)
                    }
                    ));
                    const i = vf();
                    let s = !1;
                    if (this.lastChange > 0 && i - this.lastChange < this.captureTimeout && r.length > 0 && !t && !n) {
                        const t = r[r.length - 1];
                        t.deletions = Bf([t.deletions, e.deleteSet]),
                            t.insertions = Bf([t.insertions, o])
                    } else
                        r.push(new Wm(e.deleteSet, o)),
                            s = !0;
                    t || n || (this.lastChange = i),
                        Hf(e, e.deleteSet, (e => {
                            e instanceof Nb && this.scope.some((t => fm(t, e))) && xb(e, !0)
                        }
                        ));
                    const a = [{
                        stackItem: r[r.length - 1],
                        origin: e.origin,
                        type: t ? "redo" : "undo",
                        changedParentTypes: e.changedParentTypes
                    }, this];
                    s ? this.emit("stack-item-added", a) : this.emit("stack-item-updated", a)
                }
                ,
                this.doc.on("afterTransaction", this.afterTransactionHandler),
                this.doc.on("destroy", (() => {
                    this.destroy()
                }
                ))
        }
        addToScope(e) {
            (e = qh(e) ? e : [e]).forEach((e => {
                this.scope.every((t => t !== e)) && (e.doc !== this.doc && Pf("[yjs#509] Not same Y.Doc"),
                    this.scope.push(e))
            }
            ))
        }
        addTrackedOrigin(e) {
            this.trackedOrigins.add(e)
        }
        removeTrackedOrigin(e) {
            this.trackedOrigins.delete(e)
        }
        clear() {
            let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((n => {
                e && (this.undoStack.forEach((e => qm(n, this, e))),
                    this.undoStack = []),
                    t && (this.redoStack.forEach((e => qm(n, this, e))),
                        this.redoStack = []),
                    this.emit("stack-cleared", [{
                        undoStackCleared: e,
                        redoStackCleared: t
                    }])
            }
            ))
        }
        stopCapturing() {
            this.lastChange = 0
        }
        undo() {
            let e;
            this.undoing = !0;
            try {
                e = Gm(this, this.undoStack, "undo")
            } finally {
                this.undoing = !1
            }
            return e
        }
        redo() {
            let e;
            this.redoing = !0;
            try {
                e = Gm(this, this.redoStack, "redo")
            } finally {
                this.redoing = !1
            }
            return e
        }
        canUndo() {
            return this.undoStack.length > 0
        }
        canRedo() {
            return this.redoStack.length > 0
        }
        destroy() {
            this.trackedOrigins.delete(this),
                this.doc.off("afterTransaction", this.afterTransactionHandler),
                super.destroy()
        }
    }
    class Jm {
        constructor(e, t) {
            this.gen = function* (e) {
                const t = Ip(e.restDecoder);
                for (let n = 0; n < t; n++) {
                    const t = Ip(e.restDecoder)
                        , n = e.readClient();
                    let r = Ip(e.restDecoder);
                    for (let o = 0; o < t; o++) {
                        const t = e.readInfo();
                        if (10 === t) {
                            const t = Ip(e.restDecoder);
                            yield new Ab(hm(n, r), t),
                                r += t
                        } else if (0 !== (31 & t)) {
                            const o = 0 === (192 & t)
                                , i = new Nb(hm(n, r), null, (t & Jh) === Jh ? e.readLeftID() : null, null, (t & Kh) === Kh ? e.readRightID() : null, o ? e.readParentInfo() ? e.readString() : e.readLeftID() : null, o && 32 === (32 & t) ? e.readString() : null, _b(e, t));
                            yield i,
                                r += i.length
                        } else {
                            const t = e.readLen();
                            yield new rb(hm(n, r), t),
                                r += t
                        }
                    }
                }
            }(e),
                this.curr = null,
                this.done = !1,
                this.filterSkips = t,
                this.next()
        }
        next() {
            do {
                this.curr = this.gen.next().value || null
            } while (this.filterSkips && null !== this.curr && this.curr.constructor === Ab);
            return this.curr
        }
    }
    class Zm {
        constructor(e) {
            this.currClient = 0,
                this.startClock = 0,
                this.written = 0,
                this.encoder = e,
                this.clientStructs = []
        }
    }
    const Xm = (e, t) => {
        if (e.constructor === rb) {
            const { client: n, clock: r } = e.id;
            return new rb(hm(n, r + t), e.length - t)
        }
        if (e.constructor === Ab) {
            const { client: n, clock: r } = e.id;
            return new Ab(hm(n, r + t), e.length - t)
        }
        {
            const n = e
                , { client: r, clock: o } = n.id;
            return new Nb(hm(r, o + t), null, hm(r, o + t - 1), null, n.rightOrigin, n.parent, n.parentSub, n.content.splice(t))
        }
    }
        , Qm = function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Xf
                , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : tm;
            if (1 === e.length)
                return e[0];
            const r = e.map((e => new t(Ap(e))));
            let o = r.map((e => new Jm(e, !0)))
                , i = null;
            const s = new n
                , a = new Zm(s);
            for (; o = o.filter((e => null !== e.curr)),
                o.sort(((e, t) => {
                    if (e.curr.id.client === t.curr.id.client) {
                        const n = e.curr.id.clock - t.curr.id.clock;
                        return 0 === n ? e.curr.constructor === t.curr.constructor ? 0 : e.curr.constructor === Ab ? 1 : -1 : n
                    }
                    return t.curr.id.client - e.curr.id.client
                }
                )),
                0 !== o.length;) {
                const e = o[0]
                    , t = e.curr.id.client;
                if (null !== i) {
                    let n = e.curr
                        , r = !1;
                    for (; null !== n && n.id.clock + n.length <= i.struct.id.clock + i.struct.length && n.id.client >= i.struct.id.client;)
                        n = e.next(),
                            r = !0;
                    if (null === n || n.id.client !== t || r && n.id.clock > i.struct.id.clock + i.struct.length)
                        continue;
                    if (t !== i.struct.id.client)
                        eg(a, i.struct, i.offset),
                            i = {
                                struct: n,
                                offset: 0
                            },
                            e.next();
                    else if (i.struct.id.clock + i.struct.length < n.id.clock)
                        if (i.struct.constructor === Ab)
                            i.struct.length = n.id.clock + n.length - i.struct.id.clock;
                        else {
                            eg(a, i.struct, i.offset);
                            const e = n.id.clock - i.struct.id.clock - i.struct.length;
                            i = {
                                struct: new Ab(hm(t, i.struct.id.clock + i.struct.length), e),
                                offset: 0
                            }
                        }
                    else {
                        const t = i.struct.id.clock + i.struct.length - n.id.clock;
                        t > 0 && (i.struct.constructor === Ab ? i.struct.length -= t : n = Xm(n, t)),
                            i.struct.mergeWith(n) || (eg(a, i.struct, i.offset),
                                i = {
                                    struct: n,
                                    offset: 0
                                },
                                e.next())
                    }
                } else
                    i = {
                        struct: e.curr,
                        offset: 0
                    },
                        e.next();
                for (let n = e.curr; null !== n && n.id.client === t && n.id.clock === i.struct.id.clock + i.struct.length && n.constructor !== Ab; n = e.next())
                    eg(a, i.struct, i.offset),
                        i = {
                            struct: n,
                            offset: 0
                        }
            }
            null !== i && (eg(a, i.struct, i.offset),
                i = null),
                tg(a);
            const l = r.map((e => qf(e)))
                , c = Bf(l);
            return Wf(s, c),
                s.toUint8Array()
        }
        , Ym = e => {
            e.written > 0 && (e.clientStructs.push({
                written: e.written,
                restEncoder: cp(e.encoder.restEncoder)
            }),
                e.encoder.restEncoder = lp(),
                e.written = 0)
        }
        , eg = (e, t, n) => {
            e.written > 0 && e.currClient !== t.id.client && Ym(e),
                0 === e.written && (e.currClient = t.id.client,
                    e.encoder.writeClient(t.id.client),
                    hp(e.encoder.restEncoder, t.id.clock + n)),
                t.write(e.encoder, n),
                e.written++
        }
        , tg = e => {
            Ym(e);
            const t = e.encoder.restEncoder;
            hp(t, e.clientStructs.length);
            for (let n = 0; n < e.clientStructs.length; n++) {
                const r = e.clientStructs[n];
                hp(t, r.written),
                    bp(t, r.restEncoder)
            }
        }
        , ng = "You must not compute changes after the event-handler fired.";
    class rg {
        constructor(e, t) {
            this.target = e,
                this.currentTarget = e,
                this.transaction = t,
                this._changes = null,
                this._keys = null,
                this._delta = null,
                this._path = null
        }
        get path() {
            return this._path || (this._path = og(this.currentTarget, this.target))
        }
        deletes(e) {
            return zf(this.transaction.deleteSet, e.id)
        }
        get keys() {
            if (null === this._keys) {
                if (0 === this.transaction.doc._transactionCleanups.length)
                    throw jh(ng);
                const e = new Map
                    , t = this.target;
                this.transaction.changed.get(t).forEach((n => {
                    if (null !== n) {
                        const r = t._map.get(n);
                        let o, i;
                        if (this.adds(r)) {
                            let e = r.left;
                            for (; null !== e && this.adds(e);)
                                e = e.left;
                            if (this.deletes(r)) {
                                if (null === e || !this.deletes(e))
                                    return;
                                o = "delete",
                                    i = Fh(e.content.getContent())
                            } else
                                null !== e && this.deletes(e) ? (o = "update",
                                    i = Fh(e.content.getContent())) : (o = "add",
                                        i = void 0)
                        } else {
                            if (!this.deletes(r))
                                return;
                            o = "delete",
                                i = Fh(r.content.getContent())
                        }
                        e.set(n, {
                            action: o,
                            oldValue: i
                        })
                    }
                }
                )),
                    this._keys = e
            }
            return this._keys
        }
        get delta() {
            return this.changes.delta
        }
        adds(e) {
            return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0)
        }
        get changes() {
            let e = this._changes;
            if (null === e) {
                if (0 === this.transaction.doc._transactionCleanups.length)
                    throw jh(ng);
                const t = this.target
                    , n = Lh()
                    , r = Lh()
                    , o = [];
                e = {
                    added: n,
                    deleted: r,
                    delta: o,
                    keys: this.keys
                };
                if (this.transaction.changed.get(t).has(null)) {
                    let e = null;
                    const i = () => {
                        e && o.push(e)
                    }
                        ;
                    for (let o = t._start; null !== o; o = o.right)
                        o.deleted ? this.deletes(o) && !this.adds(o) && (null !== e && void 0 !== e.delete || (i(),
                            e = {
                                delete: 0
                            }),
                            e.delete += o.length,
                            r.add(o)) : this.adds(o) ? (null !== e && void 0 !== e.insert || (i(),
                                e = {
                                    insert: []
                                }),
                                e.insert = e.insert.concat(o.content.getContent()),
                                n.add(o)) : (null !== e && void 0 !== e.retain || (i(),
                                    e = {
                                        retain: 0
                                    }),
                                    e.retain += o.length);
                    null !== e && void 0 === e.retain && i()
                }
                this._changes = e
            }
            return e
        }
    }
    const og = (e, t) => {
        const n = [];
        for (; null !== t._item && t !== e;) {
            if (null !== t._item.parentSub)
                n.unshift(t._item.parentSub);
            else {
                let e = 0
                    , r = t._item.parent._start;
                for (; r !== t._item && null !== r;)
                    !r.deleted && r.countable && (e += r.length),
                        r = r.right;
                n.unshift(e)
            }
            t = t._item.parent
        }
        return n
    }
        , ig = () => {
            Pf("Invalid access: Add Yjs type to a document before reading data.")
        }
        ;
    let sg = 0;
    class ag {
        constructor(e, t) {
            e.marker = !0,
                this.p = e,
                this.index = t,
                this.timestamp = sg++
        }
    }
    const lg = (e, t, n) => {
        e.p.marker = !1,
            e.p = t,
            t.marker = !0,
            e.index = n,
            e.timestamp = sg++
    }
        , cg = (e, t) => {
            if (null === e._start || 0 === t || null === e._searchMarker)
                return null;
            const n = 0 === e._searchMarker.length ? null : e._searchMarker.reduce(((e, n) => Sh(t - e.index) < Sh(t - n.index) ? e : n));
            let r = e._start
                , o = 0;
            for (null !== n && (r = n.p,
                o = n.index,
                (e => {
                    e.timestamp = sg++
                }
                )(n)); null !== r.right && o < t;) {
                if (!r.deleted && r.countable) {
                    if (t < o + r.length)
                        break;
                    o += r.length
                }
                r = r.right
            }
            for (; null !== r.left && o > t;)
                r = r.left,
                    !r.deleted && r.countable && (o -= r.length);
            for (; null !== r.left && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock;)
                r = r.left,
                    !r.deleted && r.countable && (o -= r.length);
            return null !== n && Sh(n.index - o) < r.parent.length / 80 ? (lg(n, r, o),
                n) : ((e, t, n) => {
                    if (e.length >= 80) {
                        const r = e.reduce(((e, t) => e.timestamp < t.timestamp ? e : t));
                        return lg(r, t, n),
                            r
                    }
                    {
                        const r = new ag(t, n);
                        return e.push(r),
                            r
                    }
                }
                )(e._searchMarker, r, o)
        }
        , dg = (e, t, n) => {
            for (let r = e.length - 1; r >= 0; r--) {
                const o = e[r];
                if (n > 0) {
                    let t = o.p;
                    for (t.marker = !1; t && (t.deleted || !t.countable);)
                        t = t.left,
                            t && !t.deleted && t.countable && (o.index -= t.length);
                    if (null === t || !0 === t.marker) {
                        e.splice(r, 1);
                        continue
                    }
                    o.p = t,
                        t.marker = !0
                }
                (t < o.index || n > 0 && t === o.index) && (o.index = Eh(t, o.index + n))
            }
        }
        , ug = (e, t, n) => {
            const r = e
                , o = t.changedParentTypes;
            for (; Vh(o, e, (() => [])).push(n),
                null !== e._item;)
                e = e._item.parent;
            cm(r._eH, n, t)
        }
        ;
    class hg {
        constructor() {
            this._item = null,
                this._map = new Map,
                this._start = null,
                this.doc = null,
                this._length = 0,
                this._eH = sm(),
                this._dEH = sm(),
                this._searchMarker = null
        }
        get parent() {
            return this._item ? this._item.parent : null
        }
        _integrate(e, t) {
            this.doc = e,
                this._item = t
        }
        _copy() {
            throw Hh()
        }
        clone() {
            throw Hh()
        }
        _write(e) { }
        get _first() {
            let e = this._start;
            for (; null !== e && e.deleted;)
                e = e.right;
            return e
        }
        _callObserver(e, t) {
            !e.local && this._searchMarker && (this._searchMarker.length = 0)
        }
        observe(e) {
            am(this._eH, e)
        }
        observeDeep(e) {
            am(this._dEH, e)
        }
        unobserve(e) {
            lm(this._eH, e)
        }
        unobserveDeep(e) {
            lm(this._dEH, e)
        }
        toJSON() { }
    }
    const pg = (e, t, n) => {
        e.doc ?? ig(),
            t < 0 && (t = e._length + t),
            n < 0 && (n = e._length + n);
        let r = n - t;
        const o = [];
        let i = e._start;
        for (; null !== i && r > 0;) {
            if (i.countable && !i.deleted) {
                const e = i.content.getContent();
                if (e.length <= t)
                    t -= e.length;
                else {
                    for (let n = t; n < e.length && r > 0; n++)
                        o.push(e[n]),
                            r--;
                    t = 0
                }
            }
            i = i.right
        }
        return o
    }
        , fg = e => {
            e.doc ?? ig();
            const t = [];
            let n = e._start;
            for (; null !== n;) {
                if (n.countable && !n.deleted) {
                    const e = n.content.getContent();
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n])
                }
                n = n.right
            }
            return t
        }
        , mg = (e, t) => {
            const n = [];
            let r = e._start;
            for (; null !== r;) {
                if (r.countable && Em(r, t)) {
                    const e = r.content.getContent();
                    for (let t = 0; t < e.length; t++)
                        n.push(e[t])
                }
                r = r.right
            }
            return n
        }
        , gg = (e, t) => {
            let n = 0
                , r = e._start;
            for (e.doc ?? ig(); null !== r;) {
                if (r.countable && !r.deleted) {
                    const o = r.content.getContent();
                    for (let r = 0; r < o.length; r++)
                        t(o[r], n++, e)
                }
                r = r.right
            }
        }
        , bg = (e, t) => {
            const n = [];
            return gg(e, ((r, o) => {
                n.push(t(r, o, e))
            }
            )),
                n
        }
        , yg = e => {
            let t = e._start
                , n = null
                , r = 0;
            return {
                [Symbol.iterator]() {
                    return this
                },
                next: () => {
                    if (null === n) {
                        for (; null !== t && t.deleted;)
                            t = t.right;
                        if (null === t)
                            return {
                                done: !0,
                                value: void 0
                            };
                        n = t.content.getContent(),
                            r = 0,
                            t = t.right
                    }
                    const e = n[r++];
                    return n.length <= r && (n = null),
                    {
                        done: !1,
                        value: e
                    }
                }
            }
        }
        , vg = (e, t) => {
            e.doc ?? ig();
            const n = cg(e, t);
            let r = e._start;
            for (null !== n && (r = n.p,
                t -= n.index); null !== r; r = r.right)
                if (!r.deleted && r.countable) {
                    if (t < r.length)
                        return r.content.getContent()[t];
                    t -= r.length
                }
        }
        , wg = (e, t, n, r) => {
            let o = n;
            const i = e.doc
                , s = i.clientID
                , a = i.store
                , l = null === n ? t._start : n.right;
            let c = [];
            const d = () => {
                c.length > 0 && (o = new Nb(hm(s, _m(a, s)), o, o && o.lastId, l, l && l.id, t, null, new hb(c)),
                    o.integrate(e, 0),
                    c = [])
            }
                ;
            r.forEach((n => {
                if (null === n)
                    c.push(n);
                else
                    switch (n.constructor) {
                        case Number:
                        case Object:
                        case Boolean:
                        case Array:
                        case String:
                            c.push(n);
                            break;
                        default:
                            switch (d(),
                            n.constructor) {
                                case Uint8Array:
                                case ArrayBuffer:
                                    o = new Nb(hm(s, _m(a, s)), o, o && o.lastId, l, l && l.id, t, null, new ob(new Uint8Array(n))),
                                        o.integrate(e, 0);
                                    break;
                                case Jf:
                                    o = new Nb(hm(s, _m(a, s)), o, o && o.lastId, l, l && l.id, t, null, new ab(n)),
                                        o.integrate(e, 0);
                                    break;
                                default:
                                    if (!(n instanceof hg))
                                        throw new Error("Unexpected content type in insert operation");
                                    o = new Nb(hm(s, _m(a, s)), o, o && o.lastId, l, l && l.id, t, null, new Cb(n)),
                                        o.integrate(e, 0)
                            }
                    }
            }
            )),
                d()
        }
        , kg = () => jh("Length exceeded!")
        , Cg = (e, t, n, r) => {
            if (n > t._length)
                throw kg();
            if (0 === n)
                return t._searchMarker && dg(t._searchMarker, n, r.length),
                    wg(e, t, null, r);
            const o = n
                , i = cg(t, n);
            let s = t._start;
            for (null !== i && (s = i.p,
                0 === (n -= i.index) && (s = s.prev,
                    n += s && s.countable && !s.deleted ? s.length : 0)); null !== s; s = s.right)
                if (!s.deleted && s.countable) {
                    if (n <= s.length) {
                        n < s.length && Rm(e, hm(s.id.client, s.id.clock + n));
                        break
                    }
                    n -= s.length
                }
            return t._searchMarker && dg(t._searchMarker, o, r.length),
                wg(e, t, s, r)
        }
        , Sg = (e, t, n, r) => {
            if (0 === r)
                return;
            const o = n
                , i = r
                , s = cg(t, n);
            let a = t._start;
            for (null !== s && (a = s.p,
                n -= s.index); null !== a && n > 0; a = a.right)
                !a.deleted && a.countable && (n < a.length && Rm(e, hm(a.id.client, a.id.clock + n)),
                    n -= a.length);
            for (; r > 0 && null !== a;)
                a.deleted || (r < a.length && Rm(e, hm(a.id.client, a.id.clock + r)),
                    a.delete(e),
                    r -= a.length),
                    a = a.right;
            if (r > 0)
                throw kg();
            t._searchMarker && dg(t._searchMarker, o, -i + r)
        }
        , xg = (e, t, n) => {
            const r = t._map.get(n);
            void 0 !== r && r.delete(e)
        }
        , Eg = (e, t, n, r) => {
            const o = t._map.get(n) || null
                , i = e.doc
                , s = i.clientID;
            let a;
            if (null == r)
                a = new hb([r]);
            else
                switch (r.constructor) {
                    case Number:
                    case Object:
                    case Boolean:
                    case Array:
                    case String:
                        a = new hb([r]);
                        break;
                    case Uint8Array:
                        a = new ob(r);
                        break;
                    case Jf:
                        a = new ab(r);
                        break;
                    default:
                        if (!(r instanceof hg))
                            throw new Error("Unexpected content type");
                        a = new Cb(r)
                }
            new Nb(hm(s, _m(i.store, s)), o, o && o.lastId, null, null, t, n, a).integrate(e, 0)
        }
        , Mg = (e, t) => {
            e.doc ?? ig();
            const n = e._map.get(t);
            return void 0 === n || n.deleted ? void 0 : n.content.getContent()[n.length - 1]
        }
        , Tg = e => {
            const t = {};
            return e.doc ?? ig(),
                e._map.forEach(((e, n) => {
                    e.deleted || (t[n] = e.content.getContent()[e.length - 1])
                }
                )),
                t
        }
        , Ng = (e, t) => {
            e.doc ?? ig();
            const n = e._map.get(t);
            return void 0 !== n && !n.deleted
        }
        , _g = e => {
            return e.doc ?? ig(),
                t = e._map.entries(),
                n = e => !e[1].deleted,
                Rf((() => {
                    let e;
                    do {
                        e = t.next()
                    } while (!e.done && !n(e.value));
                    return e
                }
                ));
            var t, n
        }
        ;
    class Og extends rg {
    }
    class Ag extends hg {
        constructor() {
            super(),
                this._prelimContent = [],
                this._searchMarker = []
        }
        static from(e) {
            const t = new Ag;
            return t.push(e),
                t
        }
        _integrate(e, t) {
            super._integrate(e, t),
                this.insert(0, this._prelimContent),
                this._prelimContent = null
        }
        _copy() {
            return new Ag
        }
        clone() {
            const e = new Ag;
            return e.insert(0, this.toArray().map((e => e instanceof hg ? e.clone() : e))),
                e
        }
        get length() {
            return this.doc ?? ig(),
                this._length
        }
        _callObserver(e, t) {
            super._callObserver(e, t),
                ug(this, e, new Og(this, e))
        }
        insert(e, t) {
            null !== this.doc ? Um(this.doc, (n => {
                Cg(n, this, e, t)
            }
            )) : this._prelimContent.splice(e, 0, ...t)
        }
        push(e) {
            null !== this.doc ? Um(this.doc, (t => {
                ((e, t, n) => {
                    let r = (t._searchMarker || []).reduce(((e, t) => t.index > e.index ? t : e), {
                        index: 0,
                        p: t._start
                    }).p;
                    if (r)
                        for (; r.right;)
                            r = r.right;
                    wg(e, t, r, n)
                }
                )(t, this, e)
            }
            )) : this._prelimContent.push(...e)
        }
        unshift(e) {
            this.insert(0, e)
        }
        delete(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            null !== this.doc ? Um(this.doc, (n => {
                Sg(n, this, e, t)
            }
            )) : this._prelimContent.splice(e, t)
        }
        get(e) {
            return vg(this, e)
        }
        toArray() {
            return fg(this)
        }
        slice() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;
            return pg(this, e, t)
        }
        toJSON() {
            return this.map((e => e instanceof hg ? e.toJSON() : e))
        }
        map(e) {
            return bg(this, e)
        }
        forEach(e) {
            gg(this, e)
        }
        [Symbol.iterator]() {
            return yg(this)
        }
        _write(e) {
            e.writeTypeRef(mb)
        }
    }
    class Pg extends rg {
        constructor(e, t, n) {
            super(e, t),
                this.keysChanged = n
        }
    }
    class Lg extends hg {
        constructor(e) {
            super(),
                this._prelimContent = null,
                this._prelimContent = void 0 === e ? new Map : new Map(e)
        }
        _integrate(e, t) {
            super._integrate(e, t),
                this._prelimContent.forEach(((e, t) => {
                    this.set(t, e)
                }
                )),
                this._prelimContent = null
        }
        _copy() {
            return new Lg
        }
        clone() {
            const e = new Lg;
            return this.forEach(((t, n) => {
                e.set(n, t instanceof hg ? t.clone() : t)
            }
            )),
                e
        }
        _callObserver(e, t) {
            ug(this, e, new Pg(this, e, t))
        }
        toJSON() {
            this.doc ?? ig();
            const e = {};
            return this._map.forEach(((t, n) => {
                if (!t.deleted) {
                    const r = t.content.getContent()[t.length - 1];
                    e[n] = r instanceof hg ? r.toJSON() : r
                }
            }
            )),
                e
        }
        get size() {
            return [..._g(this)].length
        }
        keys() {
            return Df(_g(this), (e => e[0]))
        }
        values() {
            return Df(_g(this), (e => e[1].content.getContent()[e[1].length - 1]))
        }
        entries() {
            return Df(_g(this), (e => [e[0], e[1].content.getContent()[e[1].length - 1]]))
        }
        forEach(e) {
            this.doc ?? ig(),
                this._map.forEach(((t, n) => {
                    t.deleted || e(t.content.getContent()[t.length - 1], n, this)
                }
                ))
        }
        [Symbol.iterator]() {
            return this.entries()
        }
        delete(e) {
            null !== this.doc ? Um(this.doc, (t => {
                xg(t, this, e)
            }
            )) : this._prelimContent.delete(e)
        }
        set(e, t) {
            return null !== this.doc ? Um(this.doc, (n => {
                Eg(n, this, e, t)
            }
            )) : this._prelimContent.set(e, t),
                t
        }
        get(e) {
            return Mg(this, e)
        }
        has(e) {
            return Ng(this, e)
        }
        clear() {
            null !== this.doc ? Um(this.doc, (e => {
                this.forEach((function (t, n, r) {
                    xg(e, r, n)
                }
                ))
            }
            )) : this._prelimContent.clear()
        }
        _write(e) {
            e.writeTypeRef(gb)
        }
    }
    const Rg = (e, t) => e === t || "object" === typeof e && "object" === typeof t && e && t && ((e, t) => e === t || _h(e) === _h(t) && ((e, t) => {
        for (const n in e)
            if (!t(e[n], n))
                return !1;
        return !0
    }
    )(e, ((e, n) => (void 0 !== e || Oh(t, n)) && t[n] === e)))(e, t);
    class Dg {
        constructor(e, t, n, r) {
            this.left = e,
                this.right = t,
                this.index = n,
                this.currentAttributes = r
        }
        forward() {
            if (null === this.right && zh(),
                this.right.content.constructor === cb)
                this.right.deleted || zg(this.currentAttributes, this.right.content);
            else
                this.right.deleted || (this.index += this.right.length);
            this.left = this.right,
                this.right = this.right.right
        }
    }
    const Ig = (e, t, n) => {
        for (; null !== t.right && n > 0;) {
            if (t.right.content.constructor === cb)
                t.right.deleted || zg(t.currentAttributes, t.right.content);
            else
                t.right.deleted || (n < t.right.length && Rm(e, hm(t.right.id.client, t.right.id.clock + n)),
                    t.index += t.right.length,
                    n -= t.right.length);
            t.left = t.right,
                t.right = t.right.right
        }
        return t
    }
        , jg = (e, t, n, r) => {
            const o = new Map
                , i = r ? cg(t, n) : null;
            if (i) {
                const t = new Dg(i.p.left, i.p, i.index, o);
                return Ig(e, t, n - i.index)
            }
            {
                const r = new Dg(null, t._start, 0, o);
                return Ig(e, r, n)
            }
        }
        , Hg = (e, t, n, r) => {
            for (; null !== n.right && (!0 === n.right.deleted || n.right.content.constructor === cb && Rg(r.get(n.right.content.key), n.right.content.value));)
                n.right.deleted || r.delete(n.right.content.key),
                    n.forward();
            const o = e.doc
                , i = o.clientID;
            r.forEach(((r, s) => {
                const a = n.left
                    , l = n.right
                    , c = new Nb(hm(i, _m(o.store, i)), a, a && a.lastId, l, l && l.id, t, null, new cb(s, r));
                c.integrate(e, 0),
                    n.right = c,
                    n.forward()
            }
            ))
        }
        , zg = (e, t) => {
            const { key: n, value: r } = t;
            null === r ? e.delete(n) : e.set(n, r)
        }
        , $g = (e, t) => {
            for (; null !== e.right && (e.right.deleted || e.right.content.constructor === cb && Rg(t[e.right.content.key] ?? null, e.right.content.value));)
                e.forward()
        }
        , Bg = (e, t, n, r) => {
            const o = e.doc
                , i = o.clientID
                , s = new Map;
            for (const a in r) {
                const l = r[a]
                    , c = n.currentAttributes.get(a) ?? null;
                if (!Rg(c, l)) {
                    s.set(a, c);
                    const { left: r, right: d } = n;
                    n.right = new Nb(hm(i, _m(o.store, i)), r, r && r.lastId, d, d && d.id, t, null, new cb(a, l)),
                        n.right.integrate(e, 0),
                        n.forward()
                }
            }
            return s
        }
        , Vg = (e, t, n, r, o) => {
            n.currentAttributes.forEach(((e, t) => {
                void 0 === o[t] && (o[t] = null)
            }
            ));
            const i = e.doc
                , s = i.clientID;
            $g(n, o);
            const a = Bg(e, t, n, o)
                , l = r.constructor === String ? new pb(r) : r instanceof hg ? new Cb(r) : new lb(r);
            let { left: c, right: d, index: u } = n;
            t._searchMarker && dg(t._searchMarker, n.index, l.getLength()),
                d = new Nb(hm(s, _m(i.store, s)), c, c && c.lastId, d, d && d.id, t, null, l),
                d.integrate(e, 0),
                n.right = d,
                n.index = u,
                n.forward(),
                Hg(e, t, n, a)
        }
        , Fg = (e, t, n, r, o) => {
            const i = e.doc
                , s = i.clientID;
            $g(n, o);
            const a = Bg(e, t, n, o);
            e: for (; null !== n.right && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === cb));) {
                if (!n.right.deleted)
                    switch (n.right.content.constructor) {
                        case cb:
                            {
                                const { key: t, value: i } = n.right.content
                                    , s = o[t];
                                if (void 0 !== s) {
                                    if (Rg(s, i))
                                        a.delete(t);
                                    else {
                                        if (0 === r)
                                            break e;
                                        a.set(t, i)
                                    }
                                    n.right.delete(e)
                                } else
                                    n.currentAttributes.set(t, i);
                                break
                            }
                        default:
                            r < n.right.length && Rm(e, hm(n.right.id.client, n.right.id.clock + r)),
                                r -= n.right.length
                    }
                n.forward()
            }
            if (r > 0) {
                let o = "";
                for (; r > 0; r--)
                    o += "\n";
                n.right = new Nb(hm(s, _m(i.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, t, null, new pb(o)),
                    n.right.integrate(e, 0),
                    n.forward()
            }
            Hg(e, t, n, a)
        }
        , Ug = (e, t, n, r, o) => {
            let i = t;
            const s = $h();
            for (; i && (!i.countable || i.deleted);) {
                if (!i.deleted && i.content.constructor === cb) {
                    const e = i.content;
                    s.set(e.key, e)
                }
                i = i.right
            }
            let a = 0
                , l = !1;
            for (; t !== i;) {
                if (n === t && (l = !0),
                    !t.deleted) {
                    const n = t.content;
                    switch (n.constructor) {
                        case cb:
                            {
                                const { key: i, value: c } = n
                                    , d = r.get(i) ?? null;
                                s.get(i) === n && d !== c || (t.delete(e),
                                    a++,
                                    l || (o.get(i) ?? null) !== c || d === c || (null === d ? o.delete(i) : o.set(i, d))),
                                    l || t.deleted || zg(o, n);
                                break
                            }
                    }
                }
                t = t.right
            }
            return a
        }
        , Wg = e => {
            let t = 0;
            return Um(e.doc, (n => {
                let r = e._start
                    , o = e._start
                    , i = $h();
                const s = Bh(i);
                for (; o;) {
                    if (!1 === o.deleted)
                        if (o.content.constructor === cb)
                            zg(s, o.content);
                        else
                            t += Ug(n, r, o, i, s),
                                i = Bh(s),
                                r = o;
                    o = o.right
                }
            }
            )),
                t
        }
        , qg = e => {
            const t = new Set
                , n = e.doc;
            for (const [r, o] of e.afterState.entries()) {
                const i = e.beforeState.get(r) || 0;
                o !== i && Im(e, n.store.clients.get(r), i, o, (e => {
                    e.deleted || e.content.constructor !== cb || e.constructor === rb || t.add(e.parent)
                }
                ))
            }
            Um(n, (n => {
                Hf(e, e.deleteSet, (e => {
                    if (e instanceof rb || !e.parent._hasFormatting || t.has(e.parent))
                        return;
                    const r = e.parent;
                    e.content.constructor === cb ? t.add(r) : ((e, t) => {
                        for (; t && t.right && (t.right.deleted || !t.right.countable);)
                            t = t.right;
                        const n = new Set;
                        for (; t && (t.deleted || !t.countable);) {
                            if (!t.deleted && t.content.constructor === cb) {
                                const r = t.content.key;
                                n.has(r) ? t.delete(e) : n.add(r)
                            }
                            t = t.left
                        }
                    }
                    )(n, e)
                }
                ));
                for (const e of t)
                    Wg(e)
            }
            ))
        }
        , Gg = (e, t, n) => {
            const r = n
                , o = Bh(t.currentAttributes)
                , i = t.right;
            for (; n > 0 && null !== t.right;) {
                if (!1 === t.right.deleted)
                    switch (t.right.content.constructor) {
                        case Cb:
                        case lb:
                        case pb:
                            n < t.right.length && Rm(e, hm(t.right.id.client, t.right.id.clock + n)),
                                n -= t.right.length,
                                t.right.delete(e)
                    }
                t.forward()
            }
            i && Ug(e, i, t.right, o, t.currentAttributes);
            const s = (t.left || t.right).parent;
            return s._searchMarker && dg(s._searchMarker, t.index, -r + n),
                t
        }
        ;
    class Kg extends rg {
        constructor(e, t, n) {
            super(e, t),
                this.childListChanged = !1,
                this.keysChanged = new Set,
                n.forEach((e => {
                    null === e ? this.childListChanged = !0 : this.keysChanged.add(e)
                }
                ))
        }
        get changes() {
            if (null === this._changes) {
                const e = {
                    keys: this.keys,
                    delta: this.delta,
                    added: new Set,
                    deleted: new Set
                };
                this._changes = e
            }
            return this._changes
        }
        get delta() {
            if (null === this._delta) {
                const e = this.target.doc
                    , t = [];
                Um(e, (e => {
                    const n = new Map
                        , r = new Map;
                    let o = this.target._start
                        , i = null;
                    const s = {};
                    let a = ""
                        , l = 0
                        , c = 0;
                    const d = () => {
                        if (null !== i) {
                            let e = null;
                            switch (i) {
                                case "delete":
                                    c > 0 && (e = {
                                        delete: c
                                    }),
                                        c = 0;
                                    break;
                                case "insert":
                                    ("object" === typeof a || a.length > 0) && (e = {
                                        insert: a
                                    },
                                        n.size > 0 && (e.attributes = {},
                                            n.forEach(((t, n) => {
                                                null !== t && (e.attributes[n] = t)
                                            }
                                            )))),
                                        a = "";
                                    break;
                                case "retain":
                                    l > 0 && (e = {
                                        retain: l
                                    },
                                        (e => {
                                            for (const t in e)
                                                return !1;
                                            return !0
                                        }
                                        )(s) || (e.attributes = Th({}, s))),
                                        l = 0
                            }
                            e && t.push(e),
                                i = null
                        }
                    }
                        ;
                    for (; null !== o;) {
                        switch (o.content.constructor) {
                            case Cb:
                            case lb:
                                this.adds(o) ? this.deletes(o) || (d(),
                                    i = "insert",
                                    a = o.content.getContent()[0],
                                    d()) : this.deletes(o) ? ("delete" !== i && (d(),
                                        i = "delete"),
                                        c += 1) : o.deleted || ("retain" !== i && (d(),
                                            i = "retain"),
                                            l += 1);
                                break;
                            case pb:
                                this.adds(o) ? this.deletes(o) || ("insert" !== i && (d(),
                                    i = "insert"),
                                    a += o.content.str) : this.deletes(o) ? ("delete" !== i && (d(),
                                        i = "delete"),
                                        c += o.length) : o.deleted || ("retain" !== i && (d(),
                                            i = "retain"),
                                            l += o.length);
                                break;
                            case cb:
                                {
                                    const { key: t, value: a } = o.content;
                                    if (this.adds(o)) {
                                        if (!this.deletes(o)) {
                                            const l = n.get(t) ?? null;
                                            Rg(l, a) ? null !== a && o.delete(e) : ("retain" === i && d(),
                                                Rg(a, r.get(t) ?? null) ? delete s[t] : s[t] = a)
                                        }
                                    } else if (this.deletes(o)) {
                                        r.set(t, a);
                                        const e = n.get(t) ?? null;
                                        Rg(e, a) || ("retain" === i && d(),
                                            s[t] = e)
                                    } else if (!o.deleted) {
                                        r.set(t, a);
                                        const n = s[t];
                                        void 0 !== n && (Rg(n, a) ? null !== n && o.delete(e) : ("retain" === i && d(),
                                            null === a ? delete s[t] : s[t] = a))
                                    }
                                    o.deleted || ("insert" === i && d(),
                                        zg(n, o.content));
                                    break
                                }
                        }
                        o = o.right
                    }
                    for (d(); t.length > 0;) {
                        const e = t[t.length - 1];
                        if (void 0 === e.retain || void 0 !== e.attributes)
                            break;
                        t.pop()
                    }
                }
                )),
                    this._delta = t
            }
            return this._delta
        }
    }
    class Jg extends hg {
        constructor(e) {
            super(),
                this._pending = void 0 !== e ? [() => this.insert(0, e)] : [],
                this._searchMarker = [],
                this._hasFormatting = !1
        }
        get length() {
            return this.doc ?? ig(),
                this._length
        }
        _integrate(e, t) {
            super._integrate(e, t);
            try {
                this._pending.forEach((e => e()))
            } catch (pj) {
                console.error(pj)
            }
            this._pending = null
        }
        _copy() {
            return new Jg
        }
        clone() {
            const e = new Jg;
            return e.applyDelta(this.toDelta()),
                e
        }
        _callObserver(e, t) {
            super._callObserver(e, t);
            const n = new Kg(this, e, t);
            ug(this, e, n),
                !e.local && this._hasFormatting && (e._needFormattingCleanup = !0)
        }
        toString() {
            this.doc ?? ig();
            let e = ""
                , t = this._start;
            for (; null !== t;)
                !t.deleted && t.countable && t.content.constructor === pb && (e += t.content.str),
                    t = t.right;
            return e
        }
        toJSON() {
            return this.toString()
        }
        applyDelta(e) {
            let { sanitize: t = !0 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            null !== this.doc ? Um(this.doc, (n => {
                const r = new Dg(null, this._start, 0, new Map);
                for (let o = 0; o < e.length; o++) {
                    const i = e[o];
                    if (void 0 !== i.insert) {
                        const s = t || "string" !== typeof i.insert || o !== e.length - 1 || null !== r.right || "\n" !== i.insert.slice(-1) ? i.insert : i.insert.slice(0, -1);
                        ("string" !== typeof s || s.length > 0) && Vg(n, this, r, s, i.attributes || {})
                    } else
                        void 0 !== i.retain ? Fg(n, this, r, i.retain, i.attributes || {}) : void 0 !== i.delete && Gg(n, r, i.delete)
                }
            }
            )) : this._pending.push((() => this.applyDelta(e)))
        }
        toDelta(e, t, n) {
            this.doc ?? ig();
            const r = []
                , o = new Map
                , i = this.doc;
            let s = ""
                , a = this._start;
            function l() {
                if (s.length > 0) {
                    const e = {};
                    let t = !1;
                    o.forEach(((n, r) => {
                        t = !0,
                            e[r] = n
                    }
                    ));
                    const n = {
                        insert: s
                    };
                    t && (n.attributes = e),
                        r.push(n),
                        s = ""
                }
            }
            const c = () => {
                for (; null !== a;) {
                    if (Em(a, e) || void 0 !== t && Em(a, t))
                        switch (a.content.constructor) {
                            case pb:
                                {
                                    const r = o.get("ychange");
                                    void 0 === e || Em(a, e) ? void 0 === t || Em(a, t) ? void 0 !== r && (l(),
                                        o.delete("ychange")) : void 0 !== r && r.user === a.id.client && "added" === r.type || (l(),
                                            o.set("ychange", n ? n("added", a.id) : {
                                                type: "added"
                                            })) : void 0 !== r && r.user === a.id.client && "removed" === r.type || (l(),
                                                o.set("ychange", n ? n("removed", a.id) : {
                                                    type: "removed"
                                                })),
                                        s += a.content.str;
                                    break
                                }
                            case Cb:
                            case lb:
                                {
                                    l();
                                    const e = {
                                        insert: a.content.getContent()[0]
                                    };
                                    if (o.size > 0) {
                                        const t = {};
                                        e.attributes = t,
                                            o.forEach(((e, n) => {
                                                t[n] = e
                                            }
                                            ))
                                    }
                                    r.push(e);
                                    break
                                }
                            case cb:
                                Em(a, e) && (l(),
                                    zg(o, a.content))
                        }
                    a = a.right
                }
                l()
            }
                ;
            return e || t ? Um(i, (n => {
                e && Mm(n, e),
                    t && Mm(n, t),
                    c()
            }
            ), "cleanup") : c(),
                r
        }
        insert(e, t, n) {
            if (t.length <= 0)
                return;
            const r = this.doc;
            null !== r ? Um(r, (r => {
                const o = jg(r, this, e, !n);
                n || (n = {},
                    o.currentAttributes.forEach(((e, t) => {
                        n[t] = e
                    }
                    ))),
                    Vg(r, this, o, t, n)
            }
            )) : this._pending.push((() => this.insert(e, t, n)))
        }
        insertEmbed(e, t, n) {
            const r = this.doc;
            null !== r ? Um(r, (r => {
                const o = jg(r, this, e, !n);
                Vg(r, this, o, t, n || {})
            }
            )) : this._pending.push((() => this.insertEmbed(e, t, n || {})))
        }
        delete(e, t) {
            if (0 === t)
                return;
            const n = this.doc;
            null !== n ? Um(n, (n => {
                Gg(n, jg(n, this, e, !0), t)
            }
            )) : this._pending.push((() => this.delete(e, t)))
        }
        format(e, t, n) {
            if (0 === t)
                return;
            const r = this.doc;
            null !== r ? Um(r, (r => {
                const o = jg(r, this, e, !1);
                null !== o.right && Fg(r, this, o, t, n)
            }
            )) : this._pending.push((() => this.format(e, t, n)))
        }
        removeAttribute(e) {
            null !== this.doc ? Um(this.doc, (t => {
                xg(t, this, e)
            }
            )) : this._pending.push((() => this.removeAttribute(e)))
        }
        setAttribute(e, t) {
            null !== this.doc ? Um(this.doc, (n => {
                Eg(n, this, e, t)
            }
            )) : this._pending.push((() => this.setAttribute(e, t)))
        }
        getAttribute(e) {
            return Mg(this, e)
        }
        getAttributes() {
            return Tg(this)
        }
        _write(e) {
            e.writeTypeRef(bb)
        }
    }
    class Zg {
        constructor(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => !0;
            this._filter = t,
                this._root = e,
                this._currentNode = e._start,
                this._firstCall = !0,
                e.doc ?? ig()
        }
        [Symbol.iterator]() {
            return this
        }
        next() {
            let e = this._currentNode
                , t = e && e.content && e.content.type;
            if (null !== e && (!this._firstCall || e.deleted || !this._filter(t)))
                do {
                    if (t = e.content.type,
                        e.deleted || t.constructor !== Qg && t.constructor !== Xg || null === t._start)
                        for (; null !== e;) {
                            if (null !== e.right) {
                                e = e.right;
                                break
                            }
                            e = e.parent === this._root ? null : e.parent._item
                        }
                    else
                        e = t._start
                } while (null !== e && (e.deleted || !this._filter(e.content.type)));
            return this._firstCall = !1,
                null === e ? {
                    value: void 0,
                    done: !0
                } : (this._currentNode = e,
                {
                    value: e.content.type,
                    done: !1
                })
        }
    }
    class Xg extends hg {
        constructor() {
            super(),
                this._prelimContent = []
        }
        get firstChild() {
            const e = this._first;
            return e ? e.content.getContent()[0] : null
        }
        _integrate(e, t) {
            super._integrate(e, t),
                this.insert(0, this._prelimContent),
                this._prelimContent = null
        }
        _copy() {
            return new Xg
        }
        clone() {
            const e = new Xg;
            return e.insert(0, this.toArray().map((e => e instanceof hg ? e.clone() : e))),
                e
        }
        get length() {
            return this.doc ?? ig(),
                null === this._prelimContent ? this._length : this._prelimContent.length
        }
        createTreeWalker(e) {
            return new Zg(this, e)
        }
        querySelector(e) {
            e = e.toUpperCase();
            const t = new Zg(this, (t => t.nodeName && t.nodeName.toUpperCase() === e)).next();
            return t.done ? null : t.value
        }
        querySelectorAll(e) {
            return e = e.toUpperCase(),
                Wh(new Zg(this, (t => t.nodeName && t.nodeName.toUpperCase() === e)))
        }
        _callObserver(e, t) {
            ug(this, e, new Yg(this, t, e))
        }
        toString() {
            return bg(this, (e => e.toString())).join("")
        }
        toJSON() {
            return this.toString()
        }
        toDOM() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = arguments.length > 2 ? arguments[2] : void 0;
            const r = e.createDocumentFragment();
            return void 0 !== n && n._createAssociation(r, this),
                gg(this, (o => {
                    r.insertBefore(o.toDOM(e, t, n), null)
                }
                )),
                r
        }
        insert(e, t) {
            null !== this.doc ? Um(this.doc, (n => {
                Cg(n, this, e, t)
            }
            )) : this._prelimContent.splice(e, 0, ...t)
        }
        insertAfter(e, t) {
            if (null !== this.doc)
                Um(this.doc, (n => {
                    const r = e && e instanceof hg ? e._item : e;
                    wg(n, this, r, t)
                }
                ));
            else {
                const n = this._prelimContent
                    , r = null === e ? 0 : n.findIndex((t => t === e)) + 1;
                if (0 === r && null !== e)
                    throw jh("Reference item not found");
                n.splice(r, 0, ...t)
            }
        }
        delete(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            null !== this.doc ? Um(this.doc, (n => {
                Sg(n, this, e, t)
            }
            )) : this._prelimContent.splice(e, t)
        }
        toArray() {
            return fg(this)
        }
        push(e) {
            this.insert(this.length, e)
        }
        unshift(e) {
            this.insert(0, e)
        }
        get(e) {
            return vg(this, e)
        }
        slice() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;
            return pg(this, e, t)
        }
        forEach(e) {
            gg(this, e)
        }
        _write(e) {
            e.writeTypeRef(vb)
        }
    }
    class Qg extends Xg {
        constructor() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "UNDEFINED";
            super(),
                this.nodeName = e,
                this._prelimAttrs = new Map
        }
        get nextSibling() {
            const e = this._item ? this._item.next : null;
            return e ? e.content.type : null
        }
        get prevSibling() {
            const e = this._item ? this._item.prev : null;
            return e ? e.content.type : null
        }
        _integrate(e, t) {
            super._integrate(e, t),
                this._prelimAttrs.forEach(((e, t) => {
                    this.setAttribute(t, e)
                }
                )),
                this._prelimAttrs = null
        }
        _copy() {
            return new Qg(this.nodeName)
        }
        clone() {
            const e = new Qg(this.nodeName);
            return ((e, t) => {
                for (const n in e)
                    t(e[n], n)
            }
            )(this.getAttributes(), ((t, n) => {
                "string" === typeof t && e.setAttribute(n, t)
            }
            )),
                e.insert(0, this.toArray().map((e => e instanceof hg ? e.clone() : e))),
                e
        }
        toString() {
            const e = this.getAttributes()
                , t = []
                , n = [];
            for (const i in e)
                n.push(i);
            n.sort();
            const r = n.length;
            for (let i = 0; i < r; i++) {
                const r = n[i];
                t.push(r + '="' + e[r] + '"')
            }
            const o = this.nodeName.toLocaleLowerCase();
            return `<${o}${t.length > 0 ? " " + t.join(" ") : ""}>${super.toString()}</${o}>`
        }
        removeAttribute(e) {
            null !== this.doc ? Um(this.doc, (t => {
                xg(t, this, e)
            }
            )) : this._prelimAttrs.delete(e)
        }
        setAttribute(e, t) {
            null !== this.doc ? Um(this.doc, (n => {
                Eg(n, this, e, t)
            }
            )) : this._prelimAttrs.set(e, t)
        }
        getAttribute(e) {
            return Mg(this, e)
        }
        hasAttribute(e) {
            return Ng(this, e)
        }
        getAttributes(e) {
            return e ? ((e, t) => {
                const n = {};
                return e._map.forEach(((e, r) => {
                    let o = e;
                    for (; null !== o && (!t.sv.has(o.id.client) || o.id.clock >= (t.sv.get(o.id.client) || 0));)
                        o = o.left;
                    null !== o && Em(o, t) && (n[r] = o.content.getContent()[o.length - 1])
                }
                )),
                    n
            }
            )(this, e) : Tg(this)
        }
        toDOM() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document
                , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , n = arguments.length > 2 ? arguments[2] : void 0;
            const r = e.createElement(this.nodeName)
                , o = this.getAttributes();
            for (const i in o) {
                const e = o[i];
                "string" === typeof e && r.setAttribute(i, e)
            }
            return gg(this, (o => {
                r.appendChild(o.toDOM(e, t, n))
            }
            )),
                void 0 !== n && n._createAssociation(r, this),
                r
        }
        _write(e) {
            e.writeTypeRef(yb),
                e.writeKey(this.nodeName)
        }
    }
    class Yg extends rg {
        constructor(e, t, n) {
            super(e, n),
                this.childListChanged = !1,
                this.attributesChanged = new Set,
                t.forEach((e => {
                    null === e ? this.childListChanged = !0 : this.attributesChanged.add(e)
                }
                ))
        }
    }
    class eb extends Lg {
        constructor(e) {
            super(),
                this.hookName = e
        }
        _copy() {
            return new eb(this.hookName)
        }
        clone() {
            const e = new eb(this.hookName);
            return this.forEach(((t, n) => {
                e.set(n, t)
            }
            )),
                e
        }
        toDOM() {
            arguments.length > 0 && void 0 !== arguments[0] || document;
            let e = arguments.length > 2 ? arguments[2] : void 0;
            const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})[this.hookName];
            let n;
            return n = void 0 !== t ? t.createDom(this) : document.createElement(this.hookName),
                n.setAttribute("data-yjs-hook", this.hookName),
                void 0 !== e && e._createAssociation(n, this),
                n
        }
        _write(e) {
            e.writeTypeRef(wb),
                e.writeKey(this.hookName)
        }
    }
    class tb extends Jg {
        get nextSibling() {
            const e = this._item ? this._item.next : null;
            return e ? e.content.type : null
        }
        get prevSibling() {
            const e = this._item ? this._item.prev : null;
            return e ? e.content.type : null
        }
        _copy() {
            return new tb
        }
        clone() {
            const e = new tb;
            return e.applyDelta(this.toDelta()),
                e
        }
        toDOM() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document
                , t = arguments.length > 2 ? arguments[2] : void 0;
            const n = e.createTextNode(this.toString());
            return void 0 !== t && t._createAssociation(n, this),
                n
        }
        toString() {
            return this.toDelta().map((e => {
                const t = [];
                for (const r in e.attributes) {
                    const n = [];
                    for (const t in e.attributes[r])
                        n.push({
                            key: t,
                            value: e.attributes[r][t]
                        });
                    n.sort(((e, t) => e.key < t.key ? -1 : 1)),
                        t.push({
                            nodeName: r,
                            attrs: n
                        })
                }
                t.sort(((e, t) => e.nodeName < t.nodeName ? -1 : 1));
                let n = "";
                for (let r = 0; r < t.length; r++) {
                    const e = t[r];
                    n += `<${e.nodeName}`;
                    for (let t = 0; t < e.attrs.length; t++) {
                        const r = e.attrs[t];
                        n += ` ${r.key}="${r.value}"`
                    }
                    n += ">"
                }
                n += e.insert;
                for (let r = t.length - 1; r >= 0; r--)
                    n += `</${t[r].nodeName}>`;
                return n
            }
            )).join("")
        }
        toJSON() {
            return this.toString()
        }
        _write(e) {
            e.writeTypeRef(kb)
        }
    }
    class nb {
        constructor(e, t) {
            this.id = e,
                this.length = t
        }
        get deleted() {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        write(e, t, n) {
            throw Hh()
        }
        integrate(e, t) {
            throw Hh()
        }
    }
    class rb extends nb {
        get deleted() {
            return !0
        }
        delete() { }
        mergeWith(e) {
            return this.constructor === e.constructor && (this.length += e.length,
                !0)
        }
        integrate(e, t) {
            t > 0 && (this.id.clock += t,
                this.length -= t),
                Om(e.doc.store, this)
        }
        write(e, t) {
            e.writeInfo(0),
                e.writeLen(this.length - t)
        }
        getMissing(e, t) {
            return null
        }
    }
    class ob {
        constructor(e) {
            this.content = e
        }
        getLength() {
            return 1
        }
        getContent() {
            return [this.content]
        }
        isCountable() {
            return !0
        }
        copy() {
            return new ob(this.content)
        }
        splice(e) {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        integrate(e, t) { }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            e.writeBuf(this.content)
        }
        getRef() {
            return 3
        }
    }
    class ib {
        constructor(e) {
            this.len = e
        }
        getLength() {
            return this.len
        }
        getContent() {
            return []
        }
        isCountable() {
            return !1
        }
        copy() {
            return new ib(this.len)
        }
        splice(e) {
            const t = new ib(this.len - e);
            return this.len = e,
                t
        }
        mergeWith(e) {
            return this.len += e.len,
                !0
        }
        integrate(e, t) {
            Vf(e.deleteSet, t.id.client, t.id.clock, this.len),
                t.markDeleted()
        }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            e.writeLen(this.len - t)
        }
        getRef() {
            return 1
        }
    }
    const sb = (e, t) => new Jf({
        guid: e,
        ...t,
        shouldLoad: t.shouldLoad || t.autoLoad || !1
    });
    class ab {
        constructor(e) {
            e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."),
                this.doc = e;
            const t = {};
            this.opts = t,
                e.gc || (t.gc = !1),
                e.autoLoad && (t.autoLoad = !0),
                null !== e.meta && (t.meta = e.meta)
        }
        getLength() {
            return 1
        }
        getContent() {
            return [this.doc]
        }
        isCountable() {
            return !0
        }
        copy() {
            return new ab(sb(this.doc.guid, this.opts))
        }
        splice(e) {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        integrate(e, t) {
            this.doc._item = t,
                e.subdocsAdded.add(this.doc),
                this.doc.shouldLoad && e.subdocsLoaded.add(this.doc)
        }
        delete(e) {
            e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc)
        }
        gc(e) { }
        write(e, t) {
            e.writeString(this.doc.guid),
                e.writeAny(this.opts)
        }
        getRef() {
            return 9
        }
    }
    class lb {
        constructor(e) {
            this.embed = e
        }
        getLength() {
            return 1
        }
        getContent() {
            return [this.embed]
        }
        isCountable() {
            return !0
        }
        copy() {
            return new lb(this.embed)
        }
        splice(e) {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        integrate(e, t) { }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            e.writeJSON(this.embed)
        }
        getRef() {
            return 5
        }
    }
    class cb {
        constructor(e, t) {
            this.key = e,
                this.value = t
        }
        getLength() {
            return 1
        }
        getContent() {
            return []
        }
        isCountable() {
            return !1
        }
        copy() {
            return new cb(this.key, this.value)
        }
        splice(e) {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        integrate(e, t) {
            const n = t.parent;
            n._searchMarker = null,
                n._hasFormatting = !0
        }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            e.writeKey(this.key),
                e.writeJSON(this.value)
        }
        getRef() {
            return 6
        }
    }
    class db {
        constructor(e) {
            this.arr = e
        }
        getLength() {
            return this.arr.length
        }
        getContent() {
            return this.arr
        }
        isCountable() {
            return !0
        }
        copy() {
            return new db(this.arr)
        }
        splice(e) {
            const t = new db(this.arr.slice(e));
            return this.arr = this.arr.slice(0, e),
                t
        }
        mergeWith(e) {
            return this.arr = this.arr.concat(e.arr),
                !0
        }
        integrate(e, t) { }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            const n = this.arr.length;
            e.writeLen(n - t);
            for (let r = t; r < n; r++) {
                const t = this.arr[r];
                e.writeString(void 0 === t ? "undefined" : JSON.stringify(t))
            }
        }
        getRef() {
            return 2
        }
    }
    const ub = "development" === df("node_env");
    class hb {
        constructor(e) {
            this.arr = e,
                ub && Ph(e)
        }
        getLength() {
            return this.arr.length
        }
        getContent() {
            return this.arr
        }
        isCountable() {
            return !0
        }
        copy() {
            return new hb(this.arr)
        }
        splice(e) {
            const t = new hb(this.arr.slice(e));
            return this.arr = this.arr.slice(0, e),
                t
        }
        mergeWith(e) {
            return this.arr = this.arr.concat(e.arr),
                !0
        }
        integrate(e, t) { }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            const n = this.arr.length;
            e.writeLen(n - t);
            for (let r = t; r < n; r++) {
                const t = this.arr[r];
                e.writeAny(t)
            }
        }
        getRef() {
            return 8
        }
    }
    class pb {
        constructor(e) {
            this.str = e
        }
        getLength() {
            return this.str.length
        }
        getContent() {
            return this.str.split("")
        }
        isCountable() {
            return !0
        }
        copy() {
            return new pb(this.str)
        }
        splice(e) {
            const t = new pb(this.str.slice(e));
            this.str = this.str.slice(0, e);
            const n = this.str.charCodeAt(e - 1);
            return n >= 55296 && n <= 56319 && (this.str = this.str.slice(0, e - 1) + "\ufffd",
                t.str = "\ufffd" + t.str.slice(1)),
                t
        }
        mergeWith(e) {
            return this.str += e.str,
                !0
        }
        integrate(e, t) { }
        delete(e) { }
        gc(e) { }
        write(e, t) {
            e.writeString(0 === t ? this.str : this.str.slice(t))
        }
        getRef() {
            return 4
        }
    }
    const fb = [e => new Ag, e => new Lg, e => new Jg, e => new Qg(e.readKey()), e => new Xg, e => new eb(e.readKey()), e => new tb]
        , mb = 0
        , gb = 1
        , bb = 2
        , yb = 3
        , vb = 4
        , wb = 5
        , kb = 6;
    class Cb {
        constructor(e) {
            this.type = e
        }
        getLength() {
            return 1
        }
        getContent() {
            return [this.type]
        }
        isCountable() {
            return !0
        }
        copy() {
            return new Cb(this.type._copy())
        }
        splice(e) {
            throw Hh()
        }
        mergeWith(e) {
            return !1
        }
        integrate(e, t) {
            this.type._integrate(e.doc, t)
        }
        delete(e) {
            let t = this.type._start;
            for (; null !== t;)
                t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e),
                    t = t.right;
            this.type._map.forEach((t => {
                t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e)
            }
            )),
                e.changed.delete(this.type)
        }
        gc(e) {
            let t = this.type._start;
            for (; null !== t;)
                t.gc(e, !0),
                    t = t.right;
            this.type._start = null,
                this.type._map.forEach((t => {
                    for (; null !== t;)
                        t.gc(e, !0),
                            t = t.left
                }
                )),
                this.type._map = new Map
        }
        write(e, t) {
            this.type._write(e)
        }
        getRef() {
            return 7
        }
    }
    const Sb = (e, t) => {
        let n, r = t, o = 0;
        do {
            o > 0 && (r = hm(r.client, r.clock + o)),
                n = Pm(e, r),
                o = r.clock - n.id.clock,
                r = n.redone
        } while (null !== r && n instanceof Nb);
        return {
            item: n,
            diff: o
        }
    }
        , xb = (e, t) => {
            for (; null !== e && e.keep !== t;)
                e.keep = t,
                    e = e.parent._item
        }
        , Eb = (e, t, n) => {
            const { client: r, clock: o } = t.id
                , i = new Nb(hm(r, o + n), t, hm(r, o + n - 1), t.right, t.rightOrigin, t.parent, t.parentSub, t.content.splice(n));
            return t.deleted && i.markDeleted(),
                t.keep && (i.keep = !0),
                null !== t.redone && (i.redone = hm(t.redone.client, t.redone.clock + n)),
                t.right = i,
                null !== i.right && (i.right.left = i),
                e._mergeStructs.push(i),
                null !== i.parentSub && null === i.right && i.parent._map.set(i.parentSub, i),
                t.length = n,
                i
        }
        , Mb = (e, t) => ((e, t) => {
            for (let n = 0; n < e.length; n++)
                if (t(e[n], n, e))
                    return !0;
            return !1
        }
        )(e, (e => zf(e.deletions, t)))
        , Tb = (e, t, n, r, o, i) => {
            const s = e.doc
                , a = s.store
                , l = s.clientID
                , c = t.redone;
            if (null !== c)
                return Rm(e, c);
            let d, u = t.parent._item, h = null;
            if (null !== u && !0 === u.deleted) {
                if (null === u.redone && (!n.has(u) || null === Tb(e, u, n, r, o, i)))
                    return null;
                for (; null !== u.redone;)
                    u = Rm(e, u.redone)
            }
            const p = null === u ? t.parent : u.content.type;
            if (null === t.parentSub) {
                for (h = t.left,
                    d = t; null !== h;) {
                    let t = h;
                    for (; null !== t && t.parent._item !== u;)
                        t = null === t.redone ? null : Rm(e, t.redone);
                    if (null !== t && t.parent._item === u) {
                        h = t;
                        break
                    }
                    h = h.left
                }
                for (; null !== d;) {
                    let t = d;
                    for (; null !== t && t.parent._item !== u;)
                        t = null === t.redone ? null : Rm(e, t.redone);
                    if (null !== t && t.parent._item === u) {
                        d = t;
                        break
                    }
                    d = d.right
                }
            } else if (d = null,
                t.right && !o) {
                for (h = t; null !== h && null !== h.right && (h.right.redone || zf(r, h.right.id) || Mb(i.undoStack, h.right.id) || Mb(i.redoStack, h.right.id));)
                    for (h = h.right; h.redone;)
                        h = Rm(e, h.redone);
                if (h && null !== h.right)
                    return null
            } else
                h = p._map.get(t.parentSub) || null;
            const f = _m(a, l)
                , m = hm(l, f)
                , g = new Nb(m, h, h && h.lastId, d, d && d.id, p, t.parentSub, t.content.copy());
            return t.redone = m,
                xb(g, !0),
                g.integrate(e, 0),
                g
        }
        ;
    class Nb extends nb {
        constructor(e, t, n, r, o, i, s, a) {
            super(e, a.getLength()),
                this.origin = n,
                this.left = t,
                this.right = r,
                this.rightOrigin = o,
                this.parent = i,
                this.parentSub = s,
                this.redone = null,
                this.content = a,
                this.info = this.content.isCountable() ? 2 : 0
        }
        set marker(e) {
            (8 & this.info) > 0 !== e && (this.info ^= 8)
        }
        get marker() {
            return (8 & this.info) > 0
        }
        get keep() {
            return (1 & this.info) > 0
        }
        set keep(e) {
            this.keep !== e && (this.info ^= 1)
        }
        get countable() {
            return (2 & this.info) > 0
        }
        get deleted() {
            return (4 & this.info) > 0
        }
        set deleted(e) {
            this.deleted !== e && (this.info ^= 4)
        }
        markDeleted() {
            this.info |= 4
        }
        getMissing(e, t) {
            if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= _m(t, this.origin.client))
                return this.origin.client;
            if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= _m(t, this.rightOrigin.client))
                return this.rightOrigin.client;
            if (this.parent && this.parent.constructor === dm && this.id.client !== this.parent.client && this.parent.clock >= _m(t, this.parent.client))
                return this.parent.client;
            if (this.origin && (this.left = Dm(e, t, this.origin),
                this.origin = this.left.lastId),
                this.rightOrigin && (this.right = Rm(e, this.rightOrigin),
                    this.rightOrigin = this.right.id),
                this.left && this.left.constructor === rb || this.right && this.right.constructor === rb)
                this.parent = null;
            else if (this.parent) {
                if (this.parent.constructor === dm) {
                    const e = Pm(t, this.parent);
                    e.constructor === rb ? this.parent = null : this.parent = e.content.type
                }
            } else
                this.left && this.left.constructor === Nb && (this.parent = this.left.parent,
                    this.parentSub = this.left.parentSub),
                    this.right && this.right.constructor === Nb && (this.parent = this.right.parent,
                        this.parentSub = this.right.parentSub);
            return null
        }
        integrate(e, t) {
            if (t > 0 && (this.id.clock += t,
                this.left = Dm(e, e.doc.store, hm(this.id.client, this.id.clock - 1)),
                this.origin = this.left.lastId,
                this.content = this.content.splice(t),
                this.length -= t),
                this.parent) {
                if (!this.left && (!this.right || null !== this.right.left) || this.left && this.left.right !== this.right) {
                    let t, n = this.left;
                    if (null !== n)
                        t = n.right;
                    else if (null !== this.parentSub)
                        for (t = this.parent._map.get(this.parentSub) || null; null !== t && null !== t.left;)
                            t = t.left;
                    else
                        t = this.parent._start;
                    const r = new Set
                        , o = new Set;
                    for (; null !== t && t !== this.right;) {
                        if (o.add(t),
                            r.add(t),
                            um(this.origin, t.origin)) {
                            if (t.id.client < this.id.client)
                                n = t,
                                    r.clear();
                            else if (um(this.rightOrigin, t.rightOrigin))
                                break
                        } else {
                            if (null === t.origin || !o.has(Pm(e.doc.store, t.origin)))
                                break;
                            r.has(Pm(e.doc.store, t.origin)) || (n = t,
                                r.clear())
                        }
                        t = t.right
                    }
                    this.left = n
                }
                if (null !== this.left) {
                    const e = this.left.right;
                    this.right = e,
                        this.left.right = this
                } else {
                    let e;
                    if (null !== this.parentSub)
                        for (e = this.parent._map.get(this.parentSub) || null; null !== e && null !== e.left;)
                            e = e.left;
                    else
                        e = this.parent._start,
                            this.parent._start = this;
                    this.right = e
                }
                null !== this.right ? this.right.left = this : null !== this.parentSub && (this.parent._map.set(this.parentSub, this),
                    null !== this.left && this.left.delete(e)),
                    null === this.parentSub && this.countable && !this.deleted && (this.parent._length += this.length),
                    Om(e.doc.store, this),
                    this.content.integrate(e, this),
                    zm(e, this.parent, this.parentSub),
                    (null !== this.parent._item && this.parent._item.deleted || null !== this.parentSub && null !== this.right) && this.delete(e)
            } else
                new rb(this.id, this.length).integrate(e, 0)
        }
        get next() {
            let e = this.right;
            for (; null !== e && e.deleted;)
                e = e.right;
            return e
        }
        get prev() {
            let e = this.left;
            for (; null !== e && e.deleted;)
                e = e.left;
            return e
        }
        get lastId() {
            return 1 === this.length ? this.id : hm(this.id.client, this.id.clock + this.length - 1)
        }
        mergeWith(e) {
            if (this.constructor === e.constructor && um(e.origin, this.lastId) && this.right === e && um(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && null === this.redone && null === e.redone && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
                const t = this.parent._searchMarker;
                return t && t.forEach((t => {
                    t.p === e && (t.p = this,
                        !this.deleted && this.countable && (t.index -= this.length))
                }
                )),
                    e.keep && (this.keep = !0),
                    this.right = e.right,
                    null !== this.right && (this.right.left = this),
                    this.length += e.length,
                    !0
            }
            return !1
        }
        delete(e) {
            if (!this.deleted) {
                const t = this.parent;
                this.countable && null === this.parentSub && (t._length -= this.length),
                    this.markDeleted(),
                    Vf(e.deleteSet, this.id.client, this.id.clock, this.length),
                    zm(e, t, this.parentSub),
                    this.content.delete(e)
            }
        }
        gc(e, t) {
            if (!this.deleted)
                throw zh();
            this.content.gc(e),
                t ? ((e, t, n) => {
                    const r = e.clients.get(t.id.client);
                    r[Am(r, t.id.clock)] = n
                }
                )(e, this, new rb(this.id, this.length)) : this.content = new ib(this.length)
        }
        write(e, t) {
            const n = t > 0 ? hm(this.id.client, this.id.clock + t - 1) : this.origin
                , r = this.rightOrigin
                , o = this.parentSub
                , i = 31 & this.content.getRef() | (null === n ? 0 : Jh) | (null === r ? 0 : Kh) | (null === o ? 0 : 32);
            if (e.writeInfo(i),
                null !== n && e.writeLeftID(n),
                null !== r && e.writeRightID(r),
                null === n && null === r) {
                const t = this.parent;
                if (void 0 !== t._item) {
                    const n = t._item;
                    if (null === n) {
                        const n = pm(t);
                        e.writeParentInfo(!0),
                            e.writeString(n)
                    } else
                        e.writeParentInfo(!1),
                            e.writeLeftID(n.id)
                } else
                    t.constructor === String ? (e.writeParentInfo(!0),
                        e.writeString(t)) : t.constructor === dm ? (e.writeParentInfo(!1),
                            e.writeLeftID(t)) : zh();
                null !== o && e.writeString(o)
            }
            this.content.write(e, t)
        }
    }
    const _b = (e, t) => Ob[31 & t](e)
        , Ob = [() => {
            zh()
        }
            , e => new ib(e.readLen()), e => {
                const t = e.readLen()
                    , n = [];
                for (let r = 0; r < t; r++) {
                    const t = e.readString();
                    "undefined" === t ? n.push(void 0) : n.push(JSON.parse(t))
                }
                return new db(n)
            }
            , e => new ob(e.readBuf()), e => new pb(e.readString()), e => new lb(e.readJSON()), e => new cb(e.readKey(), e.readJSON()), e => new Cb(fb[e.readTypeRef()](e)), e => {
                const t = e.readLen()
                    , n = [];
                for (let r = 0; r < t; r++)
                    n.push(e.readAny());
                return new hb(n)
            }
            , e => new ab(sb(e.readString(), e.readAny())), () => {
                zh()
            }
        ];
    class Ab extends nb {
        get deleted() {
            return !0
        }
        delete() { }
        mergeWith(e) {
            return this.constructor === e.constructor && (this.length += e.length,
                !0)
        }
        integrate(e, t) {
            zh()
        }
        write(e, t) {
            e.writeInfo(10),
                hp(e.restEncoder, this.length - t)
        }
        getMissing(e, t) {
            return null
        }
    }
    const Pb = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : {}
        , Lb = "__ $YJS$ __";
    !0 === Pb[Lb] && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438"),
        Pb[Lb] = !0;
    const Rb = e => class {
        constructor(e) {
            this._ = e
        }
        destroy() {
            e(this._)
        }
    }
        , Db = Rb(clearTimeout)
        , Ib = (e, t) => new Db(setTimeout(t, e));
    Rb(clearInterval),
        Rb((e => "undefined" !== typeof requestAnimationFrame && cancelAnimationFrame(e))),
        Rb((e => "undefined" !== typeof cancelIdleCallback && cancelIdleCallback(e)));
    let jb = null;
    const Hb = () => {
        const e = jb;
        jb = null,
            e.forEach(((e, t) => {
                const n = t.state.tr
                    , r = vh.getState(t.state);
                r && r.binding && !r.binding.isDestroyed && (e.forEach(((e, t) => {
                    n.setMeta(t, e)
                }
                )),
                    t.dispatch(n))
            }
            ))
    }
        , zb = (e, t, n) => {
            if (0 === e)
                return vm(t, 0, -1);
            let r = null === t._first ? null : t._first.content.type;
            for (; null !== r && t !== r;) {
                if (r instanceof tb) {
                    if (r._length >= e)
                        return vm(r, e, -1);
                    if (e -= r._length,
                        null !== r._item && null !== r._item.next)
                        r = r._item.next.content.type;
                    else {
                        do {
                            r = null === r._item ? null : r._item.parent,
                                e--
                        } while (r !== t && null !== r && null !== r._item && null === r._item.next);
                        null !== r && r !== t && (r = null === r._item ? null : r._item.next.content.type)
                    }
                } else {
                    const o = (n.get(r) || {
                        nodeSize: 0
                    }).nodeSize;
                    if (null !== r._first && e < o)
                        r = r._first.content.type,
                            e--;
                    else {
                        if (1 === e && 0 === r._length && o > 1)
                            return new mm(null === r._item ? null : r._item.id, null === r._item ? pm(r) : null, null);
                        if (e -= o,
                            null !== r._item && null !== r._item.next)
                            r = r._item.next.content.type;
                        else {
                            if (0 === e)
                                return r = null === r._item ? r : r._item.parent,
                                    new mm(null === r._item ? null : r._item.id, null === r._item ? pm(r) : null, null);
                            do {
                                r = r._item.parent,
                                    e--
                            } while (r !== t && null === r._item.next);
                            r !== t && (r = r._item.next.content.type)
                        }
                    }
                }
                if (null === r)
                    throw zh();
                if (0 === e && r.constructor !== tb && r !== t)
                    return $b(r._item.parent, r._item)
            }
            return vm(t, t._length, -1)
        }
        , $b = (e, t) => {
            let n = null
                , r = null;
            return null === e._item ? r = pm(e) : n = hm(e._item.id.client, e._item.id.clock),
                new mm(n, r, t.id)
        }
        , Bb = (e, t, n, r) => {
            const o = wm(n, e);
            if (null === o || o.type !== t && !fm(t, o.type._item))
                return null;
            let i = o.type
                , s = 0;
            if (i.constructor === tb)
                s = o.index;
            else if (null === i._item || !i._item.deleted) {
                let e = i._first
                    , t = 0;
                for (; t < i._length && t < o.index && null !== e;) {
                    if (!e.deleted) {
                        const n = e.content.type;
                        t++,
                            s += n instanceof tb ? n._length : r.get(n).nodeSize
                    }
                    e = e.right
                }
                s += 1
            }
            for (; i !== t && null !== i._item;) {
                const e = i._item.parent;
                if (null === e._item || !e._item.deleted) {
                    s += 1;
                    let t = e._first;
                    for (; null !== t;) {
                        const e = t.content.type;
                        if (e === i)
                            break;
                        t.deleted || (s += e instanceof tb ? e._length : r.get(e).nodeSize),
                            t = t.right
                    }
                }
                i = e
            }
            return s - 1
        }
        ;
    function Vb(e) {
        return {
            type: "doc",
            content: e.toArray().map((function e(t) {
                let n;
                if (t.nodeName) {
                    n = {
                        type: t.nodeName
                    };
                    const r = t.getAttributes();
                    Object.keys(r).length && (n.attrs = r);
                    const o = t.toArray();
                    o.length && (n.content = o.map(e).flat())
                } else {
                    n = t.toDelta().map((e => {
                        const t = {
                            type: "text",
                            text: e.insert
                        };
                        return e.attributes && (t.marks = Object.keys(e.attributes).map((t => {
                            const n = e.attributes[t]
                                , r = {
                                    type: t
                                };
                            return Object.keys(n) && (r.attrs = n),
                                r
                        }
                        ))),
                            t
                    }
                    ))
                }
                return n
            }
            ))
        }
    }
    const Fb = (e, t) => void 0 === t ? !e.deleted : t.sv.has(e.id.client) && t.sv.get(e.id.client) > e.id.clock && !zf(t.ds, e.id)
        , Ub = [{
            light: "#ecd44433",
            dark: "#ecd444"
        }]
        , Wb = (e, t, n) => {
            if (!e.has(n)) {
                if (e.size < t.length) {
                    const n = Lh();
                    e.forEach((e => n.add(e))),
                        t = t.filter((e => !n.has(e)))
                }
                e.set(n, (r = t)[Ch(Gp() * r.length)])
            }
            var r;
            return e.get(n)
        }
        , qb = (e, t) => ({
            anchor: zb(t.selection.anchor, e.type, e.mapping),
            head: zb(t.selection.head, e.type, e.mapping)
        });
    class Gb {
        constructor(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Map;
            this.type = e,
                this.prosemirrorView = null,
                this.mux = (() => {
                    let e = !0;
                    return (t, n) => {
                        if (e) {
                            e = !1;
                            try {
                                t()
                            } finally {
                                e = !0
                            }
                        } else
                            void 0 !== n && n()
                    }
                }
                )(),
                this.mapping = t,
                this._observeFunction = this._typeChanged.bind(this),
                this.doc = e.doc,
                this.beforeTransactionSelection = null,
                this.beforeAllTransactions = () => {
                    null === this.beforeTransactionSelection && null != this.prosemirrorView && (this.beforeTransactionSelection = qb(this, this.prosemirrorView.state))
                }
                ,
                this.afterAllTransactions = () => {
                    this.beforeTransactionSelection = null
                }
                ,
                this._domSelectionInView = null
        }
        get _tr() {
            return this.prosemirrorView.state.tr.setMeta("addToHistory", !1)
        }
        _isLocalCursorInView() {
            return !!this.prosemirrorView.hasFocus() && (of && null === this._domSelectionInView && (Ib(0, (() => {
                this._domSelectionInView = null
            }
            )),
                this._domSelectionInView = this._isDomSelectionInView()),
                this._domSelectionInView)
        }
        _isDomSelectionInView() {
            const e = this.prosemirrorView._root.getSelection()
                , t = this.prosemirrorView._root.createRange();
            t.setStart(e.anchorNode, e.anchorOffset),
                t.setEnd(e.focusNode, e.focusOffset);
            0 === t.getClientRects().length && t.startContainer && t.collapsed && t.selectNodeContents(t.startContainer);
            const n = t.getBoundingClientRect()
                , r = gf.documentElement;
            return n.bottom >= 0 && n.right >= 0 && n.left <= (window.innerWidth || r.clientWidth || 0) && n.top <= (window.innerHeight || r.clientHeight || 0)
        }
        renderSnapshot(e, t) {
            t || (t = Sm(Ff(), new Map)),
                this.prosemirrorView.dispatch(this._tr.setMeta(vh, {
                    snapshot: e,
                    prevSnapshot: t
                }))
        }
        unrenderSnapshot() {
            this.mapping.clear(),
                this.mux((() => {
                    const e = this.type.toArray().map((e => Jb(e, this.prosemirrorView.state.schema, this.mapping))).filter((e => null !== e))
                        , t = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new g(d.from(e), 0, 0));
                    t.setMeta(vh, {
                        snapshot: null,
                        prevSnapshot: null
                    }),
                        this.prosemirrorView.dispatch(t)
                }
                ))
        }
        _forceRerender() {
            this.mapping.clear(),
                this.mux((() => {
                    const e = null !== this.beforeTransactionSelection ? null : this.prosemirrorView.state.selection
                        , t = this.type.toArray().map((e => Jb(e, this.prosemirrorView.state.schema, this.mapping))).filter((e => null !== e))
                        , n = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new g(d.from(t), 0, 0));
                    e && n.setSelection(ut.create(n.doc, e.anchor, e.head)),
                        this.prosemirrorView.dispatch(n.setMeta(vh, {
                            isChangeOrigin: !0,
                            binding: this
                        }))
                }
                ))
        }
        _renderSnapshot(e, t, n) {
            let r = this.doc;
            e || (e = xm(this.doc)),
                (e instanceof Uint8Array || t instanceof Uint8Array) && (e instanceof Uint8Array && t instanceof Uint8Array || zh(),
                    r = new Jf({
                        gc: !1
                    }),
                    om(r, t),
                    t = xm(r),
                    om(r, e),
                    e = xm(r)),
                this.mapping.clear(),
                this.mux((() => {
                    r.transact((r => {
                        const o = n.permanentUserData;
                        o && o.dss.forEach((e => {
                            Hf(r, e, (e => { }
                            ))
                        }
                        ));
                        const i = (e, t) => {
                            const r = "added" === e ? o.getUserByClientId(t.client) : o.getUserByDeletedId(t);
                            return {
                                user: r,
                                type: e,
                                color: Wb(n.colorMapping, n.colors, r)
                            }
                        }
                            , s = mg(this.type, new Cm(t.ds, e.sv)).map((n => !n._item.deleted || Fb(n._item, e) || Fb(n._item, t) ? Jb(n, this.prosemirrorView.state.schema, new Map, e, t, i) : null)).filter((e => null !== e))
                            , a = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new g(d.from(s), 0, 0));
                        this.prosemirrorView.dispatch(a.setMeta(vh, {
                            isChangeOrigin: !0
                        }))
                    }
                    ), vh)
                }
                ))
        }
        _typeChanged(e, t) {
            if (null == this.prosemirrorView)
                return;
            const n = vh.getState(this.prosemirrorView.state);
            0 !== e.length && null == n.snapshot && null == n.prevSnapshot ? this.mux((() => {
                const e = (e, t) => this.mapping.delete(t);
                Hf(t, t.deleteSet, (e => {
                    if (e.constructor === Nb) {
                        const t = e.content.type;
                        t && this.mapping.delete(t)
                    }
                }
                )),
                    t.changed.forEach(e),
                    t.changedParentTypes.forEach(e);
                const n = this.type.toArray().map((e => Kb(e, this.prosemirrorView.state.schema, this.mapping))).filter((e => null !== e));
                let r = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new g(d.from(n), 0, 0));
                ((e, t, n) => {
                    if (null !== t && null !== t.anchor && null !== t.head) {
                        const r = Bb(n.doc, n.type, t.anchor, n.mapping)
                            , o = Bb(n.doc, n.type, t.head, n.mapping);
                        null !== r && null !== o && (e = e.setSelection(ut.create(e.doc, r, o)))
                    }
                }
                )(r, this.beforeTransactionSelection, this),
                    r = r.setMeta(vh, {
                        isChangeOrigin: !0,
                        isUndoRedoOperation: t.origin instanceof Km
                    }),
                    null !== this.beforeTransactionSelection && this._isLocalCursorInView() && r.scrollIntoView(),
                    this.prosemirrorView.dispatch(r)
            }
            )) : this.renderSnapshot(n.snapshot, n.prevSnapshot)
        }
        _prosemirrorChanged(e) {
            this.doc.transact((() => {
                ay(this.doc, this.type, e, this.mapping),
                    this.beforeTransactionSelection = qb(this, this.prosemirrorView.state)
            }
            ), vh)
        }
        initView(e) {
            null != this.prosemirrorView && this.destroy(),
                this.prosemirrorView = e,
                this.doc.on("beforeAllTransactions", this.beforeAllTransactions),
                this.doc.on("afterAllTransactions", this.afterAllTransactions),
                this.type.observeDeep(this._observeFunction)
        }
        destroy() {
            null != this.prosemirrorView && (this.prosemirrorView = null,
                this.type.unobserveDeep(this._observeFunction),
                this.doc.off("beforeAllTransactions", this.beforeAllTransactions),
                this.doc.off("afterAllTransactions", this.afterAllTransactions))
        }
    }
    const Kb = (e, t, n, r, o, i) => {
        const s = n.get(e);
        if (void 0 === s) {
            if (e instanceof Qg)
                return Jb(e, t, n, r, o, i);
            throw Hh()
        }
        return s
    }
        , Jb = (e, t, n, r, o, i) => {
            const s = []
                , a = e => {
                    if (e.constructor === Qg) {
                        const a = Kb(e, t, n, r, o, i);
                        null !== a && s.push(a)
                    } else {
                        const a = e._item.right?.content.type;
                        a instanceof Jg && !a._item.deleted && a._item.id.client === a.doc.clientID && (e.applyDelta([{
                            retain: e.length
                        }, ...a.toDelta()]),
                            a.doc.transact((e => {
                                a._item.delete(e)
                            }
                            )));
                        const l = Zb(e, t, n, r, o, i);
                        null !== l && l.forEach((e => {
                            null !== e && s.push(e)
                        }
                        ))
                    }
                }
                ;
            void 0 === r || void 0 === o ? e.toArray().forEach(a) : mg(e, new Cm(o.ds, r.sv)).forEach(a);
            try {
                const a = e.getAttributes(r);
                void 0 !== r && (Fb(e._item, r) ? Fb(e._item, o) || (a.ychange = i ? i("added", e._item.id) : {
                    type: "added"
                }) : a.ychange = i ? i("removed", e._item.id) : {
                    type: "removed"
                });
                const l = t.node(e.nodeName, a, s);
                return n.set(e, l),
                    l
            } catch (pj) {
                return e.doc.transact((t => {
                    e._item.delete(t)
                }
                ), vh),
                    n.delete(e),
                    null
            }
        }
        , Zb = (e, t, n, r, o, i) => {
            const s = []
                , a = e.toDelta(r, o, i);
            try {
                for (let e = 0; e < a.length; e++) {
                    const n = a[e]
                        , r = [];
                    for (const e in n.attributes)
                        r.push(t.mark(e, n.attributes[e]));
                    s.push(t.text(n.insert, r))
                }
            } catch (pj) {
                return e.doc.transact((t => {
                    e._item.delete(t)
                }
                ), vh),
                    null
            }
            return s
        }
        , Xb = (e, t) => e instanceof Array ? ((e, t) => {
            const n = new tb
                , r = e.map((e => ({
                    insert: e.text,
                    attributes: sy(e.marks)
                })));
            return n.applyDelta(r),
                t.set(n, e),
                n
        }
        )(e, t) : ((e, t) => {
            const n = new Qg(e.type.name);
            for (const r in e.attrs) {
                const t = e.attrs[r];
                null !== t && "ychange" !== r && n.setAttribute(r, t)
            }
            return n.insert(0, ey(e).map((e => Xb(e, t)))),
                t.set(n, e),
                n
        }
        )(e, t)
        , Qb = e => "object" === typeof e && null !== e
        , Yb = (e, t) => {
            const n = Object.keys(e).filter((t => null !== e[t]));
            let r = n.length === Object.keys(t).filter((e => null !== t[e])).length;
            for (let o = 0; o < n.length && r; o++) {
                const i = n[o]
                    , s = e[i]
                    , a = t[i];
                r = "ychange" === i || s === a || Qb(s) && Qb(a) && Yb(s, a)
            }
            return r
        }
        , ey = e => {
            const t = e.content.content
                , n = [];
            for (let r = 0; r < t.length; r++) {
                const e = t[r];
                if (e.isText) {
                    const e = [];
                    for (let n = t[r]; r < t.length && n.isText; n = t[++r])
                        e.push(n);
                    r--,
                        n.push(e)
                } else
                    n.push(e)
            }
            return n
        }
        , ty = (e, t) => {
            const n = e.toDelta();
            return n.length === t.length && n.every(((e, n) => e.insert === t[n].text && Nh(e.attributes || {}).length === t[n].marks.length && t[n].marks.every((t => Yb(e.attributes[t.type.name] || {}, t.attrs)))))
        }
        , ny = (e, t) => {
            if (e instanceof Qg && !(t instanceof Array) && ly(e, t)) {
                const n = ey(t);
                return e._length === n.length && Yb(e.getAttributes(), t.attrs) && e.toArray().every(((e, t) => ny(e, n[t])))
            }
            return e instanceof tb && t instanceof Array && ty(e, t)
        }
        , ry = (e, t) => e === t || e instanceof Array && t instanceof Array && e.length === t.length && e.every(((e, n) => t[n] === e))
        , oy = (e, t, n) => {
            const r = e.toArray()
                , o = ey(t)
                , i = o.length
                , s = r.length
                , a = xh(s, i);
            let l = 0
                , c = 0
                , d = !1;
            for (; l < a; l++) {
                const e = r[l]
                    , t = o[l];
                if (ry(n.get(e), t))
                    d = !0;
                else if (!ny(e, t))
                    break
            }
            for (; l + c < a; c++) {
                const e = r[s - c - 1]
                    , t = o[i - c - 1];
                if (ry(n.get(e), t))
                    d = !0;
                else if (!ny(e, t))
                    break
            }
            return {
                equalityFactor: l + c,
                foundMappedChild: d
            }
        }
        , iy = (e, t, n) => {
            n.set(e, t);
            const { nAttrs: r, str: o } = (e => {
                let t = ""
                    , n = e._start;
                const r = {};
                for (; null !== n;)
                    n.deleted || (n.countable && n.content instanceof pb ? t += n.content.str : n.content instanceof cb && (r[n.content.key] = null)),
                        n = n.right;
                return {
                    str: t,
                    nAttrs: r
                }
            }
            )(e)
                , i = t.map((e => ({
                    insert: e.text,
                    attributes: Object.assign({}, r, sy(e.marks))
                })))
                , { insert: s, remove: a, index: l } = Ih(o, i.map((e => e.insert)).join(""));
            e.delete(l, a),
                e.insert(l, s),
                e.applyDelta(i.map((e => ({
                    retain: e.insert.length,
                    attributes: e.attributes
                }))))
        }
        , sy = e => {
            const t = {};
            return e.forEach((e => {
                "ychange" !== e.type.name && (t[e.type.name] = e.attrs)
            }
            )),
                t
        }
        , ay = (e, t, n, r) => {
            if (t instanceof Qg && t.nodeName !== n.type.name)
                throw new Error("node name mismatch!");
            if (r.set(t, n),
                t instanceof Qg) {
                const e = t.getAttributes()
                    , r = n.attrs;
                for (const n in r)
                    null !== r[n] ? e[n] !== r[n] && "ychange" !== n && t.setAttribute(n, r[n]) : t.removeAttribute(n);
                for (const n in e)
                    void 0 === r[n] && t.removeAttribute(n)
            }
            const o = ey(n)
                , i = o.length
                , s = t.toArray()
                , a = s.length
                , l = xh(i, a);
            let c = 0
                , d = 0;
            for (; c < l; c++) {
                const e = s[c]
                    , t = o[c];
                if (!ry(r.get(e), t)) {
                    if (!ny(e, t))
                        break;
                    r.set(e, t)
                }
            }
            for (; d + c + 1 < l; d++) {
                const e = s[a - d - 1]
                    , t = o[i - d - 1];
                if (!ry(r.get(e), t)) {
                    if (!ny(e, t))
                        break;
                    r.set(e, t)
                }
            }
            e.transact((() => {
                for (; a - c - d > 0 && i - c - d > 0;) {
                    const n = s[c]
                        , l = o[c]
                        , u = s[a - d - 1]
                        , h = o[i - d - 1];
                    if (n instanceof tb && l instanceof Array)
                        ty(n, l) || iy(n, l, r),
                            c += 1;
                    else {
                        let o = n instanceof Qg && ly(n, l)
                            , i = u instanceof Qg && ly(u, h);
                        if (o && i) {
                            const e = oy(n, l, r)
                                , t = oy(u, h, r);
                            e.foundMappedChild && !t.foundMappedChild ? i = !1 : !e.foundMappedChild && t.foundMappedChild || e.equalityFactor < t.equalityFactor ? o = !1 : i = !1
                        }
                        o ? (ay(e, n, l, r),
                            c += 1) : i ? (ay(e, u, h, r),
                                d += 1) : (r.delete(t.get(c)),
                                    t.delete(c, 1),
                                    t.insert(c, [Xb(l, r)]),
                                    c += 1)
                    }
                }
                const n = a - c - d;
                if (1 === a && 0 === i && s[0] instanceof tb ? (r.delete(s[0]),
                    s[0].delete(0, s[0].length)) : n > 0 && (t.slice(c, c + n).forEach((e => r.delete(e))),
                        t.delete(c, n)),
                    c + d < i) {
                    const e = [];
                    for (let t = c; t < i - d; t++)
                        e.push(Xb(o[t], r));
                    t.insert(c, e)
                }
            }
            ), vh)
        }
        , ly = (e, t) => !(t instanceof Array) && e.nodeName === t.type.name
        , cy = new Set(["paragraph"])
        , dy = function () {
            let { protectedNodes: e = cy, trackedOrigins: t = [], undoManager: n = null } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return new Mt({
                key: wh,
                state: {
                    init: (r, o) => {
                        const i = vh.getState(o)
                            , s = n || new Km(i.type, {
                                trackedOrigins: new Set([vh].concat(t)),
                                deleteFilter: t => ((e, t) => !(e instanceof Nb) || !(e.content instanceof Cb) || !(e.content.type instanceof Jg || e.content.type instanceof Qg && t.has(e.content.type.nodeName)) || 0 === e.content.type._length)(t, e),
                                captureTransaction: e => !1 !== e.meta.get("addToHistory")
                            });
                        return {
                            undoManager: s,
                            prevSel: null,
                            hasUndoOps: s.undoStack.length > 0,
                            hasRedoOps: s.redoStack.length > 0
                        }
                    }
                    ,
                    apply: (e, t, n, r) => {
                        const o = vh.getState(r).binding
                            , i = t.undoManager
                            , s = i.undoStack.length > 0
                            , a = i.redoStack.length > 0;
                        return o ? {
                            undoManager: i,
                            prevSel: qb(o, n),
                            hasUndoOps: s,
                            hasRedoOps: a
                        } : s !== t.hasUndoOps || a !== t.hasRedoOps ? Object.assign({}, t, {
                            hasUndoOps: i.undoStack.length > 0,
                            hasRedoOps: i.redoStack.length > 0
                        }) : t
                    }
                },
                view: e => {
                    const t = vh.getState(e.state)
                        , n = wh.getState(e.state).undoManager;
                    return n.on("stack-item-added", (n => {
                        let { stackItem: r } = n;
                        const o = t.binding;
                        o && r.meta.set(o, wh.getState(e.state).prevSel)
                    }
                    )),
                        n.on("stack-item-popped", (e => {
                            let { stackItem: n } = e;
                            const r = t.binding;
                            r && (r.beforeTransactionSelection = n.meta.get(r) || r.beforeTransactionSelection)
                        }
                        )),
                    {
                        destroy: () => {
                            n.destroy()
                        }
                    }
                }
            })
        }
        , uy = as.create({
            name: "collaboration",
            priority: 1e3,
            addOptions: () => ({
                document: null,
                field: "default",
                fragment: null
            }),
            addStorage: () => ({
                isDisabled: !1
            }),
            onCreate() {
                this.editor.extensionManager.extensions.find((e => "history" === e.name)) && console.warn('[tiptap warn]: "@tiptap/extension-collaboration" comes with its own history support and is not compatible with "@tiptap/extension-history".')
            },
            addCommands: () => ({
                undo: () => e => {
                    let { tr: t, state: n, dispatch: r } = e;
                    t.setMeta("preventDispatch", !0);
                    return 0 !== wh.getState(n).undoManager.undoStack.length && (!r || (e => {
                        const t = wh.getState(e).undoManager;
                        if (null != t)
                            return t.undo(),
                                !0
                    }
                    )(n))
                }
                ,
                redo: () => e => {
                    let { tr: t, state: n, dispatch: r } = e;
                    t.setMeta("preventDispatch", !0);
                    return 0 !== wh.getState(n).undoManager.redoStack.length && (!r || (e => {
                        const t = wh.getState(e).undoManager;
                        if (null != t)
                            return t.redo(),
                                !0
                    }
                    )(n))
                }
            }),
            addKeyboardShortcuts() {
                return {
                    "Mod-z": () => this.editor.commands.undo(),
                    "Mod-y": () => this.editor.commands.redo(),
                    "Shift-Mod-z": () => this.editor.commands.redo()
                }
            },
            addProseMirrorPlugins() {
                var e;
                const t = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field)
                    , n = dy(this.options.yUndoOptions)
                    , r = n.spec.view;
                n.spec.view = e => {
                    const { undoManager: t } = wh.getState(e.state);
                    t.restore && (t.restore(),
                        t.restore = () => { }
                    );
                    const n = r ? r(e) : void 0;
                    return {
                        destroy: () => {
                            const e = t.trackedOrigins.has(t)
                                , r = t._observers;
                            t.restore = () => {
                                e && t.trackedOrigins.add(t),
                                    t.doc.on("afterTransaction", t.afterTransactionHandler),
                                    t._observers = r
                            }
                                ,
                                (null === n || void 0 === n ? void 0 : n.destroy) && n.destroy()
                        }
                    }
                }
                    ;
                const o = {
                    ...this.options.ySyncOptions,
                    onFirstRender: this.options.onFirstRender
                }
                    , i = function (e) {
                        let { colors: t = Ub, colorMapping: n = new Map, permanentUserData: r = null, onFirstRender: o = () => { }
                            , mapping: i } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                            , s = !1;
                        const a = new Gb(e, i)
                            , l = new Mt({
                                props: {
                                    editable: e => {
                                        const t = vh.getState(e);
                                        return null == t.snapshot && null == t.prevSnapshot
                                    }
                                },
                                key: vh,
                                state: {
                                    init: (o, i) => ({
                                        type: e,
                                        doc: e.doc,
                                        binding: a,
                                        snapshot: null,
                                        prevSnapshot: null,
                                        isChangeOrigin: !1,
                                        isUndoRedoOperation: !1,
                                        addToHistory: !0,
                                        colors: t,
                                        colorMapping: n,
                                        permanentUserData: r
                                    }),
                                    apply: (e, t) => {
                                        const n = e.getMeta(vh);
                                        if (void 0 !== n) {
                                            t = Object.assign({}, t);
                                            for (const e in n)
                                                t[e] = n[e]
                                        }
                                        return t.addToHistory = !1 !== e.getMeta("addToHistory"),
                                            t.isChangeOrigin = void 0 !== n && !!n.isChangeOrigin,
                                            t.isUndoRedoOperation = void 0 !== n && !!n.isChangeOrigin && !!n.isUndoRedoOperation,
                                            null !== a.prosemirrorView && (void 0 === n || null == n.snapshot && null == n.prevSnapshot || Ib(0, (() => {
                                                null != a.prosemirrorView && (null == n.restore ? a._renderSnapshot(n.snapshot, n.prevSnapshot, t) : (a._renderSnapshot(n.snapshot, n.snapshot, t),
                                                    delete t.restore,
                                                    delete t.snapshot,
                                                    delete t.prevSnapshot,
                                                    a.mux((() => {
                                                        a._prosemirrorChanged(a.prosemirrorView.state.doc)
                                                    }
                                                    ))))
                                            }
                                            ))),
                                            t
                                    }
                                },
                                view: e => (a.initView(e),
                                    null == i && a._forceRerender(),
                                    o(),
                                {
                                    update: () => {
                                        const t = l.getState(e.state);
                                        if (null == t.snapshot && null == t.prevSnapshot && (s || null !== e.state.doc.content.findDiffStart(e.state.doc.type.createAndFill().content))) {
                                            if (s = !0,
                                                !1 === t.addToHistory && !t.isChangeOrigin) {
                                                const t = wh.getState(e.state)
                                                    , n = t && t.undoManager;
                                                n && n.stopCapturing()
                                            }
                                            a.mux((() => {
                                                t.doc.transact((n => {
                                                    n.meta.set("addToHistory", t.addToHistory),
                                                        a._prosemirrorChanged(e.state.doc)
                                                }
                                                ), vh)
                                            }
                                            ))
                                        }
                                    }
                                    ,
                                    destroy: () => {
                                        a.destroy()
                                    }
                                })
                            });
                        return l
                    }(t, o);
                return this.editor.options.enableContentCheck && (null === (e = t.doc) || void 0 === e || e.on("beforeTransaction", (() => {
                    try {
                        const e = Vb(t);
                        if (0 === e.content.length)
                            return;
                        this.editor.schema.nodeFromJSON(e).check()
                    } catch (e) {
                        return this.editor.emit("contentError", {
                            error: e,
                            editor: this.editor,
                            disableCollaboration: () => {
                                var e;
                                null === (e = t.doc) || void 0 === e || e.destroy(),
                                    this.storage.isDisabled = !0
                            }
                        }),
                            !1
                    }
                }
                ))),
                    [i, n, this.editor.options.enableContentCheck && new Mt({
                        key: new _t("filterInvalidContent"),
                        filterTransaction: () => {
                            var e;
                            return !this.storage.isDisabled || (null === (e = t.doc) || void 0 === e || e.destroy(),
                                !0)
                        }
                    })].filter(Boolean)
            }
        });
    const hy = (e, t, n) => e !== t
        , py = e => {
            const t = document.createElement("span");
            t.classList.add("ProseMirror-yjs-cursor"),
                t.setAttribute("style", `border-color: ${e.color}`);
            const n = document.createElement("div");
            n.setAttribute("style", `background-color: ${e.color}`),
                n.insertBefore(document.createTextNode(e.name), null);
            const r = document.createTextNode("\u2060")
                , o = document.createTextNode("\u2060");
            return t.insertBefore(r, null),
                t.insertBefore(n, null),
                t.insertBefore(o, null),
                t
        }
        , fy = e => ({
            style: `background-color: ${e.color}70`,
            class: "ProseMirror-yjs-selection"
        })
        , my = /^#[0-9a-fA-F]{6}$/
        , gy = (e, t, n, r, o) => {
            const i = vh.getState(e)
                , s = i.doc
                , a = [];
            return null != i.snapshot || null != i.prevSnapshot || 0 === i.binding.mapping.size ? mo.create(e.doc, []) : (t.getStates().forEach(((t, l) => {
                if (n(s.clientID, l, t) && null != t.cursor) {
                    const n = t.user || {};
                    null == n.color ? n.color = "#ffa500" : my.test(n.color) || console.warn("A user uses an unsupported color format", n),
                        null == n.name && (n.name = `User: ${l}`);
                    let c = Bb(s, i.type, gm(t.cursor.anchor), i.binding.mapping)
                        , d = Bb(s, i.type, gm(t.cursor.head), i.binding.mapping);
                    if (null !== c && null !== d) {
                        const t = Eh(e.doc.content.size - 1, 0);
                        c = xh(c, t),
                            d = xh(d, t),
                            a.push(ho.widget(d, (() => r(n)), {
                                key: l + "",
                                side: 10
                            }));
                        const i = xh(c, d)
                            , s = Eh(c, d);
                        a.push(ho.inline(i, s, o(n), {
                            inclusiveEnd: !0,
                            inclusiveStart: !1
                        }))
                    }
                }
            }
            )),
                mo.create(e.doc, a))
        }
        , by = function (e) {
            let { awarenessStateFilter: t = hy, cursorBuilder: n = py, selectionBuilder: r = fy, getSelection: o = e => e.selection } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "cursor";
            return new Mt({
                key: kh,
                state: {
                    init: (o, i) => gy(i, e, t, n, r),
                    apply(o, i, s, a) {
                        const l = vh.getState(a)
                            , c = o.getMeta(kh);
                        return l && l.isChangeOrigin || c && c.awarenessUpdated ? gy(a, e, t, n, r) : i.map(o.mapping, o.doc)
                    }
                },
                props: {
                    decorations: e => kh.getState(e)
                },
                view: t => {
                    const n = () => {
                        t.docView && ((e, t, n) => {
                            jb || (jb = new Map,
                                Ib(0, Hb)),
                                Vh(jb, e, $h).set(t, n)
                        }
                        )(t, kh, {
                            awarenessUpdated: !0
                        })
                    }
                        , r = () => {
                            const n = vh.getState(t.state)
                                , r = e.getLocalState() || {};
                            if (t.hasFocus()) {
                                const s = o(t.state)
                                    , a = zb(s.anchor, n.type, n.binding.mapping)
                                    , l = zb(s.head, n.type, n.binding.mapping);
                                null != r.cursor && km(gm(r.cursor.anchor), a) && km(gm(r.cursor.head), l) || e.setLocalStateField(i, {
                                    anchor: a,
                                    head: l
                                })
                            } else
                                null != r.cursor && null !== Bb(n.doc, n.type, gm(r.cursor.anchor), n.binding.mapping) && e.setLocalStateField(i, null)
                        }
                        ;
                    return e.on("change", n),
                        t.dom.addEventListener("focusin", r),
                        t.dom.addEventListener("focusout", r),
                    {
                        update: r,
                        destroy: () => {
                            t.dom.removeEventListener("focusin", r),
                                t.dom.removeEventListener("focusout", r),
                                e.off("change", n),
                                e.setLocalStateField(i, null)
                        }
                    }
                }
            })
        }
        , yy = e => Array.from(e.entries()).map((e => {
            let [t, n] = e;
            return {
                clientId: t,
                ...n.user
            }
        }
        ))
        , vy = () => null
        , wy = as.create({
            name: "collaborationCursor",
            priority: 999,
            addOptions: () => ({
                provider: null,
                user: {
                    name: null,
                    color: null
                },
                render: e => {
                    const t = document.createElement("span");
                    t.classList.add("collaboration-cursor__caret"),
                        t.setAttribute("style", `border-color: ${e.color}`);
                    const n = document.createElement("div");
                    return n.classList.add("collaboration-cursor__label"),
                        n.setAttribute("style", `background-color: ${e.color}`),
                        n.insertBefore(document.createTextNode(e.name), null),
                        t.insertBefore(n, null),
                        t
                }
                ,
                selectionRender: fy,
                onUpdate: vy
            }),
            onCreate() {
                if (this.options.onUpdate !== vy && console.warn('[tiptap warn]: DEPRECATED: The "onUpdate" option is deprecated. Please use `editor.storage.collaborationCursor.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor'),
                    !this.options.provider)
                    throw new Error('The "provider" option is required for the CollaborationCursor extension')
            },
            addStorage: () => ({
                users: []
            }),
            addCommands() {
                return {
                    updateUser: e => () => (this.options.user = e,
                        this.options.provider.awareness.setLocalStateField("user", this.options.user),
                        !0),
                    user: e => t => {
                        let { editor: n } = t;
                        return console.warn('[tiptap warn]: DEPRECATED: The "user" command is deprecated. Please use "updateUser" instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor'),
                            n.commands.updateUser(e)
                    }
                }
            },
            addProseMirrorPlugins() {
                return [by((() => (this.options.provider.awareness.setLocalStateField("user", this.options.user),
                    this.storage.users = yy(this.options.provider.awareness.states),
                    this.options.provider.awareness.on("update", (() => {
                        this.storage.users = yy(this.options.provider.awareness.states)
                    }
                    )),
                    this.options.provider.awareness))(), {
                    cursorBuilder: this.options.render,
                    selectionBuilder: this.options.selectionRender
                })]
            }
        });
    function ky() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return new Mt({
            view: t => new Cy(t, e)
        })
    }
    class Cy {
        constructor(e, t) {
            var n;
            this.editorView = e,
                this.cursorPos = null,
                this.element = null,
                this.timeout = -1,
                this.width = null !== (n = t.width) && void 0 !== n ? n : 1,
                this.color = !1 === t.color ? void 0 : t.color || "black",
                this.class = t.class,
                this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((t => {
                    let n = e => {
                        this[t](e)
                    }
                        ;
                    return e.dom.addEventListener(t, n),
                    {
                        name: t,
                        handler: n
                    }
                }
                ))
        }
        destroy() {
            this.handlers.forEach((e => {
                let { name: t, handler: n } = e;
                return this.editorView.dom.removeEventListener(t, n)
            }
            ))
        }
        update(e, t) {
            null != this.cursorPos && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
        }
        setCursor(e) {
            e != this.cursorPos && (this.cursorPos = e,
                null == e ? (this.element.parentNode.removeChild(this.element),
                    this.element = null) : this.updateOverlay())
        }
        updateOverlay() {
            let e, t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent;
            if (n) {
                let n = t.nodeBefore
                    , r = t.nodeAfter;
                if (n || r) {
                    let t = this.editorView.nodeDOM(this.cursorPos - (n ? n.nodeSize : 0));
                    if (t) {
                        let o = t.getBoundingClientRect()
                            , i = n ? o.bottom : o.top;
                        n && r && (i = (i + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
                            e = {
                                left: o.left,
                                right: o.right,
                                top: i - this.width / 2,
                                bottom: i + this.width / 2
                            }
                    }
                }
            }
            if (!e) {
                let t = this.editorView.coordsAtPos(this.cursorPos);
                e = {
                    left: t.left - this.width / 2,
                    right: t.left + this.width / 2,
                    top: t.top,
                    bottom: t.bottom
                }
            }
            let r, o, i = this.editorView.dom.offsetParent;
            if (this.element || (this.element = i.appendChild(document.createElement("div")),
                this.class && (this.element.className = this.class),
                this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;",
                this.color && (this.element.style.backgroundColor = this.color)),
                this.element.classList.toggle("prosemirror-dropcursor-block", n),
                this.element.classList.toggle("prosemirror-dropcursor-inline", !n),
                !i || i == document.body && "static" == getComputedStyle(i).position)
                r = -pageXOffset,
                    o = -pageYOffset;
            else {
                let e = i.getBoundingClientRect();
                r = e.left - i.scrollLeft,
                    o = e.top - i.scrollTop
            }
            this.element.style.left = e.left - r + "px",
                this.element.style.top = e.top - o + "px",
                this.element.style.width = e.right - e.left + "px",
                this.element.style.height = e.bottom - e.top + "px"
        }
        scheduleRemoval(e) {
            clearTimeout(this.timeout),
                this.timeout = setTimeout((() => this.setCursor(null)), e)
        }
        dragover(e) {
            if (!this.editorView.editable)
                return;
            let t = this.editorView.posAtCoords({
                left: e.clientX,
                top: e.clientY
            })
                , n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside)
                , r = n && n.type.spec.disableDropCursor
                , o = "function" == typeof r ? r(this.editorView, t, e) : r;
            if (t && !o) {
                let e = t.pos;
                if (this.editorView.dragging && this.editorView.dragging.slice) {
                    let t = We(this.editorView.state.doc, e, this.editorView.dragging.slice);
                    null != t && (e = t)
                }
                this.setCursor(e),
                    this.scheduleRemoval(5e3)
            }
        }
        dragend() {
            this.scheduleRemoval(20)
        }
        drop() {
            this.scheduleRemoval(20)
        }
        dragleave(e) {
            e.target != this.editorView.dom && this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null)
        }
    }
    const Sy = as.create({
        name: "dropCursor",
        addOptions: () => ({
            color: "currentColor",
            width: 1,
            class: void 0
        }),
        addProseMirrorPlugins() {
            return [ky(this.options)]
        }
    });
    class xy extends at {
        constructor(e) {
            super(e, e)
        }
        map(e, t) {
            let n = e.resolve(t.map(this.head));
            return xy.valid(n) ? new xy(n) : at.near(n)
        }
        content() {
            return g.empty
        }
        eq(e) {
            return e instanceof xy && e.head == this.head
        }
        toJSON() {
            return {
                type: "gapcursor",
                pos: this.head
            }
        }
        static fromJSON(e, t) {
            if ("number" != typeof t.pos)
                throw new RangeError("Invalid input for GapCursor.fromJSON");
            return new xy(e.resolve(t.pos))
        }
        getBookmark() {
            return new Ey(this.anchor)
        }
        static valid(e) {
            let t = e.parent;
            if (t.isTextblock || !function (e) {
                for (let t = e.depth; t >= 0; t--) {
                    let n = e.index(t)
                        , r = e.node(t);
                    if (0 != n)
                        for (let e = r.child(n - 1); ; e = e.lastChild) {
                            if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating)
                                return !0;
                            if (e.inlineContent)
                                return !1
                        }
                    else if (r.type.spec.isolating)
                        return !0
                }
                return !0
            }(e) || !function (e) {
                for (let t = e.depth; t >= 0; t--) {
                    let n = e.indexAfter(t)
                        , r = e.node(t);
                    if (n != r.childCount)
                        for (let e = r.child(n); ; e = e.firstChild) {
                            if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating)
                                return !0;
                            if (e.inlineContent)
                                return !1
                        }
                    else if (r.type.spec.isolating)
                        return !0
                }
                return !0
            }(e))
                return !1;
            let n = t.type.spec.allowGapCursor;
            if (null != n)
                return n;
            let r = t.contentMatchAt(e.index()).defaultType;
            return r && r.isTextblock
        }
        static findGapCursorFrom(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            e: for (; ;) {
                if (!n && xy.valid(e))
                    return e;
                let r = e.pos
                    , o = null;
                for (let n = e.depth; ; n--) {
                    let i = e.node(n);
                    if (t > 0 ? e.indexAfter(n) < i.childCount : e.index(n) > 0) {
                        o = i.child(t > 0 ? e.indexAfter(n) : e.index(n) - 1);
                        break
                    }
                    if (0 == n)
                        return null;
                    r += t;
                    let s = e.doc.resolve(r);
                    if (xy.valid(s))
                        return s
                }
                for (; ;) {
                    let i = t > 0 ? o.firstChild : o.lastChild;
                    if (!i) {
                        if (o.isAtom && !o.isText && !pt.isSelectable(o)) {
                            e = e.doc.resolve(r + o.nodeSize * t),
                                n = !1;
                            continue e
                        }
                        break
                    }
                    o = i,
                        r += t;
                    let s = e.doc.resolve(r);
                    if (xy.valid(s))
                        return s
                }
                return null
            }
        }
    }
    xy.prototype.visible = !1,
        xy.findFrom = xy.findGapCursorFrom,
        at.jsonID("gapcursor", xy);
    class Ey {
        constructor(e) {
            this.pos = e
        }
        map(e) {
            return new Ey(e.map(this.pos))
        }
        resolve(e) {
            let t = e.resolve(this.pos);
            return xy.valid(t) ? new xy(t) : at.near(t)
        }
    }
    const My = ni({
        ArrowLeft: Ty("horiz", -1),
        ArrowRight: Ty("horiz", 1),
        ArrowUp: Ty("vert", -1),
        ArrowDown: Ty("vert", 1)
    });
    function Ty(e, t) {
        const n = "vert" == e ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
        return function (e, r, o) {
            let i = e.selection
                , s = t > 0 ? i.$to : i.$from
                , a = i.empty;
            if (i instanceof ut) {
                if (!o.endOfTextblock(n) || 0 == s.depth)
                    return !1;
                a = !1,
                    s = e.doc.resolve(t > 0 ? s.after() : s.before())
            }
            let l = xy.findGapCursorFrom(s, t, a);
            return !!l && (r && r(e.tr.setSelection(new xy(l))),
                !0)
        }
    }
    function Ny(e, t, n) {
        if (!e || !e.editable)
            return !1;
        let r = e.state.doc.resolve(t);
        if (!xy.valid(r))
            return !1;
        let o = e.posAtCoords({
            left: n.clientX,
            top: n.clientY
        });
        return !(o && o.inside > -1 && pt.isSelectable(e.state.doc.nodeAt(o.inside))) && (e.dispatch(e.state.tr.setSelection(new xy(r))),
            !0)
    }
    function _y(e, t) {
        if ("insertCompositionText" != t.inputType || !(e.state.selection instanceof xy))
            return !1;
        let { $from: n } = e.state.selection
            , r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
        if (!r)
            return !1;
        let o = d.empty;
        for (let s = r.length - 1; s >= 0; s--)
            o = d.from(r[s].createAndFill(null, o));
        let i = e.state.tr.replace(n.pos, n.pos, new g(o, 0, 0));
        return i.setSelection(ut.near(i.doc.resolve(n.pos + 1))),
            e.dispatch(i),
            !1
    }
    function Oy(e) {
        if (!(e.selection instanceof xy))
            return null;
        let t = document.createElement("div");
        return t.className = "ProseMirror-gapcursor",
            mo.create(e.doc, [ho.widget(e.selection.head, t, {
                key: "gapcursor"
            })])
    }
    const Ay = as.create({
        name: "gapCursor",
        addProseMirrorPlugins: () => [new Mt({
            props: {
                decorations: Oy,
                createSelectionBetween: (e, t, n) => t.pos == n.pos && xy.valid(n) ? new xy(n) : null,
                handleClick: Ny,
                handleKeyDown: My,
                handleDOMEvents: {
                    beforeinput: _y
                }
            }
        })],
        extendNodeSchema(e) {
            var t;
            return {
                allowGapCursor: null !== (t = Fi(Ii(e, "allowGapCursor", {
                    name: e.name,
                    options: e.options,
                    storage: e.storage
                }))) && void 0 !== t ? t : null
            }
        }
    })
        , Py = la.create({
            name: "hardBreak",
            addOptions: () => ({
                keepMarks: !0,
                HTMLAttributes: {}
            }),
            inline: !0,
            group: "inline",
            selectable: !1,
            parseHTML: () => [{
                tag: "br"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["br", $i(this.options.HTMLAttributes, t)]
            },
            renderText: () => "\n",
            addCommands() {
                return {
                    setHardBreak: () => e => {
                        let { commands: t, chain: n, state: r, editor: o } = e;
                        return t.first([() => t.exitCode(), () => t.command((() => {
                            const { selection: e, storedMarks: t } = r;
                            if (e.$from.parent.type.spec.isolating)
                                return !1;
                            const { keepMarks: i } = this.options
                                , { splittableMarks: s } = o.extensionManager
                                , a = t || e.$to.parentOffset && e.$from.marks();
                            return n().insertContent({
                                type: this.name
                            }).command((e => {
                                let { tr: t, dispatch: n } = e;
                                if (n && a && i) {
                                    const e = a.filter((e => s.includes(e.type.name)));
                                    t.ensureMarks(e)
                                }
                                return !0
                            }
                            )).run()
                        }
                        ))])
                    }
                }
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-Enter": () => this.editor.commands.setHardBreak(),
                    "Shift-Enter": () => this.editor.commands.setHardBreak()
                }
            }
        });
    var Ly = 200
        , Ry = function () { };
    Ry.prototype.append = function (e) {
        return e.length ? (e = Ry.from(e),
            !this.length && e || e.length < Ly && this.leafAppend(e) || this.length < Ly && e.leafPrepend(this) || this.appendInner(e)) : this
    }
        ,
        Ry.prototype.prepend = function (e) {
            return e.length ? Ry.from(e).append(this) : this
        }
        ,
        Ry.prototype.appendInner = function (e) {
            return new Iy(this, e)
        }
        ,
        Ry.prototype.slice = function (e, t) {
            return void 0 === e && (e = 0),
                void 0 === t && (t = this.length),
                e >= t ? Ry.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t))
        }
        ,
        Ry.prototype.get = function (e) {
            if (!(e < 0 || e >= this.length))
                return this.getInner(e)
        }
        ,
        Ry.prototype.forEach = function (e, t, n) {
            void 0 === t && (t = 0),
                void 0 === n && (n = this.length),
                t <= n ? this.forEachInner(e, t, n, 0) : this.forEachInvertedInner(e, t, n, 0)
        }
        ,
        Ry.prototype.map = function (e, t, n) {
            void 0 === t && (t = 0),
                void 0 === n && (n = this.length);
            var r = [];
            return this.forEach((function (t, n) {
                return r.push(e(t, n))
            }
            ), t, n),
                r
        }
        ,
        Ry.from = function (e) {
            return e instanceof Ry ? e : e && e.length ? new Dy(e) : Ry.empty
        }
        ;
    var Dy = function (e) {
        function t(t) {
            e.call(this),
                this.values = t
        }
        e && (t.__proto__ = e),
            t.prototype = Object.create(e && e.prototype),
            t.prototype.constructor = t;
        var n = {
            length: {
                configurable: !0
            },
            depth: {
                configurable: !0
            }
        };
        return t.prototype.flatten = function () {
            return this.values
        }
            ,
            t.prototype.sliceInner = function (e, n) {
                return 0 == e && n == this.length ? this : new t(this.values.slice(e, n))
            }
            ,
            t.prototype.getInner = function (e) {
                return this.values[e]
            }
            ,
            t.prototype.forEachInner = function (e, t, n, r) {
                for (var o = t; o < n; o++)
                    if (!1 === e(this.values[o], r + o))
                        return !1
            }
            ,
            t.prototype.forEachInvertedInner = function (e, t, n, r) {
                for (var o = t - 1; o >= n; o--)
                    if (!1 === e(this.values[o], r + o))
                        return !1
            }
            ,
            t.prototype.leafAppend = function (e) {
                if (this.length + e.length <= Ly)
                    return new t(this.values.concat(e.flatten()))
            }
            ,
            t.prototype.leafPrepend = function (e) {
                if (this.length + e.length <= Ly)
                    return new t(e.flatten().concat(this.values))
            }
            ,
            n.length.get = function () {
                return this.values.length
            }
            ,
            n.depth.get = function () {
                return 0
            }
            ,
            Object.defineProperties(t.prototype, n),
            t
    }(Ry);
    Ry.empty = new Dy([]);
    var Iy = function (e) {
        function t(t, n) {
            e.call(this),
                this.left = t,
                this.right = n,
                this.length = t.length + n.length,
                this.depth = Math.max(t.depth, n.depth) + 1
        }
        return e && (t.__proto__ = e),
            t.prototype = Object.create(e && e.prototype),
            t.prototype.constructor = t,
            t.prototype.flatten = function () {
                return this.left.flatten().concat(this.right.flatten())
            }
            ,
            t.prototype.getInner = function (e) {
                return e < this.left.length ? this.left.get(e) : this.right.get(e - this.left.length)
            }
            ,
            t.prototype.forEachInner = function (e, t, n, r) {
                var o = this.left.length;
                return !(t < o && !1 === this.left.forEachInner(e, t, Math.min(n, o), r)) && (!(n > o && !1 === this.right.forEachInner(e, Math.max(t - o, 0), Math.min(this.length, n) - o, r + o)) && void 0)
            }
            ,
            t.prototype.forEachInvertedInner = function (e, t, n, r) {
                var o = this.left.length;
                return !(t > o && !1 === this.right.forEachInvertedInner(e, t - o, Math.max(n, o) - o, r + o)) && (!(n < o && !1 === this.left.forEachInvertedInner(e, Math.min(t, o), n, r)) && void 0)
            }
            ,
            t.prototype.sliceInner = function (e, t) {
                if (0 == e && t == this.length)
                    return this;
                var n = this.left.length;
                return t <= n ? this.left.slice(e, t) : e >= n ? this.right.slice(e - n, t - n) : this.left.slice(e, n).append(this.right.slice(0, t - n))
            }
            ,
            t.prototype.leafAppend = function (e) {
                var n = this.right.leafAppend(e);
                if (n)
                    return new t(this.left, n)
            }
            ,
            t.prototype.leafPrepend = function (e) {
                var n = this.left.leafPrepend(e);
                if (n)
                    return new t(n, this.right)
            }
            ,
            t.prototype.appendInner = function (e) {
                return this.left.depth >= Math.max(this.right.depth, e.depth) + 1 ? new t(this.left, new t(this.right, e)) : new t(this, e)
            }
            ,
            t
    }(Ry);
    const jy = Ry;
    class Hy {
        constructor(e, t) {
            this.items = e,
                this.eventCount = t
        }
        popEvent(e, t) {
            if (0 == this.eventCount)
                return null;
            let n, r, o = this.items.length;
            for (; ; o--) {
                if (this.items.get(o - 1).selection) {
                    --o;
                    break
                }
            }
            t && (n = this.remapping(o, this.items.length),
                r = n.maps.length);
            let i, s, a = e.tr, l = [], c = [];
            return this.items.forEach(((e, t) => {
                if (!e.step)
                    return n || (n = this.remapping(o, t + 1),
                        r = n.maps.length),
                        r--,
                        void c.push(e);
                if (n) {
                    c.push(new zy(e.map));
                    let t, o = e.step.map(n.slice(r));
                    o && a.maybeStep(o).doc && (t = a.mapping.maps[a.mapping.maps.length - 1],
                        l.push(new zy(t, void 0, void 0, l.length + c.length))),
                        r--,
                        t && n.appendMap(t, r)
                } else
                    a.maybeStep(e.step);
                return e.selection ? (i = n ? e.selection.map(n.slice(r)) : e.selection,
                    s = new Hy(this.items.slice(0, o).append(c.reverse().concat(l)), this.eventCount - 1),
                    !1) : void 0
            }
            ), this.items.length, 0),
            {
                remaining: s,
                transform: a,
                selection: i
            }
        }
        addTransform(e, t, n, r) {
            let o = []
                , i = this.eventCount
                , s = this.items
                , a = !r && s.length ? s.get(s.length - 1) : null;
            for (let c = 0; c < e.steps.length; c++) {
                let n, l = e.steps[c].invert(e.docs[c]), d = new zy(e.mapping.maps[c], l, t);
                (n = a && a.merge(d)) && (d = n,
                    c ? o.pop() : s = s.slice(0, s.length - 1)),
                    o.push(d),
                    t && (i++,
                        t = void 0),
                    r || (a = d)
            }
            let l = i - n.depth;
            return l > By && (s = function (e, t) {
                let n;
                return e.forEach(((e, r) => {
                    if (e.selection && 0 == t--)
                        return n = r,
                            !1
                }
                )),
                    e.slice(n)
            }(s, l),
                i -= l),
                new Hy(s.append(o), i)
        }
        remapping(e, t) {
            let n = new Ce;
            return this.items.forEach(((t, r) => {
                let o = null != t.mirrorOffset && r - t.mirrorOffset >= e ? n.maps.length - t.mirrorOffset : void 0;
                n.appendMap(t.map, o)
            }
            ), e, t),
                n
        }
        addMaps(e) {
            return 0 == this.eventCount ? this : new Hy(this.items.append(e.map((e => new zy(e)))), this.eventCount)
        }
        rebased(e, t) {
            if (!this.eventCount)
                return this;
            let n = []
                , r = Math.max(0, this.items.length - t)
                , o = e.mapping
                , i = e.steps.length
                , s = this.eventCount;
            this.items.forEach((e => {
                e.selection && s--
            }
            ), r);
            let a = t;
            this.items.forEach((t => {
                let r = o.getMirror(--a);
                if (null == r)
                    return;
                i = Math.min(i, r);
                let l = o.maps[r];
                if (t.step) {
                    let i = e.steps[r].invert(e.docs[r])
                        , c = t.selection && t.selection.map(o.slice(a + 1, r));
                    c && s++,
                        n.push(new zy(l, i, c))
                } else
                    n.push(new zy(l))
            }
            ), r);
            let l = [];
            for (let u = t; u < i; u++)
                l.push(new zy(o.maps[u]));
            let c = this.items.slice(0, r).append(l).append(n)
                , d = new Hy(c, s);
            return d.emptyItemCount() > 500 && (d = d.compress(this.items.length - n.length)),
                d
        }
        emptyItemCount() {
            let e = 0;
            return this.items.forEach((t => {
                t.step || e++
            }
            )),
                e
        }
        compress() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.items.length
                , t = this.remapping(0, e)
                , n = t.maps.length
                , r = []
                , o = 0;
            return this.items.forEach(((i, s) => {
                if (s >= e)
                    r.push(i),
                        i.selection && o++;
                else if (i.step) {
                    let e = i.step.map(t.slice(n))
                        , s = e && e.getMap();
                    if (n--,
                        s && t.appendMap(s, n),
                        e) {
                        let a = i.selection && i.selection.map(t.slice(n));
                        a && o++;
                        let l, c = new zy(s.invert(), e, a), d = r.length - 1;
                        (l = r.length && r[d].merge(c)) ? r[d] = l : r.push(c)
                    }
                } else
                    i.map && n--
            }
            ), this.items.length, 0),
                new Hy(jy.from(r.reverse()), o)
        }
    }
    Hy.empty = new Hy(jy.empty, 0);
    class zy {
        constructor(e, t, n, r) {
            this.map = e,
                this.step = t,
                this.selection = n,
                this.mirrorOffset = r
        }
        merge(e) {
            if (this.step && e.step && !e.selection) {
                let t = e.step.merge(this.step);
                if (t)
                    return new zy(t.getMap().invert(), t, this.selection)
            }
        }
    }
    class $y {
        constructor(e, t, n, r, o) {
            this.done = e,
                this.undone = t,
                this.prevRanges = n,
                this.prevTime = r,
                this.prevComposition = o
        }
    }
    const By = 20;
    function Vy(e) {
        let t = [];
        for (let n = e.length - 1; n >= 0 && 0 == t.length; n--)
            e[n].forEach(((e, n, r, o) => t.push(r, o)));
        return t
    }
    function Fy(e, t) {
        if (!e)
            return null;
        let n = [];
        for (let r = 0; r < e.length; r += 2) {
            let o = t.map(e[r], 1)
                , i = t.map(e[r + 1], -1);
            o <= i && n.push(o, i)
        }
        return n
    }
    let Uy = !1
        , Wy = null;
    function qy(e) {
        let t = e.plugins;
        if (Wy != t) {
            Uy = !1,
                Wy = t;
            for (let e = 0; e < t.length; e++)
                if (t[e].spec.historyPreserveItems) {
                    Uy = !0;
                    break
                }
        }
        return Uy
    }
    const Gy = new _t("history")
        , Ky = new _t("closeHistory");
    function Jy() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return e = {
            depth: e.depth || 100,
            newGroupDelay: e.newGroupDelay || 500
        },
            new Mt({
                key: Gy,
                state: {
                    init: () => new $y(Hy.empty, Hy.empty, null, 0, -1),
                    apply: (t, n, r) => function (e, t, n, r) {
                        let o, i = n.getMeta(Gy);
                        if (i)
                            return i.historyState;
                        n.getMeta(Ky) && (e = new $y(e.done, e.undone, null, 0, -1));
                        let s = n.getMeta("appendedTransaction");
                        if (0 == n.steps.length)
                            return e;
                        if (s && s.getMeta(Gy))
                            return s.getMeta(Gy).redo ? new $y(e.done.addTransform(n, void 0, r, qy(t)), e.undone, Vy(n.mapping.maps), e.prevTime, e.prevComposition) : new $y(e.done, e.undone.addTransform(n, void 0, r, qy(t)), null, e.prevTime, e.prevComposition);
                        if (!1 === n.getMeta("addToHistory") || s && !1 === s.getMeta("addToHistory"))
                            return (o = n.getMeta("rebased")) ? new $y(e.done.rebased(n, o), e.undone.rebased(n, o), Fy(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new $y(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), Fy(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
                        {
                            let o = n.getMeta("composition")
                                , i = 0 == e.prevTime || !s && e.prevComposition != o && (e.prevTime < (n.time || 0) - r.newGroupDelay || !function (e, t) {
                                    if (!t)
                                        return !1;
                                    if (!e.docChanged)
                                        return !0;
                                    let n = !1;
                                    return e.mapping.maps[0].forEach(((e, r) => {
                                        for (let o = 0; o < t.length; o += 2)
                                            e <= t[o + 1] && r >= t[o] && (n = !0)
                                    }
                                    )),
                                        n
                                }(n, e.prevRanges))
                                , a = s ? Fy(e.prevRanges, n.mapping) : Vy(n.mapping.maps);
                            return new $y(e.done.addTransform(n, i ? t.selection.getBookmark() : void 0, r, qy(t)), Hy.empty, a, n.time, null == o ? e.prevComposition : o)
                        }
                    }(n, r, t, e)
                },
                config: e,
                props: {
                    handleDOMEvents: {
                        beforeinput(e, t) {
                            let n = t.inputType
                                , r = "historyUndo" == n ? Xy : "historyRedo" == n ? Qy : null;
                            return !!r && (t.preventDefault(),
                                r(e.state, e.dispatch))
                        }
                    }
                }
            })
    }
    function Zy(e, t) {
        return (n, r) => {
            let o = Gy.getState(n);
            if (!o || 0 == (e ? o.undone : o.done).eventCount)
                return !1;
            if (r) {
                let i = function (e, t, n) {
                    let r = qy(t)
                        , o = Gy.get(t).spec.config
                        , i = (n ? e.undone : e.done).popEvent(t, r);
                    if (!i)
                        return null;
                    let s = i.selection.resolve(i.transform.doc)
                        , a = (n ? e.done : e.undone).addTransform(i.transform, t.selection.getBookmark(), o, r)
                        , l = new $y(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
                    return i.transform.setSelection(s).setMeta(Gy, {
                        redo: n,
                        historyState: l
                    })
                }(o, n, e);
                i && r(t ? i.scrollIntoView() : i)
            }
            return !0
        }
    }
    const Xy = Zy(!1, !0)
        , Qy = Zy(!0, !0);
    Zy(!1, !1),
        Zy(!0, !1);
    const Yy = as.create({
        name: "history",
        addOptions: () => ({
            depth: 100,
            newGroupDelay: 500
        }),
        addCommands: () => ({
            undo: () => e => {
                let { state: t, dispatch: n } = e;
                return Xy(t, n)
            }
            ,
            redo: () => e => {
                let { state: t, dispatch: n } = e;
                return Qy(t, n)
            }
        }),
        addProseMirrorPlugins() {
            return [Jy(this.options)]
        },
        addKeyboardShortcuts() {
            return {
                "Mod-z": () => this.editor.commands.undo(),
                "Shift-Mod-z": () => this.editor.commands.redo(),
                "Mod-y": () => this.editor.commands.redo(),
                "Mod-\u044f": () => this.editor.commands.undo(),
                "Shift-Mod-\u044f": () => this.editor.commands.redo()
            }
        }
    })
        , ev = (e, t) => {
            for (const n in t)
                e[n] = t[n];
            return e
        }
        , tv = "numeric"
        , nv = "ascii"
        , rv = "alpha"
        , ov = "asciinumeric"
        , iv = "alphanumeric"
        , sv = "domain"
        , av = "emoji"
        , lv = "scheme"
        , cv = "slashscheme"
        , dv = "whitespace";
    function uv(e, t) {
        return e in t || (t[e] = []),
            t[e]
    }
    function hv(e, t, n) {
        t[tv] && (t[ov] = !0,
            t[iv] = !0),
            t[nv] && (t[ov] = !0,
                t[rv] = !0),
            t[ov] && (t[iv] = !0),
            t[rv] && (t[iv] = !0),
            t[iv] && (t[sv] = !0),
            t[av] && (t[sv] = !0);
        for (const r in t) {
            const t = uv(r, n);
            t.indexOf(e) < 0 && t.push(e)
        }
    }
    function pv(e) {
        void 0 === e && (e = null),
            this.j = {},
            this.jr = [],
            this.jd = null,
            this.t = e
    }
    pv.groups = {},
        pv.prototype = {
            accepts() {
                return !!this.t
            },
            go(e) {
                const t = this
                    , n = t.j[e];
                if (n)
                    return n;
                for (let r = 0; r < t.jr.length; r++) {
                    const n = t.jr[r][0]
                        , o = t.jr[r][1];
                    if (o && n.test(e))
                        return o
                }
                return t.jd
            },
            has(e, t) {
                return void 0 === t && (t = !1),
                    t ? e in this.j : !!this.go(e)
            },
            ta(e, t, n, r) {
                for (let o = 0; o < e.length; o++)
                    this.tt(e[o], t, n, r)
            },
            tr(e, t, n, r) {
                let o;
                return r = r || pv.groups,
                    t && t.j ? o = t : (o = new pv(t),
                        n && r && hv(t, n, r)),
                    this.jr.push([e, o]),
                    o
            },
            ts(e, t, n, r) {
                let o = this;
                const i = e.length;
                if (!i)
                    return o;
                for (let s = 0; s < i - 1; s++)
                    o = o.tt(e[s]);
                return o.tt(e[i - 1], t, n, r)
            },
            tt(e, t, n, r) {
                r = r || pv.groups;
                const o = this;
                if (t && t.j)
                    return o.j[e] = t,
                        t;
                const i = t;
                let s, a = o.go(e);
                if (a ? (s = new pv,
                    ev(s.j, a.j),
                    s.jr.push.apply(s.jr, a.jr),
                    s.jd = a.jd,
                    s.t = a.t) : s = new pv,
                    i) {
                    if (r)
                        if (s.t && "string" === typeof s.t) {
                            const e = ev(function (e, t) {
                                const n = {};
                                for (const r in t)
                                    t[r].indexOf(e) >= 0 && (n[r] = !0);
                                return n
                            }(s.t, r), n);
                            hv(i, e, r)
                        } else
                            n && hv(i, n, r);
                    s.t = i
                }
                return o.j[e] = s,
                    s
            }
        };
    const fv = (e, t, n, r, o) => e.ta(t, n, r, o)
        , mv = (e, t, n, r, o) => e.tr(t, n, r, o)
        , gv = (e, t, n, r, o) => e.ts(t, n, r, o)
        , bv = (e, t, n, r, o) => e.tt(t, n, r, o)
        , yv = "WORD"
        , vv = "UWORD"
        , wv = "LOCALHOST"
        , kv = "TLD"
        , Cv = "UTLD"
        , Sv = "SCHEME"
        , xv = "SLASH_SCHEME"
        , Ev = "NUM"
        , Mv = "NL"
        , Tv = "OPENBRACE"
        , Nv = "CLOSEBRACE"
        , _v = "OPENBRACKET"
        , Ov = "CLOSEBRACKET"
        , Av = "OPENPAREN"
        , Pv = "CLOSEPAREN"
        , Lv = "OPENANGLEBRACKET"
        , Rv = "CLOSEANGLEBRACKET"
        , Dv = "FULLWIDTHLEFTPAREN"
        , Iv = "FULLWIDTHRIGHTPAREN"
        , jv = "LEFTCORNERBRACKET"
        , Hv = "RIGHTCORNERBRACKET"
        , zv = "LEFTWHITECORNERBRACKET"
        , $v = "RIGHTWHITECORNERBRACKET"
        , Bv = "FULLWIDTHLESSTHAN"
        , Vv = "FULLWIDTHGREATERTHAN"
        , Fv = "AMPERSAND"
        , Uv = "APOSTROPHE"
        , Wv = "ASTERISK"
        , qv = "AT"
        , Gv = "BACKSLASH"
        , Kv = "BACKTICK"
        , Jv = "CARET"
        , Zv = "COLON"
        , Xv = "COMMA"
        , Qv = "DOLLAR"
        , Yv = "DOT"
        , ew = "EQUALS"
        , tw = "EXCLAMATION"
        , nw = "HYPHEN"
        , rw = "PERCENT"
        , ow = "PIPE"
        , iw = "PLUS"
        , sw = "POUND"
        , aw = "QUERY"
        , lw = "QUOTE"
        , cw = "SEMI"
        , dw = "SLASH"
        , uw = "TILDE"
        , hw = "UNDERSCORE"
        , pw = "EMOJI"
        , fw = "SYM";
    var mw = Object.freeze({
        __proto__: null,
        WORD: yv,
        UWORD: vv,
        LOCALHOST: wv,
        TLD: kv,
        UTLD: Cv,
        SCHEME: Sv,
        SLASH_SCHEME: xv,
        NUM: Ev,
        WS: "WS",
        NL: Mv,
        OPENBRACE: Tv,
        CLOSEBRACE: Nv,
        OPENBRACKET: _v,
        CLOSEBRACKET: Ov,
        OPENPAREN: Av,
        CLOSEPAREN: Pv,
        OPENANGLEBRACKET: Lv,
        CLOSEANGLEBRACKET: Rv,
        FULLWIDTHLEFTPAREN: Dv,
        FULLWIDTHRIGHTPAREN: Iv,
        LEFTCORNERBRACKET: jv,
        RIGHTCORNERBRACKET: Hv,
        LEFTWHITECORNERBRACKET: zv,
        RIGHTWHITECORNERBRACKET: $v,
        FULLWIDTHLESSTHAN: Bv,
        FULLWIDTHGREATERTHAN: Vv,
        AMPERSAND: Fv,
        APOSTROPHE: Uv,
        ASTERISK: Wv,
        AT: qv,
        BACKSLASH: Gv,
        BACKTICK: Kv,
        CARET: Jv,
        COLON: Zv,
        COMMA: Xv,
        DOLLAR: Qv,
        DOT: Yv,
        EQUALS: ew,
        EXCLAMATION: tw,
        HYPHEN: nw,
        PERCENT: rw,
        PIPE: ow,
        PLUS: iw,
        POUND: sw,
        QUERY: aw,
        QUOTE: lw,
        SEMI: cw,
        SLASH: dw,
        TILDE: uw,
        UNDERSCORE: hw,
        EMOJI: pw,
        SYM: fw
    });
    const gw = /[a-z]/
        , bw = /\p{L}/u
        , yw = /\p{Emoji}/u
        , vw = /\d/
        , ww = /\s/;
    let kw = null
        , Cw = null;
    function Sw(e, t, n, r, o) {
        let i;
        const s = t.length;
        for (let a = 0; a < s - 1; a++) {
            const n = t[a];
            e.j[n] ? i = e.j[n] : (i = new pv(r),
                i.jr = o.slice(),
                e.j[n] = i),
                e = i
        }
        return i = new pv(n),
            i.jr = o.slice(),
            e.j[t[s - 1]] = i,
            i
    }
    function xw(e) {
        const t = []
            , n = [];
        let r = 0;
        for (; r < e.length;) {
            let o = 0;
            for (; "0123456789".indexOf(e[r + o]) >= 0;)
                o++;
            if (o > 0) {
                t.push(n.join(""));
                for (let t = parseInt(e.substring(r, r + o), 10); t > 0; t--)
                    n.pop();
                r += o
            } else
                n.push(e[r]),
                    r++
        }
        return t
    }
    const Ew = {
        defaultProtocol: "http",
        events: null,
        format: Tw,
        formatHref: Tw,
        nl2br: !1,
        tagName: "a",
        target: null,
        rel: null,
        validate: !0,
        truncate: 1 / 0,
        className: null,
        attributes: null,
        ignoreTags: [],
        render: null
    };
    function Mw(e, t) {
        void 0 === t && (t = null);
        let n = ev({}, Ew);
        e && (n = ev(n, e instanceof Mw ? e.o : e));
        const r = n.ignoreTags
            , o = [];
        for (let i = 0; i < r.length; i++)
            o.push(r[i].toUpperCase());
        this.o = n,
            t && (this.defaultRender = t),
            this.ignoreTags = o
    }
    function Tw(e) {
        return e
    }
    Mw.prototype = {
        o: Ew,
        ignoreTags: [],
        defaultRender: e => e,
        check(e) {
            return this.get("validate", e.toString(), e)
        },
        get(e, t, n) {
            const r = null != t;
            let o = this.o[e];
            return o ? ("object" === typeof o ? (o = n.t in o ? o[n.t] : Ew[e],
                "function" === typeof o && r && (o = o(t, n))) : "function" === typeof o && r && (o = o(t, n.t, n)),
                o) : o
        },
        getObj(e, t, n) {
            let r = this.o[e];
            return "function" === typeof r && null != t && (r = r(t, n.t, n)),
                r
        },
        render(e) {
            const t = e.render(this);
            return (this.get("render", null, e) || this.defaultRender)(t, e.t, e)
        }
    };
    function Nw(e, t) {
        this.t = "token",
            this.v = e,
            this.tk = t
    }
    function _w(e, t) {
        class n extends Nw {
            constructor(t, n) {
                super(t, n),
                    this.t = e
            }
        }
        for (const r in t)
            n.prototype[r] = t[r];
        return n.t = e,
            n
    }
    Nw.prototype = {
        isLink: !1,
        toString() {
            return this.v
        },
        toHref(e) {
            return this.toString()
        },
        toFormattedString(e) {
            const t = this.toString()
                , n = e.get("truncate", t, this)
                , r = e.get("format", t, this);
            return n && r.length > n ? r.substring(0, n) + "\u2026" : r
        },
        toFormattedHref(e) {
            return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this)
        },
        startIndex() {
            return this.tk[0].s
        },
        endIndex() {
            return this.tk[this.tk.length - 1].e
        },
        toObject(e) {
            return void 0 === e && (e = Ew.defaultProtocol),
            {
                type: this.t,
                value: this.toString(),
                isLink: this.isLink,
                href: this.toHref(e),
                start: this.startIndex(),
                end: this.endIndex()
            }
        },
        toFormattedObject(e) {
            return {
                type: this.t,
                value: this.toFormattedString(e),
                isLink: this.isLink,
                href: this.toFormattedHref(e),
                start: this.startIndex(),
                end: this.endIndex()
            }
        },
        validate(e) {
            return e.get("validate", this.toString(), this)
        },
        render(e) {
            const t = this
                , n = this.toHref(e.get("defaultProtocol"))
                , r = e.get("formatHref", n, this)
                , o = e.get("tagName", n, t)
                , i = this.toFormattedString(e)
                , s = {}
                , a = e.get("className", n, t)
                , l = e.get("target", n, t)
                , c = e.get("rel", n, t)
                , d = e.getObj("attributes", n, t)
                , u = e.getObj("events", n, t);
            return s.href = r,
                a && (s.class = a),
                l && (s.target = l),
                c && (s.rel = c),
                d && ev(s, d),
            {
                tagName: o,
                attributes: s,
                content: i,
                eventListeners: u
            }
        }
    };
    const Ow = _w("email", {
        isLink: !0,
        toHref() {
            return "mailto:" + this.toString()
        }
    })
        , Aw = _w("text")
        , Pw = _w("nl")
        , Lw = _w("url", {
            isLink: !0,
            toHref(e) {
                return void 0 === e && (e = Ew.defaultProtocol),
                    this.hasProtocol() ? this.v : `${e}://${this.v}`
            },
            hasProtocol() {
                const e = this.tk;
                return e.length >= 2 && e[0].t !== wv && e[1].t === Zv
            }
        });
    const Rw = e => new pv(e);
    function Dw(e, t, n) {
        const r = n[0].s
            , o = n[n.length - 1].e;
        return new e(t.slice(r, o), n)
    }
    const Iw = "undefined" !== typeof console && console && console.warn || (() => { }
    )
        , jw = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time."
        , Hw = {
            scanner: null,
            parser: null,
            tokenQueue: [],
            pluginQueue: [],
            customSchemes: [],
            initialized: !1
        };
    function zw(e, t) {
        if (void 0 === t && (t = !1),
            Hw.initialized && Iw(`linkifyjs: already initialized - will not register custom scheme "${e}" ${jw}`),
            !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
            throw new Error('linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or "-"\n2. Cannot start or end with "-"\n3. "-" cannot repeat');
        Hw.customSchemes.push([e, t])
    }
    function $w() {
        Hw.scanner = function (e) {
            void 0 === e && (e = []);
            const t = {};
            pv.groups = t;
            const n = new pv;
            null == kw && (kw = xw("aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xf6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2")),
                null == Cw && (Cw = xw("\u03b5\u03bb1\u03c52\u0431\u04331\u0435\u043b3\u0434\u0435\u0442\u04384\u0435\u044e2\u043a\u0430\u0442\u043e\u043b\u0438\u043a6\u043e\u043c3\u043c\u043a\u04342\u043e\u043d1\u0441\u043a\u0432\u04306\u043e\u043d\u043b\u0430\u0439\u043d5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043a\u04403\u049b\u0430\u04373\u0570\u0561\u05753\u05d9\u05e9\u05e8\u05d0\u05dc5\u05e7\u05d5\u05dd3\u0627\u0628\u0648\u0638\u0628\u064a5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062f\u06464\u0628\u062d\u0631\u064a\u06465\u062c\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062f\u064a\u06296\u0639\u0644\u064a\u0627\u06465\u0645\u063a\u0631\u06285\u0645\u0627\u0631\u0627\u062a5\u06cc\u0631\u0627\u06465\u0628\u0627\u0631\u062a2\u0632\u0627\u06314\u064a\u062a\u06433\u06be\u0627\u0631\u062a5\u062a\u0648\u0646\u06334\u0633\u0648\u062f\u0627\u06463\u0631\u064a\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064a\u06466\u0642\u0637\u06313\u0643\u0627\u062b\u0648\u0644\u064a\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064a\u0633\u064a\u06275\u0648\u0631\u064a\u062a\u0627\u0646\u064a\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067e\u0627\u06a9\u0633\u062a\u0627\u06467\u0680\u0627\u0631\u062a4\u0915\u0949\u092e3\u0928\u0947\u091f3\u092d\u093e\u0930\u09240\u092e\u094d3\u094b\u09245\u0938\u0902\u0917\u0920\u09285\u09ac\u09be\u0982\u09b2\u09be5\u09ad\u09be\u09b0\u09a42\u09f0\u09a44\u0a2d\u0a3e\u0a30\u0a244\u0aad\u0abe\u0ab0\u0aa44\u0b2d\u0b3e\u0b30\u0b244\u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe6\u0bb2\u0b99\u0bcd\u0b95\u0bc86\u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd11\u0c2d\u0c3e\u0c30\u0c24\u0c4d5\u0cad\u0cbe\u0cb0\u0ca44\u0d2d\u0d3e\u0d30\u0d24\u0d025\u0dbd\u0d82\u0d9a\u0dcf4\u0e04\u0e2d\u0e213\u0e44\u0e17\u0e223\u0ea5\u0eb2\u0ea73\u10d2\u10d42\u307f\u3093\u306a3\u30a2\u30de\u30be\u30f34\u30af\u30e9\u30a6\u30c94\u30b0\u30fc\u30b0\u30eb4\u30b3\u30e02\u30b9\u30c8\u30a23\u30bb\u30fc\u30eb3\u30d5\u30a1\u30c3\u30b7\u30e7\u30f36\u30dd\u30a4\u30f3\u30c84\u4e16\u754c2\u4e2d\u4fe11\u56fd1\u570b1\u6587\u7f513\u4e9a\u9a6c\u900a3\u4f01\u4e1a2\u4f5b\u5c712\u4fe1\u606f2\u5065\u5eb72\u516b\u53662\u516c\u53f81\u76ca2\u53f0\u6e7e1\u70632\u5546\u57ce1\u5e971\u68072\u5609\u91cc0\u5927\u9152\u5e975\u5728\u7ebf2\u5927\u62ff2\u5929\u4e3b\u65593\u5a31\u4e502\u5bb6\u96fb2\u5e7f\u4e1c2\u5fae\u535a2\u6148\u55842\u6211\u7231\u4f603\u624b\u673a2\u62db\u80582\u653f\u52a11\u5e9c2\u65b0\u52a0\u57612\u95fb2\u65f6\u5c1a2\u66f8\u7c4d2\u673a\u67842\u6de1\u9a6c\u95213\u6e38\u620f2\u6fb3\u95802\u70b9\u770b2\u79fb\u52a82\u7ec4\u7ec7\u673a\u67844\u7f51\u57401\u5e971\u7ad91\u7edc2\u8054\u901a2\u8c37\u6b4c2\u8d2d\u72692\u901a\u8ca92\u96c6\u56e22\u96fb\u8a0a\u76c8\u79d14\u98de\u5229\u6d663\u98df\u54c12\u9910\u53852\u9999\u683c\u91cc\u62c93\u6e2f2\ub2f7\ub1371\ucef42\uc0bc\uc1312\ud55c\uad6d2")),
                bv(n, "'", Uv),
                bv(n, "{", Tv),
                bv(n, "}", Nv),
                bv(n, "[", _v),
                bv(n, "]", Ov),
                bv(n, "(", Av),
                bv(n, ")", Pv),
                bv(n, "<", Lv),
                bv(n, ">", Rv),
                bv(n, "\uff08", Dv),
                bv(n, "\uff09", Iv),
                bv(n, "\u300c", jv),
                bv(n, "\u300d", Hv),
                bv(n, "\u300e", zv),
                bv(n, "\u300f", $v),
                bv(n, "\uff1c", Bv),
                bv(n, "\uff1e", Vv),
                bv(n, "&", Fv),
                bv(n, "*", Wv),
                bv(n, "@", qv),
                bv(n, "`", Kv),
                bv(n, "^", Jv),
                bv(n, ":", Zv),
                bv(n, ",", Xv),
                bv(n, "$", Qv),
                bv(n, ".", Yv),
                bv(n, "=", ew),
                bv(n, "!", tw),
                bv(n, "-", nw),
                bv(n, "%", rw),
                bv(n, "|", ow),
                bv(n, "+", iw),
                bv(n, "#", sw),
                bv(n, "?", aw),
                bv(n, '"', lw),
                bv(n, "/", dw),
                bv(n, ";", cw),
                bv(n, "~", uw),
                bv(n, "_", hw),
                bv(n, "\\", Gv);
            const r = mv(n, vw, Ev, {
                [tv]: !0
            });
            mv(r, vw, r);
            const o = mv(n, gw, yv, {
                [nv]: !0
            });
            mv(o, gw, o);
            const i = mv(n, bw, vv, {
                [rv]: !0
            });
            mv(i, gw),
                mv(i, bw, i);
            const s = mv(n, ww, "WS", {
                [dv]: !0
            });
            bv(n, "\n", Mv, {
                [dv]: !0
            }),
                bv(s, "\n"),
                mv(s, ww, s);
            const a = mv(n, yw, pw, {
                [av]: !0
            });
            mv(a, yw, a),
                bv(a, "\ufe0f", a);
            const l = bv(a, "\u200d");
            mv(l, yw, a);
            const c = [[gw, o]]
                , d = [[gw, null], [bw, i]];
            for (let u = 0; u < kw.length; u++)
                Sw(n, kw[u], kv, yv, c);
            for (let u = 0; u < Cw.length; u++)
                Sw(n, Cw[u], Cv, vv, d);
            hv(kv, {
                tld: !0,
                ascii: !0
            }, t),
                hv(Cv, {
                    utld: !0,
                    alpha: !0
                }, t),
                Sw(n, "file", Sv, yv, c),
                Sw(n, "mailto", Sv, yv, c),
                Sw(n, "http", xv, yv, c),
                Sw(n, "https", xv, yv, c),
                Sw(n, "ftp", xv, yv, c),
                Sw(n, "ftps", xv, yv, c),
                hv(Sv, {
                    scheme: !0,
                    ascii: !0
                }, t),
                hv(xv, {
                    slashscheme: !0,
                    ascii: !0
                }, t),
                e = e.sort(((e, t) => e[0] > t[0] ? 1 : -1));
            for (let u = 0; u < e.length; u++) {
                const t = e[u][0]
                    , r = e[u][1] ? {
                        [lv]: !0
                    } : {
                        [cv]: !0
                    };
                t.indexOf("-") >= 0 ? r[sv] = !0 : gw.test(t) ? vw.test(t) ? r[ov] = !0 : r[nv] = !0 : r[tv] = !0,
                    gv(n, t, t, r)
            }
            return gv(n, "localhost", wv, {
                ascii: !0
            }),
                n.jd = new pv(fw),
            {
                start: n,
                tokens: ev({
                    groups: t
                }, mw)
            }
        }(Hw.customSchemes);
        for (let e = 0; e < Hw.tokenQueue.length; e++)
            Hw.tokenQueue[e][1]({
                scanner: Hw.scanner
            });
        Hw.parser = function (e) {
            let { groups: t } = e;
            const n = t.domain.concat([Fv, Wv, qv, Gv, Kv, Jv, Qv, ew, nw, Ev, rw, ow, iw, sw, dw, fw, uw, hw])
                , r = [Uv, Zv, Xv, Yv, tw, aw, lw, cw, Lv, Rv, Tv, Nv, Ov, _v, Av, Pv, Dv, Iv, jv, Hv, zv, $v, Bv, Vv]
                , o = [Fv, Uv, Wv, Gv, Kv, Jv, Qv, ew, nw, Tv, Nv, rw, ow, iw, sw, aw, dw, fw, uw, hw]
                , i = Rw()
                , s = bv(i, uw);
            fv(s, o, s),
                fv(s, t.domain, s);
            const a = Rw()
                , l = Rw()
                , c = Rw();
            fv(i, t.domain, a),
                fv(i, t.scheme, l),
                fv(i, t.slashscheme, c),
                fv(a, o, s),
                fv(a, t.domain, a);
            const d = bv(a, qv);
            bv(s, qv, d),
                bv(l, qv, d),
                bv(c, qv, d);
            const u = bv(s, Yv);
            fv(u, o, s),
                fv(u, t.domain, s);
            const h = Rw();
            fv(d, t.domain, h),
                fv(h, t.domain, h);
            const p = bv(h, Yv);
            fv(p, t.domain, h);
            const f = Rw(Ow);
            fv(p, t.tld, f),
                fv(p, t.utld, f),
                bv(d, wv, f);
            const m = bv(h, nw);
            fv(m, t.domain, h),
                fv(f, t.domain, h),
                bv(f, Yv, p),
                bv(f, nw, m);
            const g = bv(f, Zv);
            fv(g, t.numeric, Ow);
            const b = bv(a, nw)
                , y = bv(a, Yv);
            fv(b, t.domain, a),
                fv(y, o, s),
                fv(y, t.domain, a);
            const v = Rw(Lw);
            fv(y, t.tld, v),
                fv(y, t.utld, v),
                fv(v, t.domain, a),
                fv(v, o, s),
                bv(v, Yv, y),
                bv(v, nw, b),
                bv(v, qv, d);
            const w = bv(v, Zv)
                , k = Rw(Lw);
            fv(w, t.numeric, k);
            const C = Rw(Lw)
                , S = Rw();
            fv(C, n, C),
                fv(C, r, S),
                fv(S, n, C),
                fv(S, r, S),
                bv(v, dw, C),
                bv(k, dw, C);
            const x = bv(l, Zv)
                , E = bv(c, Zv)
                , M = bv(E, dw)
                , T = bv(M, dw);
            fv(l, t.domain, a),
                bv(l, Yv, y),
                bv(l, nw, b),
                fv(c, t.domain, a),
                bv(c, Yv, y),
                bv(c, nw, b),
                fv(x, t.domain, C),
                bv(x, dw, C),
                fv(T, t.domain, C),
                fv(T, n, C),
                bv(T, dw, C);
            const N = [[Tv, Nv], [_v, Ov], [Av, Pv], [Lv, Rv], [Dv, Iv], [jv, Hv], [zv, $v], [Bv, Vv]];
            for (let _ = 0; _ < N.length; _++) {
                const [e, t] = N[_]
                    , o = bv(C, e);
                bv(S, e, o),
                    bv(o, t, C);
                const i = Rw(Lw);
                fv(o, n, i);
                const s = Rw();
                fv(o, r),
                    fv(i, n, i),
                    fv(i, r, s),
                    fv(s, n, i),
                    fv(s, r, s),
                    bv(i, t, C),
                    bv(s, t, C)
            }
            return bv(i, wv, v),
                bv(i, Mv, Pw),
            {
                start: i,
                tokens: mw
            }
        }(Hw.scanner.tokens);
        for (let e = 0; e < Hw.pluginQueue.length; e++)
            Hw.pluginQueue[e][1]({
                scanner: Hw.scanner,
                parser: Hw.parser
            });
        Hw.initialized = !0
    }
    function Bw(e) {
        return Hw.initialized || $w(),
            function (e, t, n) {
                let r = n.length
                    , o = 0
                    , i = []
                    , s = [];
                for (; o < r;) {
                    let a = e
                        , l = null
                        , c = null
                        , d = 0
                        , u = null
                        , h = -1;
                    for (; o < r && !(l = a.go(n[o].t));)
                        s.push(n[o++]);
                    for (; o < r && (c = l || a.go(n[o].t));)
                        l = null,
                            a = c,
                            a.accepts() ? (h = 0,
                                u = a) : h >= 0 && h++,
                            o++,
                            d++;
                    if (h < 0)
                        o -= d,
                            o < r && (s.push(n[o]),
                                o++);
                    else {
                        s.length > 0 && (i.push(Dw(Aw, t, s)),
                            s = []),
                            o -= h,
                            d -= h;
                        const e = u.t
                            , r = n.slice(o - d, o);
                        i.push(Dw(e, t, r))
                    }
                }
                return s.length > 0 && i.push(Dw(Aw, t, s)),
                    i
            }(Hw.parser.start, e, function (e, t) {
                const n = function (e) {
                    const t = []
                        , n = e.length;
                    let r = 0;
                    for (; r < n;) {
                        let o, i = e.charCodeAt(r), s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2);
                        t.push(s),
                            r += s.length
                    }
                    return t
                }(t.replace(/[A-Z]/g, (e => e.toLowerCase())))
                    , r = n.length
                    , o = [];
                let i = 0
                    , s = 0;
                for (; s < r;) {
                    let a = e
                        , l = null
                        , c = 0
                        , d = null
                        , u = -1
                        , h = -1;
                    for (; s < r && (l = a.go(n[s]));)
                        a = l,
                            a.accepts() ? (u = 0,
                                h = 0,
                                d = a) : u >= 0 && (u += n[s].length,
                                    h++),
                            c += n[s].length,
                            i += n[s].length,
                            s++;
                    i -= u,
                        s -= h,
                        c -= u,
                        o.push({
                            t: d.t,
                            v: t.slice(i - c, i),
                            s: i - c,
                            e: i
                        })
                }
                return o
            }(Hw.scanner.start, e))
    }
    function Vw(e, t, n) {
        if (void 0 === t && (t = null),
            void 0 === n && (n = null),
            t && "object" === typeof t) {
            if (n)
                throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
            n = t,
                t = null
        }
        const r = new Mw(n)
            , o = Bw(e)
            , i = [];
        for (let s = 0; s < o.length; s++) {
            const e = o[s];
            !e.isLink || t && e.t !== t || !r.check(e) || i.push(e.toFormattedObject(r))
        }
        return i
    }
    const Fw = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
    function Uw(e, t) {
        const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
        return t && t.forEach((e => {
            const t = "string" === typeof e ? e : e.scheme;
            t && n.push(t)
        }
        )),
            !e || e.replace(Fw, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"))
    }
    const Ww = ts.create({
        name: "link",
        priority: 1e3,
        keepOnSplit: !1,
        exitable: !0,
        onCreate() {
            this.options.protocols.forEach((e => {
                "string" !== typeof e ? zw(e.scheme, e.optionalSlashes) : zw(e)
            }
            ))
        },
        onDestroy() {
            pv.groups = {},
                Hw.scanner = null,
                Hw.parser = null,
                Hw.tokenQueue = [],
                Hw.pluginQueue = [],
                Hw.customSchemes = [],
                Hw.initialized = !1
        },
        inclusive() {
            return this.options.autolink
        },
        addOptions: () => ({
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            defaultProtocol: "http",
            HTMLAttributes: {
                target: "_blank",
                rel: "noopener noreferrer nofollow",
                class: null
            },
            validate: e => !!e
        }),
        addAttributes() {
            return {
                href: {
                    default: null,
                    parseHTML: e => e.getAttribute("href")
                },
                target: {
                    default: this.options.HTMLAttributes.target
                },
                rel: {
                    default: this.options.HTMLAttributes.rel
                },
                class: {
                    default: this.options.HTMLAttributes.class
                }
            }
        },
        parseHTML() {
            return [{
                tag: "a[href]",
                getAttrs: e => {
                    const t = e.getAttribute("href");
                    return !(!t || !Uw(t, this.options.protocols)) && null
                }
            }]
        },
        renderHTML(e) {
            let { HTMLAttributes: t } = e;
            return Uw(t.href, this.options.protocols) ? ["a", $i(this.options.HTMLAttributes, t), 0] : ["a", $i(this.options.HTMLAttributes, {
                ...t,
                href: ""
            }), 0]
        },
        addCommands() {
            return {
                setLink: e => t => {
                    let { chain: n } = t;
                    return n().setMark(this.name, e).setMeta("preventAutolink", !0).run()
                }
                ,
                toggleLink: e => t => {
                    let { chain: n } = t;
                    return n().toggleMark(this.name, e, {
                        extendEmptyMarkRange: !0
                    }).setMeta("preventAutolink", !0).run()
                }
                ,
                unsetLink: () => e => {
                    let { chain: t } = e;
                    return t().unsetMark(this.name, {
                        extendEmptyMarkRange: !0
                    }).setMeta("preventAutolink", !0).run()
                }
            }
        },
        addPasteRules() {
            return [da({
                find: e => {
                    const t = [];
                    if (e) {
                        const { validate: n } = this.options
                            , r = Vw(e).filter((e => e.isLink && n(e.value)));
                        r.length && r.forEach((e => t.push({
                            text: e.value,
                            data: {
                                href: e.href
                            },
                            index: e.start
                        })))
                    }
                    return t
                }
                ,
                type: this.type,
                getAttributes: e => {
                    var t;
                    return {
                        href: null === (t = e.data) || void 0 === t ? void 0 : t.href
                    }
                }
            })]
        },
        addProseMirrorPlugins() {
            const e = [];
            return this.options.autolink && e.push(function (e) {
                return new Mt({
                    key: new _t("autolink"),
                    appendTransaction: (t, n, r) => {
                        const o = t.some((e => e.docChanged)) && !n.doc.eq(r.doc)
                            , i = t.some((e => e.getMeta("preventAutolink")));
                        if (!o || i)
                            return;
                        const { tr: s } = r;
                        return zs(Os(n.doc, [...t])).forEach((t => {
                            let { newRange: n } = t;
                            const o = Ps(r.doc, n, (e => e.isTextblock));
                            let i, a;
                            if (o.length > 1 ? (i = o[0],
                                a = r.doc.textBetween(i.pos, i.pos + i.node.nodeSize, void 0, " ")) : o.length && r.doc.textBetween(n.from, n.to, " ", " ").endsWith(" ") && (i = o[0],
                                    a = r.doc.textBetween(i.pos, n.to, void 0, " ")),
                                i && a) {
                                const t = a.split(" ").filter((e => "" !== e));
                                if (t.length <= 0)
                                    return !1;
                                const n = t[t.length - 1]
                                    , o = i.pos + a.lastIndexOf(n);
                                if (!n)
                                    return !1;
                                const c = Bw(n).map((t => t.toObject(e.defaultProtocol)));
                                if (!(1 === (l = c).length ? l[0].isLink : 3 === l.length && l[1].isLink && ["()", "[]"].includes(l[0].value + l[2].value)))
                                    return !1;
                                c.filter((e => e.isLink)).map((e => ({
                                    ...e,
                                    from: o + e.start + 1,
                                    to: o + e.end + 1
                                }))).filter((e => !r.schema.marks.code || !r.doc.rangeHasMark(e.from, e.to, r.schema.marks.code))).filter((t => e.validate(t.value))).forEach((t => {
                                    $s(t.from, t.to, r.doc).some((t => t.mark.type === e.type)) || s.addMark(t.from, t.to, e.type.create({
                                        href: t.href
                                    }))
                                }
                                ))
                            }
                            var l
                        }
                        )),
                            s.steps.length ? s : void 0
                    }
                })
            }({
                type: this.type,
                defaultProtocol: this.options.defaultProtocol,
                validate: this.options.validate
            })),
                !0 === this.options.openOnClick && e.push(function (e) {
                    return new Mt({
                        key: new _t("handleClickLink"),
                        props: {
                            handleClick: (t, n, r) => {
                                var o, i;
                                if (0 !== r.button)
                                    return !1;
                                if (!t.editable)
                                    return !1;
                                let s = r.target;
                                const a = [];
                                for (; "DIV" !== s.nodeName;)
                                    a.push(s),
                                        s = s.parentNode;
                                if (!a.find((e => "A" === e.nodeName)))
                                    return !1;
                                const l = js(t.state, e.type.name)
                                    , c = r.target
                                    , d = null !== (o = null === c || void 0 === c ? void 0 : c.href) && void 0 !== o ? o : l.href
                                    , u = null !== (i = null === c || void 0 === c ? void 0 : c.target) && void 0 !== i ? i : l.target;
                                return !(!c || !d) && (window.open(d, u),
                                    !0)
                            }
                        }
                    })
                }({
                    type: this.type
                })),
                this.options.linkOnPaste && e.push(function (e) {
                    return new Mt({
                        key: new _t("handlePasteLink"),
                        props: {
                            handlePaste: (t, n, r) => {
                                const { state: o } = t
                                    , { selection: i } = o
                                    , { empty: s } = i;
                                if (s)
                                    return !1;
                                let a = "";
                                r.content.forEach((e => {
                                    a += e.textContent
                                }
                                ));
                                const l = Vw(a, {
                                    defaultProtocol: e.defaultProtocol
                                }).find((e => e.isLink && e.value === a));
                                return !(!a || !l) && (e.editor.commands.setMark(e.type, {
                                    href: l.href
                                }),
                                    !0)
                            }
                        }
                    })
                }({
                    editor: this.editor,
                    defaultProtocol: this.options.defaultProtocol,
                    type: this.type
                })),
                e
        }
    })
        , qw = la.create({
            name: "text",
            group: "inline"
        });
    var Gw = Object.defineProperty
        , Kw = (e, t, n) => ((e, t, n) => t in e ? Gw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : e[t] = n)(e, "symbol" != typeof t ? t + "" : t, n);
    const Jw = {
        slash_menu: {
            heading: {
                title: "Heading 1",
                subtext: "Top-level heading",
                aliases: ["h", "heading1", "h1"],
                group: "Headings"
            },
            heading_2: {
                title: "Heading 2",
                subtext: "Key section heading",
                aliases: ["h2", "heading2", "subheading"],
                group: "Headings"
            },
            heading_3: {
                title: "Heading 3",
                subtext: "Subsection and group heading",
                aliases: ["h3", "heading3", "subheading"],
                group: "Headings"
            },
            numbered_list: {
                title: "Numbered List",
                subtext: "List with ordered items",
                aliases: ["ol", "li", "list", "numberedlist", "numbered list"],
                group: "Basic blocks"
            },
            bullet_list: {
                title: "Bullet List",
                subtext: "List with unordered items",
                aliases: ["ul", "li", "list", "bulletlist", "bullet list"],
                group: "Basic blocks"
            },
            check_list: {
                title: "Check List",
                subtext: "List with checkboxes",
                aliases: ["ul", "li", "list", "checklist", "check list", "checked list", "checkbox"],
                group: "Basic blocks"
            },
            paragraph: {
                title: "Paragraph",
                subtext: "The body of your document",
                aliases: ["p", "paragraph"],
                group: "Basic blocks"
            },
            code_block: {
                title: "Code Block",
                subtext: "Code block with syntax highlighting",
                aliases: ["code", "pre"],
                group: "Basic blocks"
            },
            table: {
                title: "Table",
                subtext: "Table with editable cells",
                aliases: ["table"],
                group: "Advanced"
            },
            image: {
                title: "Image",
                subtext: "Resizable image with caption",
                aliases: ["image", "imageUpload", "upload", "img", "picture", "media", "url"],
                group: "Media"
            },
            video: {
                title: "Video",
                subtext: "Resizable video with caption",
                aliases: ["video", "videoUpload", "upload", "mp4", "film", "media", "url"],
                group: "Media"
            },
            audio: {
                title: "Audio",
                subtext: "Embedded audio with caption",
                aliases: ["audio", "audioUpload", "upload", "mp3", "sound", "media", "url"],
                group: "Media"
            },
            file: {
                title: "File",
                subtext: "Embedded file",
                aliases: ["file", "upload", "embed", "media", "url"],
                group: "Media"
            },
            emoji: {
                title: "Emoji",
                subtext: "Search for and insert an emoji",
                aliases: ["emoji", "emote", "emotion", "face"],
                group: "Others"
            }
        },
        placeholders: {
            default: "Enter text or type '/' for commands",
            heading: "Heading",
            bulletListItem: "List",
            numberedListItem: "List",
            checkListItem: "List"
        },
        file_blocks: {
            image: {
                add_button_text: "Add image"
            },
            video: {
                add_button_text: "Add video"
            },
            audio: {
                add_button_text: "Add audio"
            },
            file: {
                add_button_text: "Add file"
            }
        },
        side_menu: {
            add_block_label: "Add block",
            drag_handle_label: "Open block menu"
        },
        drag_handle: {
            delete_menuitem: "Delete",
            colors_menuitem: "Colors"
        },
        table_handle: {
            delete_column_menuitem: "Delete column",
            delete_row_menuitem: "Delete row",
            add_left_menuitem: "Add column left",
            add_right_menuitem: "Add column right",
            add_above_menuitem: "Add row above",
            add_below_menuitem: "Add row below"
        },
        suggestion_menu: {
            no_items_title: "No items found",
            loading: "Loading\u2026"
        },
        color_picker: {
            text_title: "Text",
            background_title: "Background",
            colors: {
                default: "Default",
                gray: "Gray",
                brown: "Brown",
                red: "Red",
                orange: "Orange",
                yellow: "Yellow",
                green: "Green",
                blue: "Blue",
                purple: "Purple",
                pink: "Pink"
            }
        },
        formatting_toolbar: {
            bold: {
                tooltip: "Bold",
                secondary_tooltip: "Mod+B"
            },
            italic: {
                tooltip: "Italic",
                secondary_tooltip: "Mod+I"
            },
            underline: {
                tooltip: "Underline",
                secondary_tooltip: "Mod+U"
            },
            strike: {
                tooltip: "Strike",
                secondary_tooltip: "Mod+Shift+S"
            },
            code: {
                tooltip: "Code",
                secondary_tooltip: ""
            },
            colors: {
                tooltip: "Colors"
            },
            link: {
                tooltip: "Create link",
                secondary_tooltip: "Mod+K"
            },
            file_caption: {
                tooltip: "Edit caption",
                input_placeholder: "Edit caption"
            },
            file_replace: {
                tooltip: {
                    image: "Replace image",
                    video: "Replace video",
                    audio: "Replace audio",
                    file: "Replace file"
                }
            },
            file_rename: {
                tooltip: {
                    image: "Rename image",
                    video: "Rename video",
                    audio: "Rename audio",
                    file: "Rename file"
                },
                input_placeholder: {
                    image: "Rename image",
                    video: "Rename video",
                    audio: "Rename audio",
                    file: "Rename file"
                }
            },
            file_download: {
                tooltip: {
                    image: "Download image",
                    video: "Download video",
                    audio: "Download audio",
                    file: "Download file"
                }
            },
            file_delete: {
                tooltip: {
                    image: "Delete image",
                    video: "Delete video",
                    audio: "Delete audio",
                    file: "Delete file"
                }
            },
            file_preview_toggle: {
                tooltip: "Toggle preview"
            },
            nest: {
                tooltip: "Nest block",
                secondary_tooltip: "Tab"
            },
            unnest: {
                tooltip: "Unnest block",
                secondary_tooltip: "Shift+Tab"
            },
            align_left: {
                tooltip: "Align text left"
            },
            align_center: {
                tooltip: "Align text center"
            },
            align_right: {
                tooltip: "Align text right"
            },
            align_justify: {
                tooltip: "Justify text"
            }
        },
        file_panel: {
            upload: {
                title: "Upload",
                file_placeholder: {
                    image: "Upload image",
                    video: "Upload video",
                    audio: "Upload audio",
                    file: "Upload file"
                },
                upload_error: "Error: Upload failed"
            },
            embed: {
                title: "Embed",
                embed_button: {
                    image: "Embed image",
                    video: "Embed video",
                    audio: "Embed audio",
                    file: "Embed file"
                },
                url_placeholder: "Enter URL"
            }
        },
        link_toolbar: {
            delete: {
                tooltip: "Remove link"
            },
            edit: {
                text: "Edit link",
                tooltip: "Edit"
            },
            open: {
                tooltip: "Open in new tab"
            },
            form: {
                title_placeholder: "Edit title",
                url_placeholder: "Edit URL"
            }
        },
        generic: {
            ctrl_shortcut: "Ctrl"
        }
    };
    Symbol.toStringTag;
    class Zw extends Error {
        constructor(e) {
            super(`Unreachable case: ${e}`)
        }
    }
    function Xw(e) {
        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        const { "data-test": n, ...r } = e;
        if (Object.keys(r).length > 0 && t)
            throw new Error("Object must be empty " + JSON.stringify(e))
    }
    function Qw(e) {
        const t = e.filter(((t, n) => e.indexOf(t) !== n));
        return function (e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : JSON.stringify;
            const n = {};
            return e.filter((e => {
                const r = t(e);
                return !Object.prototype.hasOwnProperty.call(n, r) && (n[r] = !0)
            }
            ))
        }(t)
    }
    const Yw = as.create({
        name: "uniqueID",
        priority: 1e4,
        addOptions: () => ({
            attributeName: "id",
            types: [],
            setIdAttribute: !1,
            generateID: () => {
                if (typeof window < "u" && window.__TEST_OPTIONS) {
                    const e = window.__TEST_OPTIONS;
                    return void 0 === e.mockID ? e.mockID = 0 : e.mockID++,
                        e.mockID.toString()
                }
                return va()
            }
            ,
            filterTransaction: null
        }),
        addGlobalAttributes() {
            return [{
                types: this.options.types,
                attributes: {
                    [this.options.attributeName]: {
                        default: null,
                        parseHTML: e => e.getAttribute(`data-${this.options.attributeName}`),
                        renderHTML: e => {
                            const t = {
                                [`data-${this.options.attributeName}`]: e[this.options.attributeName]
                            };
                            return this.options.setIdAttribute ? {
                                ...t,
                                id: e[this.options.attributeName]
                            } : t
                        }
                    }
                }
            }]
        },
        addProseMirrorPlugins() {
            let e = null
                , t = !1;
            return [new Mt({
                key: new _t("uniqueID"),
                appendTransaction: (e, t, n) => {
                    const r = e.some((e => e.docChanged)) && !t.doc.eq(n.doc)
                        , o = this.options.filterTransaction && e.some((e => {
                            let t, n;
                            return !(null !== (n = (t = this.options).filterTransaction) && void 0 !== n && n.call(t, e))
                        }
                        ));
                    if (!r || o)
                        return;
                    const { tr: i } = n
                        , { types: s, attributeName: a, generateID: l } = this.options
                        , c = Os(t.doc, e)
                        , { mapping: d } = c;
                    return zs(c).forEach((e => {
                        let { newRange: r } = e;
                        const o = Ps(n.doc, r, (e => s.includes(e.type.name)))
                            , c = o.map((e => {
                                let { node: t } = e;
                                return t.attrs[a]
                            }
                            )).filter((e => null !== e))
                            , u = Qw(c);
                        o.forEach((e => {
                            let r, { node: o, pos: s } = e;
                            const c = null === (r = i.doc.nodeAt(s)) || void 0 === r ? void 0 : r.attrs[a];
                            if (null === c) {
                                const e = t.doc.type.createAndFill().content;
                                if (null === t.doc.content.findDiffStart(e)) {
                                    const t = JSON.parse(JSON.stringify(n.doc.toJSON()));
                                    if (t.content[0].content[0].attrs.id = "initialBlockId",
                                        JSON.stringify(t.content) === JSON.stringify(e.toJSON()))
                                        return void i.setNodeMarkup(s, void 0, {
                                            ...o.attrs,
                                            [a]: "initialBlockId"
                                        })
                                }
                                return void i.setNodeMarkup(s, void 0, {
                                    ...o.attrs,
                                    [a]: l()
                                })
                            }
                            const { deleted: h } = d.invert().mapResult(s);
                            h && u.includes(c) && i.setNodeMarkup(s, void 0, {
                                ...o.attrs,
                                [a]: l()
                            })
                        }
                        ))
                    }
                    )),
                        i.steps.length ? i : void 0
                }
                ,
                view(t) {
                    const n = n => {
                        let r;
                        e = null !== (r = t.dom.parentElement) && void 0 !== r && r.contains(n.target) ? t.dom.parentElement : null
                    }
                        ;
                    return window.addEventListener("dragstart", n),
                    {
                        destroy() {
                            window.removeEventListener("dragstart", n)
                        }
                    }
                },
                props: {
                    handleDOMEvents: {
                        drop: (n, r) => {
                            let o;
                            return (e !== n.dom.parentElement || "copy" === (null === (o = r.dataTransfer) || void 0 === o ? void 0 : o.effectAllowed)) && (e = null,
                                t = !0),
                                !1
                        }
                        ,
                        paste: () => (t = !0,
                            !1)
                    },
                    transformPasted: e => {
                        if (!t)
                            return e;
                        const { types: n, attributeName: r } = this.options
                            , o = e => {
                                const t = [];
                                return e.forEach((e => {
                                    if (e.isText)
                                        return void t.push(e);
                                    if (!n.includes(e.type.name))
                                        return void t.push(e.copy(o(e.content)));
                                    const i = e.type.create({
                                        ...e.attrs,
                                        [r]: null
                                    }, o(e.content), e.marks);
                                    t.push(i)
                                }
                                )),
                                    d.from(t)
                            }
                            ;
                        return t = !1,
                            new g(o(e.content), e.openStart, e.openEnd)
                    }
                }
            })]
        }
    });
    function ek(e) {
        return "link" === e.type
    }
    function tk(e) {
        return "string" != typeof e && "link" === e.type
    }
    function nk(e) {
        return "string" != typeof e && "text" === e.type
    }
    function rk(e, t, n) {
        const r = [];
        for (const [o, i] of Object.entries(e.styles)) {
            const e = n[o];
            if (!e)
                throw new Error(`style ${o} not found in styleSchema`);
            if ("boolean" === e.propSchema)
                r.push(t.mark(o));
            else {
                if ("string" !== e.propSchema)
                    throw new Zw(e.propSchema);
                r.push(t.mark(o, {
                    stringValue: i
                }))
            }
        }
        return e.text.split(/(\n)/g).filter((e => e.length > 0)).map((e => "\n" === e ? t.nodes.hardBreak.create() : t.text(e, r)))
    }
    function ok(e, t, n) {
        const r = t.marks.link.create({
            href: e.href
        });
        return ik(e.content, t, n).map((e => {
            if ("text" === e.type.name)
                return e.mark([...e.marks, r]);
            if ("hardBreak" === e.type.name)
                return e;
            throw new Error("unexpected node type")
        }
        ))
    }
    function ik(e, t, n) {
        const r = [];
        if ("string" == typeof e)
            return r.push(...rk({
                type: "text",
                text: e,
                styles: {}
            }, t, n)),
                r;
        for (const o of e)
            r.push(...rk(o, t, n));
        return r
    }
    function sk(e, t, n) {
        const r = [];
        for (const o of e)
            "string" == typeof o ? r.push(...ik(o, t, n)) : tk(o) ? r.push(...ok(o, t, n)) : nk(o) ? r.push(...ik([o], t, n)) : r.push(lk(o, t, n));
        return r
    }
    function ak(e, t, n) {
        var r;
        const o = [];
        for (const i of e.rows) {
            const s = [];
            for (let o = 0; o < i.cells.length; o++) {
                const a = i.cells[o];
                let l;
                if (a)
                    if ("string" == typeof a)
                        l = t.nodes.tableParagraph.create({}, t.text(a));
                    else {
                        const e = sk(a, t, n);
                        l = t.nodes.tableParagraph.create({}, e)
                    }
                else
                    l = t.nodes.tableParagraph.create({});
                const c = t.nodes.tableCell.create({
                    colwidth: null != (r = e.columnWidths) && r[o] ? [e.columnWidths[o]] : null
                }, l);
                s.push(c)
            }
            const a = t.nodes.tableRow.create({}, s);
            o.push(a)
        }
        return o
    }
    function lk(e, t, n) {
        let r, o = e.type;
        if (void 0 === o && (o = "paragraph"),
            !t.nodes[o])
            throw new Error(`node type ${o} not found in schema`);
        if (e.content)
            if ("string" == typeof e.content) {
                const i = sk([e.content], t, n);
                r = t.nodes[o].create(e.props, i)
            } else if (Array.isArray(e.content)) {
                const i = sk(e.content, t, n);
                r = t.nodes[o].create(e.props, i)
            } else {
                if ("tableContent" !== e.content.type)
                    throw new Zw(e.content.type);
                {
                    const i = ak(e.content, t, n);
                    r = t.nodes[o].create(e.props, i)
                }
            }
        else
            r = t.nodes[o].create(e.props);
        return r
    }
    function ck(e, t, n) {
        let r = e.id;
        void 0 === r && (r = Yw.options.generateID());
        const o = lk(e, t, n)
            , i = [];
        if (e.children)
            for (const a of e.children)
                i.push(ck(a, t, n));
        const s = t.nodes.blockGroup.create({}, i);
        return t.nodes.blockContainer.create({
            id: r,
            ...e.props
        }, i.length > 0 ? [o, s] : o)
    }
    function dk(e) {
        const t = [...e.classList].filter((e => !e.startsWith("bn-"))) || [];
        t.length > 0 ? e.className = t.join(" ") : e.removeAttribute("class")
    }
    function uk(e, t, n, r) {
        let o;
        if (!t)
            throw new Error("blockContent is required");
        if ("string" == typeof t)
            o = sk([t], e.pmSchema, e.schema.styleSchema);
        else if (Array.isArray(t))
            o = sk(t, e.pmSchema, e.schema.styleSchema);
        else {
            if ("tableContent" !== t.type)
                throw new Zw(t.type);
            o = ak(t, e.pmSchema, e.schema.styleSchema)
        }
        const i = n.serializeFragment(d.from(o), r);
        return 1 === i.nodeType && dk(i),
            i
    }
    function hk(e, t, n, r, o, i, s) {
        var a, l, c, d, u, h, p;
        const f = (null == s ? void 0 : s.document) ?? document
            , m = t.pmSchema.nodes.blockContainer;
        let g = n.props;
        if (!n.props) {
            g = {};
            for (const [e, r] of Object.entries(t.schema.blockSchema[n.type].propSchema))
                g[e] = r.default
        }
        const b = [...(null == (l = null == (a = m.spec) ? void 0 : a.toDOM) ? void 0 : l.call(a, m.create({
            id: n.id,
            ...g
        }))).dom.attributes]
            , y = t.blockImplementations[n.type].implementation.toExternalHTML({
                ...n,
                props: g
            }, t)
            , v = f.createDocumentFragment();
        if (y.dom.classList.contains("bn-block-content")) {
            const e = [...b, ...y.dom.attributes].filter((e => e.name.startsWith("data") && "data-content-type" !== e.name && "data-file-block" !== e.name && "data-node-view-wrapper" !== e.name && "data-node-type" !== e.name && "data-id" !== e.name && "data-index" !== e.name && "data-editable" !== e.name));
            for (const t of e)
                y.dom.firstChild.setAttribute(t.name, t.value);
            dk(y.dom.firstChild),
                v.append(...y.dom.childNodes)
        } else
            v.append(y.dom);
        if (y.contentDOM && n.content) {
            const e = uk(t, n.content, r, s);
            y.contentDOM.appendChild(e)
        }
        let w;
        if (o.has(n.type) ? w = "OL" : i.has(n.type) && (w = "UL"),
            w) {
            if ((null == (c = e.lastChild) ? void 0 : c.nodeName) !== w) {
                const t = f.createElement(w);
                e.append(t)
            }
            const t = f.createElement("li");
            t.append(v),
                e.lastChild.appendChild(t)
        } else
            e.append(v);
        if (n.children && n.children.length > 0) {
            const a = f.createDocumentFragment();
            if (pk(a, t, n.children, r, o, i, s),
                "UL" === (null == (d = e.lastChild) ? void 0 : d.nodeName) || "OL" === (null == (u = e.lastChild) ? void 0 : u.nodeName))
                for (; "UL" === (null == (h = a.firstChild) ? void 0 : h.nodeName) || "OL" === (null == (p = a.firstChild) ? void 0 : p.nodeName);)
                    e.lastChild.lastChild.appendChild(a.firstChild);
            e.append(a)
        }
    }
    const pk = (e, t, n, r, o, i, s) => {
        for (const a of n)
            hk(e, t, a, r, o, i, s)
    }
        , fk = (e, t) => {
            const n = ue.fromSchema(e);
            return {
                exportBlocks: (e, r) => {
                    const o = ((e, t, n, r, o, i) => {
                        const s = ((null == i ? void 0 : i.document) ?? document).createDocumentFragment();
                        return pk(s, e, t, n, r, o, i),
                            s
                    }
                    )(t, e, n, new Set(["numberedListItem"]), new Set(["bulletListItem", "checkListItem"]), r)
                        , i = document.createElement("div");
                    return i.append(o),
                        i.innerHTML
                }
                ,
                exportInlineContent: (e, r) => {
                    const o = uk(t, e, n, r)
                        , i = document.createElement("div");
                    return i.append(o.cloneNode(!0)),
                        i.innerHTML
                }
            }
        }
        ;
    function mk(e, t, n, r, o) {
        var i, s, a, l;
        const c = e.pmSchema.nodes.blockContainer;
        let u = t.props;
        if (!t.props) {
            u = {};
            for (const [n, r] of Object.entries(e.schema.blockSchema[t.type].propSchema))
                u[n] = r.default
        }
        const h = null == (s = null == (i = c.spec) ? void 0 : i.toDOM) ? void 0 : s.call(i, c.create({
            id: t.id,
            ...u
        }))
            , p = e.blockImplementations[t.type].implementation.toInternalHTML({
                ...t,
                props: u
            }, e);
        if ("numberedListItem" === t.type && p.dom.setAttribute("data-index", r.toString()),
            p.contentDOM && t.content) {
            const r = function (e, t, n, r) {
                let o;
                if (!t)
                    throw new Error("blockContent is required");
                if ("string" == typeof t)
                    o = sk([t], e.pmSchema, e.schema.styleSchema);
                else if (Array.isArray(t))
                    o = sk(t, e.pmSchema, e.schema.styleSchema);
                else {
                    if ("tableContent" !== t.type)
                        throw new Zw(t.type);
                    o = ak(t, e.pmSchema, e.schema.styleSchema)
                }
                return n.serializeFragment(d.from(o), r)
            }(e, t.content, n, o);
            p.contentDOM.appendChild(r)
        }
        return null == (a = h.contentDOM) || a.appendChild(p.dom),
            t.children && t.children.length > 0 && (null == (l = h.contentDOM) || l.appendChild(gk(e, t.children, n, o))),
            h.dom
    }
    const gk = (e, t, n, r) => {
        const o = e.pmSchema.nodes.blockGroup
            , i = o.spec.toDOM(o.create({}));
        let s = 0;
        for (const a of t) {
            "numberedListItem" === a.type ? s++ : s = 0;
            const t = mk(e, a, n, s, r);
            i.contentDOM.appendChild(t)
        }
        return i.dom
    }
        ;
    function bk(e, t) {
        const n = e.resolve(t);
        if (n.nodeAfter && "blockContainer" === n.nodeAfter.type.name)
            return {
                posBeforeNode: n.pos,
                node: n.nodeAfter
            };
        let r = n.depth
            , o = n.node(r);
        for (; r > 0;) {
            if ("blockContainer" === o.type.name)
                return {
                    posBeforeNode: n.before(r),
                    node: o
                };
            r--,
                o = n.node(r)
        }
        const i = [];
        e.descendants(((e, t) => {
            "blockContainer" === e.type.name && i.push(t)
        }
        )),
            console.warn(`Position ${t} is not within a blockContainer node.`);
        const s = e.resolve(i.find((e => e >= t)) || i[i.length - 1]);
        return {
            posBeforeNode: s.pos,
            node: s.nodeAfter
        }
    }
    function yk(e, t) {
        const n = e
            , r = t
            , o = r + n.nodeSize
            , i = {
                node: n,
                beforePos: r,
                afterPos: o
            };
        let s, a;
        if (n.forEach(((e, t) => {
            if ("blockContent" === e.type.spec.group) {
                const n = e
                    , o = r + t + 1
                    , i = o + e.nodeSize;
                s = {
                    node: n,
                    beforePos: o,
                    afterPos: i
                }
            } else if ("blockGroup" === e.type.name) {
                const n = e
                    , o = r + t + 1
                    , i = o + e.nodeSize;
                a = {
                    node: n,
                    beforePos: o,
                    afterPos: i
                }
            }
        }
        )),
            !s)
            throw new Error(`blockContainer node does not contain a blockContent node in its children: ${n}`);
        return {
            blockContainer: i,
            blockContent: s,
            blockGroup: a
        }
    }
    function vk(e) {
        return yk(e.node, e.posBeforeNode)
    }
    function wk(e) {
        if (!e.nodeAfter)
            throw new Error(`Attempted to get blockContainer node at position ${e.pos} but a node at this position does not exist`);
        if ("blockContainer" !== e.nodeAfter.type.name)
            throw new Error(`Attempted to get blockContainer node at position ${e.pos} but found node of different type ${e.nodeAfter}`);
        return yk(e.nodeAfter, e.pos)
    }
    function kk(e) {
        return vk(bk(e.doc, e.selection.anchor))
    }
    function Ck(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Ctrl";
        return typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent)) ? e.replace("Mod", "\u2318") : e.replace("Mod", t)
    }
    function Sk() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return t.filter((e => e)).join(" ")
    }
    const xk = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    function Ek(e, t, n, r) {
        const o = document.createElement("div");
        o.className = Sk("bn-block-content", n.class),
            o.setAttribute("data-content-type", e);
        for (const [s, a] of Object.entries(n))
            "class" !== s && o.setAttribute(s, a);
        const i = document.createElement(t);
        i.className = Sk("bn-inline-content", r.class);
        for (const [s, a] of Object.entries(r))
            "class" !== s && i.setAttribute(s, a);
        return o.appendChild(i),
        {
            dom: o,
            contentDOM: i
        }
    }
    const Mk = (e, t) => {
        const n = ck(e, t.pmSchema, t.schema.styleSchema).firstChild
            , r = t.pmSchema.nodes[n.type.name].spec.toDOM;
        if (void 0 === r)
            throw new Error("This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.");
        const o = r(n);
        if ("object" != typeof o || !("dom" in o))
            throw new Error("Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.");
        return o
    }
        , Tk = {
            backgroundColor: {
                default: "default"
            },
            textColor: {
                default: "default"
            },
            textAlignment: {
                default: "left",
                values: ["left", "center", "right", "justify"]
            }
        }
        , Nk = ["backgroundColor", "textColor"];
    function _k(e) {
        return "data-" + e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
    }
    function Ok(e) {
        const t = e.split("/");
        return t.length && "" !== t[t.length - 1] ? t[t.length - 1] : e
    }
    function Ak(e) {
        const t = {};
        return Object.entries(e).filter((e => {
            let [t, n] = e;
            return !Nk.includes(t)
        }
        )).forEach((e => {
            let [n, r] = e;
            t[n] = {
                default: r.default,
                keepOnSplit: !0,
                parseHTML: e => {
                    const t = e.getAttribute(_k(n));
                    if (null === t)
                        return null;
                    if ("boolean" == typeof r.default)
                        return "true" === t || "false" !== t && null;
                    if ("number" == typeof r.default) {
                        const e = parseFloat(t);
                        return !Number.isNaN(e) && Number.isFinite(e) ? e : null
                    }
                    return t
                }
                ,
                renderHTML: e => e[n] !== r.default ? {
                    [_k(n)]: e[n]
                } : {}
            }
        }
        )),
            t
    }
    function Pk(e, t, n, r) {
        if ("boolean" == typeof e)
            throw new Error("Cannot find node position as getPos is a boolean, not a function.");
        const o = e()
            , i = n.state.doc.resolve(o).node().attrs.id;
        if (!i)
            throw new Error("Block doesn't have id");
        const s = t.getBlock(i);
        if (s.type !== r)
            throw new Error("Block type does not match");
        return s
    }
    function Lk(e, t, n, r) {
        let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
            , i = arguments.length > 5 ? arguments[5] : void 0;
        const s = document.createElement("div");
        if (void 0 !== i)
            for (const [a, l] of Object.entries(i))
                "class" !== a && s.setAttribute(a, l);
        s.className = Sk("bn-block-content", (null == i ? void 0 : i.class) || ""),
            s.setAttribute("data-content-type", t);
        for (const [a, l] of Object.entries(n))
            !Nk.includes(a) && l !== r[a].default && s.setAttribute(_k(a), l);
        return o && s.setAttribute("data-file-block", ""),
            s.appendChild(e.dom),
            void 0 !== e.contentDOM && (e.contentDOM.className = Sk("bn-inline-content", e.contentDOM.className),
                e.contentDOM.setAttribute("data-editable", "")),
        {
            ...e,
            dom: s
        }
    }
    function Rk(e) {
        return la.create(e)
    }
    function Dk(e, t) {
        return {
            config: e,
            implementation: t
        }
    }
    function Ik(e, t, n) {
        return Dk({
            type: e.name,
            content: "inline*" === e.config.content ? "inline" : "tableRow+" === e.config.content ? "table" : "none",
            propSchema: t
        }, {
            node: e,
            requiredExtensions: n,
            toInternalHTML: Mk,
            toExternalHTML: Mk
        })
    }
    function jk(e) {
        return Object.fromEntries(Object.entries(e).map((e => {
            let [t, n] = e;
            return [t, n.config]
        }
        )))
    }
    function Hk(e, t) {
        e.stopEvent = e => ("mousedown" === e.type && setTimeout((() => {
            t.view.dom.blur()
        }
        ), 10),
            !0)
    }
    function zk(e, t) {
        const n = [{
            tag: "[data-content-type=" + e.type + "]",
            contentElement: "[data-editable]"
        }];
        return t && n.push({
            tag: "*",
            getAttrs(e) {
                if ("string" == typeof e)
                    return !1;
                const n = null == t ? void 0 : t(e);
                return void 0 !== n && n
            }
        }),
            n
    }
    function $k(e, t) {
        const n = Rk({
            name: e.type,
            content: "inline" === e.content ? "inline*" : "",
            group: "blockContent",
            selectable: e.isSelectable ?? !0,
            addAttributes: () => Ak(e.propSchema),
            parseHTML: () => zk(e, t.parse),
            renderHTML(t) {
                let { HTMLAttributes: n } = t;
                const r = document.createElement("div");
                return Lk({
                    dom: r,
                    contentDOM: "inline" === e.content ? r : void 0
                }, e.type, {}, e.propSchema, e.isFileBlock, n)
            },
            addNodeView() {
                return n => {
                    let { getPos: r } = n;
                    var o;
                    const i = this.options.editor
                        , s = Pk(r, i, this.editor, e.type)
                        , a = (null == (o = this.options.domAttributes) ? void 0 : o.blockContent) || {}
                        , l = Lk(t.render(s, i), s.type, s.props, e.propSchema, a);
                    return !1 === e.isSelectable && Hk(l, this.editor),
                        l
                }
            }
        });
        if (n.name !== e.type)
            throw new Error("Node name does not match block type. This is a bug in BlockNote.");
        return Dk(e, {
            node: n,
            toInternalHTML: (r, o) => {
                var i;
                const s = (null == (i = n.options.domAttributes) ? void 0 : i.blockContent) || {};
                return Lk(t.render(r, o), r.type, r.props, e.propSchema, e.isFileBlock, s)
            }
            ,
            toExternalHTML: (r, o) => {
                var i, s;
                const a = (null == (i = n.options.domAttributes) ? void 0 : i.blockContent) || {};
                let l = null == (s = t.toExternalHTML) ? void 0 : s.call(t, r, o);
                return void 0 === l && (l = t.render(r, o)),
                    Lk(l, r.type, r.props, e.propSchema, a)
            }
        })
    }
    function Bk(e, t, n) {
        const r = {
            type: "tableContent",
            columnWidths: [],
            rows: []
        };
        return e.content.forEach(((e, o, i) => {
            const s = {
                cells: []
            };
            0 === i && e.content.forEach((e => {
                var t;
                r.columnWidths.push((null == (t = e.attrs.colwidth) ? void 0 : t[0]) || void 0)
            }
            )),
                e.content.forEach((e => {
                    s.cells.push(Vk(e.firstChild, t, n))
                }
                )),
                r.rows.push(s)
        }
        )),
            r
    }
    function Vk(e, t, n) {
        const r = [];
        let o;
        return e.content.forEach((e => {
            if ("hardBreak" === e.type.name) {
                if (o)
                    if (nk(o))
                        o.text += "\n";
                    else {
                        if (!ek(o))
                            throw new Error("unexpected");
                        o.content[o.content.length - 1].text += "\n"
                    }
                else
                    o = {
                        type: "text",
                        text: "\n",
                        styles: {}
                    };
                return
            }
            if ("link" !== e.type.name && "text" !== e.type.name && t[e.type.name])
                return o && (r.push(o),
                    o = void 0),
                    void r.push(Fk(e, t, n));
            const i = {};
            let s;
            for (const t of e.marks)
                if ("link" === t.type.name)
                    s = t;
                else {
                    const e = n[t.type.name];
                    if (!e)
                        throw new Error(`style ${t.type.name} not found in styleSchema`);
                    if ("boolean" === e.propSchema)
                        i[e.type] = !0;
                    else {
                        if ("string" !== e.propSchema)
                            throw new Zw(e.propSchema);
                        i[e.type] = t.attrs.stringValue
                    }
                }
            o ? nk(o) ? s ? (r.push(o),
                o = {
                    type: "link",
                    href: s.attrs.href,
                    content: [{
                        type: "text",
                        text: e.textContent,
                        styles: i
                    }]
                }) : JSON.stringify(o.styles) === JSON.stringify(i) ? o.text += e.textContent : (r.push(o),
                    o = {
                        type: "text",
                        text: e.textContent,
                        styles: i
                    }) : ek(o) && (s ? o.href === s.attrs.href ? JSON.stringify(o.content[o.content.length - 1].styles) === JSON.stringify(i) ? o.content[o.content.length - 1].text += e.textContent : o.content.push({
                        type: "text",
                        text: e.textContent,
                        styles: i
                    }) : (r.push(o),
                        o = {
                            type: "link",
                            href: s.attrs.href,
                            content: [{
                                type: "text",
                                text: e.textContent,
                                styles: i
                            }]
                        }) : (r.push(o),
                            o = {
                                type: "text",
                                text: e.textContent,
                                styles: i
                            })) : o = s ? {
                                type: "link",
                                href: s.attrs.href,
                                content: [{
                                    type: "text",
                                    text: e.textContent,
                                    styles: i
                                }]
                            } : {
                                type: "text",
                                text: e.textContent,
                                styles: i
                            }
        }
        )),
            o && r.push(o),
            r
    }
    function Fk(e, t, n) {
        if ("text" === e.type.name || "link" === e.type.name)
            throw new Error("unexpected");
        const r = {}
            , o = t[e.type.name];
        for (const [s, a] of Object.entries(e.attrs)) {
            if (!o)
                throw Error("ic node is of an unrecognized type: " + e.type.name);
            s in o.propSchema && (r[s] = a)
        }
        let i;
        return i = "styled" === o.content ? Vk(e, t, n) : void 0,
        {
            type: e.type.name,
            props: r,
            content: i
        }
    }
    function Uk(e, t, n, r, o) {
        if ("blockContainer" !== e.type.name)
            throw Error("Node must be of type blockContainer, but is of type" + e.type.name + ".");
        const i = null == o ? void 0 : o.get(e);
        if (i)
            return i;
        const { blockContainer: s, blockContent: a, blockGroup: l } = yk(e, 0);
        let c = s.node.attrs.id;
        null === c && (c = Yw.options.generateID());
        const d = {};
        for (const [m, g] of Object.entries({
            ...e.attrs,
            ...a.node.attrs
        })) {
            const e = t[a.node.type.name];
            if (!e)
                throw Error("Block is of an unrecognized type: " + a.node.type.name);
            m in e.propSchema && (d[m] = g)
        }
        const u = t[a.node.type.name]
            , h = [];
        let p;
        if (null == l || l.node.forEach((e => {
            h.push(Uk(e, t, n, r, o))
        }
        )),
            "inline" === u.content)
            p = Vk(a.node, n, r);
        else if ("table" === u.content)
            p = Bk(a.node, n, r);
        else {
            if ("none" !== u.content)
                throw new Zw(u.content);
            p = void 0
        }
        const f = {
            id: c,
            type: u.type,
            props: d,
            content: p,
            children: h
        };
        return null == o || o.set(e, f),
            f
    }
    function Wk(e) {
        return Object.fromEntries(Object.entries(e).map((e => {
            let [t, n] = e;
            return [t, n.config]
        }
        )))
    }
    function qk(e, t) {
        return {
            config: e,
            implementation: t
        }
    }
    function Gk(e, t) {
        return qk({
            type: e.name,
            propSchema: t
        }, {
            mark: e
        })
    }
    function Kk(e) {
        return Object.fromEntries(Object.entries(e).map((e => {
            let [t, n] = e;
            return [t, n.config]
        }
        )))
    }
    const Jk = (e, t, n, r, o) => {
        const i = document.createElement("div");
        if (i.className = "bn-file-block-content-wrapper",
            "" === e.props.url) {
            const n = Qk(e, t, r, o);
            i.appendChild(n.dom);
            const s = document.createElement("div");
            s.className = "bn-file-loading-preview",
                s.textContent = "Loading...";
            const a = t.onUploadStart((t => {
                t === e.id && (i.removeChild(n.dom),
                    i.appendChild(s))
            }
            ))
                , l = t.onUploadEnd((t => {
                    t === e.id && (i.removeChild(s),
                        i.appendChild(n.dom))
                }
                ));
            return {
                dom: i,
                destroy: () => {
                    var e;
                    null == (e = n.destroy) || e.call(n),
                        a(),
                        l()
                }
            }
        }
        if (!1 === e.props.showPreview) {
            const t = Zk(e).dom;
            return {
                dom: Xk(e, t).dom
            }
        }
        return i.appendChild(n.dom),
        {
            dom: i,
            destroy: n.destroy
        }
    }
        , Zk = e => {
            const t = document.createElement("div");
            t.className = "bn-file-default-preview";
            const n = document.createElement("div");
            n.className = "bn-file-default-preview-icon",
                n.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>';
            const r = document.createElement("p");
            return r.className = "bn-file-default-preview-name",
                r.textContent = e.props.name || "",
                t.appendChild(n),
                t.appendChild(r),
            {
                dom: t
            }
        }
        , Xk = (e, t) => {
            const n = document.createElement("div");
            n.className = "bn-file-and-caption-wrapper";
            const r = document.createElement("p");
            return r.className = "bn-file-caption",
                r.textContent = e.props.caption,
                "number" == typeof e.props.previewWidth && e.props.previewWidth > 0 && void 0 !== e.props.caption && (r.style.width = `${e.props.previewWidth}px`),
                n.appendChild(t),
                n.appendChild(r),
            {
                dom: n
            }
        }
        , Qk = (e, t, n, r) => {
            const o = document.createElement("div");
            o.className = "bn-add-file-button";
            const i = document.createElement("div");
            i.className = "bn-add-file-button-icon",
                r ? i.appendChild(r) : i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>';
            const s = document.createElement("p");
            s.className = "bn-add-file-button-text",
                s.innerHTML = n || t.dictionary.file_blocks.file.add_button_text;
            const a = e => {
                e.preventDefault()
            }
                , l = () => {
                    t.dispatch(t._tiptapEditor.state.tr.setMeta(t.filePanel.plugin, {
                        block: e
                    }))
                }
                ;
            return o.appendChild(i),
                o.appendChild(s),
                o.addEventListener("mousedown", a, !0),
                o.addEventListener("click", l, !0),
            {
                dom: o,
                destroy: () => {
                    o.removeEventListener("mousedown", a, !0),
                        o.removeEventListener("click", l, !0)
                }
            }
        }
        , Yk = e => ({
            url: e.src || void 0
        })
        , eC = (e, t) => {
            const n = e.querySelector(t);
            if (!n)
                return;
            const r = e.querySelector("figcaption");
            return {
                targetElement: n,
                caption: (null == r ? void 0 : r.textContent) ?? void 0
            }
        }
        , tC = (e, t) => {
            const n = document.createElement("div")
                , r = document.createElement("p");
            return r.textContent = t,
                n.appendChild(e),
                n.appendChild(r),
            {
                dom: n
            }
        }
        , nC = (e, t) => {
            const n = document.createElement("figure")
                , r = document.createElement("figcaption");
            return r.textContent = t,
                n.appendChild(e),
                n.appendChild(r),
            {
                dom: n
            }
        }
        , rC = (e, t, n, r, o) => {
            if (!e.props.previewWidth)
                throw new Error("Block must have a `previewWidth` prop.");
            const i = document.createElement("div");
            i.className = "bn-visual-media-wrapper";
            const s = document.createElement("div");
            s.className = "bn-visual-media-resize-handle",
                s.style.left = "4px";
            const a = document.createElement("div");
            let l;
            a.className = "bn-visual-media-resize-handle",
                a.style.right = "4px";
            const c = n => {
                if (!l)
                    return void (!t.isEditable && i.contains(s) && i.contains(a) && (i.removeChild(s),
                        i.removeChild(a)));
                let r;
                r = "center" === e.props.textAlignment ? "left" === l.handleUsed ? l.initialWidth + 2 * (l.initialClientX - n.clientX) : l.initialWidth + 2 * (n.clientX - l.initialClientX) : "left" === l.handleUsed ? l.initialWidth + l.initialClientX - n.clientX : l.initialWidth + n.clientX - l.initialClientX;
                r < 64 ? o(64) : r > t.domElement.firstElementChild.clientWidth ? o(t.domElement.firstElementChild.clientWidth) : o(r)
            }
                , d = n => {
                    (!n.target || !i.contains(n.target) || !t.isEditable) && i.contains(s) && i.contains(a) && (i.removeChild(s),
                        i.removeChild(a)),
                        l && (l = void 0,
                            t.updateBlock(e, {
                                props: {
                                    previewWidth: r()
                                }
                            }))
                }
                , u = () => {
                    t.isEditable && (i.appendChild(s),
                        i.appendChild(a))
                }
                , h = e => {
                    e.relatedTarget === s || e.relatedTarget === a || l || t.isEditable && i.contains(s) && i.contains(a) && (i.removeChild(s),
                        i.removeChild(a))
                }
                , p = t => {
                    t.preventDefault(),
                        i.appendChild(s),
                        i.appendChild(a),
                        l = {
                            handleUsed: "left",
                            initialWidth: e.props.previewWidth,
                            initialClientX: t.clientX
                        }
                }
                , f = t => {
                    t.preventDefault(),
                        i.appendChild(s),
                        i.appendChild(a),
                        l = {
                            handleUsed: "right",
                            initialWidth: e.props.previewWidth,
                            initialClientX: t.clientX
                        }
                }
                ;
            return i.appendChild(n),
                window.addEventListener("mousemove", c),
                window.addEventListener("mouseup", d),
                n.addEventListener("mouseenter", u),
                n.addEventListener("mouseleave", h),
                s.addEventListener("mousedown", p),
                a.addEventListener("mousedown", f),
            {
                dom: i,
                destroy: () => {
                    window.removeEventListener("mousemove", c),
                        window.removeEventListener("mouseup", d),
                        n.removeEventListener("mouseenter", u),
                        n.removeEventListener("mouseleave", h),
                        s.removeEventListener("mousedown", p),
                        a.removeEventListener("mousedown", f)
                }
            }
        }
        , oC = e => ({
            url: e.src || void 0
        })
        , iC = {
            type: "audio",
            propSchema: {
                backgroundColor: Tk.backgroundColor,
                name: {
                    default: ""
                },
                url: {
                    default: ""
                },
                caption: {
                    default: ""
                },
                showPreview: {
                    default: !0
                }
            },
            content: "none",
            isFileBlock: !0,
            fileBlockAccept: ["audio/*"]
        }
        , sC = e => {
            if ("AUDIO" === e.tagName)
                return oC(e);
            if ("FIGURE" === e.tagName) {
                const t = eC(e, "audio");
                if (!t)
                    return;
                const { targetElement: n, caption: r } = t;
                return {
                    ...oC(n),
                    caption: r
                }
            }
        }
        , aC = $k(iC, {
            render: (e, t) => {
                const n = document.createElement("div");
                n.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"></path></svg>';
                const r = document.createElement("audio");
                r.className = "bn-audio",
                    t.resolveFileUrl(e.props.url).then((e => {
                        r.src = e
                    }
                    )),
                    r.controls = !0,
                    r.contentEditable = "false",
                    r.draggable = !1;
                const o = Xk(e, r);
                return Jk(e, t, o, t.dictionary.file_blocks.audio.add_button_text, n.firstElementChild)
            }
            ,
            parse: sC,
            toExternalHTML: e => {
                if (!e.props.url) {
                    const e = document.createElement("p");
                    return e.textContent = "Add audio",
                    {
                        dom: e
                    }
                }
                let t;
                return e.props.showPreview ? (t = document.createElement("audio"),
                    t.src = e.props.url) : (t = document.createElement("a"),
                        t.href = e.props.url,
                        t.textContent = e.props.name || e.props.url),
                    e.props.caption ? e.props.showPreview ? nC(t, e.props.caption) : tC(t, e.props.caption) : {
                        dom: t
                    }
            }
        })
        , lC = [{
            id: "angular-html",
            name: "Angular HTML",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(5026)]).then(n.bind(n, 5026)).then((e => e.f))
        }, {
            id: "angular-ts",
            name: "Angular TypeScript",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(2509), n.e(5852)]).then(n.bind(n, 5852))
        }, {
            id: "astro",
            name: "Astro",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(3253), n.e(8696)]).then(n.bind(n, 8696))
        }, {
            id: "blade",
            name: "Blade",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3535), n.e(3979), n.e(966)]).then(n.bind(n, 966))
        }, {
            id: "c",
            name: "C",
            import: () => n.e(357).then(n.bind(n, 357))
        }, {
            id: "coffee",
            name: "CoffeeScript",
            aliases: ["coffeescript"],
            import: () => Promise.all([n.e(3014), n.e(2707)]).then(n.bind(n, 5088))
        }, {
            id: "cpp",
            name: "C++",
            aliases: ["c++"],
            import: () => Promise.all([n.e(3979), n.e(357), n.e(9764)]).then(n.bind(n, 9764))
        }, {
            id: "css",
            name: "CSS",
            import: () => n.e(3224).then(n.bind(n, 3224))
        }, {
            id: "glsl",
            name: "GLSL",
            import: () => Promise.all([n.e(357), n.e(6750)]).then(n.bind(n, 6750))
        }, {
            id: "graphql",
            name: "GraphQL",
            aliases: ["gql"],
            import: () => Promise.all([n.e(3014), n.e(3253), n.e(8283), n.e(4507), n.e(5138)]).then(n.bind(n, 5138))
        }, {
            id: "haml",
            name: "Ruby Haml",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(6114)]).then(n.bind(n, 6114))
        }, {
            id: "handlebars",
            name: "Handlebars",
            aliases: ["hbs"],
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(2549)]).then(n.bind(n, 2549))
        }, {
            id: "html",
            name: "HTML",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464)]).then(n.bind(n, 9464))
        }, {
            id: "html-derivative",
            name: "HTML (Derivative)",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(853)]).then(n.bind(n, 853))
        }, {
            id: "http",
            name: "HTTP",
            import: () => Promise.all([n.e(3014), n.e(3253), n.e(3535), n.e(8283), n.e(4507), n.e(3383), n.e(5092)]).then(n.bind(n, 5092))
        }, {
            id: "imba",
            name: "Imba",
            import: () => Promise.all([n.e(3253), n.e(7013)]).then(n.bind(n, 7013))
        }, {
            id: "java",
            name: "Java",
            import: () => n.e(3535).then(n.bind(n, 3535))
        }, {
            id: "javascript",
            name: "JavaScript",
            aliases: ["js"],
            import: () => n.e(3014).then(n.bind(n, 3014))
        }, {
            id: "jinja",
            name: "Jinja",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(4503)]).then(n.bind(n, 4503))
        }, {
            id: "jison",
            name: "Jison",
            import: () => Promise.all([n.e(3014), n.e(3722)]).then(n.bind(n, 3722))
        }, {
            id: "json",
            name: "JSON",
            import: () => n.e(528).then(n.bind(n, 528))
        }, {
            id: "json5",
            name: "JSON5",
            import: () => n.e(567).then(n.bind(n, 567))
        }, {
            id: "jsonc",
            name: "JSON with Comments",
            import: () => n.e(4918).then(n.bind(n, 4918))
        }, {
            id: "jsonl",
            name: "JSON Lines",
            import: () => n.e(6972).then(n.bind(n, 6972))
        }, {
            id: "jsx",
            name: "JSX",
            import: () => n.e(8283).then(n.bind(n, 8283))
        }, {
            id: "julia",
            name: "Julia",
            aliases: ["jl"],
            import: () => Promise.all([n.e(3014), n.e(3979), n.e(357), n.e(9764), n.e(2144), n.e(7041), n.e(8287)]).then(n.bind(n, 8287))
        }, {
            id: "less",
            name: "Less",
            import: () => n.e(7734).then(n.bind(n, 7734))
        }, {
            id: "markdown",
            name: "Markdown",
            aliases: ["md"],
            import: () => n.e(3387).then(n.bind(n, 5768))
        }, {
            id: "marko",
            name: "Marko",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(2509), n.e(7734), n.e(9567)]).then(n.bind(n, 9567))
        }, {
            id: "mdc",
            name: "MDC",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3387), n.e(6251)]).then(n.bind(n, 6251))
        }, {
            id: "mdx",
            name: "MDX",
            import: () => n.e(8228).then(n.bind(n, 8228))
        }, {
            id: "php",
            name: "PHP",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3535), n.e(3979), n.e(3117)]).then(n.bind(n, 3117))
        }, {
            id: "postcss",
            name: "PostCSS",
            import: () => n.e(1606).then(n.bind(n, 1606))
        }, {
            id: "pug",
            name: "Pug",
            aliases: ["jade"],
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(8846)]).then(n.bind(n, 8846))
        }, {
            id: "python",
            name: "Python",
            aliases: ["py"],
            import: () => n.e(2144).then(n.bind(n, 2144))
        }, {
            id: "r",
            name: "R",
            import: () => n.e(7041).then(n.bind(n, 7041))
        }, {
            id: "regexp",
            name: "RegExp",
            aliases: ["regex"],
            import: () => n.e(4730).then(n.bind(n, 4730))
        }, {
            id: "sass",
            name: "Sass",
            import: () => n.e(5129).then(n.bind(n, 5129))
        }, {
            id: "scss",
            name: "SCSS",
            import: () => Promise.all([n.e(3224), n.e(2509)]).then(n.bind(n, 2509))
        }, {
            id: "shellscript",
            name: "Shell",
            aliases: ["bash", "sh", "shell", "zsh"],
            import: () => n.e(3383).then(n.bind(n, 3383))
        }, {
            id: "sql",
            name: "SQL",
            import: () => n.e(3979).then(n.bind(n, 3979))
        }, {
            id: "stylus",
            name: "Stylus",
            aliases: ["styl"],
            import: () => n.e(7096).then(n.bind(n, 7096))
        }, {
            id: "svelte",
            name: "Svelte",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(3253), n.e(7196)]).then(n.bind(n, 7196))
        }, {
            id: "ts-tags",
            name: "TypeScript with Tags",
            aliases: ["lit"],
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3253), n.e(3535), n.e(3979), n.e(357), n.e(9306)]).then(n.bind(n, 9306))
        }, {
            id: "tsx",
            name: "TSX",
            import: () => n.e(4507).then(n.bind(n, 4507))
        }, {
            id: "typescript",
            name: "TypeScript",
            aliases: ["ts"],
            import: () => n.e(3253).then(n.bind(n, 3253))
        }, {
            id: "vue",
            name: "Vue",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3253), n.e(6795)]).then(n.bind(n, 6795))
        }, {
            id: "vue-html",
            name: "Vue HTML",
            import: () => Promise.all([n.e(3014), n.e(3224), n.e(9464), n.e(3253), n.e(7231)]).then(n.bind(n, 7231))
        }, {
            id: "wasm",
            name: "WebAssembly",
            import: () => n.e(1567).then(n.bind(n, 1567))
        }, {
            id: "wgsl",
            name: "WGSL",
            import: () => n.e(4960).then(n.bind(n, 4960))
        }, {
            id: "xml",
            name: "XML",
            import: () => Promise.all([n.e(3535), n.e(7177)]).then(n.bind(n, 7177))
        }, {
            id: "yaml",
            name: "YAML",
            aliases: ["yml"],
            import: () => n.e(3468).then(n.bind(n, 3468))
        }]
        , cC = (Object.fromEntries(lC.map((e => [e.id, e.import]))),
            Object.fromEntries(lC.flatMap((e => {
                var t;
                return (null == (t = e.aliases) ? void 0 : t.map((t => [t, e.import]))) || []
            }
            ))),
            [{
                id: "text",
                name: "Plain Text",
                match: ["text", "txt", "plain"]
            }, ...lC.filter((e => !["angular-html", "angular-ts", "astro", "blade", "coffee", "handlebars", "html-derivative", "http", "imba", "jinja", "jison", "json5", "marko", "mdc", "stylus", "ts-tags"].includes(e.id))).map((e => ({
                match: [e.id, ...e.aliases || []],
                id: e.id,
                name: e.name
            }))), {
                id: "haskell",
                name: "Haskell",
                match: ["haskell", "hs"]
            }, {
                id: "csharp",
                name: "C#",
                match: ["c#", "csharp", "cs"]
            }, {
                id: "latex",
                name: "LaTeX",
                match: ["latex"]
            }, {
                id: "lua",
                name: "Lua",
                match: ["lua"]
            }, {
                id: "mermaid",
                name: "Mermaid",
                match: ["mermaid", "mmd"]
            }, {
                id: "ruby",
                name: "Ruby",
                match: ["ruby", "rb"]
            }, {
                id: "rust",
                name: "Rust",
                match: ["rust", "rs"]
            }, {
                id: "scala",
                name: "Scala",
                match: ["scala"]
            }, {
                id: "swift",
                name: "Swift",
                match: ["swift"]
            }, {
                id: "kotlin",
                name: "Kotlin",
                match: ["kotlin", "kt", "kts"]
            }, {
                id: "objective-c",
                name: "Objective C",
                match: ["objective-c", "objc"]
            }])
        , dC = {
            language: {
                default: "javascript",
                values: [...cC.map((e => e.id))]
            }
        }
        , uC = Rk({
            name: "codeBlock",
            content: "inline*",
            group: "blockContent",
            marks: "",
            code: !0,
            defining: !0,
            addOptions: () => ({
                defaultLanguage: "javascript",
                indentLineWithTab: !0,
                supportedLanguages: cC
            }),
            addAttributes() {
                return {
                    language: {
                        default: this.options.defaultLanguage,
                        parseHTML: e => {
                            let t = e;
                            "DIV" === (null == t ? void 0 : t.tagName) && "codeBlock" === (null == t ? void 0 : t.dataset.contentType) && (t = t.children[0]),
                                "PRE" === (null == t ? void 0 : t.tagName) && (t = null == t ? void 0 : t.children[0]);
                            const n = null == t ? void 0 : t.getAttribute("data-language");
                            if (n)
                                return n.toLowerCase();
                            const r = [...(null == t ? void 0 : t.className.split(" ")) || []].filter((e => e.startsWith("language-"))).map((e => e.replace("language-", "")))
                                , [o] = r;
                            return o ? o.toLowerCase() : null
                        }
                        ,
                        renderHTML: e => e.language && "text" !== e.language ? {
                            class: `language-${e.language}`
                        } : {}
                    }
                }
            },
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]"
                }, {
                    tag: "pre",
                    preserveWhitespace: "full"
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n, r;
                const o = document.createElement("pre")
                    , { dom: i, contentDOM: s } = Ek(this.name, "code", (null == (n = this.options.domAttributes) ? void 0 : n.blockContent) || {}, {
                        ...(null == (r = this.options.domAttributes) ? void 0 : r.inlineContent) || {},
                        ...t
                    });
                return i.removeChild(s),
                    i.appendChild(o),
                    o.appendChild(s),
                {
                    dom: i,
                    contentDOM: s
                }
            },
            addNodeView() {
                const e = this.options.supportedLanguages;
                return t => {
                    let { editor: n, node: r, getPos: o, HTMLAttributes: i } = t;
                    var s, a;
                    const l = document.createElement("pre")
                        , c = document.createElement("select")
                        , d = document.createElement("div")
                        , { dom: u, contentDOM: h } = Ek(this.name, "code", {
                            ...(null == (s = this.options.domAttributes) ? void 0 : s.blockContent) || {},
                            ...i
                        }, (null == (a = this.options.domAttributes) ? void 0 : a.inlineContent) || {})
                        , p = e => {
                            const t = e.target.value;
                            n.commands.command((e => {
                                let { tr: n } = e;
                                return n.setNodeAttribute(o(), "language", t),
                                    !0
                            }
                            ))
                        }
                        ;
                    return e.forEach((e => {
                        let { id: t, name: n } = e;
                        const r = document.createElement("option");
                        r.value = t,
                            r.text = n,
                            c.appendChild(r)
                    }
                    )),
                        d.contentEditable = "false",
                        c.value = r.attrs.language || this.options.defaultLanguage,
                        u.removeChild(h),
                        u.appendChild(d),
                        u.appendChild(l),
                        l.appendChild(h),
                        d.appendChild(c),
                        c.addEventListener("change", p),
                    {
                        dom: u,
                        contentDOM: h,
                        update: e => e.type === this.type,
                        destroy: () => {
                            c.removeEventListener("change", p)
                        }
                    }
                }
            },
            addProseMirrorPlugins() {
                let e, t;
                const n = this.options.supportedLanguages;
                return [ka({
                    parser: r => {
                        if (!e)
                            return Zd({
                                themes: ["github-dark"],
                                langs: []
                            }).then((t => {
                                e = t
                            }
                            ));
                        const o = r.language;
                        return o && "text" !== o && !e.getLoadedLanguages().includes(o) && n.find((e => {
                            let { id: t } = e;
                            return t === o
                        }
                        )) && Sa.find((e => {
                            let { id: t } = e;
                            return t === o
                        }
                        )) ? e.loadLanguage(o) : (t || (t = function (e, t) {
                            return function (n) {
                                let { content: r, language: o, pos: i } = n;
                                var s;
                                const a = []
                                    , { tokens: l } = e.codeToTokens(r, {
                                        lang: o,
                                        ...null != t ? t : {
                                            theme: e.getLoadedThemes()[0]
                                        }
                                    });
                                let c = i + 1;
                                for (const e of l) {
                                    for (const t of e) {
                                        const e = c + t.content.length
                                            , n = ho.inline(c, e, {
                                                style: null != (s = t.htmlStyle) ? s : `color: ${t.color}`,
                                                class: "shiki"
                                            });
                                        a.push(n),
                                            c = e
                                    }
                                    c += 1
                                }
                                return a
                            }
                        }(e)),
                            t(r))
                    }
                    ,
                    languageExtractor: e => e.attrs.language,
                    nodeTypes: [this.name]
                })]
            },
            addInputRules() {
                const e = this.options.supportedLanguages;
                return [new Zi({
                    find: /^```(.*?)\s$/,
                    handler: t => {
                        let { state: n, range: r, match: o } = t;
                        var i;
                        const s = n.doc.resolve(r.from)
                            , a = o[1].trim()
                            , l = {
                                language: (null == (i = e.find((e => {
                                    let { match: t } = e;
                                    return t.includes(a)
                                }
                                ))) ? void 0 : i.id) || this.options.defaultLanguage
                            };
                        if (!s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), this.type))
                            return null;
                        n.tr.delete(r.from, r.to).setBlockType(r.from, r.from, this.type, l).setSelection(ut.create(n.tr.doc, r.from))
                    }
                })]
            },
            addKeyboardShortcuts() {
                return {
                    Delete: e => {
                        let { editor: t } = e;
                        const { selection: n } = t.state
                            , { $from: r } = n;
                        if (t.isActive(this.name) && !r.parent.textContent && gs(n)) {
                            const e = r.pos - r.parentOffset - 2;
                            return t.chain().setNodeSelection(e).deleteSelection().run(),
                                !0
                        }
                        return !1
                    }
                    ,
                    Tab: e => {
                        let { editor: t } = e;
                        return !(!this.options.indentLineWithTab || !t.isActive(this.name)) && (t.commands.insertContent("  "),
                            !0)
                    }
                    ,
                    Enter: e => {
                        let { editor: t } = e;
                        const { $from: n } = t.state.selection;
                        if (!t.isActive(this.name))
                            return !1;
                        const r = n.parentOffset === n.parent.nodeSize - 2
                            , o = n.parent.textContent.endsWith("\n\n");
                        return r && o ? t.chain().command((e => {
                            let { tr: t } = e;
                            return t.delete(n.pos - 2, n.pos),
                                !0
                        }
                        )).exitCode().run() : (t.commands.insertContent("\n"),
                            !0)
                    }
                    ,
                    "Shift-Enter": e => {
                        let { editor: t } = e;
                        const { $from: n } = t.state.selection;
                        return !!t.isActive(this.name) && (t.chain().insertContentAt(n.pos - n.parentOffset + n.parent.nodeSize, {
                            type: "paragraph"
                        }).run(),
                            !0)
                    }
                }
            }
        })
        , hC = Ik(uC, dC);
    const pC = Gk(ts.create({
        name: "backgroundColor",
        addAttributes: () => ({
            stringValue: {
                default: void 0,
                parseHTML: e => e.getAttribute("data-background-color"),
                renderHTML: e => ({
                    "data-background-color": e.stringValue
                })
            }
        }),
        parseHTML: () => [{
            tag: "span",
            getAttrs: e => "string" != typeof e && (!!e.hasAttribute("data-background-color") && {
                stringValue: e.getAttribute("data-background-color")
            })
        }],
        renderHTML(e) {
            let { HTMLAttributes: t } = e;
            return ["span", t, 0]
        }
    }), "string")
        , fC = Gk(ts.create({
            name: "textColor",
            addAttributes: () => ({
                stringValue: {
                    default: void 0,
                    parseHTML: e => e.getAttribute("data-text-color"),
                    renderHTML: e => ({
                        "data-text-color": e.stringValue
                    })
                }
            }),
            parseHTML: () => [{
                tag: "span",
                getAttrs: e => "string" != typeof e && (!!e.hasAttribute("data-text-color") && {
                    stringValue: e.getAttribute("data-text-color")
                })
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["span", t, 0]
            }
        }), "string")
        , mC = {
            type: "file",
            propSchema: {
                backgroundColor: Tk.backgroundColor,
                name: {
                    default: ""
                },
                url: {
                    default: ""
                },
                caption: {
                    default: ""
                }
            },
            content: "none",
            isFileBlock: !0
        }
        , gC = e => {
            if ("EMBED" === e.tagName)
                return Yk(e);
            if ("FIGURE" === e.tagName) {
                const t = eC(e, "embed");
                if (!t)
                    return;
                const { targetElement: n, caption: r } = t;
                return {
                    ...Yk(n),
                    caption: r
                }
            }
        }
        , bC = $k(mC, {
            render: (e, t) => {
                const n = Zk(e).dom
                    , r = Xk(e, n);
                return Jk(e, t, r)
            }
            ,
            parse: gC,
            toExternalHTML: e => {
                if (!e.props.url) {
                    const e = document.createElement("p");
                    return e.textContent = "Add file",
                    {
                        dom: e
                    }
                }
                const t = document.createElement("a");
                return t.href = e.props.url,
                    t.textContent = e.props.name || e.props.url,
                    e.props.caption ? tC(t, e.props.caption) : {
                        dom: t
                    }
            }
        });
    function yC(e, t) {
        let n, r;
        if (t.firstChild.descendants(((t, o) => !n && ("blockContainer" !== t.type.name || t.attrs.id !== e || (n = t,
            r = o + 1,
            !1)))),
            void 0 === n || void 0 === r)
            throw Error("Could not find block in the editor with matching ID.");
        return {
            node: n,
            posBeforeNode: r
        }
    }
    const vC = (e, t, n) => r => {
        let { state: o, dispatch: i } = r;
        const { blockContainer: s, blockContent: a, blockGroup: l } = wk(o.doc.resolve(t));
        if (i) {
            if (void 0 !== n.children) {
                const t = [];
                for (const r of n.children)
                    t.push(ck(r, o.schema, e.schema.styleSchema));
                l ? o.tr.replace(l.beforePos + 1, l.afterPos - 1, new g(d.from(t), 0, 0)) : o.tr.insert(a.afterPos, o.schema.nodes.blockGroup.create({}, t))
            }
            const t = a.node.type.name
                , r = n.type || t;
            let i = "keep";
            if (n.content)
                if ("string" == typeof n.content)
                    i = sk([n.content], o.schema, e.schema.styleSchema);
                else if (Array.isArray(n.content))
                    i = sk(n.content, o.schema, e.schema.styleSchema);
                else {
                    if ("tableContent" !== n.content.type)
                        throw new Zw(n.content.type);
                    i = ak(n.content, o.schema, e.schema.styleSchema)
                }
            else {
                const e = o.schema.nodes[t].spec.content
                    , n = o.schema.nodes[r].spec.content;
                "" === e || n !== e && (i = [])
            }
            "keep" === i ? o.tr.setNodeMarkup(a.beforePos, void 0 === n.type ? void 0 : o.schema.nodes[n.type], {
                ...a.node.attrs,
                ...n.props
            }) : o.tr.replaceWith(a.beforePos, a.afterPos, o.schema.nodes[r].create({
                ...a.node.attrs,
                ...n.props
            }, i)),
                o.tr.setNodeMarkup(s.beforePos, void 0, {
                    ...s.node.attrs,
                    ...n.props
                })
        }
        return !0
    }
        ;
    const wC = {
        ...Tk,
        level: {
            default: 1,
            values: [1, 2, 3]
        }
    }
        , kC = Rk({
            name: "heading",
            content: "inline*",
            group: "blockContent",
            addAttributes: () => ({
                level: {
                    default: 1,
                    parseHTML: e => {
                        const t = e.getAttribute("data-level")
                            , n = parseInt(t);
                        if (isFinite(n))
                            return n
                    }
                    ,
                    renderHTML: e => ({
                        "data-level": e.level.toString()
                    })
                }
            }),
            addInputRules() {
                return [...[1, 2, 3].map((e => new Zi({
                    find: new RegExp(`^(#{${e}})\\s$`),
                    handler: t => {
                        let { state: n, chain: r, range: o } = t;
                        const i = kk(n);
                        "inline*" === i.blockContent.node.type.spec.content && r().command(vC(this.options.editor, i.blockContainer.beforePos, {
                            type: "heading",
                            props: {
                                level: e
                            }
                        })).deleteRange({
                            from: o.from,
                            to: o.to
                        }).run()
                    }
                })))]
            },
            addKeyboardShortcuts() {
                return {
                    "Mod-Alt-1": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "heading",
                            props: {
                                level: 1
                            }
                        }))
                    }
                    ,
                    "Mod-Alt-2": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "heading",
                            props: {
                                level: 2
                            }
                        }))
                    }
                    ,
                    "Mod-Alt-3": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "heading",
                            props: {
                                level: 3
                            }
                        }))
                    }
                }
            },
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]",
                    getAttrs: e => "string" != typeof e && {
                        level: e.getAttribute("data-level")
                    }
                }, {
                    tag: "h1",
                    attrs: {
                        level: 1
                    },
                    node: "heading"
                }, {
                    tag: "h2",
                    attrs: {
                        level: 2
                    },
                    node: "heading"
                }, {
                    tag: "h3",
                    attrs: {
                        level: 3
                    },
                    node: "heading"
                }]
            },
            renderHTML(e) {
                let { node: t, HTMLAttributes: n } = e;
                var r, o;
                return Ek(this.name, `h${t.attrs.level}`, {
                    ...(null == (r = this.options.domAttributes) ? void 0 : r.blockContent) || {},
                    ...n
                }, (null == (o = this.options.domAttributes) ? void 0 : o.inlineContent) || {})
            }
        })
        , CC = Ik(kC, wC)
        , SC = e => ({
            url: e.src || void 0,
            previewWidth: e.width || void 0
        })
        , xC = {
            type: "image",
            propSchema: {
                textAlignment: Tk.textAlignment,
                backgroundColor: Tk.backgroundColor,
                name: {
                    default: ""
                },
                url: {
                    default: ""
                },
                caption: {
                    default: ""
                },
                showPreview: {
                    default: !0
                },
                previewWidth: {
                    default: 512
                }
            },
            content: "none",
            isFileBlock: !0,
            fileBlockAccept: ["image/*"]
        }
        , EC = e => {
            if ("IMG" === e.tagName)
                return SC(e);
            if ("FIGURE" === e.tagName) {
                const t = eC(e, "img");
                if (!t)
                    return;
                const { targetElement: n, caption: r } = t;
                return {
                    ...SC(n),
                    caption: r
                }
            }
        }
        , MC = $k(xC, {
            render: (e, t) => {
                const n = document.createElement("div");
                n.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg>';
                const r = document.createElement("img");
                r.className = "bn-visual-media",
                    t.resolveFileUrl(e.props.url).then((e => {
                        r.src = e
                    }
                    )),
                    r.alt = e.props.name || e.props.caption || "BlockNote image",
                    r.contentEditable = "false",
                    r.draggable = !1,
                    r.width = Math.min(e.props.previewWidth, t.domElement.firstElementChild.clientWidth);
                const o = rC(e, t, r, (() => r.width), (e => r.width = e))
                    , i = Xk(e, o.dom);
                return Jk(e, t, i, t.dictionary.file_blocks.image.add_button_text, n.firstElementChild)
            }
            ,
            parse: EC,
            toExternalHTML: e => {
                if (!e.props.url) {
                    const e = document.createElement("p");
                    return e.textContent = "Add image",
                    {
                        dom: e
                    }
                }
                let t;
                return e.props.showPreview ? (t = document.createElement("img"),
                    t.src = e.props.url,
                    t.alt = e.props.name || e.props.caption || "BlockNote image",
                    t.width = e.props.previewWidth) : (t = document.createElement("a"),
                        t.href = e.props.url,
                        t.textContent = e.props.name || e.props.url),
                    e.props.caption ? e.props.showPreview ? nC(t, e.props.caption) : tC(t, e.props.caption) : {
                        dom: t
                    }
            }
        })
        , TC = (e, t, n) => r => {
            let { state: o, dispatch: i } = r;
            const s = bk(o.doc, e)
                , { blockContainer: a, blockContent: l } = vk(s)
                , c = [{
                    type: a.node.type,
                    attrs: n ? {
                        ...a.node.attrs,
                        id: void 0
                    } : {}
                }, {
                    type: t ? l.node.type : o.schema.nodes.paragraph,
                    attrs: n ? {
                        ...l.node.attrs
                    } : {}
                }];
            return i && o.tr.split(e, 2, c),
                !0
        }
        , NC = e => {
            const t = e._tiptapEditor
                , { blockContent: n, blockContainer: r } = kk(t.state)
                , o = t.state.selection.anchor === t.state.selection.head;
            return !("bulletListItem" !== n.node.type.name && "numberedListItem" !== n.node.type.name && "checkListItem" !== n.node.type.name || !o) && t.commands.first((t => {
                let { state: o, chain: i, commands: s } = t;
                return [() => s.command((() => 0 === n.node.childCount && s.command(vC(e, r.beforePos, {
                    type: "paragraph",
                    props: {}
                })))), () => s.command((() => n.node.childCount > 0 && (i().deleteSelection().command(TC(o.selection.from, !0)).run(),
                    !0)))]
            }
            ))
        }
        , _C = {
            ...Tk
        }
        , OC = Rk({
            name: "bulletListItem",
            content: "inline*",
            group: "blockContent",
            priority: 90,
            addInputRules() {
                return [new Zi({
                    find: new RegExp("^[-+*]\\s$"),
                    handler: e => {
                        let { state: t, chain: n, range: r } = e;
                        const o = kk(t);
                        "inline*" === o.blockContent.node.type.spec.content && n().command(vC(this.options.editor, o.blockContainer.beforePos, {
                            type: "bulletListItem",
                            props: {}
                        })).deleteRange({
                            from: r.from,
                            to: r.to
                        })
                    }
                })]
            },
            addKeyboardShortcuts() {
                return {
                    Enter: () => NC(this.options.editor),
                    "Mod-Shift-8": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.options.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "bulletListItem",
                            props: {}
                        }))
                    }
                }
            },
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]"
                }, {
                    tag: "li",
                    getAttrs: e => {
                        if ("string" == typeof e)
                            return !1;
                        const t = e.parentElement;
                        return null !== t && (("UL" === t.tagName || "DIV" === t.tagName && "UL" === t.parentElement.tagName) && {})
                    }
                    ,
                    node: "bulletListItem"
                }, {
                    tag: "p",
                    getAttrs: e => {
                        if ("string" == typeof e)
                            return !1;
                        const t = e.parentElement;
                        return null !== t && ("bulletListItem" === t.getAttribute("data-content-type") && {})
                    }
                    ,
                    priority: 300,
                    node: "bulletListItem"
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n, r;
                return Ek(this.name, "p", {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.blockContent) || {},
                    ...t
                }, (null == (r = this.options.domAttributes) ? void 0 : r.inlineContent) || {})
            }
        })
        , AC = Ik(OC, _C)
        , PC = {
            ...Tk,
            checked: {
                default: !1
            }
        }
        , LC = Rk({
            name: "checkListItem",
            content: "inline*",
            group: "blockContent",
            addAttributes: () => ({
                checked: {
                    default: !1,
                    parseHTML: e => "true" === e.getAttribute("data-checked") || void 0,
                    renderHTML: e => e.checked ? {
                        "data-checked": e.checked.toString()
                    } : {}
                }
            }),
            addInputRules() {
                return [new Zi({
                    find: new RegExp("\\[\\s*\\]\\s$"),
                    handler: e => {
                        let { state: t, chain: n, range: r } = e;
                        const o = kk(t);
                        "inline*" === o.blockContent.node.type.spec.content && n().command(vC(this.options.editor, o.blockContainer.beforePos, {
                            type: "checkListItem",
                            props: {
                                checked: !1
                            }
                        })).deleteRange({
                            from: r.from,
                            to: r.to
                        })
                    }
                }), new Zi({
                    find: new RegExp("\\[[Xx]\\]\\s$"),
                    handler: e => {
                        let { state: t, chain: n, range: r } = e;
                        const o = kk(t);
                        "inline*" === o.blockContent.node.type.spec.content && n().command(vC(this.options.editor, o.blockContainer.beforePos, {
                            type: "checkListItem",
                            props: {
                                checked: !0
                            }
                        })).deleteRange({
                            from: r.from,
                            to: r.to
                        })
                    }
                })]
            },
            addKeyboardShortcuts() {
                return {
                    Enter: () => NC(this.options.editor),
                    "Mod-Shift-9": () => {
                        const e = kk(this.options.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "checkListItem",
                            props: {}
                        }))
                    }
                }
            },
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]"
                }, {
                    tag: "input",
                    getAttrs: e => "string" != typeof e && ("checkbox" === e.type && {
                        checked: e.checked
                    }),
                    node: "checkListItem"
                }, {
                    tag: "li",
                    getAttrs: e => {
                        if ("string" == typeof e)
                            return !1;
                        const t = e.parentElement;
                        if (null === t)
                            return !1;
                        if ("UL" === t.tagName || "DIV" === t.tagName && "UL" === t.parentElement.tagName) {
                            const t = e.querySelector("input[type=checkbox]") || null;
                            return null !== t && {
                                checked: t.checked
                            }
                        }
                        return !1
                    }
                    ,
                    node: "checkListItem"
                }]
            },
            renderHTML(e) {
                let { node: t, HTMLAttributes: n } = e;
                var r, o;
                const i = document.createElement("input");
                i.type = "checkbox",
                    i.checked = t.attrs.checked,
                    t.attrs.checked && i.setAttribute("checked", "");
                const { dom: s, contentDOM: a } = Ek(this.name, "p", {
                    ...(null == (r = this.options.domAttributes) ? void 0 : r.blockContent) || {},
                    ...n
                }, (null == (o = this.options.domAttributes) ? void 0 : o.inlineContent) || {});
                return s.insertBefore(i, a),
                {
                    dom: s,
                    contentDOM: a
                }
            },
            addNodeView() {
                return e => {
                    let { node: t, getPos: n, editor: r, HTMLAttributes: o } = e;
                    var i, s;
                    const a = document.createElement("div")
                        , l = document.createElement("div");
                    l.contentEditable = "false";
                    const c = document.createElement("input");
                    c.type = "checkbox",
                        c.checked = t.attrs.checked,
                        t.attrs.checked && c.setAttribute("checked", "");
                    const d = () => {
                        if (r.isEditable) {
                            if ("boolean" != typeof n) {
                                const e = bk(r.state.doc, n());
                                this.editor.commands.command(vC(this.options.editor, e.posBeforeNode, {
                                    type: "checkListItem",
                                    props: {
                                        checked: c.checked
                                    }
                                }))
                            }
                        } else
                            c.checked = !c.checked
                    }
                        ;
                    c.addEventListener("change", d);
                    const { dom: u, contentDOM: h } = Ek(this.name, "p", {
                        ...(null == (i = this.options.domAttributes) ? void 0 : i.blockContent) || {},
                        ...o
                    }, (null == (s = this.options.domAttributes) ? void 0 : s.inlineContent) || {});
                    if ("boolean" != typeof n) {
                        const e = "label-" + this.editor.state.doc.resolve(n()).node().attrs.id;
                        c.setAttribute("aria-labelledby", e),
                            h.id = e
                    }
                    return u.removeChild(h),
                        u.appendChild(a),
                        a.appendChild(l),
                        a.appendChild(h),
                        l.appendChild(c),
                    {
                        dom: u,
                        contentDOM: h,
                        destroy: () => {
                            c.removeEventListener("change", d)
                        }
                    }
                }
            }
        })
        , RC = Ik(LC, PC)
        , DC = new _t("numbered-list-indexing")
        , IC = {
            ...Tk
        }
        , jC = Rk({
            name: "numberedListItem",
            content: "inline*",
            group: "blockContent",
            priority: 90,
            addAttributes: () => ({
                index: {
                    default: null,
                    parseHTML: e => e.getAttribute("data-index"),
                    renderHTML: e => ({
                        "data-index": e.index
                    })
                }
            }),
            addInputRules() {
                return [new Zi({
                    find: new RegExp("^1\\.\\s$"),
                    handler: e => {
                        let { state: t, chain: n, range: r } = e;
                        const o = kk(t);
                        "inline*" === o.blockContent.node.type.spec.content && n().command(vC(this.options.editor, o.blockContainer.beforePos, {
                            type: "numberedListItem",
                            props: {}
                        })).deleteRange({
                            from: r.from,
                            to: r.to
                        })
                    }
                })]
            },
            addKeyboardShortcuts() {
                return {
                    Enter: () => NC(this.options.editor),
                    "Mod-Shift-7": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "numberedListItem",
                            props: {}
                        }))
                    }
                }
            },
            addProseMirrorPlugins: () => [new Mt({
                key: DC,
                appendTransaction: (e, t, n) => {
                    const r = n.tr;
                    r.setMeta("numberedListIndexing", !0);
                    let o = !1;
                    return n.doc.descendants(((e, t) => {
                        if ("blockContainer" === e.type.name && "numberedListItem" === e.firstChild.type.name) {
                            let n = "1";
                            const i = vk({
                                posBeforeNode: t,
                                node: e
                            })
                                , s = r.doc.resolve(i.blockContainer.beforePos).nodeBefore;
                            if (s) {
                                const e = vk({
                                    posBeforeNode: i.blockContainer.beforePos - s.nodeSize,
                                    node: s
                                });
                                if ("numberedListItem" === e.blockContent.node.type.name) {
                                    const t = e.blockContent.node.attrs.index;
                                    n = (parseInt(t) + 1).toString()
                                }
                            }
                            i.blockContent.node.attrs.index !== n && (o = !0,
                                r.setNodeMarkup(i.blockContent.beforePos, void 0, {
                                    index: n
                                }))
                        }
                    }
                    )),
                        o ? r : null
                }
            })],
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]"
                }, {
                    tag: "li",
                    getAttrs: e => {
                        if ("string" == typeof e)
                            return !1;
                        const t = e.parentElement;
                        return null !== t && (("OL" === t.tagName || "DIV" === t.tagName && "OL" === t.parentElement.tagName) && {})
                    }
                    ,
                    node: "numberedListItem"
                }, {
                    tag: "p",
                    getAttrs: e => {
                        if ("string" == typeof e)
                            return !1;
                        const t = e.parentElement;
                        return null !== t && ("numberedListItem" === t.getAttribute("data-content-type") && {})
                    }
                    ,
                    priority: 300,
                    node: "numberedListItem"
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n, r;
                return Ek(this.name, "p", {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.blockContent) || {},
                    ...t
                }, (null == (r = this.options.domAttributes) ? void 0 : r.inlineContent) || {})
            }
        })
        , HC = Ik(jC, IC)
        , zC = {
            ...Tk
        }
        , $C = Ik(Rk({
            name: "paragraph",
            content: "inline*",
            group: "blockContent",
            addKeyboardShortcuts() {
                return {
                    "Mod-Alt-0": () => {
                        const e = kk(this.editor.state);
                        return "inline*" !== e.blockContent.node.type.spec.content || this.editor.commands.command(vC(this.options.editor, e.blockContainer.beforePos, {
                            type: "paragraph",
                            props: {}
                        }))
                    }
                }
            },
            parseHTML() {
                return [{
                    tag: "div[data-content-type=" + this.name + "]"
                }, {
                    tag: "p",
                    priority: 200,
                    getAttrs: e => {
                        var t;
                        return !("string" == typeof e || null == (t = e.textContent) || !t.trim()) && {}
                    }
                    ,
                    node: "paragraph"
                }]
            },
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n, r;
                return Ek(this.name, "p", {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.blockContent) || {},
                    ...t
                }, (null == (r = this.options.domAttributes) ? void 0 : r.inlineContent) || {})
            }
        }), zC)
        , BC = as.create({
            name: "BlockNoteTableExtension",
            addProseMirrorPlugins: () => [uh({
                cellMinWidth: 35,
                defaultCellMinWidth: 120,
                View: null
            }), yh()],
            addKeyboardShortcuts() {
                return {
                    Enter: () => !(!this.editor.state.selection.empty || "tableParagraph" !== this.editor.state.selection.$head.parent.type.name) && (this.editor.commands.setHardBreak(),
                        !0),
                    Backspace: () => {
                        const e = this.editor.state.selection
                            , t = e.empty
                            , n = 0 === e.$head.parentOffset
                            , r = "tableParagraph" === e.$head.node().type.name;
                        return t && n && r
                    }
                }
            },
            extendNodeSchema: e => ({
                tableRole: Fi(Ii(e, "tableRole", {
                    name: e.name,
                    options: e.options,
                    storage: e.storage
                }))
            })
        })
        , VC = {
            backgroundColor: Tk.backgroundColor,
            textColor: Tk.textColor
        }
        , FC = Rk({
            name: "table",
            content: "tableRow+",
            group: "blockContent",
            tableRole: "table",
            isolating: !0,
            parseHTML: () => [{
                tag: "table"
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n, r;
                return Ek(this.name, "table", {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.blockContent) || {},
                    ...t
                }, (null == (r = this.options.domAttributes) ? void 0 : r.inlineContent) || {})
            },
            addNodeView() {
                return e => {
                    let { node: t, HTMLAttributes: n } = e;
                    var r;
                    return new class extends lh {
                        constructor(e, t, n) {
                            super(e, t),
                                this.node = e,
                                this.cellMinWidth = t,
                                this.blockContentHTMLAttributes = n;
                            const r = document.createElement("div");
                            r.className = Sk("bn-block-content", n.class),
                                r.setAttribute("data-content-type", "table");
                            for (const [a, l] of Object.entries(n))
                                "class" !== a && r.setAttribute(a, l);
                            const o = this.dom
                                , i = document.createElement("div");
                            i.className = "tableWrapper-inner",
                                i.appendChild(o.firstChild),
                                o.appendChild(i),
                                r.appendChild(o);
                            const s = document.createElement("div");
                            s.className = "table-widgets-container",
                                s.style.position = "relative",
                                o.appendChild(s),
                                this.dom = r
                        }
                        ignoreMutation(e) {
                            return !e.target.closest(".tableWrapper-inner") || super.ignoreMutation(e)
                        }
                    }
                        (t, 120, {
                            ...(null == (r = this.options.domAttributes) ? void 0 : r.blockContent) || {},
                            ...n
                        })
                }
            }
        })
        , UC = Ik(FC, VC, [BC, la.create({
            name: "tableParagraph",
            group: "tableContent",
            content: "inline*",
            parseHTML: () => [{
                preserveWhitespace: "full",
                priority: 210,
                context: "tableContent",
                tag: "p",
                getAttrs: e => ({})
            }, {
                tag: "p",
                getAttrs: e => {
                    if ("string" == typeof e || !e.textContent)
                        return !1;
                    const t = e.parentElement;
                    return null !== t && ("TD" === t.tagName && {})
                }
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                return ["p", t, 0]
            }
        }), Cu.extend({
            content: "tableContent"
        }), ku.extend({
            content: "tableContent"
        }), Su])
        , WC = e => ({
            url: e.src || void 0,
            previewWidth: e.width || void 0
        })
        , qC = {
            type: "video",
            propSchema: {
                textAlignment: Tk.textAlignment,
                backgroundColor: Tk.backgroundColor,
                name: {
                    default: ""
                },
                url: {
                    default: ""
                },
                caption: {
                    default: ""
                },
                showPreview: {
                    default: !0
                },
                previewWidth: {
                    default: 512
                }
            },
            content: "none",
            isFileBlock: !0,
            fileBlockAccept: ["video/*"]
        }
        , GC = e => {
            if ("VIDEO" === e.tagName)
                return WC(e);
            if ("FIGURE" === e.tagName) {
                const t = eC(e, "video");
                if (!t)
                    return;
                const { targetElement: n, caption: r } = t;
                return {
                    ...WC(n),
                    caption: r
                }
            }
        }
        , KC = $k(qC, {
            render: (e, t) => {
                const n = document.createElement("div");
                n.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"></path></svg>';
                const r = document.createElement("video");
                r.className = "bn-visual-media",
                    r.src = e.props.url,
                    r.controls = !0,
                    r.contentEditable = "false",
                    r.draggable = !1,
                    r.width = Math.min(e.props.previewWidth, t.domElement.firstElementChild.clientWidth);
                const o = rC(e, t, r, (() => r.width), (e => r.width = e))
                    , i = Xk(e, o.dom);
                return Jk(e, t, i, t.dictionary.file_blocks.video.add_button_text, n.firstElementChild)
            }
            ,
            parse: GC,
            toExternalHTML: e => {
                if (!e.props.url) {
                    const e = document.createElement("p");
                    return e.textContent = "Add video",
                    {
                        dom: e
                    }
                }
                let t;
                return e.props.showPreview ? (t = document.createElement("video"),
                    t.src = e.props.url,
                    t.width = e.props.previewWidth) : (t = document.createElement("a"),
                        t.href = e.props.url,
                        t.textContent = e.props.name || e.props.url),
                    e.props.caption ? e.props.showPreview ? nC(t, e.props.caption) : tC(t, e.props.caption) : {
                        dom: t
                    }
            }
        })
        , JC = {
            paragraph: $C,
            heading: CC,
            codeBlock: hC,
            bulletListItem: AC,
            numberedListItem: HC,
            checkListItem: RC,
            table: UC,
            file: bC,
            image: MC,
            video: KC,
            audio: aC
        }
        , ZC = jk(JC)
        , XC = {
            bold: Gk(lu, "boolean"),
            italic: Gk(gu, "boolean"),
            underline: Gk(wu, "boolean"),
            strike: Gk(vu, "boolean"),
            code: Gk(uu, "boolean"),
            textColor: fC,
            backgroundColor: pC
        }
        , QC = (Kk(XC),
        {
            text: {
                config: "text",
                implementation: {}
            },
            link: {
                config: "link",
                implementation: {}
            }
        })
        , YC = Wk(QC);
    function eS(e, t) {
        return e in t.schema.blockSchema && t.schema.blockSchema[e] === ZC[e]
    }
    function tS(e, t) {
        return e.type in t.schema.blockSchema && t.schema.blockSchema[e.type].isFileBlock || !1
    }
    function nS(e, t) {
        return t.schema.blockSchema[e.type].isFileBlock && !e.props.url
    }
    function rS(e, t, n) {
        return t in n.schema.blockSchema && e in n.schema.blockSchema[t].propSchema && n.schema.blockSchema[t].propSchema[e] === Tk[e]
    }
    function oS(e, t, n) {
        return rS(e, t.type, n)
    }
    function iS(e, t, n) {
        const { block: r } = e.getTextCursorPosition()
            , o = function (e) {
                const { blockContainer: t } = kk(e._tiptapEditor.state)
                    , n = {
                        blockId: t.node.attrs.id,
                        blockPos: t.beforePos
                    };
                return e._tiptapEditor.state.selection instanceof ju ? {
                    ...n,
                    type: "cell",
                    anchorCell: e._tiptapEditor.state.selection.$anchorCell.pos,
                    headCell: e._tiptapEditor.state.selection.$headCell.pos
                } : e._tiptapEditor.state.selection instanceof pt ? {
                    ...n,
                    type: "node",
                    from: e._tiptapEditor.state.selection.from
                } : {
                    ...n,
                    type: "text",
                    anchor: e._tiptapEditor.state.selection.anchor,
                    head: e._tiptapEditor.state.selection.head
                }
            }(e);
        e.removeBlocks([r]),
            e.insertBlocks([r], t, n),
            function (e, t) {
                const n = yC(t.blockId, e._tiptapEditor.state.doc).posBeforeNode;
                let r;
                r = "cell" === t.type ? ju.create(e._tiptapEditor.state.doc, t.anchorCell + (n - t.blockPos), t.headCell + (n - t.blockPos)) : "node" === t.type ? pt.create(e._tiptapEditor.state.doc, t.from + (n - t.blockPos)) : ut.create(e._tiptapEditor.state.doc, t.anchor + (n - t.blockPos), t.head + (n - t.blockPos)),
                    e._tiptapEditor.view.dispatch(e._tiptapEditor.state.tr.setSelection(r))
            }(e, o)
    }
    function sS(e, t, n) {
        const r = e._tiptapEditor
            , o = r.state.tr
            , i = new Set(t.map((e => "string" == typeof e ? e : e.id)))
            , s = [];
        let a = 0;
        if (r.state.doc.descendants(((t, r) => {
            if (0 === i.size)
                return !1;
            if ("blockContainer" !== t.type.name || !i.has(t.attrs.id))
                return !0;
            s.push(Uk(t, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache)),
                i.delete(t.attrs.id),
                a = (null == n ? void 0 : n(t, r, o, a)) || a;
            const l = o.doc.nodeSize;
            o.delete(r - a - 1, r - a + t.nodeSize + 1);
            const c = o.doc.nodeSize;
            return a += l - c,
                !1
        }
        )),
            i.size > 0) {
            const e = [...i].join("\n");
            throw Error("Blocks with the following IDs could not be found in the editor: " + e)
        }
        return e.dispatch(o),
            s
    }
    let aS;
    async function lS() {
        if (aS)
            return aS;
        const e = await Promise.all([n.e(9425).then(n.bind(n, 9425)), n.e(6100).then(n.bind(n, 6100)), n.e(7672).then(n.bind(n, 7672)), n.e(7363).then(n.bind(n, 7363)), Promise.all([n.e(4723), n.e(8470)]).then(n.bind(n, 8470)), Promise.all([n.e(1196), n.e(3510)]).then(n.bind(n, 3510)), Promise.all([n.e(4723), n.e(7647)]).then(n.bind(n, 7647)), Promise.all([n.e(1196), n.e(5696)]).then(n.bind(n, 5696)), Promise.all([n.e(4723), n.e(8552)]).then(n.bind(n, 8552)), n.e(6104).then(n.bind(n, 6104))]);
        return aS = {
            rehypeParse: e[0],
            rehypeStringify: e[1],
            unified: e[2],
            hastUtilFromDom: e[3],
            rehypeRemark: e[4],
            remarkGfm: e[5],
            remarkStringify: e[6],
            remarkParse: e[7],
            remarkRehype: e[8],
            rehypeFormat: e[9]
        },
            aS
    }
    function cS() {
        const e = t => {
            let n = t.children.length;
            for (let r = 0; r < n; r++) {
                const o = t.children[r];
                if ("element" === o.type && (e(o),
                    "u" === o.tagName))
                    if (o.children.length > 0) {
                        t.children.splice(r, 1, ...o.children);
                        const e = o.children.length - 1;
                        n += e,
                            r += e
                    } else
                        t.children.splice(r, 1),
                            n--,
                            r--
            }
        }
            ;
        return e
    }
    function dS() {
        const e = aS;
        if (!e)
            throw new Error("addSpacesToCheckboxes requires ESM dependencies to be initialized");
        const t = n => {
            var r;
            if (n.children && "length" in n.children && n.children.length)
                for (let o = n.children.length - 1; o >= 0; o--) {
                    const i = n.children[o]
                        , s = o + 1 < n.children.length ? n.children[o + 1] : void 0;
                    "element" === i.type && "input" === i.tagName && "checkbox" === (null == (r = i.properties) ? void 0 : r.type) && "element" === (null == s ? void 0 : s.type) && "p" === s.tagName ? (s.tagName = "span",
                        s.children.splice(0, 0, e.hastUtilFromDom.fromDom(document.createTextNode(" ")))) : t(i)
                }
        }
            ;
        return t
    }
    function uS(e) {
        const t = aS;
        if (!t)
            throw new Error("cleanHTMLToMarkdown requires ESM dependencies to be initialized");
        return t.unified.unified().use(t.rehypeParse.default, {
            fragment: !0
        }).use(cS).use(dS).use(t.rehypeRemark.default).use(t.remarkGfm.default).use(t.remarkStringify.default, {
            handlers: {
                text: e => e.value
            }
        }).processSync(e).value
    }
    function hS(e) {
        e.querySelectorAll("li > ul, li > ol").forEach((e => {
            const t = function (e) {
                return Array.prototype.indexOf.call(e.parentElement.childNodes, e)
            }(e)
                , n = e.parentElement
                , r = Array.from(n.childNodes).slice(t + 1);
            e.remove(),
                r.forEach((e => {
                    e.remove()
                }
                )),
                n.insertAdjacentElement("afterend", e),
                r.reverse().forEach((t => {
                    if (function (e) {
                        return 3 === e.nodeType && !/\S/.test(e.nodeValue || "")
                    }(t))
                        return;
                    const n = document.createElement("li");
                    n.append(t),
                        e.insertAdjacentElement("afterend", n)
                }
                )),
                0 === n.childNodes.length && n.remove()
        }
        ))
    }
    let pS = null;
    function fS(e) {
        if ("string" == typeof e) {
            const t = (pS || (pS = document.implementation.createHTMLDocument("title"))).createElement("div");
            t.innerHTML = e,
                e = t
        }
        return hS(e),
            function (e) {
                e.querySelectorAll("li + ul, li + ol").forEach((e => {
                    var t, n;
                    const r = e.previousElementSibling
                        , o = document.createElement("div");
                    r.insertAdjacentElement("afterend", o),
                        o.append(r);
                    const i = document.createElement("div");
                    for (i.setAttribute("data-node-type", "blockGroup"),
                        o.append(i); "UL" === (null == (t = o.nextElementSibling) ? void 0 : t.nodeName) || "OL" === (null == (n = o.nextElementSibling) ? void 0 : n.nodeName);)
                        i.append(o.nextElementSibling)
                }
                ))
            }(e),
            e
    }
    async function mS(e, t, n, r, o) {
        const i = fS(e)
            , s = te.fromSchema(o).parse(i, {
                topNode: o.nodes.blockGroup.create()
            })
            , a = [];
        for (let l = 0; l < s.childCount; l++)
            a.push(Uk(s.child(l), t, n, r));
        return a
    }
    function gS(e, t) {
        const n = t.value ? t.value : ""
            , r = {};
        t.lang && (r["data-language"] = t.lang);
        let o = {
            type: "element",
            tagName: "code",
            properties: r,
            children: [{
                type: "text",
                value: n
            }]
        };
        return t.meta && (o.data = {
            meta: t.meta
        }),
            e.patch(t, o),
            o = e.applyData(t, o),
            o = {
                type: "element",
                tagName: "pre",
                properties: {},
                children: [o]
            },
            e.patch(t, o),
            o
    }
    class bS {
        constructor() {
            Kw(this, "callbacks", {})
        }
        on(e, t) {
            return this.callbacks[e] || (this.callbacks[e] = []),
                this.callbacks[e].push(t),
                () => this.off(e, t)
        }
        emit(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                n[r - 1] = arguments[r];
            const o = this.callbacks[e];
            o && o.forEach((e => e.apply(this, n)))
        }
        off(e, t) {
            const n = this.callbacks[e];
            n && (t ? this.callbacks[e] = n.filter((e => e !== t)) : delete this.callbacks[e])
        }
        removeAllListeners() {
            this.callbacks = {}
        }
    }
    class yS {
        constructor(e, t, n, r) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "mouseDownHandler", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                Kw(this, "dragstartHandler", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                Kw(this, "scrollHandler", (() => {
                    var e;
                    if (null != (e = this.state) && e.show) {
                        const e = this.pmView.root.querySelector(`[data-node-type="blockContainer"][data-id="${this.state.block.id}"]`);
                        if (!e)
                            return;
                        this.state.referencePos = e.getBoundingClientRect(),
                            this.emitUpdate()
                    }
                }
                )),
                Kw(this, "closeMenu", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                this.editor = e,
                this.pluginKey = t,
                this.pmView = n,
                this.emitUpdate = () => {
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized file panel");
                    r(this.state)
                }
                ,
                n.dom.addEventListener("mousedown", this.mouseDownHandler),
                n.dom.addEventListener("dragstart", this.dragstartHandler),
                n.root.addEventListener("scroll", this.scrollHandler, !0)
        }
        update(e, t) {
            var n, r;
            const o = this.pluginKey.getState(e.state);
            if ((null == (n = this.state) || !n.show) && o.block && this.editor.isEditable) {
                const e = this.pmView.root.querySelector(`[data-node-type="blockContainer"][data-id="${o.block.id}"]`);
                if (!e)
                    return;
                return this.state = {
                    show: !0,
                    referencePos: e.getBoundingClientRect(),
                    block: o.block
                },
                    void this.emitUpdate()
            }
            (!e.state.selection.eq(t.selection) || !e.state.doc.eq(t.doc) || !this.editor.isEditable) && null != (r = this.state) && r.show && (this.state.show = !1,
                this.emitUpdate())
        }
        destroy() {
            this.pmView.dom.removeEventListener("mousedown", this.mouseDownHandler),
                this.pmView.dom.removeEventListener("dragstart", this.dragstartHandler),
                this.pmView.root.removeEventListener("scroll", this.scrollHandler, !0)
        }
    }
    const vS = new _t("FilePanelPlugin");
    class wS extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "closeMenu", (() => {
                    var e;
                    return null == (e = this.view) ? void 0 : e.closeMenu()
                }
                )),
                this.plugin = new Mt({
                    key: vS,
                    view: t => (this.view = new yS(e, vS, t, (e => {
                        this.emit("update", e)
                    }
                    )),
                        this.view),
                    props: {
                        handleKeyDown: (e, t) => {
                            var n;
                            return !("Escape" !== t.key || !this.shown) && (null == (n = this.view) || n.closeMenu(),
                                !0)
                        }
                    },
                    state: {
                        init: () => ({
                            block: void 0
                        }),
                        apply: e => {
                            var t;
                            return {
                                block: null == (t = e.getMeta(vS)) ? void 0 : t.block
                            }
                        }
                    }
                })
        }
        get shown() {
            var e, t;
            return (null == (t = null == (e = this.view) ? void 0 : e.state) ? void 0 : t.show) || !1
        }
        onUpdate(e) {
            return this.on("update", e)
        }
    }
    class kS {
        constructor(e, t, n) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "preventHide", !1),
                Kw(this, "preventShow", !1),
                Kw(this, "shouldShow", (e => {
                    let { state: t, from: n, to: r, view: o } = e;
                    const { doc: i, selection: s } = t
                        , { empty: a } = s
                        , l = !i.textBetween(n, r).length && gs(t.selection);
                    return !(s.$from.parent.type.spec.code || Ws(s) && s.node.type.spec.code) && !(!o.hasFocus() || a || l)
                }
                )),
                Kw(this, "blurHandler", (e => {
                    var t;
                    if (this.preventHide)
                        return void (this.preventHide = !1);
                    const n = this.pmView.dom.parentElement;
                    e && e.relatedTarget && (n === e.relatedTarget || n.contains(e.relatedTarget) || e.relatedTarget.matches(".bn-ui-container, .bn-ui-container *")) || null != (t = this.state) && t.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                Kw(this, "viewMousedownHandler", (() => {
                    this.preventShow = !0
                }
                )),
                Kw(this, "viewMouseupHandler", (() => {
                    this.preventShow = !1,
                        setTimeout((() => this.update(this.pmView)))
                }
                )),
                Kw(this, "dragHandler", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                Kw(this, "scrollHandler", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.referencePos = this.getSelectionBoundingBox(),
                        this.emitUpdate())
                }
                )),
                Kw(this, "closeMenu", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                this.editor = e,
                this.pmView = t,
                this.emitUpdate = () => {
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized formatting toolbar");
                    n(this.state)
                }
                ,
                t.dom.addEventListener("mousedown", this.viewMousedownHandler),
                t.dom.addEventListener("mouseup", this.viewMouseupHandler),
                t.dom.addEventListener("dragstart", this.dragHandler),
                t.dom.addEventListener("dragover", this.dragHandler),
                t.dom.addEventListener("blur", this.blurHandler),
                t.root.addEventListener("scroll", this.scrollHandler, !0)
        }
        update(e, t) {
            var n, r;
            const { state: o, composing: i } = e
                , { doc: s, selection: a } = o
                , l = t && t.doc.eq(s) && t.selection.eq(a);
            if (i || l)
                return;
            const { ranges: c } = a
                , d = Math.min(...c.map((e => e.$from.pos)))
                , u = Math.max(...c.map((e => e.$to.pos)))
                , h = null == (n = this.shouldShow) ? void 0 : n.call(this, {
                    view: e,
                    state: o,
                    from: d,
                    to: u
                });
            return this.preventShow || !h && !this.preventHide ? null == (r = this.state) || !r.show || this.preventHide || h && !this.preventShow && this.editor.isEditable ? void 0 : (this.state.show = !1,
                void this.emitUpdate()) : (this.state = {
                    show: !0,
                    referencePos: this.getSelectionBoundingBox()
                },
                    void this.emitUpdate())
        }
        destroy() {
            this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler),
                this.pmView.dom.removeEventListener("mouseup", this.viewMouseupHandler),
                this.pmView.dom.removeEventListener("dragstart", this.dragHandler),
                this.pmView.dom.removeEventListener("dragover", this.dragHandler),
                this.pmView.dom.removeEventListener("blur", this.blurHandler),
                this.pmView.root.removeEventListener("scroll", this.scrollHandler, !0)
        }
        getSelectionBoundingBox() {
            const { state: e } = this.pmView
                , { selection: t } = e
                , { ranges: n } = t
                , r = Math.min(...n.map((e => e.$from.pos)))
                , o = Math.max(...n.map((e => e.$to.pos)));
            if (Ws(t)) {
                const e = this.pmView.nodeDOM(r);
                if (e)
                    return e.getBoundingClientRect()
            }
            return qs(this.pmView, r, o)
        }
    }
    const CS = new _t("FormattingToolbarPlugin");
    class SS extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "closeMenu", (() => this.view.closeMenu())),
                this.plugin = new Mt({
                    key: CS,
                    view: t => (this.view = new kS(e, t, (e => {
                        this.emit("update", e)
                    }
                    )),
                        this.view),
                    props: {
                        handleKeyDown: (e, t) => !("Escape" !== t.key || !this.shown) && (this.view.closeMenu(),
                            !0)
                    }
                })
        }
        get shown() {
            var e, t;
            return (null == (t = null == (e = this.view) ? void 0 : e.state) ? void 0 : t.show) || !1
        }
        onUpdate(e) {
            return this.on("update", e)
        }
    }
    class xS {
        constructor(e, t, n) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "menuUpdateTimer"),
                Kw(this, "startMenuUpdateTimer"),
                Kw(this, "stopMenuUpdateTimer"),
                Kw(this, "mouseHoveredLinkMark"),
                Kw(this, "mouseHoveredLinkMarkRange"),
                Kw(this, "keyboardHoveredLinkMark"),
                Kw(this, "keyboardHoveredLinkMarkRange"),
                Kw(this, "linkMark"),
                Kw(this, "linkMarkRange"),
                Kw(this, "mouseOverHandler", (e => {
                    if (this.mouseHoveredLinkMark = void 0,
                        this.mouseHoveredLinkMarkRange = void 0,
                        this.stopMenuUpdateTimer(),
                        e.target instanceof HTMLAnchorElement && "A" === e.target.nodeName) {
                        const t = e.target
                            , n = this.pmView.posAtDOM(t, 0) + 1
                            , r = this.pmView.state.doc.resolve(n)
                            , o = r.marks();
                        for (const e of o)
                            if (e.type.name === this.pmView.state.schema.mark("link").type.name) {
                                this.mouseHoveredLinkMark = e,
                                    this.mouseHoveredLinkMarkRange = fs(r, e.type, e.attrs) || void 0;
                                break
                            }
                    }
                    return this.startMenuUpdateTimer(),
                        !1
                }
                )),
                Kw(this, "clickHandler", (e => {
                    var t;
                    const n = this.pmView.dom.parentElement;
                    this.linkMark && e && e.target && n !== e.target && !n.contains(e.target) && null != (t = this.state) && t.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                Kw(this, "scrollHandler", (() => {
                    var e;
                    void 0 !== this.linkMark && null != (e = this.state) && e.show && (this.state.referencePos = qs(this.pmView, this.linkMarkRange.from, this.linkMarkRange.to),
                        this.emitUpdate())
                }
                )),
                Kw(this, "closeMenu", (() => {
                    var e;
                    null != (e = this.state) && e.show && (this.state.show = !1,
                        this.emitUpdate())
                }
                )),
                this.editor = e,
                this.pmView = t,
                this.emitUpdate = () => {
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized link toolbar");
                    n(this.state)
                }
                ,
                this.startMenuUpdateTimer = () => {
                    this.menuUpdateTimer = setTimeout((() => {
                        this.update()
                    }
                    ), 250)
                }
                ,
                this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer),
                    this.menuUpdateTimer = void 0),
                    !1),
                this.pmView.dom.addEventListener("mouseover", this.mouseOverHandler),
                this.pmView.root.addEventListener("click", this.clickHandler, !0),
                this.pmView.root.addEventListener("scroll", this.scrollHandler, !0)
        }
        editLink(e, t) {
            var n;
            const r = this.pmView.state.tr.insertText(t, this.linkMarkRange.from, this.linkMarkRange.to);
            r.addMark(this.linkMarkRange.from, this.linkMarkRange.from + t.length, this.pmView.state.schema.mark("link", {
                href: e
            })),
                this.editor.dispatch(r),
                this.pmView.focus(),
                null != (n = this.state) && n.show && (this.state.show = !1,
                    this.emitUpdate())
        }
        deleteLink() {
            var e;
            this.editor.dispatch(this.pmView.state.tr.removeMark(this.linkMarkRange.from, this.linkMarkRange.to, this.linkMark.type).setMeta("preventAutolink", !0)),
                this.pmView.focus(),
                null != (e = this.state) && e.show && (this.state.show = !1,
                    this.emitUpdate())
        }
        update() {
            var e;
            if (!this.pmView.hasFocus())
                return;
            const t = this.linkMark;
            if (this.linkMark = void 0,
                this.linkMarkRange = void 0,
                this.keyboardHoveredLinkMark = void 0,
                this.keyboardHoveredLinkMarkRange = void 0,
                this.pmView.state.selection.empty) {
                const e = this.pmView.state.selection.$from.marks();
                for (const t of e)
                    if (t.type.name === this.pmView.state.schema.mark("link").type.name) {
                        this.keyboardHoveredLinkMark = t,
                            this.keyboardHoveredLinkMarkRange = fs(this.pmView.state.selection.$from, t.type, t.attrs) || void 0;
                        break
                    }
            }
            return this.mouseHoveredLinkMark && (this.linkMark = this.mouseHoveredLinkMark,
                this.linkMarkRange = this.mouseHoveredLinkMarkRange),
                this.keyboardHoveredLinkMark && (this.linkMark = this.keyboardHoveredLinkMark,
                    this.linkMarkRange = this.keyboardHoveredLinkMarkRange),
                this.linkMark && this.editor.isEditable ? (this.state = {
                    show: !0,
                    referencePos: qs(this.pmView, this.linkMarkRange.from, this.linkMarkRange.to),
                    url: this.linkMark.attrs.href,
                    text: this.pmView.state.doc.textBetween(this.linkMarkRange.from, this.linkMarkRange.to)
                },
                    void this.emitUpdate()) : null == (e = this.state) || !e.show || !t || this.linkMark && this.editor.isEditable ? void 0 : (this.state.show = !1,
                        void this.emitUpdate())
        }
        destroy() {
            this.pmView.dom.removeEventListener("mouseover", this.mouseOverHandler),
                this.pmView.root.removeEventListener("scroll", this.scrollHandler, !0),
                this.pmView.root.removeEventListener("click", this.clickHandler, !0)
        }
    }
    const ES = new _t("LinkToolbarPlugin");
    class MS extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "editLink", ((e, t) => {
                    this.view.editLink(e, t)
                }
                )),
                Kw(this, "deleteLink", (() => {
                    this.view.deleteLink()
                }
                )),
                Kw(this, "startHideTimer", (() => {
                    this.view.startMenuUpdateTimer()
                }
                )),
                Kw(this, "stopHideTimer", (() => {
                    this.view.stopMenuUpdateTimer()
                }
                )),
                Kw(this, "closeMenu", (() => this.view.closeMenu())),
                this.plugin = new Mt({
                    key: ES,
                    view: t => (this.view = new xS(e, t, (e => {
                        this.emit("update", e)
                    }
                    )),
                        this.view),
                    props: {
                        handleKeyDown: (e, t) => !("Escape" !== t.key || !this.shown) && (this.view.closeMenu(),
                            !0)
                    }
                })
        }
        onUpdate(e) {
            return this.on("update", e)
        }
        get shown() {
            var e, t;
            return (null == (t = null == (e = this.view) ? void 0 : e.state) ? void 0 : t.show) || !1
        }
    }
    function TS(e, t) {
        const n = [];
        return e.descendants((e => {
            var r;
            return "blockContainer" !== e.type.name || ("blockGroup" === (null == (r = e.firstChild) ? void 0 : r.type.name) || (n.push(Uk(e, t.blockSchema, t.inlineContentSchema, t.styleSchema)),
                !1))
        }
        )),
            n
    }
    class NS extends at {
        constructor(e, t) {
            super(e, t),
                Kw(this, "nodes");
            const n = e.node();
            this.nodes = [],
                e.doc.nodesBetween(e.pos, t.pos, ((e, t, r) => {
                    if (null !== r && r.eq(n))
                        return this.nodes.push(e),
                            !1
                }
                ))
        }
        static create(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t;
            return new NS(e.resolve(t), e.resolve(n))
        }
        content() {
            return new g(d.from(this.nodes), 0, 0)
        }
        eq(e) {
            if (!(e instanceof NS) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)
                return !1;
            for (let t = 0; t < this.nodes.length; t++)
                if (!this.nodes[t].eq(e.nodes[t]))
                    return !1;
            return !0
        }
        map(e, t) {
            const n = t.mapResult(this.from)
                , r = t.mapResult(this.to);
            return r.deleted ? at.near(e.resolve(n.pos)) : n.deleted ? at.near(e.resolve(r.pos)) : new NS(e.resolve(n.pos), e.resolve(r.pos))
        }
        toJSON() {
            return {
                type: "node",
                anchor: this.anchor,
                head: this.head
            }
        }
    }
    let _S;
    function OS(e, t) {
        for (var n, r; e && e.parentElement && e.parentElement !== t.dom && "blockContainer" !== (null == (n = e.getAttribute) ? void 0 : n.call(e, "data-node-type"));)
            e = e.parentElement;
        if ("blockContainer" === (null == (r = e.getAttribute) ? void 0 : r.call(e, "data-node-type")))
            return {
                node: e,
                id: e.getAttribute("data-id")
            }
    }
    function AS(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t;
        t === n && (n += e.state.doc.resolve(t + 1).node().nodeSize);
        const r = e.domAtPos(t).node.cloneNode(!0)
            , o = e.domAtPos(t).node
            , i = (e, t) => Array.prototype.indexOf.call(e.children, t)
            , s = i(o, e.domAtPos(t + 1).node.parentElement)
            , a = i(o, e.domAtPos(n - 1).node.parentElement);
        for (let c = o.childElementCount - 1; c >= 0; c--)
            (c > a || c < s) && r.removeChild(r.children[c]);
        PS(e.root),
            _S = r;
        const l = e.dom.className.split(" ").filter((e => "ProseMirror" !== e && "bn-root" !== e && "bn-editor" !== e)).join(" ");
        _S.className = _S.className + " bn-drag-preview " + l,
            e.root instanceof ShadowRoot ? e.root.appendChild(_S) : e.root.body.appendChild(_S)
    }
    function PS(e) {
        void 0 !== _S && (e instanceof ShadowRoot ? e.removeChild(_S) : e.body.removeChild(_S),
            _S = void 0)
    }
    function LS(e, t) {
        if (!e.dataTransfer)
            return;
        const n = t.prosemirrorView
            , r = n.dom.getBoundingClientRect()
            , o = {
                left: r.left + r.width / 2,
                top: e.clientY
            }
            , i = n.root.elementsFromPoint(o.left, o.top);
        let s;
        for (const l of i)
            if (n.dom.contains(l)) {
                s = OS(l, n);
                break
            }
        if (!s)
            return;
        const a = function (e, t) {
            const n = OS(e, t);
            if (n && 1 === n.node.nodeType) {
                const e = t.docView
                    , r = e.nearestDesc(n.node, !0);
                return r && r !== e ? r.posBefore : null
            }
            return null
        }(s.node, n);
        if (null != a) {
            const r = n.state.selection
                , o = n.state.doc
                , { from: i, to: s } = function (e, t) {
                    let n, r;
                    const o = "blockContent" === t.resolve(e.from).node().type.spec.group
                        , i = "blockContent" === t.resolve(e.to).node().type.spec.group
                        , s = Math.min(e.$anchor.depth, e.$head.depth);
                    if (o && i) {
                        const o = e.$from.start(s - 1)
                            , i = e.$to.end(s - 1);
                        n = t.resolve(o - 1).pos,
                            r = t.resolve(i + 1).pos
                    } else
                        n = e.from,
                            r = e.to;
                    return {
                        from: n,
                        to: r
                    }
                }(r, o)
                , l = i <= a && a < s
                , c = r.$anchor.node() !== r.$head.node() || r instanceof NS;
            l && c ? (n.dispatch(n.state.tr.setSelection(NS.create(o, i, s))),
                AS(n, i, s)) : (n.dispatch(n.state.tr.setSelection(pt.create(n.state.doc, a))),
                    AS(n, a));
            const d = n.state.selection.content()
                , u = t.pmSchema
                , h = $o(n, d).dom.innerHTML
                , p = fk(u, t)
                , f = TS(d.content, t.schema)
                , m = p.exportBlocks(f, {})
                , g = uS(m);
            e.dataTransfer.clearData(),
                e.dataTransfer.setData("blocknote/html", h),
                e.dataTransfer.setData("text/html", m),
                e.dataTransfer.setData("text/plain", g),
                e.dataTransfer.effectAllowed = "move",
                e.dataTransfer.setDragImage(_S, 0, 0),
                n.dragging = {
                    slice: d,
                    move: !0
                }
        }
    }
    class RS {
        constructor(e, t, n) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "mousePos"),
                Kw(this, "hoveredBlock"),
                Kw(this, "menuFrozen", !1),
                Kw(this, "updateState", (e => {
                    this.state = e,
                        this.emitUpdate(this.state)
                }
                )),
                Kw(this, "updateStateFromMousePos", (() => {
                    var e, t, n, r;
                    if (this.menuFrozen || !this.mousePos)
                        return;
                    const o = ((e, t) => {
                        if (!t.dom.firstChild)
                            return;
                        const n = t.dom.firstChild.getBoundingClientRect()
                            , r = {
                                left: n.left + n.width / 2,
                                top: e.y
                            }
                            , o = t.root.elementsFromPoint(r.left, r.top);
                        let i;
                        for (const s of o)
                            if (t.dom.contains(s)) {
                                i = OS(s, t);
                                break
                            }
                        return i
                    }
                    )(this.mousePos, this.pmView);
                    if (!o || !this.editor.isEditable)
                        return void (null != (e = this.state) && e.show && (this.state.show = !1,
                            this.updateState(this.state)));
                    if (null != (t = this.state) && t.show && null != (n = this.hoveredBlock) && n.hasAttribute("data-id") && (null == (r = this.hoveredBlock) ? void 0 : r.getAttribute("data-id")) === o.id)
                        return;
                    this.hoveredBlock = o.node;
                    const i = o.node.firstChild;
                    if (i && this.editor.isEditable) {
                        const e = this.pmView.dom.firstChild.getBoundingClientRect()
                            , t = i.getBoundingClientRect();
                        this.updateState({
                            show: !0,
                            referencePos: new DOMRect(e.x, t.y, t.width, t.height),
                            block: this.editor.getBlock(this.hoveredBlock.getAttribute("data-id"))
                        })
                    }
                }
                )),
                Kw(this, "onDrop", (e => {
                    var t;
                    if (this.editor._tiptapEditor.commands.blur(),
                        e.synthetic || null == (t = e.dataTransfer) || !t.types.includes("blocknote/html"))
                        return;
                    const n = this.pmView.posAtCoords({
                        left: e.clientX,
                        top: e.clientY
                    });
                    if (!n || -1 === n.inside) {
                        const t = new Event("drop", e)
                            , n = this.pmView.dom.firstChild.getBoundingClientRect();
                        t.clientX = e.clientX < n.left || e.clientX > n.left + n.width ? n.left + n.width / 2 : e.clientX,
                            t.clientY = Math.min(Math.max(e.clientY, n.top), n.top + n.height),
                            t.dataTransfer = e.dataTransfer,
                            t.preventDefault = () => e.preventDefault(),
                            t.synthetic = !0,
                            this.pmView.dom.dispatchEvent(t)
                    }
                }
                )),
                Kw(this, "onDragOver", (e => {
                    var t;
                    if (e.synthetic || null == (t = e.dataTransfer) || !t.types.includes("blocknote/html"))
                        return;
                    const n = this.pmView.posAtCoords({
                        left: e.clientX,
                        top: e.clientY
                    });
                    if (!n || -1 === n.inside && this.pmView.dom.firstChild) {
                        const t = new Event("dragover", e)
                            , n = this.pmView.dom.firstChild.getBoundingClientRect();
                        t.clientX = n.left + n.width / 2,
                            t.clientY = e.clientY,
                            t.dataTransfer = e.dataTransfer,
                            t.preventDefault = () => e.preventDefault(),
                            t.synthetic = !0,
                            this.pmView.dom.dispatchEvent(t)
                    }
                }
                )),
                Kw(this, "onKeyDown", (e => {
                    var t;
                    null != (t = this.state) && t.show && this.editor.isFocused() && (this.state.show = !1,
                        this.emitUpdate(this.state))
                }
                )),
                Kw(this, "onMouseMove", (e => {
                    var t;
                    if (this.menuFrozen)
                        return;
                    this.mousePos = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    const n = this.pmView.dom.getBoundingClientRect()
                        , r = this.mousePos.x > n.left && this.mousePos.x < n.right && this.mousePos.y > n.top && this.mousePos.y < n.bottom
                        , o = this.pmView.dom.parentElement;
                    r && e && e.target && o !== e.target && !o.contains(e.target) ? null != (t = this.state) && t.show && (this.state.show = !1,
                        this.emitUpdate(this.state)) : this.updateStateFromMousePos()
                }
                )),
                this.editor = e,
                this.pmView = t,
                this.emitUpdate = () => {
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized side menu");
                    n(this.state)
                }
                ,
                this.pmView.root.addEventListener("drop", this.onDrop, !0),
                this.pmView.root.addEventListener("dragover", this.onDragOver),
                lS(),
                this.pmView.root.addEventListener("mousemove", this.onMouseMove, !0),
                this.pmView.root.addEventListener("keydown", this.onKeyDown, !0)
        }
        update(e, t) {
            var n;
            !t.doc.eq(this.pmView.state.doc) && null != (n = this.state) && n.show && this.updateStateFromMousePos()
        }
        destroy() {
            var e;
            null != (e = this.state) && e.show && (this.state.show = !1,
                this.emitUpdate(this.state)),
                this.pmView.root.removeEventListener("mousemove", this.onMouseMove, !0),
                this.pmView.root.removeEventListener("dragover", this.onDragOver),
                this.pmView.root.removeEventListener("drop", this.onDrop, !0),
                this.pmView.root.removeEventListener("keydown", this.onKeyDown, !0)
        }
    }
    const DS = new _t("SideMenuPlugin");
    class IS extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "blockDragStart", (e => {
                    LS(e, this.editor)
                }
                )),
                Kw(this, "blockDragEnd", (() => PS(this.editor.prosemirrorView.root))),
                Kw(this, "freezeMenu", (() => this.view.menuFrozen = !0)),
                Kw(this, "unfreezeMenu", (() => {
                    this.view.menuFrozen = !1,
                        this.view.state.show = !1,
                        this.view.emitUpdate(this.view.state)
                }
                )),
                this.editor = e,
                this.plugin = new Mt({
                    key: DS,
                    view: t => (this.view = new RS(e, t, (e => {
                        this.emit("update", e)
                    }
                    )),
                        this.view)
                })
        }
        onUpdate(e) {
            return this.on("update", e)
        }
    }
    const jS = Ls((e => "blockContainer" === e.type.name));
    class HS {
        constructor(e, t) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "rootEl"),
                Kw(this, "pluginState"),
                Kw(this, "handleScroll", (() => {
                    var e, t;
                    if (null != (e = this.state) && e.show) {
                        const e = null == (t = this.rootEl) ? void 0 : t.querySelector(`[data-decoration-id="${this.pluginState.decorationId}"]`);
                        if (!e)
                            return;
                        this.state.referencePos = e.getBoundingClientRect(),
                            this.emitUpdate(this.pluginState.triggerCharacter)
                    }
                }
                )),
                Kw(this, "closeMenu", (() => {
                    this.editor.dispatch(this.editor._tiptapEditor.view.state.tr.setMeta(zS, null))
                }
                )),
                Kw(this, "clearQuery", (() => {
                    void 0 !== this.pluginState && this.editor._tiptapEditor.chain().focus().deleteRange({
                        from: this.pluginState.queryStartPos - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),
                        to: this.editor._tiptapEditor.state.selection.from
                    }).run()
                }
                )),
                this.editor = e,
                this.pluginState = void 0,
                this.emitUpdate = e => {
                    var n;
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized suggestions menu");
                    t(e, {
                        ...this.state,
                        ignoreQueryLength: null == (n = this.pluginState) ? void 0 : n.ignoreQueryLength
                    })
                }
                ,
                this.rootEl = this.editor._tiptapEditor.view.root,
                this.rootEl.addEventListener("scroll", this.handleScroll, !0)
        }
        update(e, t) {
            var n;
            const r = zS.getState(t)
                , o = zS.getState(e.state)
                , i = void 0 !== r && void 0 === o;
            if (!(void 0 === r && void 0 !== o) && (void 0 === r || void 0 === o) && !i)
                return;
            if (this.pluginState = i ? r : o,
                i || !this.editor.isEditable)
                return this.state.show = !1,
                    void this.emitUpdate(this.pluginState.triggerCharacter);
            const s = null == (n = this.rootEl) ? void 0 : n.querySelector(`[data-decoration-id="${this.pluginState.decorationId}"]`);
            this.editor.isEditable && s && (this.state = {
                show: !0,
                referencePos: s.getBoundingClientRect(),
                query: this.pluginState.query
            },
                this.emitUpdate(this.pluginState.triggerCharacter))
        }
        destroy() {
            var e;
            null == (e = this.rootEl) || e.removeEventListener("scroll", this.handleScroll, !0)
        }
    }
    const zS = new _t("SuggestionMenuPlugin");
    class $S extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "triggerCharacters", []),
                Kw(this, "addTriggerCharacter", (e => {
                    this.triggerCharacters.push(e)
                }
                )),
                Kw(this, "removeTriggerCharacter", (e => {
                    this.triggerCharacters = this.triggerCharacters.filter((t => t !== e))
                }
                )),
                Kw(this, "closeMenu", (() => this.view.closeMenu())),
                Kw(this, "clearQuery", (() => this.view.clearQuery()));
            const t = this.triggerCharacters;
            this.plugin = new Mt({
                key: zS,
                view: () => (this.view = new HS(e, ((e, t) => {
                    this.emit(`update ${e}`, t)
                }
                )),
                    this.view),
                state: {
                    init() { },
                    apply(e, t, n, r) {
                        if (void 0 !== e.getMeta("orderedListIndexing") || e.selection.$from.parent.type.spec.code)
                            return t;
                        const o = e.getMeta(zS);
                        if ("object" == typeof o && null !== o && void 0 === t)
                            return {
                                triggerCharacter: o.triggerCharacter,
                                deleteTriggerCharacter: !1 !== o.deleteTriggerCharacter,
                                queryStartPos: r.selection.from,
                                query: "",
                                decorationId: `id_${Math.floor(4294967295 * Math.random())}`,
                                ignoreQueryLength: null == o ? void 0 : o.ignoreQueryLength
                            };
                        if (void 0 === t)
                            return t;
                        if (r.selection.from !== r.selection.to || null === o || e.getMeta("focus") || e.getMeta("blur") || e.getMeta("pointer") || void 0 !== t.triggerCharacter && r.selection.from < t.queryStartPos)
                            return;
                        const i = {
                            ...t
                        };
                        return i.query = r.doc.textBetween(t.queryStartPos, r.selection.from),
                            i
                    }
                },
                props: {
                    handleTextInput(e, n, r, o) {
                        const i = this.getState(e.state);
                        return !(!t.includes(o) || void 0 !== i) && (e.dispatch(e.state.tr.insertText(o).scrollIntoView().setMeta(zS, {
                            triggerCharacter: o
                        })),
                            !0)
                    },
                    decorations(e) {
                        const t = this.getState(e);
                        if (void 0 === t)
                            return null;
                        if (!t.deleteTriggerCharacter) {
                            const n = jS(e.selection);
                            if (n)
                                return mo.create(e.doc, [ho.node(n.pos, n.pos + n.node.nodeSize, {
                                    nodeName: "span",
                                    class: "bn-suggestion-decorator",
                                    "data-decoration-id": t.decorationId
                                })])
                        }
                        return mo.create(e.doc, [ho.inline(t.queryStartPos - t.triggerCharacter.length, t.queryStartPos, {
                            nodeName: "span",
                            class: "bn-suggestion-decorator",
                            "data-decoration-id": t.decorationId
                        })])
                    }
                }
            })
        }
        onUpdate(e, t) {
            return this.triggerCharacters.includes(e) || this.addTriggerCharacter(e),
                this.on(`update ${e}`, t)
        }
        get shown() {
            var e, t;
            return (null == (t = null == (e = this.view) ? void 0 : e.state) ? void 0 : t.show) || !1
        }
    }
    let BS;
    function VS(e) {
        BS || (BS = document.createElement("div"),
            BS.innerHTML = "_",
            BS.style.opacity = "0",
            BS.style.height = "1px",
            BS.style.width = "1px",
            e instanceof Document ? e.body.appendChild(BS) : e.appendChild(BS))
    }
    function FS(e) {
        return Array.prototype.indexOf.call(e.parentElement.childNodes, e)
    }
    class US {
        constructor(e, t, n) {
            Kw(this, "state"),
                Kw(this, "emitUpdate"),
                Kw(this, "tableId"),
                Kw(this, "tablePos"),
                Kw(this, "tableElement"),
                Kw(this, "menuFrozen", !1),
                Kw(this, "mouseState", "up"),
                Kw(this, "prevWasEditable", null),
                Kw(this, "viewMousedownHandler", (() => {
                    this.mouseState = "down"
                }
                )),
                Kw(this, "mouseUpHandler", (e => {
                    this.mouseState = "up",
                        this.mouseMoveHandler(e)
                }
                )),
                Kw(this, "mouseMoveHandler", (e => {
                    var t, n, r, o;
                    if (this.menuFrozen || "selecting" === this.mouseState || !(e.target instanceof Element) || !this.pmView.dom.contains(e.target))
                        return;
                    const i = function (e) {
                        let t = e;
                        for (; t && "TD" !== t.nodeName && "TH" !== t.nodeName && !t.classList.contains("tableWrapper");) {
                            if (t.classList.contains("ProseMirror"))
                                return;
                            const e = t.parentNode;
                            if (!e || !(e instanceof Element))
                                return;
                            t = e
                        }
                        return "TD" === t.nodeName || "TH" === t.nodeName ? {
                            type: "cell",
                            domNode: t,
                            tbodyNode: t.closest("tbody")
                        } : {
                            type: "wrapper",
                            domNode: t,
                            tbodyNode: t.querySelector("tbody")
                        }
                    }(e.target);
                    if ("cell" === (null == i ? void 0 : i.type) && "down" === this.mouseState && (null == (t = this.state) || !t.draggingState))
                        return this.mouseState = "selecting",
                            void (null != (n = this.state) && n.show && (this.state.show = !1,
                                this.state.showAddOrRemoveRowsButton = !1,
                                this.state.showAddOrRemoveColumnsButton = !1,
                                this.emitUpdate()));
                    if (!i || !this.editor.isEditable)
                        return void (null != (r = this.state) && r.show && (this.state.show = !1,
                            this.state.showAddOrRemoveRowsButton = !1,
                            this.state.showAddOrRemoveColumnsButton = !1,
                            this.emitUpdate()));
                    if (!i.tbodyNode)
                        return;
                    const s = i.tbodyNode.getBoundingClientRect()
                        , a = OS(i.domNode, this.pmView);
                    if (!a)
                        return;
                    let l;
                    this.tableElement = a.node;
                    const c = yC(a.id, this.editor._tiptapEditor.state.doc)
                        , d = Uk(c.node, this.editor.schema.blockSchema, this.editor.schema.inlineContentSchema, this.editor.schema.styleSchema, this.editor.blockCache);
                    if (function (e, t, n) {
                        return t.type === e && t.type in n.schema.blockSchema && eS(t.type, n)
                    }("table", d, this.editor) && (this.tablePos = c.posBeforeNode + 1,
                        l = d),
                        !l)
                        return;
                    this.tableId = a.id;
                    const u = null == (o = i.domNode.closest(".tableWrapper")) ? void 0 : o.querySelector(".table-widgets-container");
                    if ("wrapper" === (null == i ? void 0 : i.type)) {
                        const t = e.clientY >= s.bottom - 1 && e.clientY < s.bottom + 20
                            , n = e.clientX >= s.right - 1 && e.clientX < s.right + 20
                            , r = e.clientX > s.right || e.clientY > s.bottom;
                        this.state = {
                            ...this.state,
                            show: !0,
                            showAddOrRemoveRowsButton: t,
                            showAddOrRemoveColumnsButton: n,
                            referencePosTable: s,
                            block: l,
                            widgetContainer: u,
                            colIndex: r ? void 0 : this.state.colIndex,
                            rowIndex: r ? void 0 : this.state.rowIndex,
                            referencePosCell: r ? void 0 : this.state.referencePosCell
                        }
                    } else {
                        const e = FS(i.domNode)
                            , t = FS(i.domNode.parentElement)
                            , n = i.domNode.getBoundingClientRect();
                        if (void 0 !== this.state && this.state.show && this.tableId === a.id && this.state.rowIndex === t && this.state.colIndex === e)
                            return;
                        this.state = {
                            show: !0,
                            showAddOrRemoveColumnsButton: e === l.content.rows[0].cells.length - 1,
                            showAddOrRemoveRowsButton: t === l.content.rows.length - 1,
                            referencePosTable: s,
                            block: l,
                            draggingState: void 0,
                            referencePosCell: n,
                            colIndex: e,
                            rowIndex: t,
                            widgetContainer: u
                        }
                    }
                    return this.emitUpdate(),
                        !1
                }
                )),
                Kw(this, "dragOverHandler", (e => {
                    var t;
                    if (void 0 === (null == (t = this.state) ? void 0 : t.draggingState))
                        return;
                    e.preventDefault(),
                        e.dataTransfer.dropEffect = "move",
                        function (e, t) {
                            const n = t.querySelectorAll(e);
                            for (let r = 0; r < n.length; r++)
                                n[r].style.visibility = "hidden"
                        }(".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline", this.pmView.root);
                    const n = {
                        left: Math.min(Math.max(e.clientX, this.state.referencePosTable.left + 1), this.state.referencePosTable.right - 1),
                        top: Math.min(Math.max(e.clientY, this.state.referencePosTable.top + 1), this.state.referencePosTable.bottom - 1)
                    }
                        , r = this.pmView.root.elementsFromPoint(n.left, n.top).filter((e => "TD" === e.tagName || "TH" === e.tagName));
                    if (0 === r.length)
                        throw new Error("Could not find table cell element that the mouse cursor is hovering over.");
                    const o = r[0];
                    let i = !1;
                    const s = FS(o.parentElement)
                        , a = FS(o)
                        , l = "row" === this.state.draggingState.draggedCellOrientation ? this.state.rowIndex : this.state.colIndex
                        , c = ("row" === this.state.draggingState.draggedCellOrientation ? s : a) !== l;
                    (this.state.rowIndex !== s || this.state.colIndex !== a) && (this.state.rowIndex = s,
                        this.state.colIndex = a,
                        this.state.referencePosCell = o.getBoundingClientRect(),
                        i = !0);
                    const d = "row" === this.state.draggingState.draggedCellOrientation ? n.top : n.left;
                    this.state.draggingState.mousePos !== d && (this.state.draggingState.mousePos = d,
                        i = !0),
                        i && this.emitUpdate(),
                        c && this.editor.dispatch(this.pmView.state.tr.setMeta(WS, !0))
                }
                )),
                Kw(this, "dropHandler", (e => {
                    if (this.mouseState = "up",
                        void 0 === this.state || void 0 === this.state.draggingState)
                        return;
                    if (void 0 === this.state.rowIndex || void 0 === this.state.colIndex)
                        throw new Error("Attempted to drop table row or column, but no table block was hovered prior.");
                    e.preventDefault();
                    const { draggingState: t, colIndex: n, rowIndex: r } = this.state
                        , o = this.state.block.content.rows;
                    if ("row" === t.draggedCellOrientation) {
                        const e = o[t.originalIndex];
                        o.splice(t.originalIndex, 1),
                            o.splice(r, 0, e)
                    } else {
                        const e = o.map((e => e.cells[t.originalIndex]));
                        o.forEach(((r, o) => {
                            r.cells.splice(t.originalIndex, 1),
                                r.cells.splice(n, 0, e[o])
                        }
                        ))
                    }
                    this.editor.updateBlock(this.state.block, {
                        type: "table",
                        content: {
                            type: "tableContent",
                            rows: o
                        }
                    }),
                        this.editor.setTextCursorPosition(this.state.block.id)
                }
                )),
                this.editor = e,
                this.pmView = t,
                this.emitUpdate = () => {
                    if (!this.state)
                        throw new Error("Attempting to update uninitialized image toolbar");
                    n(this.state)
                }
                ,
                t.dom.addEventListener("mousemove", this.mouseMoveHandler),
                t.dom.addEventListener("mousedown", this.viewMousedownHandler),
                window.addEventListener("mouseup", this.mouseUpHandler),
                t.root.addEventListener("dragover", this.dragOverHandler),
                t.root.addEventListener("drop", this.dropHandler)
        }
        update() {
            if (!this.state || !this.state.show)
                return;
            const e = this.tableElement.querySelector("tbody");
            if (e) {
                if (void 0 !== this.state.rowIndex && void 0 !== this.state.colIndex) {
                    this.state.rowIndex >= e.children.length && (this.state.rowIndex = e.children.length - 1),
                        this.state.colIndex >= e.children[0].children.length && (this.state.colIndex = e.children[0].children.length - 1);
                    const t = e.children[this.state.rowIndex].children[this.state.colIndex];
                    this.state.referencePosCell = t.getBoundingClientRect()
                }
                this.state.block = this.editor.getBlock(this.state.block.id),
                    this.state.referencePosTable = e.getBoundingClientRect(),
                    this.emitUpdate()
            }
        }
        destroy() {
            this.pmView.dom.removeEventListener("mousemove", this.mouseMoveHandler),
                window.removeEventListener("mouseup", this.mouseUpHandler),
                this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler),
                this.pmView.root.removeEventListener("dragover", this.dragOverHandler),
                this.pmView.root.removeEventListener("drop", this.dropHandler)
        }
    }
    const WS = new _t("TableHandlesPlugin");
    class qS extends bS {
        constructor(e) {
            super(),
                Kw(this, "view"),
                Kw(this, "plugin"),
                Kw(this, "colDragStart", (e => {
                    if (void 0 === this.view.state || void 0 === this.view.state.colIndex)
                        throw new Error("Attempted to drag table column, but no table block was hovered prior.");
                    this.view.state.draggingState = {
                        draggedCellOrientation: "col",
                        originalIndex: this.view.state.colIndex,
                        mousePos: e.clientX
                    },
                        this.view.emitUpdate(),
                        this.editor.dispatch(this.editor._tiptapEditor.state.tr.setMeta(WS, {
                            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
                            originalIndex: this.view.state.colIndex,
                            newIndex: this.view.state.colIndex,
                            tablePos: this.view.tablePos
                        })),
                        VS(this.editor._tiptapEditor.view.root),
                        e.dataTransfer.setDragImage(BS, 0, 0),
                        e.dataTransfer.effectAllowed = "move"
                }
                )),
                Kw(this, "rowDragStart", (e => {
                    if (void 0 === this.view.state || void 0 === this.view.state.rowIndex)
                        throw new Error("Attempted to drag table row, but no table block was hovered prior.");
                    this.view.state.draggingState = {
                        draggedCellOrientation: "row",
                        originalIndex: this.view.state.rowIndex,
                        mousePos: e.clientY
                    },
                        this.view.emitUpdate(),
                        this.editor.dispatch(this.editor._tiptapEditor.state.tr.setMeta(WS, {
                            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
                            originalIndex: this.view.state.rowIndex,
                            newIndex: this.view.state.rowIndex,
                            tablePos: this.view.tablePos
                        })),
                        VS(this.editor._tiptapEditor.view.root),
                        e.dataTransfer.setDragImage(BS, 0, 0),
                        e.dataTransfer.effectAllowed = "copyMove"
                }
                )),
                Kw(this, "dragEnd", (() => {
                    if (void 0 === this.view.state)
                        throw new Error("Attempted to drag table row, but no table block was hovered prior.");
                    var e;
                    this.view.state.draggingState = void 0,
                        this.view.emitUpdate(),
                        this.editor.dispatch(this.editor._tiptapEditor.state.tr.setMeta(WS, null)),
                        e = this.editor._tiptapEditor.view.root,
                        BS && (e instanceof Document ? e.body.removeChild(BS) : e.removeChild(BS),
                            BS = void 0)
                }
                )),
                Kw(this, "freezeHandles", (() => {
                    this.view.menuFrozen = !0
                }
                )),
                Kw(this, "unfreezeHandles", (() => {
                    this.view.menuFrozen = !1
                }
                )),
                this.editor = e,
                this.plugin = new Mt({
                    key: WS,
                    view: t => (this.view = new US(e, t, (e => {
                        this.emit("update", e)
                    }
                    )),
                        this.view),
                    props: {
                        decorations: e => {
                            if (void 0 === this.view || void 0 === this.view.state || void 0 === this.view.state.draggingState || void 0 === this.view.tablePos)
                                return;
                            const t = "row" === this.view.state.draggingState.draggedCellOrientation ? this.view.state.rowIndex : this.view.state.colIndex;
                            if (void 0 === t)
                                return;
                            const n = [];
                            if (t === this.view.state.draggingState.originalIndex)
                                return mo.create(e.doc, n);
                            const r = e.doc.resolve(this.view.tablePos + 1)
                                , o = r.node();
                            if ("row" === this.view.state.draggingState.draggedCellOrientation) {
                                const o = e.doc.resolve(r.posAtIndex(t) + 1)
                                    , i = o.node();
                                for (let r = 0; r < i.childCount; r++) {
                                    const i = e.doc.resolve(o.posAtIndex(r) + 1)
                                        , s = i.node()
                                        , a = i.pos + (t > this.view.state.draggingState.originalIndex ? s.nodeSize - 2 : 0);
                                    n.push(ho.widget(a, (() => {
                                        const e = document.createElement("div");
                                        return e.className = "bn-table-drop-cursor",
                                            e.style.left = "0",
                                            e.style.right = "0",
                                            t > this.view.state.draggingState.originalIndex ? e.style.bottom = "-2px" : e.style.top = "-3px",
                                            e.style.height = "4px",
                                            e
                                    }
                                    )))
                                }
                            } else
                                for (let i = 0; i < o.childCount; i++) {
                                    const o = e.doc.resolve(r.posAtIndex(i) + 1)
                                        , s = e.doc.resolve(o.posAtIndex(t) + 1)
                                        , a = s.node()
                                        , l = s.pos + (t > this.view.state.draggingState.originalIndex ? a.nodeSize - 2 : 0);
                                    n.push(ho.widget(l, (() => {
                                        const e = document.createElement("div");
                                        return e.className = "bn-table-drop-cursor",
                                            e.style.top = "0",
                                            e.style.bottom = "0",
                                            t > this.view.state.draggingState.originalIndex ? e.style.right = "-2px" : e.style.left = "-3px",
                                            e.style.width = "4px",
                                            e
                                    }
                                    )))
                                }
                            return mo.create(e.doc, n)
                        }
                    }
                })
        }
        onUpdate(e) {
            return this.on("update", e)
        }
    }
    const GS = ["vscode-editor-data", "blocknote/html", "Files", "text/html", "text/plain"];
    function KS(e, t) {
        if (!e.startsWith(".") || !t.startsWith("."))
            throw new Error("The strings provided are not valid file extensions.");
        return e === t
    }
    function JS(e, t) {
        const n = e.split("/")
            , r = t.split("/");
        if (2 !== n.length)
            throw new Error(`The string ${e} is not a valid MIME type.`);
        if (2 !== r.length)
            throw new Error(`The string ${t} is not a valid MIME type.`);
        return "*" === n[1] || "*" === r[1] ? n[0] === r[0] : ("*" === n[0] || "*" === r[0] || n[0] === r[0]) && n[1] === r[1]
    }
    async function ZS(e, t) {
        if (!t.uploadFile)
            return;
        const n = "dataTransfer" in e ? e.dataTransfer : e.clipboardData;
        if (null === n)
            return;
        let r = null;
        for (const s of GS)
            if (n.types.includes(s)) {
                r = s;
                break
            }
        if ("Files" !== r)
            return;
        const o = n.items;
        if (!o)
            return;
        e.preventDefault();
        const i = Object.values(t.schema.blockSchema).filter((e => e.isFileBlock));
        for (let s = 0; s < o.length; s++) {
            let n = "file";
            for (const e of i)
                for (const t of e.fileBlockAccept || []) {
                    const r = t.startsWith(".")
                        , i = o[s].getAsFile();
                    if (i && (!r && i.type && JS(o[s].type, t) || r && KS("." + i.name.split(".").pop(), t))) {
                        n = e.type;
                        break
                    }
                }
            const r = o[s].getAsFile();
            if (r) {
                const o = {
                    type: n,
                    props: {
                        name: r.name
                    }
                };
                let i;
                if ("paste" === e.type)
                    i = t.insertBlocks([o], t.getTextCursorPosition().block, "after")[0].id;
                else {
                    if ("drop" !== e.type)
                        return;
                    {
                        const n = {
                            left: e.clientX,
                            top: e.clientY
                        }
                            , r = t._tiptapEditor.view.posAtCoords(n);
                        if (!r)
                            return;
                        const s = vk(bk(t._tiptapEditor.state.doc, r.pos));
                        i = t.insertBlocks([o], s.blockContainer.node.attrs.id, "after")[0].id
                    }
                }
                const s = await t.uploadFile(r, i)
                    , a = "string" == typeof s ? {
                        props: {
                            url: s
                        }
                    } : {
                        ...s
                    };
                t.updateBlock(i, a)
            }
        }
    }
    const XS = e => as.create({
        name: "dropFile",
        addProseMirrorPlugins: () => [new Mt({
            props: {
                handleDOMEvents: {
                    drop(t, n) {
                        if (!e.isEditable)
                            return;
                        let r = null;
                        for (const e of GS)
                            if (n.dataTransfer.types.includes(e)) {
                                r = e;
                                break
                            }
                        return null === r || "Files" === r && (ZS(n, e),
                            !0)
                    }
                }
            }
        })]
    });
    const QS = e => as.create({
        name: "pasteFromClipboard",
        addProseMirrorPlugins: () => [new Mt({
            props: {
                handleDOMEvents: {
                    paste(t, n) {
                        if (n.preventDefault(),
                            !e.isEditable)
                            return;
                        let r;
                        for (const e of GS)
                            if (n.clipboardData.types.includes(e)) {
                                r = e;
                                break
                            }
                        if (!r)
                            return !0;
                        if ("vscode-editor-data" === r)
                            return async function (e, t) {
                                const n = t.prosemirrorView
                                    , { schema: r } = n.state;
                                if (!e.clipboardData)
                                    return !1;
                                const o = e.clipboardData.getData("text/plain")
                                    , i = e.clipboardData.getData("vscode-editor-data")
                                    , s = i ? JSON.parse(i) : void 0
                                    , a = null == s ? void 0 : s.mode;
                                !!o && (r.nodes.codeBlock ? !!a && t._tiptapEditor.view.pasteHTML(`<pre><code class="language-${a}">${o.replace(/\r\n?/g, "\n")}</code></pre>`) : n.pasteText(o))
                            }(n, e),
                                !0;
                        if ("Files" === r)
                            return ZS(n, e),
                                !0;
                        let o = n.clipboardData.getData(r);
                        return "blocknote/html" === r ? (e._tiptapEditor.view.pasteHTML(o),
                            !0) : "text/html" === r ? (o = fS(o.trim()).innerHTML,
                                e._tiptapEditor.view.pasteHTML(o),
                                !0) : (e._tiptapEditor.view.pasteText(o),
                                    !0)
                    }
                }
            }
        })]
    });
    function YS(e, t) {
        "node" in e.state.selection && "blockContent" === e.state.selection.node.type.spec.group && t.dispatch(t._tiptapEditor.state.tr.setSelection(new pt(e.state.doc.resolve(e.state.selection.from - 1))));
        const n = $o(e, e.state.selection.content()).dom.innerHTML
            , r = e.state.selection.content().content
            , o = function (e, t, n) {
                var r;
                let o = !1;
                const i = e.state.selection instanceof ju;
                if (!i) {
                    const n = e.state.doc.slice(e.state.selection.from, e.state.selection.to, !1).content
                        , r = [];
                    for (let e = 0; e < n.childCount; e++)
                        r.push(n.child(e));
                    o = void 0 === r.find((e => "blockContainer" === e.type.name || "blockGroup" === e.type.name || "blockContent" === e.type.spec.group)),
                        o && (t = n)
                }
                let s;
                const a = fk(e.state.schema, n);
                if (i) {
                    "table" === (null == (r = t.firstChild) ? void 0 : r.type.name) && (t = t.firstChild.content);
                    const e = Bk(t, n.schema.inlineContentSchema, n.schema.styleSchema);
                    s = a.exportInlineContent(e, {})
                } else if (o) {
                    const e = Vk(t, n.schema.inlineContentSchema, n.schema.styleSchema);
                    s = a.exportInlineContent(e, {})
                } else {
                    const e = TS(t, n.schema);
                    s = a.exportBlocks(e, {})
                }
                return s
            }(e, r, t);
        return {
            clipboardHTML: n,
            externalHTML: o,
            markdown: uS(o)
        }
    }
    const ex = (e, t, n) => {
        n.preventDefault(),
            n.clipboardData.clearData();
        const { clipboardHTML: r, externalHTML: o, markdown: i } = YS(t, e);
        n.clipboardData.setData("blocknote/html", r),
            n.clipboardData.setData("text/html", o),
            n.clipboardData.setData("text/plain", i)
    }
        , tx = e => as.create({
            name: "copyToClipboard",
            addProseMirrorPlugins: () => [new Mt({
                props: {
                    handleDOMEvents: {
                        copy: (t, n) => (ex(e, t, n),
                            !0),
                        cut: (t, n) => (ex(e, t, n),
                            t.dispatch(t.state.tr.deleteSelection()),
                            !0),
                        dragstart(t, n) {
                            if (!("node" in t.state.selection) || "blockContent" !== t.state.selection.node.type.spec.group)
                                return;
                            e.dispatch(e._tiptapEditor.state.tr.setSelection(new pt(t.state.doc.resolve(t.state.selection.from - 1)))),
                                n.preventDefault(),
                                n.dataTransfer.clearData();
                            const { clipboardHTML: r, externalHTML: o, markdown: i } = YS(t, e);
                            return n.dataTransfer.setData("blocknote/html", r),
                                n.dataTransfer.setData("text/html", o),
                                n.dataTransfer.setData("text/plain", i),
                                !0
                        }
                    }
                }
            })]
        })
        , nx = as.create({
            name: "blockBackgroundColor",
            addGlobalAttributes: () => [{
                types: ["blockContainer"],
                attributes: {
                    backgroundColor: {
                        default: Tk.backgroundColor.default,
                        parseHTML: e => e.hasAttribute("data-background-color") ? e.getAttribute("data-background-color") : Tk.backgroundColor.default,
                        renderHTML: e => e.backgroundColor === Tk.backgroundColor.default ? {} : {
                            "data-background-color": e.backgroundColor
                        }
                    }
                }
            }]
        })
        , rx = (e, t) => {
            if (!t.nodeBefore)
                throw new Error(`Attempted to get previous blockContainer node for merge at position ${t.pos} but a previous node does not exist`);
            let n = t.posAtIndex(t.index() - 1)
                , r = wk(e.resolve(n));
            for (; r.blockGroup;) {
                const t = r.blockGroup.node;
                n = e.resolve(r.blockGroup.beforePos + 1).posAtIndex(t.childCount - 1),
                    r = wk(e.resolve(n))
            }
            return e.resolve(n)
        }
        , ox = e => t => {
            let { state: n, dispatch: r } = t;
            const o = n.doc.resolve(e)
                , i = rx(n.doc, o);
            return !!((e, t) => {
                const n = wk(e)
                    , r = wk(t);
                return "inline*" === n.blockContent.node.type.spec.content && "inline*" === r.blockContent.node.type.spec.content && n.blockContent.node.childCount > 0
            }
            )(i, o) && ((e, t, n, r) => {
                const o = wk(r);
                if (o.blockGroup) {
                    const n = e.doc.resolve(o.blockGroup.beforePos + 1)
                        , i = e.doc.resolve(o.blockGroup.afterPos - 1)
                        , s = n.blockRange(i);
                    t && e.tr.lift(s, r.depth)
                }
                if (t) {
                    const r = wk(n);
                    t(e.tr.delete(r.blockContent.afterPos - 1, o.blockContent.beforePos + 1))
                }
                return !0
            }
            )(n, r, i, o)
        }
        , ix = as.create({
            priority: 50,
            addKeyboardShortcuts() {
                return {
                    Backspace: () => this.editor.commands.first((e => {
                        let { chain: t, commands: n } = e;
                        return [() => n.deleteSelection(), () => n.undoInputRule(), () => n.command((e => {
                            let { state: t } = e;
                            const r = kk(t)
                                , o = t.selection.from === r.blockContent.beforePos + 1
                                , i = "paragraph" === r.blockContent.node.type.name;
                            return !(!o || i) && n.command(vC(this.options.editor, r.blockContainer.beforePos, {
                                type: "paragraph",
                                props: {}
                            }))
                        }
                        )), () => n.command((e => {
                            let { state: t } = e;
                            const { blockContent: r } = kk(t);
                            return t.selection.from === r.beforePos + 1 && n.liftListItem("blockContainer")
                        }
                        )), () => n.command((e => {
                            let { state: n } = e;
                            const { blockContainer: r, blockContent: o } = kk(n)
                                , { depth: i } = n.doc.resolve(r.beforePos)
                                , s = n.selection.from === o.beforePos + 1
                                , a = n.selection.empty
                                , l = 1 === r.beforePos
                                , c = r.beforePos;
                            return !(l || !s || !a || 1 !== i) && t().command(ox(c)).scrollIntoView().run()
                        }
                        )), () => n.command((e => {
                            let { state: n } = e;
                            const r = kk(n)
                                , { depth: o } = n.doc.resolve(r.blockContainer.beforePos)
                                , i = n.selection.from === r.blockContent.beforePos + 1
                                , s = n.selection.empty;
                            if (1 !== r.blockContainer.beforePos && i && s && 1 === o) {
                                const e = rx(n.doc, n.doc.resolve(r.blockContainer.beforePos))
                                    , o = wk(n.doc.resolve(e.pos));
                                if ("" === o.blockContent.node.type.spec.content || "inline*" === o.blockContent.node.type.spec.content && 0 === o.blockContent.node.childCount)
                                    return t().cut({
                                        from: r.blockContainer.beforePos,
                                        to: r.blockContainer.afterPos
                                    }, o.blockContainer.afterPos).deleteRange({
                                        from: o.blockContainer.beforePos,
                                        to: o.blockContainer.afterPos
                                    }).run()
                            }
                            return !1
                        }
                        ))]
                    }
                    )),
                    Delete: () => this.editor.commands.first((e => {
                        let { commands: t } = e;
                        return [() => t.deleteSelection(), () => t.command((e => {
                            let { state: n } = e;
                            const { blockContainer: r, blockContent: o, blockGroup: i } = kk(n)
                                , { depth: s } = n.doc.resolve(r.beforePos)
                                , a = r.afterPos === n.doc.nodeSize - 3
                                , l = n.selection.from === o.afterPos - 1
                                , c = n.selection.empty;
                            if (!a && l && c && void 0 === i) {
                                let e = s
                                    , o = r.afterPos + 1
                                    , i = n.doc.resolve(o).depth;
                                for (; i < e;)
                                    e = i,
                                        o += 2,
                                        i = n.doc.resolve(o).depth;
                                return t.command(ox(o - 1))
                            }
                            return !1
                        }
                        ))]
                    }
                    )),
                    Enter: () => this.editor.commands.first((e => {
                        let { commands: t } = e;
                        return [() => t.command((e => {
                            let { state: n } = e;
                            const { blockContent: r, blockContainer: o } = kk(n)
                                , { depth: i } = n.doc.resolve(o.beforePos)
                                , s = 0 === n.selection.$anchor.parentOffset
                                , a = n.selection.anchor === n.selection.head
                                , l = 0 === r.node.childCount;
                            return !!(s && a && l && i > 1) && t.liftListItem("blockContainer")
                        }
                        )), () => t.command((e => {
                            let { state: t, dispatch: n } = e;
                            const { blockContainer: r, blockContent: o } = kk(t)
                                , i = 0 === t.selection.$anchor.parentOffset
                                , s = t.selection.anchor === t.selection.head
                                , a = 0 === o.node.childCount;
                            if (i && s && a) {
                                const e = r.afterPos
                                    , o = e + 2;
                                if (n) {
                                    const n = t.schema.nodes.blockContainer.createAndFill();
                                    t.tr.insert(e, n).scrollIntoView(),
                                        t.tr.setSelection(new ut(t.doc.resolve(o)))
                                }
                                return !0
                            }
                            return !1
                        }
                        )), () => t.command((e => {
                            let { state: t, chain: n } = e;
                            const { blockContent: r } = kk(t)
                                , o = 0 === t.selection.$anchor.parentOffset;
                            return 0 !== r.node.childCount && (n().deleteSelection().command(TC(t.selection.from, o, o)).run(),
                                !0)
                        }
                        ))]
                    }
                    )),
                    Tab: () => {
                        var e, t, n;
                        return !(null != (e = this.options.editor.formattingToolbar) && e.shown || null != (t = this.options.editor.linkToolbar) && t.shown || null != (n = this.options.editor.filePanel) && n.shown) && (this.editor.commands.sinkListItem("blockContainer"),
                            !0)
                    }
                    ,
                    "Shift-Tab": () => {
                        var e, t, n;
                        return !(null != (e = this.options.editor.formattingToolbar) && e.shown || null != (t = this.options.editor.linkToolbar) && t.shown || null != (n = this.options.editor.filePanel) && n.shown) && (this.editor.commands.liftListItem("blockContainer"),
                            !0)
                    }
                    ,
                    "Shift-Mod-ArrowUp": () => (this.options.editor.moveBlockUp(),
                        !0),
                    "Shift-Mod-ArrowDown": () => (this.options.editor.moveBlockDown(),
                        !0)
                }
            }
        })
        , sx = as.create({
            name: "textAlignment",
            addGlobalAttributes: () => [{
                types: ["paragraph", "heading", "bulletListItem", "numberedListItem", "checkListItem"],
                attributes: {
                    textAlignment: {
                        default: "left",
                        parseHTML: e => e.getAttribute("data-text-alignment"),
                        renderHTML: e => "left" === e.textAlignment ? {} : {
                            "data-text-alignment": e.textAlignment
                        }
                    }
                }
            }]
        })
        , ax = as.create({
            name: "blockTextColor",
            addGlobalAttributes: () => [{
                types: ["blockContainer"],
                attributes: {
                    textColor: {
                        default: Tk.textColor.default,
                        parseHTML: e => e.hasAttribute("data-text-color") ? e.getAttribute("data-text-color") : Tk.textColor.default,
                        renderHTML: e => e.textColor === Tk.textColor.default ? {} : {
                            "data-text-color": e.textColor
                        }
                    }
                }
            }]
        })
        , lx = as.create({
            name: "trailingNode",
            addProseMirrorPlugins() {
                const e = new _t(this.name);
                return [new Mt({
                    key: e,
                    appendTransaction: (t, n, r) => {
                        const { doc: o, tr: i, schema: s } = r
                            , a = e.getState(r)
                            , l = o.content.size - 2
                            , c = s.nodes.blockContainer
                            , d = s.nodes.paragraph;
                        if (a)
                            return i.insert(l, c.create(void 0, d.create()))
                    }
                    ,
                    state: {
                        init: (e, t) => { }
                        ,
                        apply: (e, t) => {
                            if (!e.docChanged)
                                return t;
                            let n = e.doc.lastChild;
                            if (!n || "blockGroup" !== n.type.name)
                                throw new Error("Expected blockGroup");
                            if (n = n.lastChild,
                                !n || "blockContainer" !== n.type.name)
                                throw new Error("Expected blockContainer");
                            const r = n.firstChild;
                            if (!r)
                                throw new Error("Expected blockContent");
                            return n.nodeSize > 4 || "inline*" !== r.type.spec.content
                        }
                    }
                })]
            }
        })
        , cx = {
            blockColor: "data-block-color",
            blockStyle: "data-block-style",
            id: "data-id",
            depth: "data-depth",
            depthChange: "data-depth-change"
        }
        , dx = la.create({
            name: "blockContainer",
            group: "blockContainer",
            content: "blockContent blockGroup?",
            priority: 50,
            defining: !0,
            parseHTML: () => [{
                tag: "div",
                getAttrs: e => {
                    if ("string" == typeof e)
                        return !1;
                    const t = {};
                    for (const [n, r] of Object.entries(cx))
                        e.getAttribute(r) && (t[n] = e.getAttribute(r));
                    return "blockContainer" === e.getAttribute("data-node-type") && t
                }
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n;
                const r = document.createElement("div");
                r.className = "bn-block-outer",
                    r.setAttribute("data-node-type", "blockOuter");
                for (const [s, a] of Object.entries(t))
                    "class" !== s && r.setAttribute(s, a);
                const o = {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.block) || {},
                    ...t
                }
                    , i = document.createElement("div");
                i.className = Sk("bn-block", o.class),
                    i.setAttribute("data-node-type", this.name);
                for (const [s, a] of Object.entries(o))
                    "class" !== s && i.setAttribute(s, a);
                return r.appendChild(i),
                {
                    dom: r,
                    contentDOM: i
                }
            }
        })
        , ux = la.create({
            name: "blockGroup",
            group: "blockGroup",
            content: "blockContainer+",
            parseHTML: () => [{
                tag: "div",
                getAttrs: e => "string" != typeof e && ("blockGroup" === e.getAttribute("data-node-type") && null)
            }],
            renderHTML(e) {
                let { HTMLAttributes: t } = e;
                var n;
                const r = {
                    ...(null == (n = this.options.domAttributes) ? void 0 : n.blockGroup) || {},
                    ...t
                }
                    , o = document.createElement("div");
                o.className = Sk("bn-block-group", r.class),
                    o.setAttribute("data-node-type", "blockGroup");
                for (const [i, s] of Object.entries(r))
                    "class" !== i && o.setAttribute(i, s);
                return {
                    dom: o,
                    contentDOM: o
                }
            }
        })
        , hx = la.create({
            name: "doc",
            topNode: !0,
            content: "blockGroup"
        })
        , px = e => {
            var t;
            const n = [oa.ClipboardTextSerializer, oa.Commands, oa.Editable, oa.FocusEvents, oa.Tabindex, Ay, Yw.configure({
                types: ["blockContainer"],
                setIdAttribute: e.setIdAttribute
            }), Py.extend({
                priority: 10
            }), qw, Ww.extend({
                addKeyboardShortcuts() {
                    return {
                        "Mod-k": () => (this.editor.commands.toggleLink({
                            href: ""
                        }),
                            !0)
                    }
                }
            }), ...Object.values(e.styleSpecs).map((e => e.implementation.mark)), ax, nx, sx, as.create({
                name: "OverrideEscape",
                addKeyboardShortcuts() {
                    return {
                        Escape: () => !e.editor.suggestionMenus.shown && this.editor.commands.blur()
                    }
                }
            }), hx, dx.configure({
                editor: e.editor,
                domAttributes: e.domAttributes
            }), ix.configure({
                editor: e.editor
            }), ux.configure({
                domAttributes: e.domAttributes
            }), ...Object.values(e.inlineContentSpecs).filter((e => "link" !== e.config && "text" !== e.config)).map((t => t.implementation.node.configure({
                editor: e.editor
            }))), ...Object.values(e.blockSpecs).flatMap((t => [...(t.implementation.requiredExtensions || []).map((t => t.configure({
                editor: e.editor,
                domAttributes: e.domAttributes
            }))), t.implementation.node.configure({
                editor: e.editor,
                domAttributes: e.domAttributes
            })])), tx(e.editor), QS(e.editor), XS(e.editor), Sy.configure({
                width: 5,
                color: "#ddeeff"
            }), ...void 0 === e.trailingBlock || e.trailingBlock ? [lx] : []];
            if (e.collaboration) {
                if (n.push(uy.configure({
                    fragment: e.collaboration.fragment
                })),
                    null != (t = e.collaboration.provider) && t.awareness) {
                    const t = e => {
                        const t = document.createElement("span");
                        t.classList.add("collaboration-cursor__caret"),
                            t.setAttribute("style", `border-color: ${e.color}`);
                        const n = document.createElement("span");
                        n.classList.add("collaboration-cursor__label"),
                            n.setAttribute("style", `background-color: ${e.color}`),
                            n.insertBefore(document.createTextNode(e.name), null);
                        const r = document.createTextNode("\u2060")
                            , o = document.createTextNode("\u2060");
                        return t.insertBefore(r, null),
                            t.insertBefore(n, null),
                            t.insertBefore(o, null),
                            t
                    }
                        ;
                    n.push(wy.configure({
                        user: e.collaboration.user,
                        render: e.collaboration.renderCursor || t,
                        provider: e.collaboration.provider
                    }))
                }
            } else
                n.push(Yy);
            const r = e.disableExtensions || [];
            return n.filter((e => !r.includes(e.name)))
        }
        ;
    function fx(e, t) {
        const n = [];
        return e.forEach(((e, r, o) => {
            o !== t && n.push(e)
        }
        )),
            d.from(n)
    }
    function mx(e, t) {
        let n = d.from(e.content);
        n = function (e, t) {
            const n = [];
            for (let r = 0; r < e.childCount; r++)
                if ("tableRow" === e.child(r).type.name)
                    if (n.length > 0 && "table" === n[n.length - 1].type.name) {
                        const t = n[n.length - 1]
                            , o = t.copy(t.content.addToEnd(e.child(r)));
                        n[n.length - 1] = o
                    } else {
                        const o = t.nodes.table.create(void 0, e.child(r));
                        n.push(o)
                    }
                else
                    n.push(e.child(r));
            return d.from(n)
        }(n, t.state.schema);
        for (let r = 0; r < n.childCount; r++)
            if ("blockContent" === n.child(r).type.spec.group) {
                const e = [n.child(r)];
                if (r + 1 < n.childCount && "blockGroup" === n.child(r + 1).type.spec.group) {
                    const t = n.child(r + 1).child(0).child(0);
                    ("bulletListItem" === t.type.name || "numberedListItem" === t.type.name || "checkListItem" === t.type.name) && (e.push(n.child(r + 1)),
                        n = fx(n, r + 1))
                }
                const o = t.state.schema.nodes.blockContainer.create(void 0, e);
                n = n.replaceChild(r, o)
            }
        return new g(n, e.openStart, e.openEnd)
    }
    function gx(e) {
        return e && Object.fromEntries(Object.entries(e).filter((e => {
            let [, t] = e;
            return void 0 !== t
        }
        )))
    }
    class bx {
        constructor(e) {
            Kw(this, "blockSpecs"),
                Kw(this, "inlineContentSpecs"),
                Kw(this, "styleSpecs"),
                Kw(this, "blockSchema"),
                Kw(this, "inlineContentSchema"),
                Kw(this, "styleSchema"),
                Kw(this, "BlockNoteEditor", "only for types"),
                Kw(this, "Block", "only for types"),
                Kw(this, "PartialBlock", "only for types"),
                this.blockSpecs = gx(null == e ? void 0 : e.blockSpecs) || JC,
                this.inlineContentSpecs = gx(null == e ? void 0 : e.inlineContentSpecs) || QC,
                this.styleSpecs = gx(null == e ? void 0 : e.styleSpecs) || XC,
                this.blockSchema = jk(this.blockSpecs),
                this.inlineContentSchema = Wk(this.inlineContentSpecs),
                this.styleSchema = Kk(this.styleSpecs)
        }
        static create(e) {
            return new bx(e)
        }
    }
    const yx = class extends sa {
        constructor(e, t) {
            super({
                ...e,
                content: void 0
            }),
                Kw(this, "_state"),
                Kw(this, "mount", (e => {
                    e ? (this.options.element = e,
                        this.createViewAlternative()) : this.destroy()
                }
                ));
            const n = this.schema;
            let r;
            const o = n.nodes.doc.createAndFill;
            let i;
            n.nodes.doc.createAndFill = function () {
                if (r)
                    return r;
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                    t[i] = arguments[i];
                const s = o.apply(n.nodes.doc, t)
                    , a = JSON.parse(JSON.stringify(s.toJSON()));
                return a.content[0].content[0].attrs.id = "initialBlockId",
                    r = R.fromJSON(n, a),
                    r
            }
                ;
            try {
                i = Ns({
                    type: "doc",
                    content: [{
                        type: "blockGroup",
                        content: null == e ? void 0 : e.content.map((e => ck(e, this.schema, t).toJSON()))
                    }]
                }, this.schema, this.options.parseOptions)
            } catch (s) {
                throw console.error("Error creating document from blocks passed as `initialContent`. Caused by exception: ", s),
                new Error("Error creating document from blocks passed as `initialContent`:\n" + +JSON.stringify(e.content))
            }
            this._state = xt.create({
                doc: i,
                schema: this.schema
            })
        }
        get state() {
            return this.view && (this._state = this.view.state),
                this._state
        }
        dispatch(e) {
            this.view ? this.view.dispatch(e) : this._state = this.state.apply(e)
        }
        createViewAlternative() {
            queueMicrotask((() => {
                this.view = new Bo({
                    mount: this.options.element
                }, {
                    ...this.options.editorProps,
                    dispatchTransaction: this.dispatchTransaction.bind(this),
                    state: this.state
                });
                const e = this.state.reconfigure({
                    plugins: this.extensionManager.plugins
                });
                this.view.updateState(e),
                    this.createNodeViews(),
                    this.commands.focus(this.options.autofocus),
                    this.emit("create", {
                        editor: this
                    }),
                    this.isInitialized = !0
            }
            ))
        }
    }
        ;
    Kw(yx, "create", ((e, t) => {
        var n, r;
        const o = null == (n = null == globalThis ? void 0 : globalThis.window) ? void 0 : n.setTimeout;
        typeof (null == (r = null == globalThis ? void 0 : globalThis.window) ? void 0 : r.setTimeout) < "u" && (globalThis.window.setTimeout = () => 0);
        try {
            return new yx(e, t)
        } finally {
            o && (globalThis.window.setTimeout = o)
        }
    }
    ));
    let vx = yx;
    vx.prototype.createView = function () {
        this.options.onPaste = this.options.onDrop = void 0
    }
        ;
    const wx = new _t("blocknote-placeholder")
        , kx = (e, t) => new Mt({
            key: wx,
            view: () => {
                const n = document.createElement("style")
                    , r = e._tiptapEditor.options.injectNonce;
                r && n.setAttribute("nonce", r),
                    e._tiptapEditor.view.root instanceof ShadowRoot ? e._tiptapEditor.view.root.append(n) : e._tiptapEditor.view.root.head.appendChild(n);
                const o = n.sheet
                    , i = function () {
                        return `.bn-block-content${arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`
                    }
                    , s = function (e) {
                        const t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? "[data-is-empty-and-focused]" : "";
                        if ("default" === e)
                            return i(t);
                        return i(t + `[data-content-type="${e}"]`)
                    };
                for (const [e, a] of Object.entries(t)) {
                    const t = "default" === e;
                    o.insertRule(`${s(e, t)}{ content: ${JSON.stringify(a)}; }`),
                        t || o.insertRule(`${s(e, !0)}{ content: ${JSON.stringify(a)}; }`)
                }
                return {
                    destroy: () => {
                        e._tiptapEditor.view.root instanceof ShadowRoot ? e._tiptapEditor.view.root.removeChild(n) : e._tiptapEditor.view.root.head.removeChild(n)
                    }
                }
            }
            ,
            props: {
                decorations: t => {
                    const { doc: n, selection: r } = t;
                    if (!e.isEditable || !r.empty || r.$from.parent.type.spec.code)
                        return;
                    const o = r.$anchor
                        , i = o.parent;
                    if (i.content.size > 0)
                        return null;
                    const s = o.before()
                        , a = ho.node(s, s + i.nodeSize, {
                            "data-is-empty-and-focused": "true"
                        });
                    return mo.create(n, [a])
                }
            }
        })
        , Cx = new _t("node-selection-keyboard")
        , Sx = new _t("previous-blocks")
        , xx = {
            index: "index",
            level: "level",
            type: "type",
            depth: "depth",
            "depth-change": "depth-change"
        }
        , Ex = () => {
            let e;
            return new Mt({
                key: Sx,
                view(t) {
                    return {
                        update: async (t, n) => {
                            var r;
                            (null == (r = this.key) ? void 0 : r.getState(t.state).updatedBlocks.size) > 0 && (e = setTimeout((() => {
                                t.dispatch(t.state.tr.setMeta(Sx, {
                                    clearUpdate: !0
                                }))
                            }
                            ), 0))
                        }
                        ,
                        destroy: () => {
                            e && clearTimeout(e)
                        }
                    }
                },
                state: {
                    init: () => ({
                        prevTransactionOldBlockAttrs: {},
                        currentTransactionOldBlockAttrs: {},
                        updatedBlocks: new Set
                    }),
                    apply(e, t, n, r) {
                        if (t.currentTransactionOldBlockAttrs = {},
                            t.updatedBlocks.clear(),
                            !e.docChanged || n.doc.eq(r.doc))
                            return t;
                        const o = {}
                            , i = As(n.doc, (e => e.attrs.id))
                            , s = new Map(i.map((e => [e.node.attrs.id, e])))
                            , a = As(r.doc, (e => e.attrs.id));
                        for (const l of a) {
                            const i = s.get(l.node.attrs.id)
                                , a = null == i ? void 0 : i.node.firstChild
                                , c = l.node.firstChild;
                            if (i && a && c) {
                                const s = {
                                    index: c.attrs.index,
                                    level: c.attrs.level,
                                    type: c.type.name,
                                    depth: r.doc.resolve(l.pos).depth
                                };
                                let d = {
                                    index: a.attrs.index,
                                    level: a.attrs.level,
                                    type: a.type.name,
                                    depth: n.doc.resolve(i.pos).depth
                                };
                                o[l.node.attrs.id] = d,
                                    e.getMeta("numberedListIndexing") && (l.node.attrs.id in t.prevTransactionOldBlockAttrs && (d = t.prevTransactionOldBlockAttrs[l.node.attrs.id]),
                                        "numberedListItem" === s.type && (d.index = s.index)),
                                    t.currentTransactionOldBlockAttrs[l.node.attrs.id] = d,
                                    JSON.stringify(d) !== JSON.stringify(s) && (d["depth-change"] = d.depth - s.depth,
                                        t.updatedBlocks.add(l.node.attrs.id))
                            }
                        }
                        return t.prevTransactionOldBlockAttrs = o,
                            t
                    }
                },
                props: {
                    decorations(e) {
                        const t = this.getState(e);
                        if (0 === t.updatedBlocks.size)
                            return;
                        const n = [];
                        return e.doc.descendants(((e, r) => {
                            if (!e.attrs.id || !t.updatedBlocks.has(e.attrs.id))
                                return;
                            const o = t.currentTransactionOldBlockAttrs[e.attrs.id]
                                , i = {};
                            for (const [t, n] of Object.entries(o))
                                i["data-prev-" + xx[t]] = n || "none";
                            const s = ho.node(r, r + e.nodeSize, {
                                ...i
                            });
                            n.push(s)
                        }
                        )),
                            mo.create(e.doc, n)
                    }
                }
            })
        }
        , Mx = {
            enableInputRules: !0,
            enablePasteRules: !0,
            enableCoreExtensions: !1
        };
    class Tx {
        constructor(e) {
            var t, n, r, o, i, s, a;
            Kw(this, "_pmSchema"),
                Kw(this, "headless", !1),
                Kw(this, "_tiptapEditor"),
                Kw(this, "elementRenderer", null),
                Kw(this, "blockCache", new WeakMap),
                Kw(this, "dictionary"),
                Kw(this, "schema"),
                Kw(this, "blockImplementations"),
                Kw(this, "inlineContentImplementations"),
                Kw(this, "styleImplementations"),
                Kw(this, "formattingToolbar"),
                Kw(this, "linkToolbar"),
                Kw(this, "sideMenu"),
                Kw(this, "suggestionMenus"),
                Kw(this, "filePanel"),
                Kw(this, "tableHandles"),
                Kw(this, "uploadFile"),
                Kw(this, "onUploadStartCallbacks", []),
                Kw(this, "onUploadEndCallbacks", []),
                Kw(this, "resolveFileUrl"),
                Kw(this, "mount", (e => {
                    this._tiptapEditor.mount(e)
                }
                )),
                this.options = e;
            const l = e;
            if (l.onEditorContentChange)
                throw new Error("onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)");
            if (l.onTextCursorPositionChange)
                throw new Error("onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)");
            if (l.onEditorReady)
                throw new Error("onEditorReady is deprecated. Editor is immediately ready for use after creation.");
            if (l.editable)
                throw new Error("editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false");
            this.dictionary = e.dictionary || Jw;
            const c = {
                defaultStyles: !0,
                schema: e.schema || bx.create(),
                _headless: !1,
                ...e,
                placeholders: {
                    ...this.dictionary.placeholders,
                    ...e.placeholders
                }
            };
            this.schema = c.schema,
                this.blockImplementations = c.schema.blockSpecs,
                this.inlineContentImplementations = c.schema.inlineContentSpecs,
                this.styleImplementations = c.schema.styleSpecs,
                this.formattingToolbar = new SS(this),
                this.linkToolbar = new MS(this),
                this.sideMenu = new IS(this),
                this.suggestionMenus = new $S(this),
                this.filePanel = new wS(this),
                eS("table", this) && (this.tableHandles = new qS(this));
            const d = px({
                editor: this,
                domAttributes: c.domAttributes || {},
                blockSpecs: this.schema.blockSpecs,
                styleSpecs: this.schema.styleSpecs,
                inlineContentSpecs: this.schema.inlineContentSpecs,
                collaboration: c.collaboration,
                trailingBlock: c.trailingBlock,
                disableExtensions: c.disableExtensions,
                setIdAttribute: c.setIdAttribute
            })
                , u = as.create({
                    name: "BlockNoteUIExtension",
                    addProseMirrorPlugins: () => [this.formattingToolbar.plugin, this.linkToolbar.plugin, this.sideMenu.plugin, this.suggestionMenus.plugin, ...this.filePanel ? [this.filePanel.plugin] : [], ...this.tableHandles ? [this.tableHandles.plugin] : [], kx(this, c.placeholders), new Mt({
                        key: Cx,
                        props: {
                            handleKeyDown: (e, t) => {
                                if ("node" in e.state.selection) {
                                    if (t.ctrlKey || t.metaKey)
                                        return !1;
                                    if (1 === t.key.length)
                                        return t.preventDefault(),
                                            !0;
                                    if ("Enter" === t.key && !t.shiftKey && !t.altKey && !t.ctrlKey && !t.metaKey) {
                                        const t = e.state.tr;
                                        return e.dispatch(t.insert(e.state.tr.selection.$to.after(), e.state.schema.nodes.paragraph.create()).setSelection(new ut(t.doc.resolve(e.state.tr.selection.$to.after() + 1)))),
                                            !0
                                    }
                                }
                                return !1
                            }
                        }
                    }), ...this.options.animations ?? 1 ? [Ex()] : []]
                });
            if (d.push(u),
                c.uploadFile) {
                const e = c.uploadFile;
                this.uploadFile = async (t, n) => {
                    this.onUploadStartCallbacks.forEach((e => e.apply(this, [n])));
                    try {
                        return await e(t, n)
                    } finally {
                        this.onUploadEndCallbacks.forEach((e => e.apply(this, [n])))
                    }
                }
            }
            this.resolveFileUrl = c.resolveFileUrl || (async e => e),
                this.headless = c._headless,
                c.collaboration && c.initialContent && console.warn("When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider");
            const h = c.initialContent || (e.collaboration ? [{
                type: "paragraph",
                id: "initialBlockId"
            }] : [{
                type: "paragraph",
                id: Yw.options.generateID()
            }]);
            if (!Array.isArray(h) || 0 === h.length)
                throw new Error("initialContent must be a non-empty array of blocks, received: " + h);
            const p = {
                ...Mx,
                ...c._tiptapOptions,
                content: h,
                extensions: [...(null == (t = c._tiptapOptions) ? void 0 : t.extensions) || [], ...d],
                editorProps: {
                    ...null == (n = c._tiptapOptions) ? void 0 : n.editorProps,
                    attributes: {
                        tabIndex: "0",
                        ...null == (o = null == (r = c._tiptapOptions) ? void 0 : r.editorProps) ? void 0 : o.attributes,
                        ...null == (i = c.domAttributes) ? void 0 : i.editor,
                        class: Sk("bn-editor", c.defaultStyles ? "bn-default-styles" : "", (null == (a = null == (s = c.domAttributes) ? void 0 : s.editor) ? void 0 : a.class) || "")
                    },
                    transformPasted: mx
                }
            };
            this.headless ? this._pmSchema = Ds(p.extensions) : (this._tiptapEditor = vx.create(p, this.schema.styleSchema),
                this._pmSchema = this._tiptapEditor.schema)
        }
        get pmSchema() {
            return this._pmSchema
        }
        static create() {
            return new Tx(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
        }
        dispatch(e) {
            this._tiptapEditor.dispatch(e)
        }
        get prosemirrorView() {
            return this._tiptapEditor.view
        }
        get domElement() {
            return this._tiptapEditor.view.dom
        }
        isFocused() {
            return this._tiptapEditor.view.hasFocus()
        }
        focus() {
            this._tiptapEditor.view.focus()
        }
        onUploadStart(e) {
            return this.onUploadStartCallbacks.push(e),
                () => {
                    const t = this.onUploadStartCallbacks.indexOf(e);
                    t > -1 && this.onUploadStartCallbacks.splice(t, 1)
                }
        }
        onUploadEnd(e) {
            return this.onUploadEndCallbacks.push(e),
                () => {
                    const t = this.onUploadEndCallbacks.indexOf(e);
                    t > -1 && this.onUploadEndCallbacks.splice(t, 1)
                }
        }
        get topLevelBlocks() {
            return this.document
        }
        get document() {
            const e = [];
            return this._tiptapEditor.state.doc.firstChild.descendants((t => (e.push(Uk(t, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache)),
                !1))),
                e
        }
        getBlock(e) {
            const t = "string" == typeof e ? e : e.id;
            let n;
            return this._tiptapEditor.state.doc.firstChild.descendants((e => !(typeof n < "u") && ("blockContainer" !== e.type.name || e.attrs.id !== t || (n = Uk(e, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache),
                !1)))),
                n
        }
        forEachBlock(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const n = this.document.slice();
            t && n.reverse(),
                function n(r) {
                    for (const o of r) {
                        if (!1 === e(o))
                            return !1;
                        if (!n(t ? o.children.slice().reverse() : o.children))
                            return !1
                    }
                    return !0
                }(n)
        }
        onEditorContentChange(e) {
            this._tiptapEditor.on("update", e)
        }
        onEditorSelectionChange(e) {
            this._tiptapEditor.on("selectionUpdate", e)
        }
        getTextCursorPosition() {
            return function (e) {
                const { blockContainer: t } = kk(e._tiptapEditor.state)
                    , n = e._tiptapEditor.state.doc.resolve(t.beforePos)
                    , r = n.nodeBefore
                    , o = e._tiptapEditor.state.doc.resolve(t.afterPos).nodeAfter;
                let i;
                return n.depth > 1 && (i = n.node(n.depth - 1)),
                {
                    block: Uk(t.node, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache),
                    prevBlock: null === r ? void 0 : Uk(r, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache),
                    nextBlock: null === o ? void 0 : Uk(o, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache),
                    parentBlock: void 0 === i ? void 0 : Uk(i, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache)
                }
            }(this)
        }
        setTextCursorPosition(e) {
            !function (e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "start";
                const r = yC("string" == typeof t ? t : t.id, e._tiptapEditor.state.doc)
                    , { blockContent: o } = vk(r)
                    , i = e.schema.blockSchema[o.node.type.name].content;
                if ("none" !== i)
                    if ("inline" === i)
                        "start" === n ? e._tiptapEditor.commands.setTextSelection(o.beforePos + 1) : e._tiptapEditor.commands.setTextSelection(o.afterPos - 1);
                    else {
                        if ("table" !== i)
                            throw new Zw(i);
                        "start" === n ? e._tiptapEditor.commands.setTextSelection(o.beforePos + 4) : e._tiptapEditor.commands.setTextSelection(o.afterPos - 4)
                    }
                else
                    e._tiptapEditor.commands.setNodeSelection(o.beforePos)
            }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "start")
        }
        getSelection() {
            if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to || "node" in this._tiptapEditor.state.selection)
                return;
            const e = [];
            return this._tiptapEditor.state.doc.descendants(((t, n) => {
                if ("blockContent" !== t.type.spec.group)
                    return !0;
                const r = n + 1;
                return n + t.nodeSize - 1 <= this._tiptapEditor.state.selection.from || r >= this._tiptapEditor.state.selection.to || (e.push(Uk(this._tiptapEditor.state.doc.resolve(n).node(), this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache)),
                    !1)
            }
            )),
            {
                blocks: e
            }
        }
        get isEditable() {
            if (!this._tiptapEditor) {
                if (!this.headless)
                    throw new Error("no editor, but also not headless?");
                return !1
            }
            return void 0 === this._tiptapEditor.isEditable || this._tiptapEditor.isEditable
        }
        set isEditable(e) {
            if (this._tiptapEditor)
                this._tiptapEditor.options.editable !== e && this._tiptapEditor.setEditable(e);
            else if (!this.headless)
                throw new Error("no editor, but also not headless?")
        }
        insertBlocks(e, t) {
            return function (e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "before";
                const o = "string" == typeof n ? n : n.id
                    , i = [];
                for (const c of t)
                    i.push(ck(c, e.pmSchema, e.schema.styleSchema));
                const { node: s, posBeforeNode: a } = yC(o, e._tiptapEditor.state.doc);
                "before" === r && e.dispatch(e._tiptapEditor.state.tr.insert(a, i)),
                    "after" === r && e.dispatch(e._tiptapEditor.state.tr.insert(a + s.nodeSize, i));
                const l = [];
                for (const c of i)
                    l.push(Uk(c, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache));
                return l
            }(this, e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "before")
        }
        updateBlock(e, t) {
            return function (e, t, n) {
                const r = e._tiptapEditor
                    , o = "string" == typeof t ? t : t.id
                    , { posBeforeNode: i } = yC(o, r.state.doc);
                return r.commands.command((t => {
                    let { state: r, dispatch: o } = t;
                    return vC(e, i, n)({
                        state: r,
                        dispatch: o
                    }),
                        !0
                }
                )),
                    Uk(r.state.doc.resolve(i + 1).node(), e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache)
            }(this, e, t)
        }
        removeBlocks(e) {
            return function (e, t) {
                return sS(e, t)
            }(this, e)
        }
        replaceBlocks(e, t) {
            return function (e, t, n) {
                const r = [];
                for (const a of n)
                    r.push(ck(a, e.pmSchema, e.schema.styleSchema));
                const o = "string" == typeof t[0] ? t[0] : t[0].id
                    , i = sS(e, t, ((e, t, n, i) => {
                        if (e.attrs.id === o) {
                            const e = n.doc.nodeSize;
                            return n.insert(t, r),
                                i + e - n.doc.nodeSize
                        }
                        return i
                    }
                    ))
                    , s = [];
                for (const a of r)
                    s.push(Uk(a, e.schema.blockSchema, e.schema.inlineContentSchema, e.schema.styleSchema, e.blockCache));
                return {
                    insertedBlocks: s,
                    removedBlocks: i
                }
            }(this, e, t)
        }
        insertInlineContent(e) {
            const t = sk(e, this.pmSchema, this.schema.styleSchema);
            !function (e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                    updateSelection: !0
                };
                const o = n._tiptapEditor.state.tr;
                let { from: i, to: s } = "number" == typeof e ? {
                    from: e,
                    to: e
                } : {
                    from: e.from,
                    to: e.to
                }
                    , a = !0
                    , l = !0
                    , c = "";
                if (t.forEach((e => {
                    e.check(),
                        a && e.isText && 0 === e.marks.length ? c += e.text : a = !1,
                        l = !!l && e.isBlock
                }
                )),
                    i === s && l) {
                    const { parent: e } = o.doc.resolve(i);
                    e.isTextblock && !e.type.spec.code && !e.childCount && (i -= 1,
                        s += 1)
                }
                a ? o.insertText(c, i, s) : o.replaceWith(i, s, t),
                    r.updateSelection && Ss(o, o.steps.length - 1, -1),
                    n.dispatch(o)
            }({
                from: this._tiptapEditor.state.selection.from,
                to: this._tiptapEditor.state.selection.to
            }, t, this)
        }
        getActiveStyles() {
            const e = {}
                , t = this._tiptapEditor.state.selection.$to.marks();
            for (const n of t) {
                const t = this.schema.styleSchema[n.type.name];
                t ? "boolean" === t.propSchema ? e[t.type] = !0 : e[t.type] = n.attrs.stringValue : "link" !== n.type.name && console.warn("mark not found in styleschema", n.type.name)
            }
            return e
        }
        addStyles(e) {
            for (const [t, n] of Object.entries(e)) {
                const e = this.schema.styleSchema[t];
                if (!e)
                    throw new Error(`style ${t} not found in styleSchema`);
                if ("boolean" === e.propSchema)
                    this._tiptapEditor.commands.setMark(t);
                else {
                    if ("string" !== e.propSchema)
                        throw new Zw(e.propSchema);
                    this._tiptapEditor.commands.setMark(t, {
                        stringValue: n
                    })
                }
            }
        }
        removeStyles(e) {
            for (const t of Object.keys(e))
                this._tiptapEditor.commands.unsetMark(t)
        }
        toggleStyles(e) {
            for (const [t, n] of Object.entries(e)) {
                const e = this.schema.styleSchema[t];
                if (!e)
                    throw new Error(`style ${t} not found in styleSchema`);
                if ("boolean" === e.propSchema)
                    this._tiptapEditor.commands.toggleMark(t);
                else {
                    if ("string" !== e.propSchema)
                        throw new Zw(e.propSchema);
                    this._tiptapEditor.commands.toggleMark(t, {
                        stringValue: n
                    })
                }
            }
        }
        getSelectedText() {
            return this._tiptapEditor.state.doc.textBetween(this._tiptapEditor.state.selection.from, this._tiptapEditor.state.selection.to)
        }
        getSelectedLinkUrl() {
            return this._tiptapEditor.getAttributes("link").href
        }
        createLink(e, t) {
            if ("" === e)
                return;
            const { from: n, to: r } = this._tiptapEditor.state.selection;
            t || (t = this._tiptapEditor.state.doc.textBetween(n, r));
            const o = this.pmSchema.mark("link", {
                href: e
            });
            this.dispatch(this._tiptapEditor.state.tr.insertText(t, n, r).addMark(n, n + t.length, o))
        }
        canNestBlock() {
            const { blockContainer: e } = kk(this._tiptapEditor.state);
            return null !== this._tiptapEditor.state.doc.resolve(e.beforePos).nodeBefore
        }
        nestBlock() {
            this._tiptapEditor.commands.sinkListItem("blockContainer")
        }
        canUnnestBlock() {
            const { blockContainer: e } = kk(this._tiptapEditor.state);
            return this._tiptapEditor.state.doc.resolve(e.beforePos).depth > 1
        }
        unnestBlock() {
            this._tiptapEditor.commands.liftListItem("blockContainer")
        }
        moveBlockUp() {
            !function (e) {
                const t = e.getSelection();
                if (t && t.blocks.length > 1)
                    return;
                const { prevBlock: n, parentBlock: r } = e.getTextCursorPosition();
                let o, i;
                n ? n.children.length > 0 ? (o = n.children[n.children.length - 1].id,
                    i = "after") : (o = n.id,
                        i = "before") : r && (o = r.id,
                            i = "before"),
                    o && i && iS(e, o, i)
            }(this)
        }
        moveBlockDown() {
            !function (e) {
                const t = e.getSelection();
                if (t && t.blocks.length > 1)
                    return;
                const { nextBlock: n, parentBlock: r } = e.getTextCursorPosition();
                let o, i;
                n ? n.children.length > 0 ? (o = n.children[0].id,
                    i = "before") : (o = n.id,
                        i = "after") : r && (o = r.id,
                            i = "after"),
                    o && i && iS(e, o, i)
            }(this)
        }
        async blocksToHTMLLossy() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.document;
            return fk(this.pmSchema, this).exportBlocks(e, {})
        }
        async blocksToFullHTML(e) {
            return ((e, t) => {
                const n = ue.fromSchema(e);
                return {
                    serializeBlocks: (e, r) => gk(t, e, n, r).outerHTML
                }
            }
            )(this.pmSchema, this).serializeBlocks(e, {})
        }
        async tryParseHTMLToBlocks(e) {
            return mS(e, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.pmSchema)
        }
        async blocksToMarkdownLossy() {
            return async function (e, t, n, r) {
                return await lS(),
                    uS(fk(t, n).exportBlocks(e, r))
            }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.document, this.pmSchema, this, {})
        }
        async tryParseMarkdownToBlocks(e) {
            return async function (e, t, n, r, o) {
                const i = await lS();
                return mS(i.unified.unified().use(i.remarkParse.default).use(i.remarkGfm.default).use(i.remarkRehype.default, {
                    handlers: {
                        ...i.remarkRehype.defaultHandlers,
                        code: gS
                    }
                }).use(i.rehypeStringify.default).processSync(e).value, t, n, r, o)
            }(e, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.pmSchema)
        }
        updateCollaborationUserInfo(e) {
            if (!this.options.collaboration)
                throw new Error("Cannot update collaboration user info when collaboration is disabled.");
            this._tiptapEditor.commands.updateUser(e)
        }
        onChange(e) {
            if (this.headless)
                return;
            const t = () => {
                e(this)
            }
                ;
            return this._tiptapEditor.on("update", t),
                () => {
                    this._tiptapEditor.off("update", t)
                }
        }
        onSelectionChange(e) {
            if (this.headless)
                return;
            const t = () => {
                e(this)
            }
                ;
            return this._tiptapEditor.on("selectionUpdate", t),
                () => {
                    this._tiptapEditor.off("selectionUpdate", t)
                }
        }
        openSuggestionMenu(e, t) {
            const n = this.prosemirrorView.state.tr
                , r = t && t.deleteTriggerCharacter ? n.insertText(e) : n;
            this.prosemirrorView.focus(),
                this.prosemirrorView.dispatch(r.scrollIntoView().setMeta(this.suggestionMenus.plugin, {
                    triggerCharacter: e,
                    deleteTriggerCharacter: (null == t ? void 0 : t.deleteTriggerCharacter) || !1,
                    ignoreQueryLength: (null == t ? void 0 : t.ignoreQueryLength) || !1
                }))
        }
    }
    let Nx, _x;
    async function Ox(e, t) {
        if (!function (e, t) {
            return e in t.schema.inlineContentSchema && t.schema.inlineContentSchema[e] === YC[e]
        }("text", e))
            return [];
        if (!Nx) {
            Nx = n.e(410).then(n.t.bind(n, 410, 17)),
                _x = await n.e(3412).then(n.bind(n, 1031));
            const e = (await Nx).default;
            await _x.init({
                data: e
            })
        }
        const r = (await Nx).default;
        return ("" === t.trim() ? Object.values(r.emojis) : await _x.SearchIndex.search(t)).map((t => ({
            id: t.skins[0].native,
            onItemClick: () => e.insertInlineContent(t.skins[0].native + " ")
        })))
    }
    function Ax(e, t) {
        const n = e.getTextCursorPosition().block;
        if (void 0 === n.content)
            throw new Error("Slash Menu open in a block that doesn't contain content.");
        let r;
        return Array.isArray(n.content) && (1 === n.content.length && nk(n.content[0]) && "text" === n.content[0].type && "/" === n.content[0].text || 0 === n.content.length) ? (r = e.updateBlock(n, t),
            t.content && e.setTextCursorPosition(r)) : (r = e.insertBlocks([t], n, "after")[0],
                e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)),
            function (e) {
                let t = e.getTextCursorPosition().block
                    , n = e.schema.blockSchema[t.type].content;
                for (; "none" === n;)
                    t = e.getTextCursorPosition().nextBlock,
                        n = e.schema.blockSchema[t.type].content,
                        e.setTextCursorPosition(t, "end")
            }(e),
            r
    }
    function Px(e, t) {
        return e.filter((e => {
            let { title: n, aliases: r } = e;
            return n.toLowerCase().includes(t.toLowerCase()) || r && 0 !== r.filter((e => e.toLowerCase().includes(t.toLowerCase()))).length
        }
        ))
    }
    var Lx = n(579);
    function Rx() {
        return "undefined" !== typeof window
    }
    function Dx(e) {
        return Hx(e) ? (e.nodeName || "").toLowerCase() : "#document"
    }
    function Ix(e) {
        var t;
        return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
    }
    function jx(e) {
        var t;
        return null == (t = (Hx(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
    }
    function Hx(e) {
        return !!Rx() && (e instanceof Node || e instanceof Ix(e).Node)
    }
    function zx(e) {
        return !!Rx() && (e instanceof Element || e instanceof Ix(e).Element)
    }
    function $x(e) {
        return !!Rx() && (e instanceof HTMLElement || e instanceof Ix(e).HTMLElement)
    }
    function Bx(e) {
        return !(!Rx() || "undefined" === typeof ShadowRoot) && (e instanceof ShadowRoot || e instanceof Ix(e).ShadowRoot)
    }
    function Vx(e) {
        const { overflow: t, overflowX: n, overflowY: r, display: o } = Kx(e);
        return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o)
    }
    function Fx(e) {
        return ["table", "td", "th"].includes(Dx(e))
    }
    function Ux(e) {
        return [":popover-open", ":modal"].some((t => {
            try {
                return e.matches(t)
            } catch (pj) {
                return !1
            }
        }
        ))
    }
    function Wx(e) {
        const t = qx()
            , n = zx(e) ? Kx(e) : e;
        return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some((e => (n.willChange || "").includes(e))) || ["paint", "layout", "strict", "content"].some((e => (n.contain || "").includes(e)))
    }
    function qx() {
        return !("undefined" === typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
    }
    function Gx(e) {
        return ["html", "body", "#document"].includes(Dx(e))
    }
    function Kx(e) {
        return Ix(e).getComputedStyle(e)
    }
    function Jx(e) {
        return zx(e) ? {
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTop
        } : {
            scrollLeft: e.scrollX,
            scrollTop: e.scrollY
        }
    }
    function Zx(e) {
        if ("html" === Dx(e))
            return e;
        const t = e.assignedSlot || e.parentNode || Bx(e) && e.host || jx(e);
        return Bx(t) ? t.host : t
    }
    function Xx(e) {
        const t = Zx(e);
        return Gx(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : $x(t) && Vx(t) ? t : Xx(t)
    }
    function Qx(e, t, n) {
        var r;
        void 0 === t && (t = []),
            void 0 === n && (n = !0);
        const o = Xx(e)
            , i = o === (null == (r = e.ownerDocument) ? void 0 : r.body)
            , s = Ix(o);
        if (i) {
            const e = Yx(s);
            return t.concat(s, s.visualViewport || [], Vx(o) ? o : [], e && n ? Qx(e) : [])
        }
        return t.concat(o, Qx(o, [], n))
    }
    function Yx(e) {
        return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
    }
    function eE(e) {
        let t = e.activeElement;
        for (; null != (null == (n = t) || null == (n = n.shadowRoot) ? void 0 : n.activeElement);) {
            var n;
            t = t.shadowRoot.activeElement
        }
        return t
    }
    function tE(e, t) {
        if (!e || !t)
            return !1;
        const n = null == t.getRootNode ? void 0 : t.getRootNode();
        if (e.contains(t))
            return !0;
        if (n && Bx(n)) {
            let n = t;
            for (; n;) {
                if (e === n)
                    return !0;
                n = n.parentNode || n.host
            }
        }
        return !1
    }
    function nE() {
        const e = navigator.userAgentData;
        return null != e && e.platform ? e.platform : navigator.platform
    }
    function rE() {
        const e = navigator.userAgentData;
        return e && Array.isArray(e.brands) ? e.brands.map((e => {
            let { brand: t, version: n } = e;
            return t + "/" + n
        }
        )).join(" ") : navigator.userAgent
    }
    function oE(e) {
        return !rE().includes("jsdom/") && (!sE() && 0 === e.width && 0 === e.height || sE() && 1 === e.width && 1 === e.height && 0 === e.pressure && 0 === e.detail && "mouse" === e.pointerType || e.width < 1 && e.height < 1 && 0 === e.pressure && 0 === e.detail && "touch" === e.pointerType)
    }
    function iE() {
        return /apple/i.test(navigator.vendor)
    }
    function sE() {
        const e = /android/i;
        return e.test(nE()) || e.test(rE())
    }
    function aE(e, t) {
        const n = ["mouse", "pen"];
        return t || n.push("", void 0),
            n.includes(e)
    }
    function lE(e) {
        return (null == e ? void 0 : e.ownerDocument) || document
    }
    function cE(e, t) {
        if (null == t)
            return !1;
        if ("composedPath" in e)
            return e.composedPath().includes(t);
        const n = e;
        return null != n.target && t.contains(n.target)
    }
    function dE(e) {
        return "composedPath" in e ? e.composedPath()[0] : e.target
    }
    function uE(e) {
        return $x(e) && e.matches("input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])")
    }
    var hE = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"]
        , pE = hE.join(",")
        , fE = "undefined" === typeof Element
        , mE = fE ? function () { }
            : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector
        , gE = !fE && Element.prototype.getRootNode ? function (e) {
            var t;
            return null === e || void 0 === e || null === (t = e.getRootNode) || void 0 === t ? void 0 : t.call(e)
        }
            : function (e) {
                return null === e || void 0 === e ? void 0 : e.ownerDocument
            }
        , bE = function e(t, n) {
            var r;
            void 0 === n && (n = !0);
            var o = null === t || void 0 === t || null === (r = t.getAttribute) || void 0 === r ? void 0 : r.call(t, "inert");
            return "" === o || "true" === o || n && t && e(t.parentNode)
        }
        , yE = function (e, t, n) {
            if (bE(e))
                return [];
            var r = Array.prototype.slice.apply(e.querySelectorAll(pE));
            return t && mE.call(e, pE) && r.unshift(e),
                r = r.filter(n)
        }
        , vE = function e(t, n, r) {
            for (var o = [], i = Array.from(t); i.length;) {
                var s = i.shift();
                if (!bE(s, !1))
                    if ("SLOT" === s.tagName) {
                        var a = s.assignedElements()
                            , l = e(a.length ? a : s.children, !0, r);
                        r.flatten ? o.push.apply(o, l) : o.push({
                            scopeParent: s,
                            candidates: l
                        })
                    } else {
                        mE.call(s, pE) && r.filter(s) && (n || !t.includes(s)) && o.push(s);
                        var c = s.shadowRoot || "function" === typeof r.getShadowRoot && r.getShadowRoot(s)
                            , d = !bE(c, !1) && (!r.shadowRootFilter || r.shadowRootFilter(s));
                        if (c && d) {
                            var u = e(!0 === c ? s.children : c.children, !0, r);
                            r.flatten ? o.push.apply(o, u) : o.push({
                                scopeParent: s,
                                candidates: u
                            })
                        } else
                            i.unshift.apply(i, s.children)
                    }
            }
            return o
        }
        , wE = function (e) {
            return !isNaN(parseInt(e.getAttribute("tabindex"), 10))
        }
        , kE = function (e) {
            if (!e)
                throw new Error("No node provided");
            return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || function (e) {
                var t, n = null === e || void 0 === e || null === (t = e.getAttribute) || void 0 === t ? void 0 : t.call(e, "contenteditable");
                return "" === n || "true" === n
            }(e)) && !wE(e) ? 0 : e.tabIndex
        }
        , CE = function (e, t) {
            return e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex
        }
        , SE = function (e) {
            return "INPUT" === e.tagName
        }
        , xE = function (e) {
            return function (e) {
                return SE(e) && "radio" === e.type
            }(e) && !function (e) {
                if (!e.name)
                    return !0;
                var t, n = e.form || gE(e), r = function (e) {
                    return n.querySelectorAll('input[type="radio"][name="' + e + '"]')
                };
                if ("undefined" !== typeof window && "undefined" !== typeof window.CSS && "function" === typeof window.CSS.escape)
                    t = r(window.CSS.escape(e.name));
                else
                    try {
                        t = r(e.name)
                    } catch (i) {
                        return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", i.message),
                            !1
                    }
                var o = function (e, t) {
                    for (var n = 0; n < e.length; n++)
                        if (e[n].checked && e[n].form === t)
                            return e[n]
                }(t, e.form);
                return !o || o === e
            }(e)
        }
        , EE = function (e) {
            var t = e.getBoundingClientRect()
                , n = t.width
                , r = t.height;
            return 0 === n && 0 === r
        }
        , ME = function (e, t) {
            var n = t.displayCheck
                , r = t.getShadowRoot;
            if ("hidden" === getComputedStyle(e).visibility)
                return !0;
            var o = mE.call(e, "details>summary:first-of-type") ? e.parentElement : e;
            if (mE.call(o, "details:not([open]) *"))
                return !0;
            if (n && "full" !== n && "legacy-full" !== n) {
                if ("non-zero-area" === n)
                    return EE(e)
            } else {
                if ("function" === typeof r) {
                    for (var i = e; e;) {
                        var s = e.parentElement
                            , a = gE(e);
                        if (s && !s.shadowRoot && !0 === r(s))
                            return EE(e);
                        e = e.assignedSlot ? e.assignedSlot : s || a === e.ownerDocument ? s : a.host
                    }
                    e = i
                }
                if (function (e) {
                    var t, n, r, o, i = e && gE(e), s = null === (t = i) || void 0 === t ? void 0 : t.host, a = !1;
                    if (i && i !== e)
                        for (a = !!(null !== (n = s) && void 0 !== n && null !== (r = n.ownerDocument) && void 0 !== r && r.contains(s) || null !== e && void 0 !== e && null !== (o = e.ownerDocument) && void 0 !== o && o.contains(e)); !a && s;) {
                            var l, c, d;
                            a = !(null === (c = s = null === (l = i = gE(s)) || void 0 === l ? void 0 : l.host) || void 0 === c || null === (d = c.ownerDocument) || void 0 === d || !d.contains(s))
                        }
                    return a
                }(e))
                    return !e.getClientRects().length;
                if ("legacy-full" !== n)
                    return !0
            }
            return !1
        }
        , TE = function (e, t) {
            return !(t.disabled || bE(t) || function (e) {
                return SE(e) && "hidden" === e.type
            }(t) || ME(t, e) || function (e) {
                return "DETAILS" === e.tagName && Array.prototype.slice.apply(e.children).some((function (e) {
                    return "SUMMARY" === e.tagName
                }
                ))
            }(t) || function (e) {
                if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
                    for (var t = e.parentElement; t;) {
                        if ("FIELDSET" === t.tagName && t.disabled) {
                            for (var n = 0; n < t.children.length; n++) {
                                var r = t.children.item(n);
                                if ("LEGEND" === r.tagName)
                                    return !!mE.call(t, "fieldset[disabled] *") || !r.contains(e)
                            }
                            return !0
                        }
                        t = t.parentElement
                    }
                return !1
            }(t))
        }
        , NE = function (e, t) {
            return !(xE(t) || kE(t) < 0 || !TE(e, t))
        }
        , _E = function (e) {
            var t = parseInt(e.getAttribute("tabindex"), 10);
            return !!(isNaN(t) || t >= 0)
        }
        , OE = function e(t) {
            var n = []
                , r = [];
            return t.forEach((function (t, o) {
                var i = !!t.scopeParent
                    , s = i ? t.scopeParent : t
                    , a = function (e, t) {
                        var n = kE(e);
                        return n < 0 && t && !wE(e) ? 0 : n
                    }(s, i)
                    , l = i ? e(t.candidates) : s;
                0 === a ? i ? n.push.apply(n, l) : n.push(s) : r.push({
                    documentOrder: o,
                    tabIndex: a,
                    item: t,
                    isScope: i,
                    content: l
                })
            }
            )),
                r.sort(CE).reduce((function (e, t) {
                    return t.isScope ? e.push.apply(e, t.content) : e.push(t.content),
                        e
                }
                ), []).concat(n)
        }
        , AE = function (e, t) {
            var n;
            return n = (t = t || {}).getShadowRoot ? vE([e], t.includeContainer, {
                filter: NE.bind(null, t),
                flatten: !1,
                getShadowRoot: t.getShadowRoot,
                shadowRootFilter: _E
            }) : yE(e, t.includeContainer, NE.bind(null, t)),
                OE(n)
        }
        , PE = n(7950);
    const LE = Math.min
        , RE = Math.max
        , DE = Math.round
        , IE = Math.floor
        , jE = e => ({
            x: e,
            y: e
        })
        , HE = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        }
        , zE = {
            start: "end",
            end: "start"
        };
    function $E(e, t, n) {
        return RE(e, LE(t, n))
    }
    function BE(e, t) {
        return "function" === typeof e ? e(t) : e
    }
    function VE(e) {
        return e.split("-")[0]
    }
    function FE(e) {
        return e.split("-")[1]
    }
    function UE(e) {
        return "x" === e ? "y" : "x"
    }
    function WE(e) {
        return "y" === e ? "height" : "width"
    }
    function qE(e) {
        return ["top", "bottom"].includes(VE(e)) ? "y" : "x"
    }
    function GE(e) {
        return UE(qE(e))
    }
    function KE(e) {
        return e.replace(/start|end/g, (e => zE[e]))
    }
    function JE(e) {
        return e.replace(/left|right|bottom|top/g, (e => HE[e]))
    }
    function ZE(e) {
        return "number" !== typeof e ? function (e) {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                ...e
            }
        }(e) : {
            top: e,
            right: e,
            bottom: e,
            left: e
        }
    }
    function XE(e) {
        const { x: t, y: n, width: r, height: o } = e;
        return {
            width: r,
            height: o,
            top: n,
            left: t,
            right: t + r,
            bottom: n + o,
            x: t,
            y: n
        }
    }
    function QE(e, t, n) {
        let { reference: r, floating: o } = e;
        const i = qE(t)
            , s = GE(t)
            , a = WE(s)
            , l = VE(t)
            , c = "y" === i
            , d = r.x + r.width / 2 - o.width / 2
            , u = r.y + r.height / 2 - o.height / 2
            , h = r[a] / 2 - o[a] / 2;
        let p;
        switch (l) {
            case "top":
                p = {
                    x: d,
                    y: r.y - o.height
                };
                break;
            case "bottom":
                p = {
                    x: d,
                    y: r.y + r.height
                };
                break;
            case "right":
                p = {
                    x: r.x + r.width,
                    y: u
                };
                break;
            case "left":
                p = {
                    x: r.x - o.width,
                    y: u
                };
                break;
            default:
                p = {
                    x: r.x,
                    y: r.y
                }
        }
        switch (FE(t)) {
            case "start":
                p[s] -= h * (n && c ? -1 : 1);
                break;
            case "end":
                p[s] += h * (n && c ? -1 : 1)
        }
        return p
    }
    async function YE(e, t) {
        var n;
        void 0 === t && (t = {});
        const { x: r, y: o, platform: i, rects: s, elements: a, strategy: l } = e
            , { boundary: c = "clippingAncestors", rootBoundary: d = "viewport", elementContext: u = "floating", altBoundary: h = !1, padding: p = 0 } = BE(t, e)
            , f = ZE(p)
            , m = a[h ? "floating" === u ? "reference" : "floating" : u]
            , g = XE(await i.getClippingRect({
                element: null == (n = await (null == i.isElement ? void 0 : i.isElement(m))) || n ? m : m.contextElement || await (null == i.getDocumentElement ? void 0 : i.getDocumentElement(a.floating)),
                boundary: c,
                rootBoundary: d,
                strategy: l
            }))
            , b = "floating" === u ? {
                x: r,
                y: o,
                width: s.floating.width,
                height: s.floating.height
            } : s.reference
            , y = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(a.floating))
            , v = await (null == i.isElement ? void 0 : i.isElement(y)) && await (null == i.getScale ? void 0 : i.getScale(y)) || {
                x: 1,
                y: 1
            }
            , w = XE(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
                elements: a,
                rect: b,
                offsetParent: y,
                strategy: l
            }) : b);
        return {
            top: (g.top - w.top + f.top) / v.y,
            bottom: (w.bottom - g.bottom + f.bottom) / v.y,
            left: (g.left - w.left + f.left) / v.x,
            right: (w.right - g.right + f.right) / v.x
        }
    }
    function eM(e) {
        const t = LE(...e.map((e => e.left)))
            , n = LE(...e.map((e => e.top)));
        return {
            x: t,
            y: n,
            width: RE(...e.map((e => e.right))) - t,
            height: RE(...e.map((e => e.bottom))) - n
        }
    }
    function tM(e) {
        const t = Kx(e);
        let n = parseFloat(t.width) || 0
            , r = parseFloat(t.height) || 0;
        const o = $x(e)
            , i = o ? e.offsetWidth : n
            , s = o ? e.offsetHeight : r
            , a = DE(n) !== i || DE(r) !== s;
        return a && (n = i,
            r = s),
        {
            width: n,
            height: r,
            $: a
        }
    }
    function nM(e) {
        return zx(e) ? e : e.contextElement
    }
    function rM(e) {
        const t = nM(e);
        if (!$x(t))
            return jE(1);
        const n = t.getBoundingClientRect()
            , { width: r, height: o, $: i } = tM(t);
        let s = (i ? DE(n.width) : n.width) / r
            , a = (i ? DE(n.height) : n.height) / o;
        return s && Number.isFinite(s) || (s = 1),
            a && Number.isFinite(a) || (a = 1),
        {
            x: s,
            y: a
        }
    }
    const oM = jE(0);
    function iM(e) {
        const t = Ix(e);
        return qx() && t.visualViewport ? {
            x: t.visualViewport.offsetLeft,
            y: t.visualViewport.offsetTop
        } : oM
    }
    function sM(e, t, n, r) {
        void 0 === t && (t = !1),
            void 0 === n && (n = !1);
        const o = e.getBoundingClientRect()
            , i = nM(e);
        let s = jE(1);
        t && (r ? zx(r) && (s = rM(r)) : s = rM(e));
        const a = function (e, t, n) {
            return void 0 === t && (t = !1),
                !(!n || t && n !== Ix(e)) && t
        }(i, n, r) ? iM(i) : jE(0);
        let l = (o.left + a.x) / s.x
            , c = (o.top + a.y) / s.y
            , d = o.width / s.x
            , u = o.height / s.y;
        if (i) {
            const e = Ix(i)
                , t = r && zx(r) ? Ix(r) : r;
            let n = e
                , o = Yx(n);
            for (; o && r && t !== n;) {
                const e = rM(o)
                    , t = o.getBoundingClientRect()
                    , r = Kx(o)
                    , i = t.left + (o.clientLeft + parseFloat(r.paddingLeft)) * e.x
                    , s = t.top + (o.clientTop + parseFloat(r.paddingTop)) * e.y;
                l *= e.x,
                    c *= e.y,
                    d *= e.x,
                    u *= e.y,
                    l += i,
                    c += s,
                    n = Ix(o),
                    o = Yx(n)
            }
        }
        return XE({
            width: d,
            height: u,
            x: l,
            y: c
        })
    }
    function aM(e, t) {
        const n = Jx(e).scrollLeft;
        return t ? t.left + n : sM(jx(e)).left + n
    }
    function lM(e, t, n) {
        void 0 === n && (n = !1);
        const r = e.getBoundingClientRect();
        return {
            x: r.left + t.scrollLeft - (n ? 0 : aM(e, r)),
            y: r.top + t.scrollTop
        }
    }
    function cM(e, t, n) {
        let r;
        if ("viewport" === t)
            r = function (e, t) {
                const n = Ix(e)
                    , r = jx(e)
                    , o = n.visualViewport;
                let i = r.clientWidth
                    , s = r.clientHeight
                    , a = 0
                    , l = 0;
                if (o) {
                    i = o.width,
                        s = o.height;
                    const e = qx();
                    (!e || e && "fixed" === t) && (a = o.offsetLeft,
                        l = o.offsetTop)
                }
                return {
                    width: i,
                    height: s,
                    x: a,
                    y: l
                }
            }(e, n);
        else if ("document" === t)
            r = function (e) {
                const t = jx(e)
                    , n = Jx(e)
                    , r = e.ownerDocument.body
                    , o = RE(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth)
                    , i = RE(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
                let s = -n.scrollLeft + aM(e);
                const a = -n.scrollTop;
                return "rtl" === Kx(r).direction && (s += RE(t.clientWidth, r.clientWidth) - o),
                {
                    width: o,
                    height: i,
                    x: s,
                    y: a
                }
            }(jx(e));
        else if (zx(t))
            r = function (e, t) {
                const n = sM(e, !0, "fixed" === t)
                    , r = n.top + e.clientTop
                    , o = n.left + e.clientLeft
                    , i = $x(e) ? rM(e) : jE(1);
                return {
                    width: e.clientWidth * i.x,
                    height: e.clientHeight * i.y,
                    x: o * i.x,
                    y: r * i.y
                }
            }(t, n);
        else {
            const n = iM(e);
            r = {
                x: t.x - n.x,
                y: t.y - n.y,
                width: t.width,
                height: t.height
            }
        }
        return XE(r)
    }
    function dM(e, t) {
        const n = Zx(e);
        return !(n === t || !zx(n) || Gx(n)) && ("fixed" === Kx(n).position || dM(n, t))
    }
    function uM(e, t, n) {
        const r = $x(t)
            , o = jx(t)
            , i = "fixed" === n
            , s = sM(e, !0, i, t);
        let a = {
            scrollLeft: 0,
            scrollTop: 0
        };
        const l = jE(0);
        if (r || !r && !i)
            if (("body" !== Dx(t) || Vx(o)) && (a = Jx(t)),
                r) {
                const e = sM(t, !0, i, t);
                l.x = e.x + t.clientLeft,
                    l.y = e.y + t.clientTop
            } else
                o && (l.x = aM(o));
        const c = !o || r || i ? jE(0) : lM(o, a);
        return {
            x: s.left + a.scrollLeft - l.x - c.x,
            y: s.top + a.scrollTop - l.y - c.y,
            width: s.width,
            height: s.height
        }
    }
    function hM(e) {
        return "static" === Kx(e).position
    }
    function pM(e, t) {
        if (!$x(e) || "fixed" === Kx(e).position)
            return null;
        if (t)
            return t(e);
        let n = e.offsetParent;
        return jx(e) === n && (n = n.ownerDocument.body),
            n
    }
    function fM(e, t) {
        const n = Ix(e);
        if (Ux(e))
            return n;
        if (!$x(e)) {
            let t = Zx(e);
            for (; t && !Gx(t);) {
                if (zx(t) && !hM(t))
                    return t;
                t = Zx(t)
            }
            return n
        }
        let r = pM(e, t);
        for (; r && Fx(r) && hM(r);)
            r = pM(r, t);
        return r && Gx(r) && hM(r) && !Wx(r) ? n : r || function (e) {
            let t = Zx(e);
            for (; $x(t) && !Gx(t);) {
                if (Wx(t))
                    return t;
                if (Ux(t))
                    return null;
                t = Zx(t)
            }
            return null
        }(e) || n
    }
    const mM = {
        convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
            let { elements: t, rect: n, offsetParent: r, strategy: o } = e;
            const i = "fixed" === o
                , s = jx(r)
                , a = !!t && Ux(t.floating);
            if (r === s || a && i)
                return n;
            let l = {
                scrollLeft: 0,
                scrollTop: 0
            }
                , c = jE(1);
            const d = jE(0)
                , u = $x(r);
            if ((u || !u && !i) && (("body" !== Dx(r) || Vx(s)) && (l = Jx(r)),
                $x(r))) {
                const e = sM(r);
                c = rM(r),
                    d.x = e.x + r.clientLeft,
                    d.y = e.y + r.clientTop
            }
            const h = !s || u || i ? jE(0) : lM(s, l, !0);
            return {
                width: n.width * c.x,
                height: n.height * c.y,
                x: n.x * c.x - l.scrollLeft * c.x + d.x + h.x,
                y: n.y * c.y - l.scrollTop * c.y + d.y + h.y
            }
        },
        getDocumentElement: jx,
        getClippingRect: function (e) {
            let { element: t, boundary: n, rootBoundary: r, strategy: o } = e;
            const i = "clippingAncestors" === n ? Ux(t) ? [] : function (e, t) {
                const n = t.get(e);
                if (n)
                    return n;
                let r = Qx(e, [], !1).filter((e => zx(e) && "body" !== Dx(e)))
                    , o = null;
                const i = "fixed" === Kx(e).position;
                let s = i ? Zx(e) : e;
                for (; zx(s) && !Gx(s);) {
                    const t = Kx(s)
                        , n = Wx(s);
                    n || "fixed" !== t.position || (o = null),
                        (i ? !n && !o : !n && "static" === t.position && o && ["absolute", "fixed"].includes(o.position) || Vx(s) && !n && dM(e, s)) ? r = r.filter((e => e !== s)) : o = t,
                        s = Zx(s)
                }
                return t.set(e, r),
                    r
            }(t, this._c) : [].concat(n)
                , s = [...i, r]
                , a = s[0]
                , l = s.reduce(((e, n) => {
                    const r = cM(t, n, o);
                    return e.top = RE(r.top, e.top),
                        e.right = LE(r.right, e.right),
                        e.bottom = LE(r.bottom, e.bottom),
                        e.left = RE(r.left, e.left),
                        e
                }
                ), cM(t, a, o));
            return {
                width: l.right - l.left,
                height: l.bottom - l.top,
                x: l.left,
                y: l.top
            }
        },
        getOffsetParent: fM,
        getElementRects: async function (e) {
            const t = this.getOffsetParent || fM
                , n = this.getDimensions
                , r = await n(e.floating);
            return {
                reference: uM(e.reference, await t(e.floating), e.strategy),
                floating: {
                    x: 0,
                    y: 0,
                    width: r.width,
                    height: r.height
                }
            }
        },
        getClientRects: function (e) {
            return Array.from(e.getClientRects())
        },
        getDimensions: function (e) {
            const { width: t, height: n } = tM(e);
            return {
                width: t,
                height: n
            }
        },
        getScale: rM,
        isElement: zx,
        isRTL: function (e) {
            return "rtl" === Kx(e).direction
        }
    };
    function gM(e, t, n, r) {
        void 0 === r && (r = {});
        const { ancestorScroll: o = !0, ancestorResize: i = !0, elementResize: s = "function" === typeof ResizeObserver, layoutShift: a = "function" === typeof IntersectionObserver, animationFrame: l = !1 } = r
            , c = nM(e)
            , d = o || i ? [...c ? Qx(c) : [], ...Qx(t)] : [];
        d.forEach((e => {
            o && e.addEventListener("scroll", n, {
                passive: !0
            }),
                i && e.addEventListener("resize", n)
        }
        ));
        const u = c && a ? function (e, t) {
            let n, r = null;
            const o = jx(e);
            function i() {
                var e;
                clearTimeout(n),
                    null == (e = r) || e.disconnect(),
                    r = null
            }
            return function s(a, l) {
                void 0 === a && (a = !1),
                    void 0 === l && (l = 1),
                    i();
                const { left: c, top: d, width: u, height: h } = e.getBoundingClientRect();
                if (a || t(),
                    !u || !h)
                    return;
                const p = {
                    rootMargin: -IE(d) + "px " + -IE(o.clientWidth - (c + u)) + "px " + -IE(o.clientHeight - (d + h)) + "px " + -IE(c) + "px",
                    threshold: RE(0, LE(1, l)) || 1
                };
                let f = !0;
                function m(e) {
                    const t = e[0].intersectionRatio;
                    if (t !== l) {
                        if (!f)
                            return s();
                        t ? s(!1, t) : n = setTimeout((() => {
                            s(!1, 1e-7)
                        }
                        ), 1e3)
                    }
                    f = !1
                }
                try {
                    r = new IntersectionObserver(m, {
                        ...p,
                        root: o.ownerDocument
                    })
                } catch (pj) {
                    r = new IntersectionObserver(m, p)
                }
                r.observe(e)
            }(!0),
                i
        }(c, n) : null;
        let h, p = -1, f = null;
        s && (f = new ResizeObserver((e => {
            let [r] = e;
            r && r.target === c && f && (f.unobserve(t),
                cancelAnimationFrame(p),
                p = requestAnimationFrame((() => {
                    var e;
                    null == (e = f) || e.observe(t)
                }
                ))),
                n()
        }
        )),
            c && !l && f.observe(c),
            f.observe(t));
        let m = l ? sM(e) : null;
        return l && function t() {
            const r = sM(e);
            !m || r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height || n();
            m = r,
                h = requestAnimationFrame(t)
        }(),
            n(),
            () => {
                var e;
                d.forEach((e => {
                    o && e.removeEventListener("scroll", n),
                        i && e.removeEventListener("resize", n)
                }
                )),
                    null == u || u(),
                    null == (e = f) || e.disconnect(),
                    f = null,
                    l && cancelAnimationFrame(h)
            }
    }
    const bM = function (e) {
        return void 0 === e && (e = 0),
        {
            name: "offset",
            options: e,
            async fn(t) {
                var n, r;
                const { x: o, y: i, placement: s, middlewareData: a } = t
                    , l = await async function (e, t) {
                        const { placement: n, platform: r, elements: o } = e
                            , i = await (null == r.isRTL ? void 0 : r.isRTL(o.floating))
                            , s = VE(n)
                            , a = FE(n)
                            , l = "y" === qE(n)
                            , c = ["left", "top"].includes(s) ? -1 : 1
                            , d = i && l ? -1 : 1
                            , u = BE(t, e);
                        let { mainAxis: h, crossAxis: p, alignmentAxis: f } = "number" === typeof u ? {
                            mainAxis: u,
                            crossAxis: 0,
                            alignmentAxis: null
                        } : {
                            mainAxis: u.mainAxis || 0,
                            crossAxis: u.crossAxis || 0,
                            alignmentAxis: u.alignmentAxis
                        };
                        return a && "number" === typeof f && (p = "end" === a ? -1 * f : f),
                            l ? {
                                x: p * d,
                                y: h * c
                            } : {
                                x: h * c,
                                y: p * d
                            }
                    }(t, e);
                return s === (null == (n = a.offset) ? void 0 : n.placement) && null != (r = a.arrow) && r.alignmentOffset ? {} : {
                    x: o + l.x,
                    y: i + l.y,
                    data: {
                        ...l,
                        placement: s
                    }
                }
            }
        }
    }
        , yM = function (e) {
            return void 0 === e && (e = {}),
            {
                name: "shift",
                options: e,
                async fn(t) {
                    const { x: n, y: r, placement: o } = t
                        , { mainAxis: i = !0, crossAxis: s = !1, limiter: a = {
                            fn: e => {
                                let { x: t, y: n } = e;
                                return {
                                    x: t,
                                    y: n
                                }
                            }
                        }, ...l } = BE(e, t)
                        , c = {
                            x: n,
                            y: r
                        }
                        , d = await YE(t, l)
                        , u = qE(VE(o))
                        , h = UE(u);
                    let p = c[h]
                        , f = c[u];
                    if (i) {
                        const e = "y" === h ? "bottom" : "right";
                        p = $E(p + d["y" === h ? "top" : "left"], p, p - d[e])
                    }
                    if (s) {
                        const e = "y" === u ? "bottom" : "right";
                        f = $E(f + d["y" === u ? "top" : "left"], f, f - d[e])
                    }
                    const m = a.fn({
                        ...t,
                        [h]: p,
                        [u]: f
                    });
                    return {
                        ...m,
                        data: {
                            x: m.x - n,
                            y: m.y - r,
                            enabled: {
                                [h]: i,
                                [u]: s
                            }
                        }
                    }
                }
            }
        }
        , vM = function (e) {
            return void 0 === e && (e = {}),
            {
                name: "flip",
                options: e,
                async fn(t) {
                    var n, r;
                    const { placement: o, middlewareData: i, rects: s, initialPlacement: a, platform: l, elements: c } = t
                        , { mainAxis: d = !0, crossAxis: u = !0, fallbackPlacements: h, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: f = "none", flipAlignment: m = !0, ...g } = BE(e, t);
                    if (null != (n = i.arrow) && n.alignmentOffset)
                        return {};
                    const b = VE(o)
                        , y = qE(a)
                        , v = VE(a) === a
                        , w = await (null == l.isRTL ? void 0 : l.isRTL(c.floating))
                        , k = h || (v || !m ? [JE(a)] : function (e) {
                            const t = JE(e);
                            return [KE(e), t, KE(t)]
                        }(a))
                        , C = "none" !== f;
                    !h && C && k.push(...function (e, t, n, r) {
                        const o = FE(e);
                        let i = function (e, t, n) {
                            const r = ["left", "right"]
                                , o = ["right", "left"]
                                , i = ["top", "bottom"]
                                , s = ["bottom", "top"];
                            switch (e) {
                                case "top":
                                case "bottom":
                                    return n ? t ? o : r : t ? r : o;
                                case "left":
                                case "right":
                                    return t ? i : s;
                                default:
                                    return []
                            }
                        }(VE(e), "start" === n, r);
                        return o && (i = i.map((e => e + "-" + o)),
                            t && (i = i.concat(i.map(KE)))),
                            i
                    }(a, m, f, w));
                    const S = [a, ...k]
                        , x = await YE(t, g)
                        , E = [];
                    let M = (null == (r = i.flip) ? void 0 : r.overflows) || [];
                    if (d && E.push(x[b]),
                        u) {
                        const e = function (e, t, n) {
                            void 0 === n && (n = !1);
                            const r = FE(e)
                                , o = GE(e)
                                , i = WE(o);
                            let s = "x" === o ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top";
                            return t.reference[i] > t.floating[i] && (s = JE(s)),
                                [s, JE(s)]
                        }(o, s, w);
                        E.push(x[e[0]], x[e[1]])
                    }
                    if (M = [...M, {
                        placement: o,
                        overflows: E
                    }],
                        !E.every((e => e <= 0))) {
                        var T, N;
                        const e = ((null == (T = i.flip) ? void 0 : T.index) || 0) + 1
                            , t = S[e];
                        if (t)
                            return {
                                data: {
                                    index: e,
                                    overflows: M
                                },
                                reset: {
                                    placement: t
                                }
                            };
                        let n = null == (N = M.filter((e => e.overflows[0] <= 0)).sort(((e, t) => e.overflows[1] - t.overflows[1]))[0]) ? void 0 : N.placement;
                        if (!n)
                            switch (p) {
                                case "bestFit":
                                    {
                                        var _;
                                        const e = null == (_ = M.filter((e => {
                                            if (C) {
                                                const t = qE(e.placement);
                                                return t === y || "y" === t
                                            }
                                            return !0
                                        }
                                        )).map((e => [e.placement, e.overflows.filter((e => e > 0)).reduce(((e, t) => e + t), 0)])).sort(((e, t) => e[1] - t[1]))[0]) ? void 0 : _[0];
                                        e && (n = e);
                                        break
                                    }
                                case "initialPlacement":
                                    n = a
                            }
                        if (o !== n)
                            return {
                                reset: {
                                    placement: n
                                }
                            }
                    }
                    return {}
                }
            }
        }
        , wM = function (e) {
            return void 0 === e && (e = {}),
            {
                name: "size",
                options: e,
                async fn(t) {
                    var n, r;
                    const { placement: o, rects: i, platform: s, elements: a } = t
                        , { apply: l = () => { }
                            , ...c } = BE(e, t)
                        , d = await YE(t, c)
                        , u = VE(o)
                        , h = FE(o)
                        , p = "y" === qE(o)
                        , { width: f, height: m } = i.floating;
                    let g, b;
                    "top" === u || "bottom" === u ? (g = u,
                        b = h === (await (null == s.isRTL ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (b = u,
                            g = "end" === h ? "top" : "bottom");
                    const y = m - d.top - d.bottom
                        , v = f - d.left - d.right
                        , w = LE(m - d[g], y)
                        , k = LE(f - d[b], v)
                        , C = !t.middlewareData.shift;
                    let S = w
                        , x = k;
                    if (null != (n = t.middlewareData.shift) && n.enabled.x && (x = v),
                        null != (r = t.middlewareData.shift) && r.enabled.y && (S = y),
                        C && !h) {
                        const e = RE(d.left, 0)
                            , t = RE(d.right, 0)
                            , n = RE(d.top, 0)
                            , r = RE(d.bottom, 0);
                        p ? x = f - 2 * (0 !== e || 0 !== t ? e + t : RE(d.left, d.right)) : S = m - 2 * (0 !== n || 0 !== r ? n + r : RE(d.top, d.bottom))
                    }
                    await l({
                        ...t,
                        availableWidth: x,
                        availableHeight: S
                    });
                    const E = await s.getDimensions(a.floating);
                    return f !== E.width || m !== E.height ? {
                        reset: {
                            rects: !0
                        }
                    } : {}
                }
            }
        }
        , kM = e => ({
            name: "arrow",
            options: e,
            async fn(t) {
                const { x: n, y: r, placement: o, rects: i, platform: s, elements: a, middlewareData: l } = t
                    , { element: c, padding: d = 0 } = BE(e, t) || {};
                if (null == c)
                    return {};
                const u = ZE(d)
                    , h = {
                        x: n,
                        y: r
                    }
                    , p = GE(o)
                    , f = WE(p)
                    , m = await s.getDimensions(c)
                    , g = "y" === p
                    , b = g ? "top" : "left"
                    , y = g ? "bottom" : "right"
                    , v = g ? "clientHeight" : "clientWidth"
                    , w = i.reference[f] + i.reference[p] - h[p] - i.floating[f]
                    , k = h[p] - i.reference[p]
                    , C = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(c));
                let S = C ? C[v] : 0;
                S && await (null == s.isElement ? void 0 : s.isElement(C)) || (S = a.floating[v] || i.floating[f]);
                const x = w / 2 - k / 2
                    , E = S / 2 - m[f] / 2 - 1
                    , M = LE(u[b], E)
                    , T = LE(u[y], E)
                    , N = M
                    , _ = S - m[f] - T
                    , O = S / 2 - m[f] / 2 + x
                    , A = $E(N, O, _)
                    , P = !l.arrow && null != FE(o) && O !== A && i.reference[f] / 2 - (O < N ? M : T) - m[f] / 2 < 0
                    , L = P ? O < N ? O - N : O - _ : 0;
                return {
                    [p]: h[p] + L,
                    data: {
                        [p]: A,
                        centerOffset: O - A - L,
                        ...P && {
                            alignmentOffset: L
                        }
                    },
                    reset: P
                }
            }
        })
        , CM = function (e) {
            return void 0 === e && (e = {}),
            {
                name: "inline",
                options: e,
                async fn(t) {
                    const { placement: n, elements: r, rects: o, platform: i, strategy: s } = t
                        , { padding: a = 2, x: l, y: c } = BE(e, t)
                        , d = Array.from(await (null == i.getClientRects ? void 0 : i.getClientRects(r.reference)) || [])
                        , u = function (e) {
                            const t = e.slice().sort(((e, t) => e.y - t.y))
                                , n = [];
                            let r = null;
                            for (let o = 0; o < t.length; o++) {
                                const e = t[o];
                                !r || e.y - r.y > r.height / 2 ? n.push([e]) : n[n.length - 1].push(e),
                                    r = e
                            }
                            return n.map((e => XE(eM(e))))
                        }(d)
                        , h = XE(eM(d))
                        , p = ZE(a);
                    const f = await i.getElementRects({
                        reference: {
                            getBoundingClientRect: function () {
                                if (2 === u.length && u[0].left > u[1].right && null != l && null != c)
                                    return u.find((e => l > e.left - p.left && l < e.right + p.right && c > e.top - p.top && c < e.bottom + p.bottom)) || h;
                                if (u.length >= 2) {
                                    if ("y" === qE(n)) {
                                        const e = u[0]
                                            , t = u[u.length - 1]
                                            , r = "top" === VE(n)
                                            , o = e.top
                                            , i = t.bottom
                                            , s = r ? e.left : t.left
                                            , a = r ? e.right : t.right;
                                        return {
                                            top: o,
                                            bottom: i,
                                            left: s,
                                            right: a,
                                            width: a - s,
                                            height: i - o,
                                            x: s,
                                            y: o
                                        }
                                    }
                                    const e = "left" === VE(n)
                                        , t = RE(...u.map((e => e.right)))
                                        , r = LE(...u.map((e => e.left)))
                                        , o = u.filter((n => e ? n.left === r : n.right === t))
                                        , i = o[0].top
                                        , s = o[o.length - 1].bottom;
                                    return {
                                        top: i,
                                        bottom: s,
                                        left: r,
                                        right: t,
                                        width: t - r,
                                        height: s - i,
                                        x: r,
                                        y: i
                                    }
                                }
                                return h
                            }
                        },
                        floating: r.floating,
                        strategy: s
                    });
                    return o.reference.x !== f.reference.x || o.reference.y !== f.reference.y || o.reference.width !== f.reference.width || o.reference.height !== f.reference.height ? {
                        reset: {
                            rects: f
                        }
                    } : {}
                }
            }
        }
        , SM = function (e) {
            return void 0 === e && (e = {}),
            {
                options: e,
                fn(t) {
                    const { x: n, y: r, placement: o, rects: i, middlewareData: s } = t
                        , { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = BE(e, t)
                        , d = {
                            x: n,
                            y: r
                        }
                        , u = qE(o)
                        , h = UE(u);
                    let p = d[h]
                        , f = d[u];
                    const m = BE(a, t)
                        , g = "number" === typeof m ? {
                            mainAxis: m,
                            crossAxis: 0
                        } : {
                            mainAxis: 0,
                            crossAxis: 0,
                            ...m
                        };
                    if (l) {
                        const e = "y" === h ? "height" : "width"
                            , t = i.reference[h] - i.floating[e] + g.mainAxis
                            , n = i.reference[h] + i.reference[e] - g.mainAxis;
                        p < t ? p = t : p > n && (p = n)
                    }
                    if (c) {
                        var b, y;
                        const e = "y" === h ? "width" : "height"
                            , t = ["top", "left"].includes(VE(o))
                            , n = i.reference[u] - i.floating[e] + (t && (null == (b = s.offset) ? void 0 : b[u]) || 0) + (t ? 0 : g.crossAxis)
                            , r = i.reference[u] + i.reference[e] + (t ? 0 : (null == (y = s.offset) ? void 0 : y[u]) || 0) - (t ? g.crossAxis : 0);
                        f < n ? f = n : f > r && (f = r)
                    }
                    return {
                        [h]: p,
                        [u]: f
                    }
                }
            }
        }
        , xM = (e, t, n) => {
            const r = new Map
                , o = {
                    platform: mM,
                    ...n
                }
                , i = {
                    ...o.platform,
                    _c: r
                };
            return (async (e, t, n) => {
                const { placement: r = "bottom", strategy: o = "absolute", middleware: i = [], platform: s } = n
                    , a = i.filter(Boolean)
                    , l = await (null == s.isRTL ? void 0 : s.isRTL(t));
                let c = await s.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: o
                })
                    , { x: d, y: u } = QE(c, r, l)
                    , h = r
                    , p = {}
                    , f = 0;
                for (let m = 0; m < a.length; m++) {
                    const { name: n, fn: i } = a[m]
                        , { x: g, y: b, data: y, reset: v } = await i({
                            x: d,
                            y: u,
                            initialPlacement: r,
                            placement: h,
                            strategy: o,
                            middlewareData: p,
                            rects: c,
                            platform: s,
                            elements: {
                                reference: e,
                                floating: t
                            }
                        });
                    d = null != g ? g : d,
                        u = null != b ? b : u,
                        p = {
                            ...p,
                            [n]: {
                                ...p[n],
                                ...y
                            }
                        },
                        v && f <= 50 && (f++,
                            "object" === typeof v && (v.placement && (h = v.placement),
                                v.rects && (c = !0 === v.rects ? await s.getElementRects({
                                    reference: e,
                                    floating: t,
                                    strategy: o
                                }) : v.rects),
                                ({ x: d, y: u } = QE(c, h, l))),
                            m = -1)
                }
                return {
                    x: d,
                    y: u,
                    placement: h,
                    strategy: o,
                    middlewareData: p
                }
            }
            )(e, t, {
                ...o,
                platform: i
            })
        }
        ;
    var EM = "undefined" !== typeof document ? r.useLayoutEffect : r.useEffect;
    function MM(e, t) {
        if (e === t)
            return !0;
        if (typeof e !== typeof t)
            return !1;
        if ("function" === typeof e && e.toString() === t.toString())
            return !0;
        let n, r, o;
        if (e && t && "object" === typeof e) {
            if (Array.isArray(e)) {
                if (n = e.length,
                    n !== t.length)
                    return !1;
                for (r = n; 0 !== r--;)
                    if (!MM(e[r], t[r]))
                        return !1;
                return !0
            }
            if (o = Object.keys(e),
                n = o.length,
                n !== Object.keys(t).length)
                return !1;
            for (r = n; 0 !== r--;)
                if (!{}.hasOwnProperty.call(t, o[r]))
                    return !1;
            for (r = n; 0 !== r--;) {
                const n = o[r];
                if (("_owner" !== n || !e.$$typeof) && !MM(e[n], t[n]))
                    return !1
            }
            return !0
        }
        return e !== e && t !== t
    }
    function TM(e) {
        if ("undefined" === typeof window)
            return 1;
        return (e.ownerDocument.defaultView || window).devicePixelRatio || 1
    }
    function NM(e, t) {
        const n = TM(e);
        return Math.round(t * n) / n
    }
    function _M(e) {
        const t = r.useRef(e);
        return EM((() => {
            t.current = e
        }
        )),
            t
    }
    const OM = e => ({
        name: "arrow",
        options: e,
        fn(t) {
            const { element: n, padding: r } = "function" === typeof e ? e(t) : e;
            return n && (o = n,
                {}.hasOwnProperty.call(o, "current")) ? null != n.current ? kM({
                    element: n.current,
                    padding: r
                }).fn(t) : {} : n ? kM({
                    element: n,
                    padding: r
                }).fn(t) : {};
            var o
        }
    })
        , AM = (e, t) => ({
            ...bM(e),
            options: [e, t]
        })
        , PM = (e, t) => ({
            ...yM(e),
            options: [e, t]
        })
        , LM = (e, t) => ({
            ...SM(e),
            options: [e, t]
        })
        , RM = (e, t) => ({
            ...vM(e),
            options: [e, t]
        })
        , DM = (e, t) => ({
            ...wM(e),
            options: [e, t]
        })
        , IM = (e, t) => ({
            ...CM(e),
            options: [e, t]
        })
        , jM = (e, t) => ({
            ...OM(e),
            options: [e, t]
        });
    const HM = {
        ...o
    }
        , zM = HM.useInsertionEffect || (e => e());
    function $M(e) {
        const t = r.useRef((() => {
            0
        }
        ));
        return zM((() => {
            t.current = e
        }
        )),
            r.useCallback((function () {
                for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                    n[r] = arguments[r];
                return null == t.current ? void 0 : t.current(...n)
            }
            ), [])
    }
    const BM = "ArrowUp"
        , VM = "ArrowDown"
        , FM = "ArrowLeft"
        , UM = "ArrowRight";
    var WM = "undefined" !== typeof document ? r.useLayoutEffect : r.useEffect;
    const qM = [FM, UM]
        , GM = [BM, VM];
    function KM() {
        return KM = Object.assign ? Object.assign.bind() : function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
            ,
            KM.apply(this, arguments)
    }
    let JM = !1
        , ZM = 0;
    const XM = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + ZM++;
    const QM = HM.useId || function () {
        const [e, t] = r.useState((() => JM ? XM() : void 0));
        return WM((() => {
            null == e && t(XM())
        }
        ), []),
            r.useEffect((() => {
                JM = !0
            }
            ), []),
            e
    }
        ;
    function YM() {
        const e = new Map;
        return {
            emit(t, n) {
                var r;
                null == (r = e.get(t)) || r.forEach((e => e(n)))
            },
            on(t, n) {
                e.set(t, [...e.get(t) || [], n])
            },
            off(t, n) {
                var r;
                e.set(t, (null == (r = e.get(t)) ? void 0 : r.filter((e => e !== n))) || [])
            }
        }
    }
    const eT = r.createContext(null)
        , tT = r.createContext(null)
        , nT = () => {
            var e;
            return (null == (e = r.useContext(eT)) ? void 0 : e.id) || null
        }
        , rT = () => r.useContext(tT);
    function oT(e) {
        return "data-floating-ui-" + e
    }
    function iT(e) {
        const t = (0,
            r.useRef)(e);
        return WM((() => {
            t.current = e
        }
        )),
            t
    }
    const sT = oT("safe-polygon");
    function aT(e, t, n) {
        return n && !aE(n) ? 0 : "number" === typeof e ? e : null == e ? void 0 : e[t]
    }
    function lT(e, t) {
        void 0 === t && (t = {});
        const { open: n, onOpenChange: o, dataRef: i, events: s, elements: a } = e
            , { enabled: l = !0, delay: c = 0, handleClose: d = null, mouseOnly: u = !1, restMs: h = 0, move: p = !0 } = t
            , f = rT()
            , m = nT()
            , g = iT(d)
            , b = iT(c)
            , y = iT(n)
            , v = r.useRef()
            , w = r.useRef(-1)
            , k = r.useRef()
            , C = r.useRef(-1)
            , S = r.useRef(!0)
            , x = r.useRef(!1)
            , E = r.useRef((() => { }
            ))
            , M = r.useRef(!1)
            , T = r.useCallback((() => {
                var e;
                const t = null == (e = i.current.openEvent) ? void 0 : e.type;
                return (null == t ? void 0 : t.includes("mouse")) && "mousedown" !== t
            }
            ), [i]);
        r.useEffect((() => {
            if (l)
                return s.on("openchange", e),
                    () => {
                        s.off("openchange", e)
                    }
                    ;
            function e(e) {
                let { open: t } = e;
                t || (clearTimeout(w.current),
                    clearTimeout(C.current),
                    S.current = !0,
                    M.current = !1)
            }
        }
        ), [l, s]),
            r.useEffect((() => {
                if (!l)
                    return;
                if (!g.current)
                    return;
                if (!n)
                    return;
                function e(e) {
                    T() && o(!1, e, "hover")
                }
                const t = lE(a.floating).documentElement;
                return t.addEventListener("mouseleave", e),
                    () => {
                        t.removeEventListener("mouseleave", e)
                    }
            }
            ), [a.floating, n, o, l, g, T]);
        const N = r.useCallback((function (e, t, n) {
            void 0 === t && (t = !0),
                void 0 === n && (n = "hover");
            const r = aT(b.current, "close", v.current);
            r && !k.current ? (clearTimeout(w.current),
                w.current = window.setTimeout((() => o(!1, e, n)), r)) : t && (clearTimeout(w.current),
                    o(!1, e, n))
        }
        ), [b, o])
            , _ = $M((() => {
                E.current(),
                    k.current = void 0
            }
            ))
            , O = $M((() => {
                if (x.current) {
                    const e = lE(a.floating).body;
                    e.style.pointerEvents = "",
                        e.removeAttribute(sT),
                        x.current = !1
                }
            }
            ));
        r.useEffect((() => {
            if (l && zx(a.domReference)) {
                var e;
                const t = a.domReference;
                return n && t.addEventListener("mouseleave", c),
                    null == (e = a.floating) || e.addEventListener("mouseleave", c),
                    p && t.addEventListener("mousemove", r, {
                        once: !0
                    }),
                    t.addEventListener("mouseenter", r),
                    t.addEventListener("mouseleave", s),
                    () => {
                        var e;
                        n && t.removeEventListener("mouseleave", c),
                            null == (e = a.floating) || e.removeEventListener("mouseleave", c),
                            p && t.removeEventListener("mousemove", r),
                            t.removeEventListener("mouseenter", r),
                            t.removeEventListener("mouseleave", s)
                    }
            }
            function t() {
                return !!i.current.openEvent && ["click", "mousedown"].includes(i.current.openEvent.type)
            }
            function r(e) {
                if (clearTimeout(w.current),
                    S.current = !1,
                    u && !aE(v.current) || h > 0 && !aT(b.current, "open"))
                    return;
                const t = aT(b.current, "open", v.current);
                t ? w.current = window.setTimeout((() => {
                    y.current || o(!0, e, "hover")
                }
                ), t) : o(!0, e, "hover")
            }
            function s(e) {
                if (t())
                    return;
                E.current();
                const r = lE(a.floating);
                if (clearTimeout(C.current),
                    M.current = !1,
                    g.current && i.current.floatingContext) {
                    n || clearTimeout(w.current),
                        k.current = g.current({
                            ...i.current.floatingContext,
                            tree: f,
                            x: e.clientX,
                            y: e.clientY,
                            onClose() {
                                O(),
                                    _(),
                                    N(e, !0, "safe-polygon")
                            }
                        });
                    const t = k.current;
                    return r.addEventListener("mousemove", t),
                        void (E.current = () => {
                            r.removeEventListener("mousemove", t)
                        }
                        )
                }
                ("touch" !== v.current || !tE(a.floating, e.relatedTarget)) && N(e)
            }
            function c(e) {
                t() || i.current.floatingContext && (null == g.current || g.current({
                    ...i.current.floatingContext,
                    tree: f,
                    x: e.clientX,
                    y: e.clientY,
                    onClose() {
                        O(),
                            _(),
                            N(e)
                    }
                })(e))
            }
        }
        ), [a, l, e, u, h, p, N, _, O, o, n, y, f, b, g, i]),
            WM((() => {
                var e;
                if (l && n && null != (e = g.current) && e.__options.blockPointerEvents && T()) {
                    x.current = !0;
                    const e = a.floating;
                    if (zx(a.domReference) && e) {
                        var t;
                        const n = lE(a.floating).body;
                        n.setAttribute(sT, "");
                        const r = a.domReference
                            , o = null == f || null == (t = f.nodesRef.current.find((e => e.id === m))) || null == (t = t.context) ? void 0 : t.elements.floating;
                        return o && (o.style.pointerEvents = ""),
                            n.style.pointerEvents = "none",
                            r.style.pointerEvents = "auto",
                            e.style.pointerEvents = "auto",
                            () => {
                                n.style.pointerEvents = "",
                                    r.style.pointerEvents = "",
                                    e.style.pointerEvents = ""
                            }
                    }
                }
            }
            ), [l, n, m, a, f, g, T]),
            WM((() => {
                n || (v.current = void 0,
                    M.current = !1,
                    _(),
                    O())
            }
            ), [n, _, O]),
            r.useEffect((() => () => {
                _(),
                    clearTimeout(w.current),
                    clearTimeout(C.current),
                    O()
            }
            ), [l, a.domReference, _, O]);
        const A = r.useMemo((() => {
            function e(e) {
                v.current = e.pointerType
            }
            return {
                onPointerDown: e,
                onPointerEnter: e,
                onMouseMove(e) {
                    const { nativeEvent: t } = e;
                    function r() {
                        S.current || y.current || o(!0, t, "hover")
                    }
                    u && !aE(v.current) || n || 0 === h || M.current && e.movementX ** 2 + e.movementY ** 2 < 2 || (clearTimeout(C.current),
                        "touch" === v.current ? r() : (M.current = !0,
                            C.current = window.setTimeout(r, h)))
                }
            }
        }
        ), [u, o, n, y, h])
            , P = r.useMemo((() => ({
                onMouseEnter() {
                    clearTimeout(w.current)
                },
                onMouseLeave(e) {
                    N(e.nativeEvent, !1)
                }
            })), [N]);
        return r.useMemo((() => l ? {
            reference: A,
            floating: P
        } : {}), [l, A, P])
    }
    const cT = () => { }
        , dT = r.createContext({
            delay: 0,
            initialDelay: 0,
            timeoutMs: 0,
            currentId: null,
            setCurrentId: cT,
            setState: cT,
            isInstantPhase: !1
        })
        , uT = () => r.useContext(dT);
    function hT(e) {
        const { children: t, delay: n, timeoutMs: o = 0 } = e
            , [i, s] = r.useReducer(((e, t) => ({
                ...e,
                ...t
            })), {
                delay: n,
                timeoutMs: o,
                initialDelay: n,
                currentId: null,
                isInstantPhase: !1
            })
            , a = r.useRef(null)
            , l = r.useCallback((e => {
                s({
                    currentId: e
                })
            }
            ), []);
        return WM((() => {
            i.currentId ? null === a.current ? a.current = i.currentId : i.isInstantPhase || s({
                isInstantPhase: !0
            }) : (i.isInstantPhase && s({
                isInstantPhase: !1
            }),
                a.current = null)
        }
        ), [i.currentId, i.isInstantPhase]),
            r.createElement(dT.Provider, {
                value: r.useMemo((() => ({
                    ...i,
                    setState: s,
                    setCurrentId: l
                })), [i, l])
            }, t)
    }
    function pT(e, t) {
        void 0 === t && (t = {});
        const { open: n, onOpenChange: r, floatingId: o } = e
            , { id: i, enabled: s = !0 } = t
            , a = null != i ? i : o
            , l = uT()
            , { currentId: c, setCurrentId: d, initialDelay: u, setState: h, timeoutMs: p } = l;
        return WM((() => {
            s && c && (h({
                delay: {
                    open: 1,
                    close: aT(u, "close")
                }
            }),
                c !== a && r(!1))
        }
        ), [s, a, r, h, c, u]),
            WM((() => {
                function e() {
                    r(!1),
                        h({
                            delay: u,
                            currentId: null
                        })
                }
                if (s && c && !n && c === a) {
                    if (p) {
                        const t = window.setTimeout(e, p);
                        return () => {
                            clearTimeout(t)
                        }
                    }
                    e()
                }
            }
            ), [s, n, h, c, a, r, u, p]),
            WM((() => {
                s && d !== cT && n && d(a)
            }
            ), [s, n, d, a]),
            l
    }
    function fT(e, t) {
        let n = e.filter((e => {
            var n;
            return e.parentId === t && (null == (n = e.context) ? void 0 : n.open)
        }
        ))
            , r = n;
        for (; r.length;)
            r = e.filter((e => {
                var t;
                return null == (t = r) ? void 0 : t.some((t => {
                    var n;
                    return e.parentId === t.id && (null == (n = e.context) ? void 0 : n.open)
                }
                ))
            }
            )),
                n = n.concat(r);
        return n
    }
    const mT = () => ({
        getShadowRoot: !0,
        displayCheck: "function" === typeof ResizeObserver && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
    });
    function gT(e, t) {
        const n = AE(e, mT());
        "prev" === t && n.reverse();
        const r = n.indexOf(eE(lE(e)));
        return n.slice(r + 1)[0]
    }
    function bT() {
        return gT(document.body, "next")
    }
    function yT() {
        return gT(document.body, "prev")
    }
    function vT(e, t) {
        const n = t || e.currentTarget
            , r = e.relatedTarget;
        return !r || !tE(n, r)
    }
    function wT(e) {
        AE(e, mT()).forEach((e => {
            e.dataset.tabindex = e.getAttribute("tabindex") || "",
                e.setAttribute("tabindex", "-1")
        }
        ))
    }
    function kT(e) {
        e.querySelectorAll("[data-tabindex]").forEach((e => {
            const t = e.dataset.tabindex;
            delete e.dataset.tabindex,
                t ? e.setAttribute("tabindex", t) : e.removeAttribute("tabindex")
        }
        ))
    }
    const CT = {
        border: 0,
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: 0,
        position: "fixed",
        whiteSpace: "nowrap",
        width: "1px",
        top: 0,
        left: 0
    };
    function ST(e) {
        "Tab" === e.key && (e.target,
            clearTimeout(undefined))
    }
    const xT = r.forwardRef((function (e, t) {
        const [n, o] = r.useState();
        WM((() => (iE() && o("button"),
            document.addEventListener("keydown", ST),
            () => {
                document.removeEventListener("keydown", ST)
            }
        )), []);
        const i = {
            ref: t,
            tabIndex: 0,
            role: n,
            "aria-hidden": !n || void 0,
            [oT("focus-guard")]: "",
            style: CT
        };
        return r.createElement("span", KM({}, e, i))
    }
    ))
        , ET = r.createContext(null)
        , MT = oT("portal");
    function TT(e) {
        const { children: t, id: n, root: o, preserveTabOrder: i = !0 } = e
            , s = function (e) {
                void 0 === e && (e = {});
                const { id: t, root: n } = e
                    , o = QM()
                    , i = NT()
                    , [s, a] = r.useState(null)
                    , l = r.useRef(null);
                return WM((() => () => {
                    null == s || s.remove(),
                        queueMicrotask((() => {
                            l.current = null
                        }
                        ))
                }
                ), [s]),
                    WM((() => {
                        if (!o)
                            return;
                        if (l.current)
                            return;
                        const e = t ? document.getElementById(t) : null;
                        if (!e)
                            return;
                        const n = document.createElement("div");
                        n.id = o,
                            n.setAttribute(MT, ""),
                            e.appendChild(n),
                            l.current = n,
                            a(n)
                    }
                    ), [t, o]),
                    WM((() => {
                        if (null === n)
                            return;
                        if (!o)
                            return;
                        if (l.current)
                            return;
                        let e = n || (null == i ? void 0 : i.portalNode);
                        e && !zx(e) && (e = e.current),
                            e = e || document.body;
                        let r = null;
                        t && (r = document.createElement("div"),
                            r.id = t,
                            e.appendChild(r));
                        const s = document.createElement("div");
                        s.id = o,
                            s.setAttribute(MT, ""),
                            e = r || e,
                            e.appendChild(s),
                            l.current = s,
                            a(s)
                    }
                    ), [t, n, o, i]),
                    s
            }({
                id: n,
                root: o
            })
            , [a, l] = r.useState(null)
            , c = r.useRef(null)
            , d = r.useRef(null)
            , u = r.useRef(null)
            , h = r.useRef(null)
            , p = null == a ? void 0 : a.modal
            , f = null == a ? void 0 : a.open
            , m = !!a && !a.modal && a.open && i && !(!o && !s);
        return r.useEffect((() => {
            if (s && i && !p)
                return s.addEventListener("focusin", e, !0),
                    s.addEventListener("focusout", e, !0),
                    () => {
                        s.removeEventListener("focusin", e, !0),
                            s.removeEventListener("focusout", e, !0)
                    }
                    ;
            function e(e) {
                if (s && vT(e)) {
                    ("focusin" === e.type ? kT : wT)(s)
                }
            }
        }
        ), [s, i, p]),
            r.useEffect((() => {
                s && (f || kT(s))
            }
            ), [f, s]),
            r.createElement(ET.Provider, {
                value: r.useMemo((() => ({
                    preserveTabOrder: i,
                    beforeOutsideRef: c,
                    afterOutsideRef: d,
                    beforeInsideRef: u,
                    afterInsideRef: h,
                    portalNode: s,
                    setFocusManagerState: l
                })), [i, s])
            }, m && s && r.createElement(xT, {
                "data-type": "outside",
                ref: c,
                onFocus: e => {
                    if (vT(e, s)) {
                        var t;
                        null == (t = u.current) || t.focus()
                    } else {
                        const e = yT() || (null == a ? void 0 : a.refs.domReference.current);
                        null == e || e.focus()
                    }
                }
            }), m && s && r.createElement("span", {
                "aria-owns": s.id,
                style: CT
            }), s && PE.createPortal(t, s), m && s && r.createElement(xT, {
                "data-type": "outside",
                ref: d,
                onFocus: e => {
                    if (vT(e, s)) {
                        var t;
                        null == (t = h.current) || t.focus()
                    } else {
                        const t = bT() || (null == a ? void 0 : a.refs.domReference.current);
                        null == t || t.focus(),
                            (null == a ? void 0 : a.closeOnFocusOut) && (null == a || a.onOpenChange(!1, e.nativeEvent, "focus-out"))
                    }
                }
            }))
    }
    const NT = () => r.useContext(ET)
        , _T = "data-floating-ui-focusable";
    const OT = {
        pointerdown: "onPointerDown",
        mousedown: "onMouseDown",
        click: "onClick"
    }
        , AT = {
            pointerdown: "onPointerDownCapture",
            mousedown: "onMouseDownCapture",
            click: "onClickCapture"
        }
        , PT = e => {
            var t, n;
            return {
                escapeKey: "boolean" === typeof e ? e : null != (t = null == e ? void 0 : e.escapeKey) && t,
                outsidePress: "boolean" === typeof e ? e : null == (n = null == e ? void 0 : e.outsidePress) || n
            }
        }
        ;
    function LT(e, t) {
        void 0 === t && (t = {});
        const { open: n, onOpenChange: o, elements: i, dataRef: s } = e
            , { enabled: a = !0, escapeKey: l = !0, outsidePress: c = !0, outsidePressEvent: d = "pointerdown", referencePress: u = !1, referencePressEvent: h = "pointerdown", ancestorScroll: p = !1, bubbles: f, capture: m } = t
            , g = rT()
            , b = $M("function" === typeof c ? c : () => !1)
            , y = "function" === typeof c ? b : c
            , v = r.useRef(!1)
            , w = r.useRef(!1)
            , { escapeKey: k, outsidePress: C } = PT(f)
            , { escapeKey: S, outsidePress: x } = PT(m)
            , E = r.useRef(!1)
            , M = $M((e => {
                var t;
                if (!n || !a || !l || "Escape" !== e.key)
                    return;
                if (E.current)
                    return;
                const r = null == (t = s.current.floatingContext) ? void 0 : t.nodeId
                    , i = g ? fT(g.nodesRef.current, r) : [];
                if (!k && (e.stopPropagation(),
                    i.length > 0)) {
                    let e = !0;
                    if (i.forEach((t => {
                        var n;
                        null == (n = t.context) || !n.open || t.context.dataRef.current.__escapeKeyBubbles || (e = !1)
                    }
                    )),
                        !e)
                        return
                }
                o(!1, function (e) {
                    return "nativeEvent" in e
                }(e) ? e.nativeEvent : e, "escape-key")
            }
            ))
            , T = $M((e => {
                var t;
                const n = () => {
                    var t;
                    M(e),
                        null == (t = dE(e)) || t.removeEventListener("keydown", n)
                }
                    ;
                null == (t = dE(e)) || t.addEventListener("keydown", n)
            }
            ))
            , N = $M((e => {
                var t;
                const n = v.current;
                v.current = !1;
                const r = w.current;
                if (w.current = !1,
                    "click" === d && r)
                    return;
                if (n)
                    return;
                if ("function" === typeof y && !y(e))
                    return;
                const a = dE(e)
                    , l = "[" + oT("inert") + "]"
                    , c = lE(i.floating).querySelectorAll(l);
                let u = zx(a) ? a : null;
                for (; u && !Gx(u);) {
                    const e = Zx(u);
                    if (Gx(e) || !zx(e))
                        break;
                    u = e
                }
                if (c.length && zx(a) && !a.matches("html,body") && !tE(a, i.floating) && Array.from(c).every((e => !tE(u, e))))
                    return;
                if ($x(a) && A) {
                    const t = a.clientWidth > 0 && a.scrollWidth > a.clientWidth
                        , n = a.clientHeight > 0 && a.scrollHeight > a.clientHeight;
                    let r = n && e.offsetX > a.clientWidth;
                    if (n) {
                        "rtl" === Kx(a).direction && (r = e.offsetX <= a.offsetWidth - a.clientWidth)
                    }
                    if (r || t && e.offsetY > a.clientHeight)
                        return
                }
                const h = null == (t = s.current.floatingContext) ? void 0 : t.nodeId
                    , p = g && fT(g.nodesRef.current, h).some((t => {
                        var n;
                        return cE(e, null == (n = t.context) ? void 0 : n.elements.floating)
                    }
                    ));
                if (cE(e, i.floating) || cE(e, i.domReference) || p)
                    return;
                const f = g ? fT(g.nodesRef.current, h) : [];
                if (f.length > 0) {
                    let e = !0;
                    if (f.forEach((t => {
                        var n;
                        null == (n = t.context) || !n.open || t.context.dataRef.current.__outsidePressBubbles || (e = !1)
                    }
                    )),
                        !e)
                        return
                }
                o(!1, e, "outside-press")
            }
            ))
            , _ = $M((e => {
                var t;
                const n = () => {
                    var t;
                    N(e),
                        null == (t = dE(e)) || t.removeEventListener(d, n)
                }
                    ;
                null == (t = dE(e)) || t.addEventListener(d, n)
            }
            ));
        r.useEffect((() => {
            if (!n || !a)
                return;
            s.current.__escapeKeyBubbles = k,
                s.current.__outsidePressBubbles = C;
            let e = -1;
            function t(e) {
                o(!1, e, "ancestor-scroll")
            }
            function r() {
                window.clearTimeout(e),
                    E.current = !0
            }
            function c() {
                e = window.setTimeout((() => {
                    E.current = !1
                }
                ), qx() ? 5 : 0)
            }
            const u = lE(i.floating);
            l && (u.addEventListener("keydown", S ? T : M, S),
                u.addEventListener("compositionstart", r),
                u.addEventListener("compositionend", c)),
                y && u.addEventListener(d, x ? _ : N, x);
            let h = [];
            return p && (zx(i.domReference) && (h = Qx(i.domReference)),
                zx(i.floating) && (h = h.concat(Qx(i.floating))),
                !zx(i.reference) && i.reference && i.reference.contextElement && (h = h.concat(Qx(i.reference.contextElement)))),
                h = h.filter((e => {
                    var t;
                    return e !== (null == (t = u.defaultView) ? void 0 : t.visualViewport)
                }
                )),
                h.forEach((e => {
                    e.addEventListener("scroll", t, {
                        passive: !0
                    })
                }
                )),
                () => {
                    l && (u.removeEventListener("keydown", S ? T : M, S),
                        u.removeEventListener("compositionstart", r),
                        u.removeEventListener("compositionend", c)),
                        y && u.removeEventListener(d, x ? _ : N, x),
                        h.forEach((e => {
                            e.removeEventListener("scroll", t)
                        }
                        )),
                        window.clearTimeout(e)
                }
        }
        ), [s, i, l, y, d, n, o, p, a, k, C, M, S, T, N, x, _]),
            r.useEffect((() => {
                v.current = !1
            }
            ), [y, d]);
        const O = r.useMemo((() => ({
            onKeyDown: M,
            [OT[h]]: e => {
                u && o(!1, e.nativeEvent, "reference-press")
            }
        })), [M, o, u, h])
            , A = r.useMemo((() => ({
                onKeyDown: M,
                onMouseDown() {
                    w.current = !0
                },
                onMouseUp() {
                    w.current = !0
                },
                [AT[d]]: () => {
                    v.current = !0
                }
            })), [M, d]);
        return r.useMemo((() => a ? {
            reference: O,
            floating: A
        } : {}), [a, O, A])
    }
    function RT(e) {
        void 0 === e && (e = {});
        const { nodeId: t } = e
            , n = function (e) {
                const { open: t = !1, onOpenChange: n, elements: o } = e
                    , i = QM()
                    , s = r.useRef({})
                    , [a] = r.useState((() => YM()))
                    , l = null != nT()
                    , [c, d] = r.useState(o.reference)
                    , u = $M(((e, t, r) => {
                        s.current.openEvent = e ? t : void 0,
                            a.emit("openchange", {
                                open: e,
                                event: t,
                                reason: r,
                                nested: l
                            }),
                            null == n || n(e, t, r)
                    }
                    ))
                    , h = r.useMemo((() => ({
                        setPositionReference: d
                    })), [])
                    , p = r.useMemo((() => ({
                        reference: c || o.reference || null,
                        floating: o.floating || null,
                        domReference: o.reference
                    })), [c, o.reference, o.floating]);
                return r.useMemo((() => ({
                    dataRef: s,
                    open: t,
                    onOpenChange: u,
                    elements: p,
                    events: a,
                    floatingId: i,
                    refs: h
                })), [t, u, p, a, i, h])
            }({
                ...e,
                elements: {
                    reference: null,
                    floating: null,
                    ...e.elements
                }
            })
            , o = e.rootContext || n
            , i = o.elements
            , [s, a] = r.useState(null)
            , [l, c] = r.useState(null)
            , d = (null == i ? void 0 : i.domReference) || s
            , u = r.useRef(null)
            , h = rT();
        WM((() => {
            d && (u.current = d)
        }
        ), [d]);
        const p = function (e) {
            void 0 === e && (e = {});
            const { placement: t = "bottom", strategy: n = "absolute", middleware: o = [], platform: i, elements: { reference: s, floating: a } = {}, transform: l = !0, whileElementsMounted: c, open: d } = e
                , [u, h] = r.useState({
                    x: 0,
                    y: 0,
                    strategy: n,
                    placement: t,
                    middlewareData: {},
                    isPositioned: !1
                })
                , [p, f] = r.useState(o);
            MM(p, o) || f(o);
            const [m, g] = r.useState(null)
                , [b, y] = r.useState(null)
                , v = r.useCallback((e => {
                    e !== S.current && (S.current = e,
                        g(e))
                }
                ), [])
                , w = r.useCallback((e => {
                    e !== x.current && (x.current = e,
                        y(e))
                }
                ), [])
                , k = s || m
                , C = a || b
                , S = r.useRef(null)
                , x = r.useRef(null)
                , E = r.useRef(u)
                , M = null != c
                , T = _M(c)
                , N = _M(i)
                , _ = _M(d)
                , O = r.useCallback((() => {
                    if (!S.current || !x.current)
                        return;
                    const e = {
                        placement: t,
                        strategy: n,
                        middleware: p
                    };
                    N.current && (e.platform = N.current),
                        xM(S.current, x.current, e).then((e => {
                            const t = {
                                ...e,
                                isPositioned: !1 !== _.current
                            };
                            A.current && !MM(E.current, t) && (E.current = t,
                                PE.flushSync((() => {
                                    h(t)
                                }
                                )))
                        }
                        ))
                }
                ), [p, t, n, N, _]);
            EM((() => {
                !1 === d && E.current.isPositioned && (E.current.isPositioned = !1,
                    h((e => ({
                        ...e,
                        isPositioned: !1
                    }))))
            }
            ), [d]);
            const A = r.useRef(!1);
            EM((() => (A.current = !0,
                () => {
                    A.current = !1
                }
            )), []),
                EM((() => {
                    if (k && (S.current = k),
                        C && (x.current = C),
                        k && C) {
                        if (T.current)
                            return T.current(k, C, O);
                        O()
                    }
                }
                ), [k, C, O, T, M]);
            const P = r.useMemo((() => ({
                reference: S,
                floating: x,
                setReference: v,
                setFloating: w
            })), [v, w])
                , L = r.useMemo((() => ({
                    reference: k,
                    floating: C
                })), [k, C])
                , R = r.useMemo((() => {
                    const e = {
                        position: n,
                        left: 0,
                        top: 0
                    };
                    if (!L.floating)
                        return e;
                    const t = NM(L.floating, u.x)
                        , r = NM(L.floating, u.y);
                    return l ? {
                        ...e,
                        transform: "translate(" + t + "px, " + r + "px)",
                        ...TM(L.floating) >= 1.5 && {
                            willChange: "transform"
                        }
                    } : {
                        position: n,
                        left: t,
                        top: r
                    }
                }
                ), [n, l, L.floating, u.x, u.y]);
            return r.useMemo((() => ({
                ...u,
                update: O,
                refs: P,
                elements: L,
                floatingStyles: R
            })), [u, O, P, L, R])
        }({
            ...e,
            elements: {
                ...i,
                ...l && {
                    reference: l
                }
            }
        })
            , f = r.useCallback((e => {
                const t = zx(e) ? {
                    getBoundingClientRect: () => e.getBoundingClientRect(),
                    contextElement: e
                } : e;
                c(t),
                    p.refs.setReference(t)
            }
            ), [p.refs])
            , m = r.useCallback((e => {
                (zx(e) || null === e) && (u.current = e,
                    a(e)),
                    (zx(p.refs.reference.current) || null === p.refs.reference.current || null !== e && !zx(e)) && p.refs.setReference(e)
            }
            ), [p.refs])
            , g = r.useMemo((() => ({
                ...p.refs,
                setReference: m,
                setPositionReference: f,
                domReference: u
            })), [p.refs, m, f])
            , b = r.useMemo((() => ({
                ...p.elements,
                domReference: d
            })), [p.elements, d])
            , y = r.useMemo((() => ({
                ...p,
                ...o,
                refs: g,
                elements: b,
                nodeId: t
            })), [p, g, b, t, o]);
        return WM((() => {
            o.dataRef.current.floatingContext = y;
            const e = null == h ? void 0 : h.nodesRef.current.find((e => e.id === t));
            e && (e.context = y)
        }
        )),
            r.useMemo((() => ({
                ...p,
                context: y,
                refs: g,
                elements: b
            })), [p, g, b, y])
    }
    function DT(e, t) {
        void 0 === t && (t = {});
        const { open: n, onOpenChange: o, events: i, dataRef: s, elements: a } = e
            , { enabled: l = !0, visibleOnly: c = !0 } = t
            , d = r.useRef(!1)
            , u = r.useRef()
            , h = r.useRef(!0);
        r.useEffect((() => {
            if (!l)
                return;
            const e = Ix(a.domReference);
            function t() {
                !n && $x(a.domReference) && a.domReference === eE(lE(a.domReference)) && (d.current = !0)
            }
            function r() {
                h.current = !0
            }
            return e.addEventListener("blur", t),
                e.addEventListener("keydown", r, !0),
                () => {
                    e.removeEventListener("blur", t),
                        e.removeEventListener("keydown", r, !0)
                }
        }
        ), [a.domReference, n, l]),
            r.useEffect((() => {
                if (l)
                    return i.on("openchange", e),
                        () => {
                            i.off("openchange", e)
                        }
                        ;
                function e(e) {
                    let { reason: t } = e;
                    "reference-press" !== t && "escape-key" !== t || (d.current = !0)
                }
            }
            ), [i, l]),
            r.useEffect((() => () => {
                clearTimeout(u.current)
            }
            ), []);
        const p = r.useMemo((() => ({
            onPointerDown(e) {
                oE(e.nativeEvent) || (h.current = !1)
            },
            onMouseLeave() {
                d.current = !1
            },
            onFocus(e) {
                if (d.current)
                    return;
                const t = dE(e.nativeEvent);
                if (c && zx(t))
                    try {
                        if (iE() && nE().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints)
                            throw Error();
                        if (!t.matches(":focus-visible"))
                            return
                    } catch (pj) {
                        if (!h.current && !uE(t))
                            return
                    }
                o(!0, e.nativeEvent, "focus")
            },
            onBlur(e) {
                d.current = !1;
                const t = e.relatedTarget
                    , n = e.nativeEvent
                    , r = zx(t) && t.hasAttribute(oT("focus-guard")) && "outside" === t.getAttribute("data-type");
                u.current = window.setTimeout((() => {
                    var e;
                    const i = eE(a.domReference ? a.domReference.ownerDocument : document);
                    (t || i !== a.domReference) && (tE(null == (e = s.current.floatingContext) ? void 0 : e.refs.floating.current, i) || tE(a.domReference, i) || r || o(!1, n, "focus"))
                }
                ))
            }
        })), [s, a.domReference, o, c]);
        return r.useMemo((() => l ? {
            reference: p
        } : {}), [l, p])
    }
    const IT = "active"
        , jT = "selected";
    function HT(e, t, n) {
        const r = new Map
            , o = "item" === n;
        let i = e;
        if (o && e) {
            const { [IT]: t, [jT]: n, ...r } = e;
            i = r
        }
        return {
            ..."floating" === n && {
                tabIndex: -1,
                [_T]: ""
            },
            ...i,
            ...t.map((t => {
                const r = t ? t[n] : null;
                return "function" === typeof r ? e ? r(e) : null : r
            }
            )).concat(e).reduce(((e, t) => t ? (Object.entries(t).forEach((t => {
                let [n, i] = t;
                var s;
                o && [IT, jT].includes(n) || (0 === n.indexOf("on") ? (r.has(n) || r.set(n, []),
                    "function" === typeof i && (null == (s = r.get(n)) || s.push(i),
                        e[n] = function () {
                            for (var e, t = arguments.length, o = new Array(t), i = 0; i < t; i++)
                                o[i] = arguments[i];
                            return null == (e = r.get(n)) ? void 0 : e.map((e => e(...o))).find((e => void 0 !== e))
                        }
                    )) : e[n] = i)
            }
            )),
                e) : e), {})
        }
    }
    function zT(e) {
        void 0 === e && (e = []);
        const t = e.map((e => null == e ? void 0 : e.reference))
            , n = e.map((e => null == e ? void 0 : e.floating))
            , o = e.map((e => null == e ? void 0 : e.item))
            , i = r.useCallback((t => HT(t, e, "reference")), t)
            , s = r.useCallback((t => HT(t, e, "floating")), n)
            , a = r.useCallback((t => HT(t, e, "item")), o);
        return r.useMemo((() => ({
            getReferenceProps: i,
            getFloatingProps: s,
            getItemProps: a
        })), [i, s, a])
    }
    const $T = new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
    function BT(e, t) {
        var n;
        void 0 === t && (t = {});
        const { open: o, floatingId: i } = e
            , { enabled: s = !0, role: a = "dialog" } = t
            , l = null != (n = $T.get(a)) ? n : a
            , c = QM()
            , d = null != nT()
            , u = r.useMemo((() => "tooltip" === l || "label" === a ? {
                ["aria-" + ("label" === a ? "labelledby" : "describedby")]: o ? i : void 0
            } : {
                "aria-expanded": o ? "true" : "false",
                "aria-haspopup": "alertdialog" === l ? "dialog" : l,
                "aria-controls": o ? i : void 0,
                ..."listbox" === l && {
                    role: "combobox"
                },
                ..."menu" === l && {
                    id: c
                },
                ..."menu" === l && d && {
                    role: "menuitem"
                },
                ..."select" === a && {
                    "aria-autocomplete": "none"
                },
                ..."combobox" === a && {
                    "aria-autocomplete": "list"
                }
            }), [l, i, d, o, c, a])
            , h = r.useMemo((() => {
                const e = {
                    id: i,
                    ...l && {
                        role: l
                    }
                };
                return "tooltip" === l || "label" === a ? e : {
                    ...e,
                    ..."menu" === l && {
                        "aria-labelledby": c
                    }
                }
            }
            ), [l, i, c, a])
            , p = r.useCallback((e => {
                let { active: t, selected: n } = e;
                const r = {
                    role: "option",
                    ...t && {
                        id: i + "-option"
                    }
                };
                switch (a) {
                    case "select":
                        return {
                            ...r,
                            "aria-selected": t && n
                        };
                    case "combobox":
                        return {
                            ...r,
                            ...t && {
                                "aria-selected": !0
                            }
                        }
                }
                return {}
            }
            ), [i, a]);
        return r.useMemo((() => s ? {
            reference: u,
            floating: h,
            item: p
        } : {}), [s, u, h, p])
    }
    const VT = e => e.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ((e, t) => (t ? "-" : "") + e.toLowerCase()));
    function FT(e, t) {
        return "function" === typeof e ? e(t) : e
    }
    function UT(e, t) {
        void 0 === t && (t = {});
        const { open: n, elements: { floating: o } } = e
            , { duration: i = 250 } = t
            , s = ("number" === typeof i ? i : i.close) || 0
            , [a, l] = r.useState("unmounted")
            , c = function (e, t) {
                const [n, o] = r.useState(e);
                return e && !n && o(!0),
                    r.useEffect((() => {
                        if (!e && n) {
                            const e = setTimeout((() => o(!1)), t);
                            return () => clearTimeout(e)
                        }
                    }
                    ), [e, n, t]),
                    n
            }(n, s);
        return c || "close" !== a || l("unmounted"),
            WM((() => {
                if (o) {
                    if (n) {
                        l("initial");
                        const e = requestAnimationFrame((() => {
                            l("open")
                        }
                        ));
                        return () => {
                            cancelAnimationFrame(e)
                        }
                    }
                    l("close")
                }
            }
            ), [n, o]),
        {
            isMounted: c,
            status: a
        }
    }
    function WT(e, t) {
        void 0 === t && (t = {});
        const { initial: n = {
            opacity: 0
        }, open: o, close: i, common: s, duration: a = 250 } = t
            , l = e.placement
            , c = l.split("-")[0]
            , d = r.useMemo((() => ({
                side: c,
                placement: l
            })), [c, l])
            , u = "number" === typeof a
            , h = (u ? a : a.open) || 0
            , p = (u ? a : a.close) || 0
            , [f, m] = r.useState((() => ({
                ...FT(s, d),
                ...FT(n, d)
            })))
            , { isMounted: g, status: b } = UT(e, {
                duration: a
            })
            , y = iT(n)
            , v = iT(o)
            , w = iT(i)
            , k = iT(s);
        return WM((() => {
            const e = FT(y.current, d)
                , t = FT(w.current, d)
                , n = FT(k.current, d)
                , r = FT(v.current, d) || Object.keys(e).reduce(((e, t) => (e[t] = "",
                    e)), {});
            if ("initial" === b && m((t => ({
                transitionProperty: t.transitionProperty,
                ...n,
                ...e
            }))),
                "open" === b && m({
                    transitionProperty: Object.keys(r).map(VT).join(","),
                    transitionDuration: h + "ms",
                    ...n,
                    ...r
                }),
                "close" === b) {
                const r = t || e;
                m({
                    transitionProperty: Object.keys(r).map(VT).join(","),
                    transitionDuration: p + "ms",
                    ...n,
                    ...r
                })
            }
        }
        ), [p, w, y, v, k, h, b, d]),
        {
            isMounted: g,
            styles: f
        }
    }
    var qT, GT = {
        exports: {}
    }, KT = {};
    GT.exports = function () {
        if (qT)
            return KT;
        qT = 1;
        var e = r
            , t = "function" === typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
            , n = e.useState
            , o = e.useEffect
            , i = e.useLayoutEffect
            , s = e.useDebugValue;
        function a(e) {
            var n = e.getSnapshot;
            e = e.value;
            try {
                var r = n();
                return !t(e, r)
            } catch (o) {
                return !0
            }
        }
        var l = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? function (e, t) {
            return t()
        }
            : function (e, t) {
                var r = t()
                    , l = n({
                        inst: {
                            value: r,
                            getSnapshot: t
                        }
                    })
                    , c = l[0].inst
                    , d = l[1];
                return i((function () {
                    c.value = r,
                        c.getSnapshot = t,
                        a(c) && d({
                            inst: c
                        })
                }
                ), [e, r, t]),
                    o((function () {
                        return a(c) && d({
                            inst: c
                        }),
                            e((function () {
                                a(c) && d({
                                    inst: c
                                })
                            }
                            ))
                    }
                    ), [e]),
                    s(r),
                    r
            }
            ;
        return KT.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : l,
            KT
    }();
    var JT = GT.exports;
    const ZT = function () {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return e => {
            t.forEach((t => {
                "function" === typeof t ? t(e) : t && (t.current = e)
            }
            ))
        }
    }
        , XT = e => {
            let { contentComponent: t } = e;
            const n = JT.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getServerSnapshot);
            return r.createElement(r.Fragment, null, Object.values(n))
        }
        ;
    class QT extends r.Component {
        constructor(e) {
            var t;
            super(e),
                this.editorContentRef = r.createRef(),
                this.initialized = !1,
                this.state = {
                    hasContentComponentInitialized: Boolean(null === (t = e.editor) || void 0 === t ? void 0 : t.contentComponent)
                }
        }
        componentDidMount() {
            this.init()
        }
        componentDidUpdate() {
            this.init()
        }
        init() {
            const e = this.props.editor;
            if (e && !e.isDestroyed && e.options.element) {
                if (e.contentComponent)
                    return;
                const t = this.editorContentRef.current;
                t.append(...e.options.element.childNodes),
                    e.setOptions({
                        element: t
                    }),
                    e.contentComponent = function () {
                        const e = new Set;
                        let t = {};
                        return {
                            subscribe: t => (e.add(t),
                                () => {
                                    e.delete(t)
                                }
                            ),
                            getSnapshot: () => t,
                            getServerSnapshot: () => t,
                            setRenderer(n, r) {
                                t = {
                                    ...t,
                                    [n]: PE.createPortal(r.reactElement, r.element, n)
                                },
                                    e.forEach((e => e()))
                            },
                            removeRenderer(n) {
                                const r = {
                                    ...t
                                };
                                delete r[n],
                                    t = r,
                                    e.forEach((e => e()))
                            }
                        }
                    }(),
                    this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = e.contentComponent.subscribe((() => {
                        this.setState((e => e.hasContentComponentInitialized ? e : {
                            hasContentComponentInitialized: !0
                        })),
                            this.unsubscribeToContentComponent && this.unsubscribeToContentComponent()
                    }
                    ))),
                    e.createNodeViews(),
                    this.initialized = !0
            }
        }
        componentWillUnmount() {
            const e = this.props.editor;
            if (!e)
                return;
            if (this.initialized = !1,
                e.isDestroyed || e.view.setProps({
                    nodeViews: {}
                }),
                this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(),
                e.contentComponent = null,
                !e.options.element.firstChild)
                return;
            const t = document.createElement("div");
            t.append(...e.options.element.childNodes),
                e.setOptions({
                    element: t
                })
        }
        render() {
            const { editor: e, innerRef: t, ...n } = this.props;
            return r.createElement(r.Fragment, null, r.createElement("div", {
                ref: ZT(t, this.editorContentRef),
                ...n
            }), (null === e || void 0 === e ? void 0 : e.contentComponent) && r.createElement(XT, {
                contentComponent: e.contentComponent
            }))
        }
    }
    const YT = (0,
        r.forwardRef)(((e, t) => {
            const n = r.useMemo((() => Math.floor(4294967295 * Math.random()).toString()), [e.editor]);
            return r.createElement(QT, {
                key: n,
                innerRef: t,
                ...e
            })
        }
        ));
    r.memo(YT);
    var eN, tN = {
        exports: {}
    }, nN = {};
    tN.exports = function () {
        if (eN)
            return nN;
        eN = 1;
        var e = r
            , t = JT
            , n = "function" === typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
            , o = t.useSyncExternalStore
            , i = e.useRef
            , s = e.useEffect
            , a = e.useMemo
            , l = e.useDebugValue;
        return nN.useSyncExternalStoreWithSelector = function (e, t, r, c, d) {
            var u = i(null);
            if (null === u.current) {
                var h = {
                    hasValue: !1,
                    value: null
                };
                u.current = h
            } else
                h = u.current;
            u = a((function () {
                function e(e) {
                    if (!s) {
                        if (s = !0,
                            o = e,
                            e = c(e),
                            void 0 !== d && h.hasValue) {
                            var t = h.value;
                            if (d(t, e))
                                return i = t
                        }
                        return i = e
                    }
                    if (t = i,
                        n(o, e))
                        return t;
                    var r = c(e);
                    return void 0 !== d && d(t, r) ? t : (o = e,
                        i = r)
                }
                var o, i, s = !1, a = void 0 === r ? null : r;
                return [function () {
                    return e(t())
                }
                    , null === a ? void 0 : function () {
                        return e(a())
                    }
                ]
            }
            ), [t, r, c, d]);
            var p = o(e, u[0], u[1]);
            return s((function () {
                h.hasValue = !0,
                    h.value = p
            }
            ), [p]),
                l(p),
                p
        }
            ,
            nN
    }();
    tN.exports;
    const rN = "undefined" === typeof window;
    rN || Boolean("undefined" !== typeof window && window.next);
    const oN = (0,
        r.createContext)({
            editor: null
        });
    oN.Consumer;
    const iN = (0,
        r.createContext)({
            onDragStart: void 0
        })
        , sN = () => (0,
            r.useContext)(iN)
        , aN = r.forwardRef(((e, t) => {
            const { onDragStart: n } = sN()
                , o = e.as || "div";
            return r.createElement(o, {
                ...e,
                ref: t,
                "data-node-view-wrapper": "",
                onDragStart: n,
                style: {
                    whiteSpace: "normal",
                    ...e.style
                }
            })
        }
        ));
    class lN {
        constructor(e, t) {
            let { editor: n, props: r = {}, as: o = "div", className: i = "" } = t;
            this.ref = null,
                this.id = Math.floor(4294967295 * Math.random()).toString(),
                this.component = e,
                this.editor = n,
                this.props = r,
                this.element = document.createElement(o),
                this.element.classList.add("react-renderer"),
                i && this.element.classList.add(...i.split(" ")),
                this.editor.isInitialized ? (0,
                    PE.flushSync)((() => {
                        this.render()
                    }
                    )) : this.render()
        }
        render() {
            var e;
            const t = this.component
                , n = this.props
                , o = this.editor;
            (function (e) {
                return !("function" !== typeof e || !e.prototype || !e.prototype.isReactComponent)
            }(t) || function (e) {
                var t;
                return !("object" !== typeof e || "Symbol(react.forward_ref)" !== (null === (t = e.$$typeof) || void 0 === t ? void 0 : t.toString()))
            }(t)) && (n.ref = e => {
                this.ref = e
            }
                ),
                this.reactElement = r.createElement(t, n),
                null === (e = null === o || void 0 === o ? void 0 : o.contentComponent) || void 0 === e || e.setRenderer(this.id, this)
        }
        updateProps() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.props = {
                ...this.props,
                ...e
            },
                this.render()
        }
        destroy() {
            var e;
            const t = this.editor;
            null === (e = null === t || void 0 === t ? void 0 : t.contentComponent) || void 0 === e || e.removeRenderer(this.id)
        }
        updateAttributes(e) {
            Object.keys(e).forEach((t => {
                this.element.setAttribute(t, e[t])
            }
            ))
        }
    }
    class cN extends ca {
        mount() {
            var e = this;
            const t = {
                editor: this.editor,
                node: this.node,
                decorations: this.decorations,
                innerDecorations: this.innerDecorations,
                view: this.view,
                selected: !1,
                extension: this.extension,
                HTMLAttributes: this.HTMLAttributes,
                getPos: () => this.getPos(),
                updateAttributes: function () {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return e.updateAttributes(t)
                },
                deleteNode: () => this.deleteNode()
            };
            if (!this.component.displayName) {
                const e = e => e.charAt(0).toUpperCase() + e.substring(1);
                this.component.displayName = e(this.extension.name)
            }
            const n = {
                onDragStart: this.onDragStart.bind(this),
                nodeViewContentRef: e => {
                    e && this.contentDOMElement && e.firstChild !== this.contentDOMElement && e.appendChild(this.contentDOMElement)
                }
            }
                , o = this.component
                , i = r.memo((e => r.createElement(iN.Provider, {
                    value: n
                }, r.createElement(o, e))));
            i.displayName = "ReactNodeView",
                this.node.isLeaf ? this.contentDOMElement = null : this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"),
                this.contentDOMElement && (this.contentDOMElement.dataset.nodeViewContentReact = "",
                    this.contentDOMElement.style.whiteSpace = "inherit");
            let s = this.node.isInline ? "span" : "div";
            this.options.as && (s = this.options.as);
            const { className: a = "" } = this.options;
            this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this),
                this.editor.on("selectionUpdate", this.handleSelectionUpdate),
                this.renderer = new lN(i, {
                    editor: this.editor,
                    props: t,
                    as: s,
                    className: `node-${this.node.type.name} ${a}`.trim()
                }),
                this.updateElementAttributes()
        }
        get dom() {
            var e;
            if (this.renderer.element.firstElementChild && !(null === (e = this.renderer.element.firstElementChild) || void 0 === e ? void 0 : e.hasAttribute("data-node-view-wrapper")))
                throw Error("Please use the NodeViewWrapper component for your node view.");
            return this.renderer.element
        }
        get contentDOM() {
            return this.node.isLeaf ? null : this.contentDOMElement
        }
        handleSelectionUpdate() {
            const { from: e, to: t } = this.editor.state.selection
                , n = this.getPos();
            if ("number" === typeof n)
                if (e <= n && t >= n + this.node.nodeSize) {
                    if (this.renderer.props.selected)
                        return;
                    this.selectNode()
                } else {
                    if (!this.renderer.props.selected)
                        return;
                    this.deselectNode()
                }
        }
        update(e, t, n) {
            const r = e => {
                this.renderer.updateProps(e),
                    "function" === typeof this.options.attrs && this.updateElementAttributes()
            }
                ;
            if (e.type !== this.node.type)
                return !1;
            if ("function" === typeof this.options.update) {
                const o = this.node
                    , i = this.decorations
                    , s = this.innerDecorations;
                return this.node = e,
                    this.decorations = t,
                    this.innerDecorations = n,
                    this.options.update({
                        oldNode: o,
                        oldDecorations: i,
                        newNode: e,
                        newDecorations: t,
                        oldInnerDecorations: s,
                        innerDecorations: n,
                        updateProps: () => r({
                            node: e,
                            decorations: t,
                            innerDecorations: n
                        })
                    })
            }
            return e === this.node && this.decorations === t && this.innerDecorations === n || (this.node = e,
                this.decorations = t,
                this.innerDecorations = n,
                r({
                    node: e,
                    decorations: t,
                    innerDecorations: n
                })),
                !0
        }
        selectNode() {
            this.renderer.updateProps({
                selected: !0
            }),
                this.renderer.element.classList.add("ProseMirror-selectednode")
        }
        deselectNode() {
            this.renderer.updateProps({
                selected: !1
            }),
                this.renderer.element.classList.remove("ProseMirror-selectednode")
        }
        destroy() {
            this.renderer.destroy(),
                this.editor.off("selectionUpdate", this.handleSelectionUpdate),
                this.contentDOMElement = null
        }
        updateElementAttributes() {
            if (this.options.attrs) {
                let e = {};
                if ("function" === typeof this.options.attrs) {
                    const t = this.editor.extensionManager.attributes
                        , n = Bi(this.node, t);
                    e = this.options.attrs({
                        node: this.node,
                        HTMLAttributes: n
                    })
                } else
                    e = this.options.attrs;
                this.renderer.updateAttributes(e)
            }
        }
    }
    const dN = (0,
        r.createContext)(void 0);
    function uN(e) {
        return (0,
            r.useContext)(dN)
    }
    function hN(e) {
        const t = uN();
        if (null == t || !t.editor)
            throw new Error("useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component");
        return t.editor
    }
    function pN(e, t, n, o) {
        const { refs: i, update: s, context: a, floatingStyles: l } = RT({
            open: e,
            ...o
        })
            , { isMounted: c, styles: d } = WT(a)
            , u = LT(a)
            , { getReferenceProps: h, getFloatingProps: p } = zT([u]);
        return (0,
            r.useEffect)((() => {
                s()
            }
            ), [t, s]),
            (0,
                r.useEffect)((() => {
                    null !== t && i.setReference({
                        getBoundingClientRect: () => t
                    })
                }
                ), [t, i]),
            (0,
                r.useMemo)((() => ({
                    isMounted: c,
                    ref: i.setFloating,
                    style: {
                        display: "flex",
                        ...d,
                        ...l,
                        zIndex: n
                    },
                    getFloatingProps: p,
                    getReferenceProps: h
                })), [l, c, i.setFloating, d, n, p, h])
    }
    function fN(e) {
        const [t, n] = (0,
            r.useState)();
        return (0,
            r.useEffect)((() => e((e => {
                n({
                    ...e
                })
            }
            ))), [e]),
            t
    }
    const mN = (0,
        r.createContext)(void 0);
    function gN() {
        return (0,
            r.useContext)(mN)
    }
    function bN() {
        return uN().editor.dictionary
    }
    const yN = e => {
        const t = gN()
            , n = bN()
            , { block: o } = e
            , i = hN()
            , [s, a] = (0,
                r.useState)("")
            , l = (0,
                r.useCallback)((e => {
                    a(e.currentTarget.value)
                }
                ), [])
            , c = (0,
                r.useCallback)((e => {
                    "Enter" === e.key && (e.preventDefault(),
                        i.updateBlock(o, {
                            props: {
                                name: Ok(s),
                                url: s
                            }
                        }))
                }
                ), [i, o, s])
            , d = (0,
                r.useCallback)((() => {
                    i.updateBlock(o, {
                        props: {
                            name: Ok(s),
                            url: s
                        }
                    })
                }
                ), [i, o, s]);
        return (0,
            Lx.jsxs)(t.FilePanel.TabPanel, {
                className: "bn-tab-panel",
                children: [(0,
                    Lx.jsx)(t.FilePanel.TextInput, {
                        className: "bn-text-input",
                        placeholder: n.file_panel.embed.url_placeholder,
                        value: s,
                        onChange: l,
                        onKeyDown: c,
                        "data-test": "embed-input"
                    }), (0,
                        Lx.jsx)(t.FilePanel.Button, {
                            className: "bn-button",
                            onClick: d,
                            "data-test": "embed-input-button",
                            children: n.file_panel.embed.embed_button[o.type] || n.file_panel.embed.embed_button.file
                        })]
            })
    }
        , vN = e => {
            var t;
            const n = gN()
                , o = bN()
                , { block: i, setLoading: s } = e
                , a = hN()
                , [l, c] = (0,
                    r.useState)(!1);
            (0,
                r.useEffect)((() => {
                    l && setTimeout((() => {
                        c(!1)
                    }
                    ), 3e3)
                }
                ), [l]);
            const d = (0,
                r.useCallback)((e => {
                    null !== e && async function (e) {
                        if (s(!0),
                            void 0 !== a.uploadFile)
                            try {
                                let t = await a.uploadFile(e);
                                "string" == typeof t && (t = {
                                    props: {
                                        name: e.name,
                                        url: t
                                    }
                                }),
                                    a.updateBlock(i, t)
                            } catch {
                                c(!0)
                            } finally {
                                s(!1)
                            }
                    }(e)
                }
                ), [i, a, s])
                , u = a.schema.blockSchema[i.type]
                , h = u.isFileBlock && null != (t = u.fileBlockAccept) && t.length ? u.fileBlockAccept.join(",") : "*/*";
            return (0,
                Lx.jsxs)(n.FilePanel.TabPanel, {
                    className: "bn-tab-panel",
                    children: [(0,
                        Lx.jsx)(n.FilePanel.FileInput, {
                            className: "bn-file-input",
                            "data-test": "upload-input",
                            accept: h,
                            placeholder: o.file_panel.upload.file_placeholder[i.type] || o.file_panel.upload.file_placeholder.file,
                            value: null,
                            onChange: d
                        }), l && (0,
                            Lx.jsx)("div", {
                                className: "bn-error-text",
                                children: o.file_panel.upload.upload_error
                            })]
                })
        }
        , wN = e => {
            const t = gN()
                , n = bN()
                , o = hN()
                , [i, s] = (0,
                    r.useState)(!1)
                , a = e.tabs ?? [...void 0 !== o.uploadFile ? [{
                    name: n.file_panel.upload.title,
                    tabPanel: (0,
                        Lx.jsx)(vN, {
                            block: e.block,
                            setLoading: s
                        })
                }] : [], {
                    name: n.file_panel.embed.title,
                    tabPanel: (0,
                        Lx.jsx)(yN, {
                            block: e.block
                        })
                }]
                , [l, c] = (0,
                    r.useState)(e.defaultOpenTab || a[0].name);
            return (0,
                Lx.jsx)(t.FilePanel.Root, {
                    className: "bn-panel",
                    defaultOpenTab: l,
                    openTab: l,
                    setOpenTab: c,
                    tabs: a,
                    loading: i
                })
        }
        , kN = e => {
            const t = hN();
            if (!t.filePanel)
                throw new Error("FileToolbarController can only be used when BlockNote editor schema contains file block");
            const n = fN(t.filePanel.onUpdate.bind(t.filePanel))
                , { isMounted: r, ref: o, style: i, getFloatingProps: s } = pN((null == n ? void 0 : n.show) || !1, (null == n ? void 0 : n.referencePos) || null, 5e3, {
                    placement: "bottom",
                    middleware: [AM(10), RM()],
                    onOpenChange: e => {
                        e || (t.filePanel.closeMenu(),
                            t.focus())
                    }
                });
            if (!r || !n)
                return null;
            const { show: a, referencePos: l, ...c } = n
                , d = e.filePanel || wN;
            return (0,
                Lx.jsx)("div", {
                    ref: o,
                    style: i,
                    ...s(),
                    children: (0,
                        Lx.jsx)(d, {
                            ...c
                        })
                })
        }
        ;
    function CN(e, t) {
        const n = uN();
        t || (t = null == n ? void 0 : n.editor),
            (0,
                r.useEffect)((() => {
                    if (!t)
                        throw new Error("'editor' is required, either from BlockNoteContext or as a function argument");
                    return t.onChange(e)
                }
                ), [e, t])
    }
    function SN(e, t) {
        const n = uN();
        t || (t = null == n ? void 0 : n.editor),
            (0,
                r.useEffect)((() => {
                    if (!t)
                        throw new Error("'editor' is required, either from BlockNoteContext or as a function argument");
                    return t.onSelectionChange(e)
                }
                ), [e, t])
    }
    function xN(e, t) {
        CN(e, t),
            SN(e, t)
    }
    var EN = {
        color: void 0,
        size: void 0,
        className: void 0,
        style: void 0,
        attr: void 0
    }
        , MN = r.createContext && r.createContext(EN)
        , TN = ["attr", "size", "title"];
    function NN(e, t) {
        if (null == e)
            return {};
        var n, r, o = function (e, t) {
            if (null == e)
                return {};
            var n = {};
            for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                    if (t.indexOf(r) >= 0)
                        continue;
                    n[r] = e[r]
                }
            return n
        }(e, t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            for (r = 0; r < i.length; r++)
                n = i[r],
                    !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n])
        }
        return o
    }
    function _N() {
        return _N = Object.assign ? Object.assign.bind() : function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
            ,
            _N.apply(this, arguments)
    }
    function ON(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
                n.push.apply(n, r)
        }
        return n
    }
    function AN(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? ON(Object(n), !0).forEach((function (t) {
                PN(e, t, n[t])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ON(Object(n)).forEach((function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            ))
        }
        return e
    }
    function PN(e, t, n) {
        return t = function (e) {
            var t = function (e, t) {
                if ("object" != typeof e || !e)
                    return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(e, t || "default");
                    if ("object" != typeof r)
                        return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === t ? String : Number)(e)
            }(e, "string");
            return "symbol" == typeof t ? t : t + ""
        }(t),
            t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n,
            e
    }
    function LN(e) {
        return e && e.map(((e, t) => r.createElement(e.tag, AN({
            key: t
        }, e.attr), LN(e.child))))
    }
    function RN(e) {
        return t => r.createElement(DN, _N({
            attr: AN({}, e.attr)
        }, t), LN(e.child))
    }
    function DN(e) {
        var t = t => {
            var n, { attr: o, size: i, title: s } = e, a = NN(e, TN), l = i || t.size || "1em";
            return t.className && (n = t.className),
                e.className && (n = (n ? n + " " : "") + e.className),
                r.createElement("svg", _N({
                    stroke: "currentColor",
                    fill: "currentColor",
                    strokeWidth: "0"
                }, t.attr, o, a, {
                    className: n,
                    style: AN(AN({
                        color: e.color || t.color
                    }, t.style), e.style),
                    height: l,
                    width: l,
                    xmlns: "http://www.w3.org/2000/svg"
                }), s && r.createElement("title", null, s), e.children)
        }
            ;
        return void 0 !== MN ? r.createElement(MN.Consumer, null, (e => t(e))) : t(EN)
    }
    function IN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"
                },
                child: []
            }]
        })(e)
    }
    function jN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M5.55397 22H3.3999L10.9999 3H12.9999L20.5999 22H18.4458L16.0458 16H7.95397L5.55397 22ZM8.75397 14H15.2458L11.9999 5.88517L8.75397 14Z"
                },
                child: []
            }]
        })(e)
    }
    function HN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z"
                },
                child: []
            }]
        })(e)
    }
    function zN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z"
                },
                child: []
            }]
        })(e)
    }
    function $N(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z"
                },
                child: []
            }]
        })(e)
    }
    function BN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z"
                },
                child: []
            }]
        })(e)
    }
    function VN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z"
                },
                child: []
            }]
        })(e)
    }
    function FN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M8 5H11V19H8V21H16V19H13V5H16V3H8V5ZM2 7C1.44772 7 1 7.44772 1 8V16C1 16.5523 1.44772 17 2 17H8V15H3V9H8V7H2ZM16 9H21V15H16V17H22C22.5523 17 23 16.5523 23 16V8C23 7.44772 22.5523 7 22 7H16V9Z"
                },
                child: []
            }]
        })(e)
    }
    function UN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z"
                },
                child: []
            }]
        })(e)
    }
    function WN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M18.3638 15.5355L16.9496 14.1213L18.3638 12.7071C20.3164 10.7545 20.3164 7.58866 18.3638 5.63604C16.4112 3.68341 13.2453 3.68341 11.2927 5.63604L9.87849 7.05025L8.46428 5.63604L9.87849 4.22182C12.6122 1.48815 17.0443 1.48815 19.778 4.22182C22.5117 6.95549 22.5117 11.3876 19.778 14.1213L18.3638 15.5355ZM15.5353 18.364L14.1211 19.7782C11.3875 22.5118 6.95531 22.5118 4.22164 19.7782C1.48797 17.0445 1.48797 12.6123 4.22164 9.87868L5.63585 8.46446L7.05007 9.87868L5.63585 11.2929C3.68323 13.2455 3.68323 16.4113 5.63585 18.364C7.58847 20.3166 10.7543 20.3166 12.7069 18.364L14.1211 16.9497L15.5353 18.364ZM14.8282 7.75736L16.2425 9.17157L9.17139 16.2426L7.75717 14.8284L14.8282 7.75736Z"
                },
                child: []
            }]
        })(e)
    }
    function qN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M8.00008 6V9H5.00008V6H8.00008ZM3.00008 4V11H10.0001V4H3.00008ZM13.0001 4H21.0001V6H13.0001V4ZM13.0001 11H21.0001V13H13.0001V11ZM13.0001 18H21.0001V20H13.0001V18ZM10.7072 16.2071L9.29297 14.7929L6.00008 18.0858L4.20718 16.2929L2.79297 17.7071L6.00008 20.9142L10.7072 16.2071Z"
                },
                child: []
            }]
        })(e)
    }
    function GN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z"
                },
                child: []
            }]
        })(e)
    }
    function KN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z"
                },
                child: []
            }]
        })(e)
    }
    function JN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M13 6V21H11V6H5V4H19V6H13Z"
                },
                child: []
            }]
        })(e)
    }
    function ZN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"
                },
                child: []
            }]
        })(e)
    }
    function XN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M21 15V18H24V20H21V23H19V20H16V18H19V15H21ZM21.0082 3C21.556 3 22 3.44495 22 3.9934L22.0007 13.3417C21.3749 13.1204 20.7015 13 20 13V5H4L4.001 19L13.2929 9.70715C13.6528 9.34604 14.22 9.31823 14.6123 9.62322L14.7065 9.70772L18.2521 13.2586C15.791 14.0069 14 16.2943 14 19C14 19.7015 14.1204 20.3749 14.3417 21.0007L2.9918 21C2.44405 21 2 20.5551 2 20.0066V3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082ZM8 7C9.10457 7 10 7.89543 10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7Z"
                },
                child: []
            }]
        })(e)
    }
    function QN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z"
                },
                child: []
            }]
        })(e)
    }
    function YN(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M3 3.9934C3 3.44476 3.44495 3 3.9934 3H20.0066C20.5552 3 21 3.44495 21 3.9934V20.0066C21 20.5552 20.5551 21 20.0066 21H3.9934C3.44476 21 3 20.5551 3 20.0066V3.9934ZM10.6219 8.41459C10.5562 8.37078 10.479 8.34741 10.4 8.34741C10.1791 8.34741 10 8.52649 10 8.74741V15.2526C10 15.3316 10.0234 15.4088 10.0672 15.4745C10.1897 15.6583 10.4381 15.708 10.6219 15.5854L15.5008 12.3328C15.5447 12.3035 15.5824 12.2658 15.6117 12.2219C15.7343 12.0381 15.6846 11.7897 15.5008 11.6672L10.6219 8.41459Z"
                },
                child: []
            }]
        })(e)
    }
    function e_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"
                },
                child: []
            }]
        })(e)
    }
    function t_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M11 11V5H13V11H19V13H13V19H11V13H5V11H11Z"
                },
                child: []
            }]
        })(e)
    }
    function n_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 4V6H15V4H9Z"
                },
                child: []
            }]
        })(e)
    }
    function r_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M4 19H20V12H22V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V12H4V19ZM14 9H19L12 16L5 9H10V3H14V9Z"
                },
                child: []
            }]
        })(e)
    }
    function o_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24",
                fill: "currentColor"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z"
                },
                child: []
            }]
        })(e)
    }
    function i_(e) {
        const t = uN();
        if (e || (e = null == t ? void 0 : t.editor),
            !e)
            throw new Error("'editor' is required, either from BlockNoteContext or as a function argument");
        const n = e
            , [o, i] = (0,
                r.useState)((() => {
                    var e;
                    return (null == (e = n.getSelection()) ? void 0 : e.blocks) || [n.getTextCursorPosition().block]
                }
                ));
        return xN((() => {
            var e;
            return i((null == (e = n.getSelection()) ? void 0 : e.blocks) || [n.getTextCursorPosition().block])
        }
        ), n),
            o
    }
    const s_ = {
        bold: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z"
                    },
                    child: []
                }]
            })(e)
        },
        italic: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z"
                    },
                    child: []
                }]
            })(e)
        },
        underline: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z"
                    },
                    child: []
                }]
            })(e)
        },
        strike: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z"
                    },
                    child: []
                }]
            })(e)
        },
        code: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M23 12L15.9289 19.0711L14.5147 17.6569L20.1716 12L14.5147 6.34317L15.9289 4.92896L23 12ZM3.82843 12L9.48528 17.6569L8.07107 19.0711L1 12L8.07107 4.92896L9.48528 6.34317L3.82843 12Z"
                    },
                    child: []
                }]
            })(e)
        }
    };
    const a_ = e => {
        const t = bN()
            , n = gN()
            , o = hN()
            , i = function (e, t) {
                return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && "boolean" === t.schema.styleSchema[e].propSchema
            }(e.basicTextStyle, o)
            , s = i_(o)
            , [a, l] = (0,
                r.useState)(e.basicTextStyle in o.getActiveStyles());
        xN((() => {
            i && l(e.basicTextStyle in o.getActiveStyles())
        }
        ), o);
        if (!(0,
            r.useMemo)((() => !!i && !!s.find((e => void 0 !== e.content))), [i, s]) || !o.isEditable)
            return null;
        const c = s_[e.basicTextStyle];
        return (0,
            Lx.jsx)(n.FormattingToolbar.Button, {
                className: "bn-button",
                "data-test": e.basicTextStyle,
                onClick: () => (e => {
                    if (o.focus(),
                        i) {
                        if ("boolean" !== o.schema.styleSchema[e].propSchema)
                            throw new Error("can only toggle boolean styles");
                        o.toggleStyles({
                            [e]: !0
                        })
                    }
                }
                )(e.basicTextStyle),
                isSelected: a,
                label: t.formatting_toolbar[e.basicTextStyle].tooltip,
                mainTooltip: t.formatting_toolbar[e.basicTextStyle].tooltip,
                secondaryTooltip: Ck(t.formatting_toolbar[e.basicTextStyle].secondary_tooltip, t.generic.ctrl_shortcut),
                icon: (0,
                    Lx.jsx)(c, {})
            })
    }
        , l_ = e => {
            const t = e.textColor || "default"
                , n = e.backgroundColor || "default"
                , o = e.size || 16
                , i = (0,
                    r.useMemo)((() => ({
                        pointerEvents: "none",
                        fontSize: (.75 * o).toString() + "px",
                        height: o.toString() + "px",
                        lineHeight: o.toString() + "px",
                        textAlign: "center",
                        width: o.toString() + "px"
                    })), [o]);
            return (0,
                Lx.jsx)("div", {
                    className: "bn-color-icon",
                    "data-background-color": n,
                    "data-text-color": t,
                    style: i,
                    children: "A"
                })
        }
        , c_ = ["default", "gray", "brown", "red", "orange", "yellow", "green", "blue", "purple", "pink"]
        , d_ = e => {
            const t = gN()
                , n = bN();
            return (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [(0,
                        Lx.jsx)((() => e.text ? (0,
                            Lx.jsxs)(Lx.Fragment, {
                                children: [(0,
                                    Lx.jsx)(t.Generic.Menu.Label, {
                                        children: n.color_picker.text_title
                                    }), c_.map((r => (0,
                                        Lx.jsx)(t.Generic.Menu.Item, {
                                            onClick: () => {
                                                e.onClick && e.onClick(),
                                                    e.text.setColor(r)
                                            }
                                            ,
                                            "data-test": "text-color-" + r,
                                            icon: (0,
                                                Lx.jsx)(l_, {
                                                    textColor: r,
                                                    size: e.iconSize
                                                }),
                                            checked: e.text.color === r,
                                            children: n.color_picker.colors[r]
                                        }, "text-color-" + r)))]
                            }) : null), {}), (0,
                                Lx.jsx)((() => e.background ? (0,
                                    Lx.jsxs)(Lx.Fragment, {
                                        children: [(0,
                                            Lx.jsx)(t.Generic.Menu.Label, {
                                                children: n.color_picker.background_title
                                            }), c_.map((r => (0,
                                                Lx.jsx)(t.Generic.Menu.Item, {
                                                    onClick: () => {
                                                        e.onClick && e.onClick(),
                                                            e.background.setColor(r)
                                                    }
                                                    ,
                                                    "data-test": "background-color-" + r,
                                                    icon: (0,
                                                        Lx.jsx)(l_, {
                                                            backgroundColor: r,
                                                            size: e.iconSize
                                                        }),
                                                    checked: e.background.color === r,
                                                    children: n.color_picker.colors[r]
                                                }, "background-color-" + r)))]
                                    }) : null), {})]
                })
        }
        ;
    function u_(e, t) {
        return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && "string" === t.schema.styleSchema[`${e}Color`].propSchema
    }
    const h_ = () => {
        const e = gN()
            , t = bN()
            , n = hN()
            , o = u_("text", n)
            , i = u_("background", n)
            , s = i_(n)
            , [a, l] = (0,
                r.useState)(o && n.getActiveStyles().textColor || "default")
            , [c, d] = (0,
                r.useState)(i && n.getActiveStyles().backgroundColor || "default");
        xN((() => {
            o && l(n.getActiveStyles().textColor || "default"),
                i && d(n.getActiveStyles().backgroundColor || "default")
        }
        ), n);
        const u = (0,
            r.useCallback)((e => {
                if (!o)
                    throw Error("Tried to set text color, but style does not exist in editor schema.");
                "default" === e ? n.removeStyles({
                    textColor: e
                }) : n.addStyles({
                    textColor: e
                }),
                    setTimeout((() => {
                        n.focus()
                    }
                    ))
            }
            ), [n, o])
            , h = (0,
                r.useCallback)((e => {
                    if (!i)
                        throw Error("Tried to set background color, but style does not exist in editor schema.");
                    "default" === e ? n.removeStyles({
                        backgroundColor: e
                    }) : n.addStyles({
                        backgroundColor: e
                    }),
                        setTimeout((() => {
                            n.focus()
                        }
                        ))
                }
                ), [i, n]);
        return (0,
            r.useMemo)((() => {
                if (!o && !i)
                    return !1;
                for (const e of s)
                    if (void 0 !== e.content)
                        return !0;
                return !1
            }
            ), [i, s, o]) && n.isEditable ? (0,
                Lx.jsxs)(e.Generic.Menu.Root, {
                    children: [(0,
                        Lx.jsx)(e.Generic.Menu.Trigger, {
                            children: (0,
                                Lx.jsx)(e.FormattingToolbar.Button, {
                                    className: "bn-button",
                                    "data-test": "colors",
                                    label: t.formatting_toolbar.colors.tooltip,
                                    mainTooltip: t.formatting_toolbar.colors.tooltip,
                                    icon: (0,
                                        Lx.jsx)(l_, {
                                            textColor: a,
                                            backgroundColor: c,
                                            size: 20
                                        })
                                })
                        }), (0,
                            Lx.jsx)(e.Generic.Menu.Dropdown, {
                                className: "bn-menu-dropdown bn-color-picker-dropdown",
                                children: (0,
                                    Lx.jsx)(d_, {
                                        text: o ? {
                                            color: a,
                                            setColor: u
                                        } : void 0,
                                        background: i ? {
                                            color: c,
                                            setColor: h
                                        } : void 0
                                    })
                            })]
                }) : null
    }
        , p_ = e => {
            const t = gN()
                , n = bN()
                , { url: o, text: i, editLink: s } = e
                , [a, l] = (0,
                    r.useState)(o)
                , [c, d] = (0,
                    r.useState)(i);
            (0,
                r.useEffect)((() => {
                    l(o),
                        d(i)
                }
                ), [i, o]);
            const u = (0,
                r.useCallback)((e => {
                    "Enter" === e.key && (e.preventDefault(),
                        s(a, c))
                }
                ), [s, a, c])
                , h = (0,
                    r.useCallback)((e => l(e.currentTarget.value)), [])
                , p = (0,
                    r.useCallback)((e => d(e.currentTarget.value)), [])
                , f = (0,
                    r.useCallback)((() => s(a, c)), [s, a, c]);
            return (0,
                Lx.jsxs)(t.Generic.Form.Root, {
                    children: [(0,
                        Lx.jsx)(t.Generic.Form.TextInput, {
                            className: "bn-text-input",
                            name: "url",
                            icon: (0,
                                Lx.jsx)(WN, {}),
                            autoFocus: !0,
                            placeholder: n.link_toolbar.form.url_placeholder,
                            value: a,
                            onKeyDown: u,
                            onChange: h,
                            onSubmit: f
                        }), (0,
                            Lx.jsx)(t.Generic.Form.TextInput, {
                                className: "bn-text-input",
                                name: "title",
                                icon: (0,
                                    Lx.jsx)(JN, {}),
                                placeholder: n.link_toolbar.form.title_placeholder,
                                value: c,
                                onKeyDown: u,
                                onChange: p,
                                onSubmit: f
                            })]
                })
        }
        ;
    const f_ = () => {
        const e = hN()
            , t = gN()
            , n = bN()
            , o = function (e) {
                return "link" in e.schema.inlineContentSchema && "link" === e.schema.inlineContentSchema.link
            }(e)
            , i = i_(e)
            , [s, a] = (0,
                r.useState)(e.getSelectedLinkUrl() || "")
            , [l, c] = (0,
                r.useState)(e.getSelectedText());
        xN((() => {
            c(e.getSelectedText() || ""),
                a(e.getSelectedLinkUrl() || "")
        }
        ), e);
        const d = (0,
            r.useCallback)(((t, n) => {
                e.createLink(t, n),
                    e.focus()
            }
            ), [e]);
        return (0,
            r.useMemo)((() => {
                if (!o)
                    return !1;
                for (const e of i)
                    if (void 0 === e.content)
                        return !1;
                return !0
            }
            ), [o, i]) && "link" in e.schema.inlineContentSchema && e.isEditable ? (0,
                Lx.jsxs)(t.Generic.Popover.Root, {
                    children: [(0,
                        Lx.jsx)(t.Generic.Popover.Trigger, {
                            children: (0,
                                Lx.jsx)(t.FormattingToolbar.Button, {
                                    className: "bn-button",
                                    "data-test": "createLink",
                                    label: n.formatting_toolbar.link.tooltip,
                                    mainTooltip: n.formatting_toolbar.link.tooltip,
                                    secondaryTooltip: Ck(n.formatting_toolbar.link.secondary_tooltip, n.generic.ctrl_shortcut),
                                    icon: (0,
                                        Lx.jsx)(WN, {})
                                })
                        }), (0,
                            Lx.jsx)(t.Generic.Popover.Content, {
                                className: "bn-popover-content bn-form-popover",
                                variant: "form-popover",
                                children: (0,
                                    Lx.jsx)(p_, {
                                        url: s,
                                        text: l,
                                        editLink: d
                                    })
                            })]
                }) : null
    }
        , m_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , [o, i] = (0,
                    r.useState)()
                , s = i_(n)
                , a = (0,
                    r.useMemo)((() => {
                        if (1 !== s.length)
                            return;
                        const e = s[0];
                        return tS(e, n) ? (i(e.props.caption),
                            e) : void 0
                    }
                    ), [n, s])
                , l = (0,
                    r.useCallback)((e => {
                        a && "Enter" === e.key && (e.preventDefault(),
                            n.updateBlock(a, {
                                props: {
                                    caption: o
                                }
                            }))
                    }
                    ), [o, n, a])
                , c = (0,
                    r.useCallback)((e => i(e.currentTarget.value)), []);
            return a && !nS(a, n) && n.isEditable ? (0,
                Lx.jsxs)(t.Generic.Popover.Root, {
                    children: [(0,
                        Lx.jsx)(t.Generic.Popover.Trigger, {
                            children: (0,
                                Lx.jsx)(t.FormattingToolbar.Button, {
                                    className: "bn-button",
                                    label: e.formatting_toolbar.file_caption.tooltip,
                                    mainTooltip: e.formatting_toolbar.file_caption.tooltip,
                                    icon: (0,
                                        Lx.jsx)(FN, {}),
                                    isSelected: "" !== a.props.caption
                                })
                        }), (0,
                            Lx.jsx)(t.Generic.Popover.Content, {
                                className: "bn-popover-content bn-form-popover",
                                variant: "form-popover",
                                children: (0,
                                    Lx.jsx)(t.Generic.Form.Root, {
                                        children: (0,
                                            Lx.jsx)(t.Generic.Form.TextInput, {
                                                name: "file-caption",
                                                icon: (0,
                                                    Lx.jsx)(FN, {}),
                                                value: o || "",
                                                autoFocus: !0,
                                                placeholder: e.formatting_toolbar.file_caption.input_placeholder,
                                                onKeyDown: l,
                                                onChange: c
                                            })
                                    })
                            })]
                }) : null
        }
        , g_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , o = i_(n)
                , i = (0,
                    r.useMemo)((() => {
                        if (1 !== o.length)
                            return;
                        const e = o[0];
                        return tS(e, n) ? e : void 0
                    }
                    ), [n, o])
                , s = (0,
                    r.useCallback)((() => {
                        n.focus(),
                            n.removeBlocks([i])
                    }
                    ), [n, i]);
            return i && !nS(i, n) && n.isEditable ? (0,
                Lx.jsx)(t.FormattingToolbar.Button, {
                    className: "bn-button",
                    label: e.formatting_toolbar.file_delete.tooltip[i.type] || e.formatting_toolbar.file_delete.tooltip.file,
                    mainTooltip: e.formatting_toolbar.file_delete.tooltip[i.type] || e.formatting_toolbar.file_delete.tooltip.file,
                    icon: (0,
                        Lx.jsx)(n_, {}),
                    onClick: s
                }) : null
        }
        , b_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , [o, i] = (0,
                    r.useState)()
                , s = i_(n)
                , a = (0,
                    r.useMemo)((() => {
                        if (1 !== s.length)
                            return;
                        const e = s[0];
                        return tS(e, n) ? (i(e.props.name),
                            e) : void 0
                    }
                    ), [n, s])
                , l = (0,
                    r.useCallback)((e => {
                        a && "Enter" === e.key && (e.preventDefault(),
                            n.updateBlock(a, {
                                props: {
                                    name: o
                                }
                            }))
                    }
                    ), [o, n, a])
                , c = (0,
                    r.useCallback)((e => i(e.currentTarget.value)), []);
            return a && !nS(a, n) && n.isEditable ? (0,
                Lx.jsxs)(t.Generic.Popover.Root, {
                    children: [(0,
                        Lx.jsx)(t.Generic.Popover.Trigger, {
                            children: (0,
                                Lx.jsx)(t.FormattingToolbar.Button, {
                                    className: "bn-button",
                                    label: e.formatting_toolbar.file_rename.tooltip[a.type] || e.formatting_toolbar.file_rename.tooltip.file,
                                    mainTooltip: e.formatting_toolbar.file_rename.tooltip[a.type] || e.formatting_toolbar.file_rename.tooltip.file,
                                    icon: (0,
                                        Lx.jsx)(jN, {})
                                })
                        }), (0,
                            Lx.jsx)(t.Generic.Popover.Content, {
                                className: "bn-popover-content bn-form-popover",
                                variant: "form-popover",
                                children: (0,
                                    Lx.jsx)(t.Generic.Form.Root, {
                                        children: (0,
                                            Lx.jsx)(t.Generic.Form.TextInput, {
                                                name: "file-name",
                                                icon: (0,
                                                    Lx.jsx)(jN, {}),
                                                value: o || "",
                                                autoFocus: !0,
                                                placeholder: e.formatting_toolbar.file_rename.input_placeholder[a.type] || e.formatting_toolbar.file_rename.input_placeholder.file,
                                                onKeyDown: l,
                                                onChange: c
                                            })
                                    })
                            })]
                }) : null
        }
        , y_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , o = i_(n)
                , [i, s] = (0,
                    r.useState)(!1);
            (0,
                r.useEffect)((() => {
                    s(!1)
                }
                ), [o]);
            const a = 1 === o.length ? o[0] : void 0;
            return void 0 !== a && tS(a, n) && n.isEditable ? (0,
                Lx.jsxs)(t.Generic.Popover.Root, {
                    opened: i,
                    position: "bottom",
                    children: [(0,
                        Lx.jsx)(t.Generic.Popover.Trigger, {
                            children: (0,
                                Lx.jsx)(t.FormattingToolbar.Button, {
                                    className: "bn-button",
                                    onClick: () => s(!i),
                                    isSelected: i,
                                    mainTooltip: e.formatting_toolbar.file_replace.tooltip[a.type] || e.formatting_toolbar.file_replace.tooltip.file,
                                    label: e.formatting_toolbar.file_replace.tooltip[a.type] || e.formatting_toolbar.file_replace.tooltip.file,
                                    icon: (0,
                                        Lx.jsx)(QN, {})
                                })
                        }), (0,
                            Lx.jsx)(t.Generic.Popover.Content, {
                                className: "bn-popover-content bn-panel-popover",
                                variant: "panel-popover",
                                children: (0,
                                    Lx.jsx)(wN, {
                                        block: a
                                    })
                            })]
                }) : null
        }
        , v_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , o = i_(n)
                , [i, s] = (0,
                    r.useState)((() => n.canNestBlock()));
            xN((() => {
                s(n.canNestBlock())
            }
            ), n);
            const a = (0,
                r.useCallback)((() => {
                    n.focus(),
                        n.nestBlock()
                }
                ), [n]);
            return (0,
                r.useMemo)((() => !o.find((e => "inline" !== n.schema.blockSchema[e.type].content))), [n.schema.blockSchema, o]) && n.isEditable ? (0,
                    Lx.jsx)(t.FormattingToolbar.Button, {
                        className: "bn-button",
                        "data-test": "nestBlock",
                        onClick: a,
                        isDisabled: !i,
                        label: e.formatting_toolbar.nest.tooltip,
                        mainTooltip: e.formatting_toolbar.nest.tooltip,
                        secondaryTooltip: Ck(e.formatting_toolbar.nest.secondary_tooltip, e.generic.ctrl_shortcut),
                        icon: (0,
                            Lx.jsx)(VN, {})
                    }) : null
        }
        , w_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , o = i_(n)
                , [i, s] = (0,
                    r.useState)((() => n.canUnnestBlock()));
            xN((() => {
                s(n.canUnnestBlock())
            }
            ), n);
            const a = (0,
                r.useCallback)((() => {
                    n.focus(),
                        n.unnestBlock()
                }
                ), [n]);
            return (0,
                r.useMemo)((() => !o.find((e => "inline" !== n.schema.blockSchema[e.type].content))), [n.schema.blockSchema, o]) && n.isEditable ? (0,
                    Lx.jsx)(t.FormattingToolbar.Button, {
                        className: "bn-button",
                        "data-test": "unnestBlock",
                        onClick: a,
                        isDisabled: !i,
                        label: e.formatting_toolbar.unnest.tooltip,
                        mainTooltip: e.formatting_toolbar.unnest.tooltip,
                        secondaryTooltip: Ck(e.formatting_toolbar.unnest.secondary_tooltip, e.generic.ctrl_shortcut),
                        icon: (0,
                            Lx.jsx)(BN, {})
                    }) : null
        }
        , k_ = e => {
            const t = gN()
                , n = bN()
                , o = hN()
                , i = i_(o)
                , [s, a] = (0,
                    r.useState)(o.getTextCursorPosition().block)
                , l = (0,
                    r.useMemo)((() => (e.items || (e => [{
                        name: e.slash_menu.paragraph.title,
                        type: "paragraph",
                        icon: JN,
                        isSelected: e => "paragraph" === e.type
                    }, {
                        name: e.slash_menu.heading.title,
                        type: "heading",
                        props: {
                            level: 1
                        },
                        icon: HN,
                        isSelected: e => "heading" === e.type && "level" in e.props && 1 === e.props.level
                    }, {
                        name: e.slash_menu.heading_2.title,
                        type: "heading",
                        props: {
                            level: 2
                        },
                        icon: zN,
                        isSelected: e => "heading" === e.type && "level" in e.props && 2 === e.props.level
                    }, {
                        name: e.slash_menu.heading_3.title,
                        type: "heading",
                        props: {
                            level: 3
                        },
                        icon: $N,
                        isSelected: e => "heading" === e.type && "level" in e.props && 3 === e.props.level
                    }, {
                        name: e.slash_menu.bullet_list.title,
                        type: "bulletListItem",
                        icon: KN,
                        isSelected: e => "bulletListItem" === e.type
                    }, {
                        name: e.slash_menu.numbered_list.title,
                        type: "numberedListItem",
                        icon: GN,
                        isSelected: e => "numberedListItem" === e.type
                    }, {
                        name: e.slash_menu.check_list.title,
                        type: "checkListItem",
                        icon: qN,
                        isSelected: e => "checkListItem" === e.type
                    }])(n)).filter((e => e.type in o.schema.blockSchema))), [o, n, e.items])
                , c = (0,
                    r.useMemo)((() => void 0 !== l.find((e => e.type === s.type))), [s.type, l])
                , d = (0,
                    r.useMemo)((() => l.map((e => {
                        const t = e.icon;
                        return {
                            text: e.name,
                            icon: (0,
                                Lx.jsx)(t, {
                                    size: 16
                                }),
                            onClick: () => (e => {
                                o.focus();
                                for (const t of i)
                                    o.updateBlock(t, {
                                        type: e.type,
                                        props: e.props
                                    })
                            }
                            )(e),
                            isSelected: e.isSelected(s)
                        }
                    }
                    ))), [s, l, o, i]);
            return xN((() => {
                a(o.getTextCursorPosition().block)
            }
            ), o),
                c && o.isEditable ? (0,
                    Lx.jsx)(t.FormattingToolbar.Select, {
                        className: "bn-select",
                        items: d
                    }) : null
        }
        ;
    function C_(e, t) {
        try {
            const n = new URL(e, t);
            if ("javascript:" !== n.protocol)
                return n.href
        } catch { }
        return "#"
    }
    const S_ = () => {
        const e = bN()
            , t = gN()
            , n = hN()
            , o = i_(n)
            , i = (0,
                r.useMemo)((() => {
                    if (1 !== o.length)
                        return;
                    const e = o[0];
                    return tS(e, n) ? e : void 0
                }
                ), [n, o])
            , s = (0,
                r.useCallback)((() => {
                    i && i.props.url && (n.focus(),
                        n.resolveFileUrl(i.props.url).then((e => window.open(C_(e, window.location.href)))))
                }
                ), [n, i]);
        return !i || nS(i, n) ? null : (0,
            Lx.jsx)(t.FormattingToolbar.Button, {
                className: "bn-button",
                label: e.formatting_toolbar.file_download.tooltip[i.type] || e.formatting_toolbar.file_download.tooltip.file,
                mainTooltip: e.formatting_toolbar.file_download.tooltip[i.type] || e.formatting_toolbar.file_download.tooltip.file,
                icon: (0,
                    Lx.jsx)(r_, {}),
                onClick: s
            })
    }
        , x_ = () => {
            const e = bN()
                , t = gN()
                , n = hN()
                , o = i_(n)
                , i = (0,
                    r.useMemo)((() => {
                        if (1 !== o.length)
                            return;
                        const e = o[0];
                        return function (e, t) {
                            return e.type in t.schema.blockSchema && t.schema.blockSchema[e.type].isFileBlock && "showPreview" in t.schema.blockSchema[e.type].propSchema || !1
                        }(e, n) ? e : void 0
                    }
                    ), [n, o])
                , s = (0,
                    r.useCallback)((() => {
                        i && n.updateBlock(i, {
                            props: {
                                showPreview: !i.props.showPreview
                            }
                        })
                    }
                    ), [n, i]);
            return i && !nS(i, n) && n.isEditable ? (0,
                Lx.jsx)(t.FormattingToolbar.Button, {
                    className: "bn-button",
                    label: "Toggle preview",
                    mainTooltip: e.formatting_toolbar.file_preview_toggle.tooltip,
                    icon: (0,
                        Lx.jsx)(XN, {}),
                    isSelected: i.props.showPreview,
                    onClick: s
                }) : null
        }
        , E_ = {
            left: function (e) {
                return RN({
                    tag: "svg",
                    attr: {
                        viewBox: "0 0 24 24",
                        fill: "currentColor"
                    },
                    child: [{
                        tag: "path",
                        attr: {
                            d: "M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z"
                        },
                        child: []
                    }]
                })(e)
            },
            center: function (e) {
                return RN({
                    tag: "svg",
                    attr: {
                        viewBox: "0 0 24 24",
                        fill: "currentColor"
                    },
                    child: [{
                        tag: "path",
                        attr: {
                            d: "M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z"
                        },
                        child: []
                    }]
                })(e)
            },
            right: function (e) {
                return RN({
                    tag: "svg",
                    attr: {
                        viewBox: "0 0 24 24",
                        fill: "currentColor"
                    },
                    child: [{
                        tag: "path",
                        attr: {
                            d: "M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z"
                        },
                        child: []
                    }]
                })(e)
            },
            justify: function (e) {
                return RN({
                    tag: "svg",
                    attr: {
                        viewBox: "0 0 24 24",
                        fill: "currentColor"
                    },
                    child: [{
                        tag: "path",
                        attr: {
                            d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z"
                        },
                        child: []
                    }]
                })(e)
            }
        }
        , M_ = e => {
            const t = gN()
                , n = bN()
                , o = hN()
                , i = i_(o)
                , s = (0,
                    r.useMemo)((() => {
                        const e = i[0];
                        if (oS("textAlignment", e, o))
                            return e.props.textAlignment
                    }
                    ), [o, i])
                , a = (0,
                    r.useCallback)((e => {
                        o.focus();
                        for (const t of i)
                            rS("textAlignment", t.type, o) && o.updateBlock(t, {
                                props: {
                                    textAlignment: e
                                }
                            })
                    }
                    ), [o, i]);
            if (!(0,
                r.useMemo)((() => !!i.find((e => "textAlignment" in e.props))), [i]) || !o.isEditable)
                return null;
            const l = E_[e.textAlignment];
            return (0,
                Lx.jsx)(t.FormattingToolbar.Button, {
                    className: "bn-button",
                    "data-test": `alignText${e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1)}`,
                    onClick: () => a(e.textAlignment),
                    isSelected: s === e.textAlignment,
                    label: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
                    mainTooltip: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
                    icon: (0,
                        Lx.jsx)(l, {})
                })
        }
        , T_ = e => [(0,
            Lx.jsx)(k_, {
                items: e
            }, "blockTypeSelect"), (0,
                Lx.jsx)(m_, {}, "fileCaptionButton"), (0,
                    Lx.jsx)(y_, {}, "replaceFileButton"), (0,
                        Lx.jsx)(b_, {}, "fileRenameButton"), (0,
                            Lx.jsx)(g_, {}, "fileDeleteButton"), (0,
                                Lx.jsx)(S_, {}, "fileDownloadButton"), (0,
                                    Lx.jsx)(x_, {}, "filePreviewButton"), (0,
                                        Lx.jsx)(a_, {
                                            basicTextStyle: "bold"
                                        }, "boldStyleButton"), (0,
                                            Lx.jsx)(a_, {
                                                basicTextStyle: "italic"
                                            }, "italicStyleButton"), (0,
                                                Lx.jsx)(a_, {
                                                    basicTextStyle: "underline"
                                                }, "underlineStyleButton"), (0,
                                                    Lx.jsx)(a_, {
                                                        basicTextStyle: "strike"
                                                    }, "strikeStyleButton"), (0,
                                                        Lx.jsx)(M_, {
                                                            textAlignment: "left"
                                                        }, "textAlignLeftButton"), (0,
                                                            Lx.jsx)(M_, {
                                                                textAlignment: "center"
                                                            }, "textAlignCenterButton"), (0,
                                                                Lx.jsx)(M_, {
                                                                    textAlignment: "right"
                                                                }, "textAlignRightButton"), (0,
                                                                    Lx.jsx)(h_, {}, "colorStyleButton"), (0,
                                                                        Lx.jsx)(v_, {}, "nestBlockButton"), (0,
                                                                            Lx.jsx)(w_, {}, "unnestBlockButton"), (0,
                                                                                Lx.jsx)(f_, {}, "createLinkButton")]
        , N_ = e => {
            const t = gN();
            return (0,
                Lx.jsx)(t.FormattingToolbar.Root, {
                    className: "bn-toolbar bn-formatting-toolbar",
                    children: e.children || T_(e.blockTypeSelectItems)
                })
        }
        , __ = e => {
            switch (e) {
                case "left":
                default:
                    return "top-start";
                case "center":
                    return "top";
                case "right":
                    return "top-end"
            }
        }
        , O_ = e => {
            const t = (0,
                r.useRef)(null)
                , n = hN()
                , [o, i] = (0,
                    r.useState)((() => {
                        const e = n.getTextCursorPosition().block;
                        return "textAlignment" in e.props ? __(e.props.textAlignment) : "top-start"
                    }
                    ));
            xN((() => {
                const e = n.getTextCursorPosition().block;
                "textAlignment" in e.props ? i(__(e.props.textAlignment)) : i("top-start")
            }
            ), n);
            const s = fN(n.formattingToolbar.onUpdate.bind(n.formattingToolbar))
                , { isMounted: a, ref: l, style: c, getFloatingProps: d } = pN((null == s ? void 0 : s.show) || !1, (null == s ? void 0 : s.referencePos) || null, 3e3, {
                    placement: o,
                    middleware: [AM(10), RM()],
                    onOpenChange: (e, t) => {
                        e || (n.formattingToolbar.closeMenu(),
                            n.focus())
                    }
                })
                , u = (0,
                    r.useMemo)((() => function (e) {
                        return t => {
                            e.forEach((e => {
                                "function" == typeof e ? e(t) : null != e && (e.current = t)
                            }
                            ))
                        }
                    }([t, l])), [t, l]);
            if (!a || !s)
                return null;
            if (!s.show && t.current)
                return (0,
                    Lx.jsx)("div", {
                        ref: u,
                        style: c,
                        dangerouslySetInnerHTML: {
                            __html: t.current.innerHTML
                        }
                    });
            const h = e.formattingToolbar || N_;
            return (0,
                Lx.jsx)("div", {
                    ref: u,
                    style: c,
                    ...d(),
                    children: (0,
                        Lx.jsx)(h, {})
                })
        }
        , A_ = e => {
            const t = gN()
                , n = bN();
            return (0,
                Lx.jsx)(t.LinkToolbar.Button, {
                    className: "bn-button",
                    label: n.link_toolbar.delete.tooltip,
                    mainTooltip: n.link_toolbar.delete.tooltip,
                    isSelected: !1,
                    onClick: e.deleteLink,
                    icon: (0,
                        Lx.jsx)(UN, {})
                })
        }
        , P_ = e => {
            const t = gN()
                , n = bN();
            return (0,
                Lx.jsxs)(t.Generic.Popover.Root, {
                    children: [(0,
                        Lx.jsx)(t.Generic.Popover.Trigger, {
                            children: (0,
                                Lx.jsx)(t.LinkToolbar.Button, {
                                    className: "bn-button",
                                    mainTooltip: n.link_toolbar.edit.tooltip,
                                    isSelected: !1,
                                    children: n.link_toolbar.edit.text
                                })
                        }), (0,
                            Lx.jsx)(t.Generic.Popover.Content, {
                                className: "bn-popover-content bn-form-popover",
                                variant: "form-popover",
                                children: (0,
                                    Lx.jsx)(p_, {
                                        ...e
                                    })
                            })]
                })
        }
        , L_ = e => {
            const t = gN()
                , n = bN();
            return (0,
                Lx.jsx)(t.LinkToolbar.Button, {
                    className: "bn-button",
                    mainTooltip: n.link_toolbar.open.tooltip,
                    label: n.link_toolbar.open.tooltip,
                    isSelected: !1,
                    onClick: () => {
                        window.open(C_(e.url, window.location.href), "_blank")
                    }
                    ,
                    icon: (0,
                        Lx.jsx)(o_, {})
                })
        }
        , R_ = e => {
            const t = gN();
            return e.children ? (0,
                Lx.jsx)(t.LinkToolbar.Root, {
                    className: "bn-toolbar bn-link-toolbar",
                    children: e.children
                }) : (0,
                    Lx.jsxs)(t.LinkToolbar.Root, {
                        className: "bn-toolbar bn-link-toolbar",
                        onMouseEnter: e.stopHideTimer,
                        onMouseLeave: e.startHideTimer,
                        children: [(0,
                            Lx.jsx)(P_, {
                                url: e.url,
                                text: e.text,
                                editLink: e.editLink
                            }), (0,
                                Lx.jsx)(L_, {
                                    url: e.url
                                }), (0,
                                    Lx.jsx)(A_, {
                                        deleteLink: e.deleteLink
                                    })]
                    })
        }
        , D_ = e => {
            const t = hN()
                , n = {
                    deleteLink: t.linkToolbar.deleteLink,
                    editLink: t.linkToolbar.editLink,
                    startHideTimer: t.linkToolbar.startHideTimer,
                    stopHideTimer: t.linkToolbar.stopHideTimer
                }
                , r = fN(t.linkToolbar.onUpdate.bind(t.linkToolbar))
                , { isMounted: o, ref: i, style: s, getFloatingProps: a } = pN((null == r ? void 0 : r.show) || !1, (null == r ? void 0 : r.referencePos) || null, 4e3, {
                    placement: "top-start",
                    middleware: [AM(10), RM()],
                    onOpenChange: e => {
                        e || (t.linkToolbar.closeMenu(),
                            t.focus())
                    }
                });
            if (!o || !r)
                return null;
            const { show: l, referencePos: c, ...d } = r
                , u = e.linkToolbar || R_;
            return (0,
                Lx.jsx)("div", {
                    ref: i,
                    style: s,
                    ...a(),
                    children: (0,
                        Lx.jsx)(u, {
                            ...d,
                            ...n
                        })
                })
        }
        ;
    function I_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 1024 1024"
            },
            child: [{
                tag: "path",
                attr: {
                    d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z"
                },
                child: []
            }, {
                tag: "path",
                attr: {
                    d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z"
                },
                child: []
            }]
        })(e)
    }
    const j_ = e => {
        const t = gN()
            , n = bN()
            , o = hN()
            , i = (0,
                r.useCallback)((() => {
                    const t = e.block.content;
                    if (void 0 !== t && Array.isArray(t) && 0 === t.length)
                        o.setTextCursorPosition(e.block),
                            o.openSuggestionMenu("/");
                    else {
                        const t = o.insertBlocks([{
                            type: "paragraph"
                        }], e.block, "after")[0];
                        o.setTextCursorPosition(t),
                            o.openSuggestionMenu("/")
                    }
                }
                ), [o, e.block]);
        return (0,
            Lx.jsx)(t.SideMenu.Button, {
                className: "bn-button",
                label: n.side_menu.add_block_label,
                icon: (0,
                    Lx.jsx)(I_, {
                        size: 24,
                        onClick: i,
                        "data-test": "dragHandleAdd"
                    })
            })
    }
        ;
    function H_(e) {
        return RN({
            tag: "svg",
            attr: {
                viewBox: "0 0 24 24"
            },
            child: [{
                tag: "path",
                attr: {
                    fill: "none",
                    d: "M0 0h24v24H0V0z"
                },
                child: []
            }, {
                tag: "path",
                attr: {
                    d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
                },
                child: []
            }]
        })(e)
    }
    const z_ = e => {
        const t = gN()
            , n = hN();
        return rS("textColor", e.block.type, n) || rS("backgroundColor", e.block.type, n) ? (0,
            Lx.jsxs)(t.Generic.Menu.Root, {
                position: "right",
                sub: !0,
                children: [(0,
                    Lx.jsx)(t.Generic.Menu.Trigger, {
                        sub: !0,
                        children: (0,
                            Lx.jsx)(t.Generic.Menu.Item, {
                                className: "bn-menu-item",
                                subTrigger: !0,
                                children: e.children
                            })
                    }), (0,
                        Lx.jsx)(t.Generic.Menu.Dropdown, {
                            sub: !0,
                            className: "bn-menu-dropdown bn-color-picker-dropdown",
                            children: (0,
                                Lx.jsx)(d_, {
                                    iconSize: 18,
                                    text: rS("textColor", e.block.type, n) && oS("textColor", e.block, n) ? {
                                        color: e.block.props.textColor,
                                        setColor: t => n.updateBlock(e.block, {
                                            type: e.block.type,
                                            props: {
                                                textColor: t
                                            }
                                        })
                                    } : void 0,
                                    background: rS("backgroundColor", e.block.type, n) && oS("backgroundColor", e.block, n) ? {
                                        color: e.block.props.backgroundColor,
                                        setColor: t => n.updateBlock(e.block, {
                                            props: {
                                                backgroundColor: t
                                            }
                                        })
                                    } : void 0
                                })
                        })]
            }) : null
    }
        , $_ = e => {
            const t = gN()
                , n = hN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Item, {
                    className: "bn-menu-item",
                    onClick: () => n.removeBlocks([e.block]),
                    children: e.children
                })
        }
        , B_ = e => {
            const t = gN()
                , n = bN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Dropdown, {
                    className: "bn-menu-dropdown bn-drag-handle-menu",
                    children: e.children || (0,
                        Lx.jsxs)(Lx.Fragment, {
                            children: [(0,
                                Lx.jsx)($_, {
                                    ...e,
                                    children: n.drag_handle.delete_menuitem
                                }), (0,
                                    Lx.jsx)(z_, {
                                        ...e,
                                        children: n.drag_handle.colors_menuitem
                                    })]
                        })
                })
        }
        , V_ = e => {
            const t = gN()
                , n = bN()
                , r = e.dragHandleMenu || B_;
            return (0,
                Lx.jsxs)(t.Generic.Menu.Root, {
                    onOpenChange: t => {
                        t ? e.freezeMenu() : e.unfreezeMenu()
                    }
                    ,
                    position: "left",
                    children: [(0,
                        Lx.jsx)(t.Generic.Menu.Trigger, {
                            children: (0,
                                Lx.jsx)(t.SideMenu.Button, {
                                    label: n.side_menu.drag_handle_label,
                                    draggable: !0,
                                    onDragStart: e.blockDragStart,
                                    onDragEnd: e.blockDragEnd,
                                    className: "bn-button",
                                    icon: (0,
                                        Lx.jsx)(H_, {
                                            size: 24,
                                            "data-test": "dragHandle"
                                        })
                                })
                        }), (0,
                            Lx.jsx)(r, {
                                block: e.block
                            })]
                })
        }
        , F_ = e => {
            const t = gN()
                , n = (0,
                    r.useMemo)((() => {
                        const t = {
                            "data-block-type": e.block.type
                        };
                        return "heading" === e.block.type && (t["data-level"] = e.block.props.level.toString()),
                            e.editor.schema.blockSchema[e.block.type].isFileBlock && (e.block.props.url ? t["data-url"] = "true" : t["data-url"] = "false"),
                            t
                    }
                    ), [e.block, e.editor.schema.blockSchema]);
            return (0,
                Lx.jsx)(t.SideMenu.Root, {
                    className: "bn-side-menu",
                    ...n,
                    children: e.children || (0,
                        Lx.jsxs)(Lx.Fragment, {
                            children: [(0,
                                Lx.jsx)(j_, {
                                    ...e
                                }), (0,
                                    Lx.jsx)(V_, {
                                        ...e
                                    })]
                        })
                })
        }
        , U_ = e => {
            const t = hN()
                , n = {
                    blockDragStart: t.sideMenu.blockDragStart,
                    blockDragEnd: t.sideMenu.blockDragEnd,
                    freezeMenu: t.sideMenu.freezeMenu,
                    unfreezeMenu: t.sideMenu.unfreezeMenu
                }
                , r = fN(t.sideMenu.onUpdate.bind(t.sideMenu))
                , { isMounted: o, ref: i, style: s, getFloatingProps: a } = pN((null == r ? void 0 : r.show) || !1, (null == r ? void 0 : r.referencePos) || null, 1e3, {
                    placement: "left-start"
                });
            if (!o || !r)
                return null;
            const { show: l, referencePos: c, ...d } = r
                , u = e.sideMenu || F_;
            return (0,
                Lx.jsx)("div", {
                    ref: i,
                    style: s,
                    ...a(),
                    children: (0,
                        Lx.jsx)(u, {
                            ...d,
                            ...n,
                            editor: t
                        })
                })
        }
        ;
    function W_(e) {
        const t = gN()
            , n = bN()
            , { items: o, loadingState: i, selectedIndex: s, onItemClick: a, columns: l } = e
            , c = "loading-initial" === i || "loading" === i ? (0,
                Lx.jsx)(t.GridSuggestionMenu.Loader, {
                    className: "bn-grid-suggestion-menu-loader",
                    columns: l,
                    children: n.suggestion_menu.loading
                }) : null
            , d = (0,
                r.useMemo)((() => {
                    const e = [];
                    for (let n = 0; n < o.length; n++) {
                        const r = o[n];
                        e.push((0,
                            Lx.jsx)(t.GridSuggestionMenu.Item, {
                                className: "bn-grid-suggestion-menu-item",
                                item: r,
                                id: `bn-grid-suggestion-menu-item-${n}`,
                                isSelected: n === s,
                                onClick: () => null == a ? void 0 : a(r)
                            }, r.id))
                    }
                    return e
                }
                ), [t, o, a, s]);
        return (0,
            Lx.jsxs)(t.GridSuggestionMenu.Root, {
                id: "bn-grid-suggestion-menu",
                columns: l,
                className: "bn-grid-suggestion-menu",
                children: [c, d, 0 === d.length && "loaded" === e.loadingState && (0,
                    Lx.jsx)(t.GridSuggestionMenu.EmptyItem, {
                        className: "bn-grid-suggestion-menu-empty-item",
                        columns: l,
                        children: n.suggestion_menu.no_items_title
                    })]
            })
    }
    function q_(e, t, n) {
        let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 3;
        const i = (0,
            r.useRef)(0);
        (0,
            r.useEffect)((() => {
                void 0 !== t && (e.length > 0 ? i.current = t.length : t.length - i.current > o && n())
            }
            ), [n, o, e.length, t])
    }
    function G_(e, t) {
        const [n, o] = (0,
            r.useState)([])
            , [i, s] = (0,
                r.useState)(!1)
            , a = (0,
                r.useRef)()
            , l = (0,
                r.useRef)();
        return (0,
            r.useEffect)((() => {
                const n = e;
                a.current = e,
                    s(!0),
                    t(e).then((e => {
                        a.current === n && (o(e),
                            s(!1),
                            l.current = n)
                    }
                    ))
            }
            ), [e, t]),
        {
            items: n || [],
            usedQuery: l.current,
            loadingState: void 0 === l.current ? "loading-initial" : i ? "loading" : "loaded"
        }
    }
    function K_(e) {
        const t = uN().setContentEditableProps
            , n = hN()
            , { getItems: o, gridSuggestionMenuComponent: i, query: s, clearQuery: a, closeMenu: l, onItemClick: c, columns: d } = e
            , u = (0,
                r.useCallback)((e => {
                    l(),
                        a(),
                        null == c || c(e)
                }
                ), [c, l, a])
            , { items: h, usedQuery: p, loadingState: f } = G_(s, o);
        q_(h, p, l);
        const { selectedIndex: m } = function (e, t, n, o, i) {
            const [s, a] = (0,
                r.useState)(0)
                , l = void 0 !== o && o > 1;
            return (0,
                r.useEffect)((() => {
                    const t = e => ("ArrowLeft" === e.key && (e.preventDefault(),
                        n.length && a((s - 1 + n.length) % n.length)),
                        "ArrowRight" === e.key && (e.preventDefault(),
                            n.length && a((s + 1 + n.length) % n.length)),
                        "ArrowUp" === e.key ? (e.preventDefault(),
                            n.length && a((s - o + n.length) % n.length),
                            !0) : "ArrowDown" === e.key ? (e.preventDefault(),
                                n.length && a((s + o) % n.length),
                                !0) : "Enter" === e.key && !e.isComposing && (e.preventDefault(),
                                    n.length && (null == i || i(n[s])),
                                    !0));
                    return e.domElement.addEventListener("keydown", t, !0),
                        () => {
                            e.domElement.removeEventListener("keydown", t, !0)
                        }
                }
                ), [e.domElement, n, s, i, o, l]),
                (0,
                    r.useEffect)((() => {
                        a(0)
                    }
                    ), [t]),
            {
                selectedIndex: 0 === n.length ? void 0 : s
            }
        }(n, s, h, d, u);
        return (0,
            r.useEffect)((() => (t((e => ({
                ...e,
                "aria-expanded": !0,
                "aria-controls": "bn-suggestion-menu"
            }))),
                () => {
                    t((e => ({
                        ...e,
                        "aria-expanded": !1,
                        "aria-controls": void 0
                    })))
                }
            )), [t]),
            (0,
                r.useEffect)((() => (t((e => ({
                    ...e,
                    "aria-activedescendant": m ? "bn-suggestion-menu-item-" + m : void 0
                }))),
                    () => {
                        t((e => ({
                            ...e,
                            "aria-activedescendant": void 0
                        })))
                    }
                )), [t, m]),
            (0,
                Lx.jsx)(i, {
                    items: h,
                    onItemClick: u,
                    loadingState: f,
                    selectedIndex: m,
                    columns: d
                })
    }
    function J_(e) {
        const t = hN()
            , { triggerCharacter: n, gridSuggestionMenuComponent: o, columns: i, minQueryLength: s, onItemClick: a, getItems: l } = e
            , c = (0,
                r.useMemo)((() => a || (e => {
                    e.onItemClick(t)
                }
                )), [t, a])
            , d = (0,
                r.useMemo)((() => l || (async e => await async function (e, t) {
                    return (await Ox(e, t)).map((e => {
                        let { id: t, onItemClick: n } = e;
                        return {
                            id: t,
                            onItemClick: n,
                            icon: t
                        }
                    }
                    ))
                }(t, e))), [t, l])
            , u = {
                closeMenu: t.suggestionMenus.closeMenu,
                clearQuery: t.suggestionMenus.clearQuery
            }
            , h = (0,
                r.useCallback)((e => t.suggestionMenus.onUpdate(n, e)), [t.suggestionMenus, n])
            , p = fN(h)
            , { isMounted: f, ref: m, style: g, getFloatingProps: b } = pN((null == p ? void 0 : p.show) || !1, (null == p ? void 0 : p.referencePos) || null, 2e3, {
                placement: "bottom-start",
                middleware: [AM(10), RM(), DM({
                    apply(e) {
                        let { availableHeight: t, elements: n } = e;
                        Object.assign(n.floating.style, {
                            maxHeight: t - 10 + "px"
                        })
                    }
                })],
                onOpenChange(e) {
                    e || t.suggestionMenus.closeMenu()
                }
            });
        return f && p && (null != p && p.ignoreQueryLength || !s || !(p.query.startsWith(" ") || p.query.length < s)) ? (0,
            Lx.jsx)("div", {
                ref: m,
                style: g,
                ...b(),
                children: (0,
                    Lx.jsx)(K_, {
                        query: p.query,
                        closeMenu: u.closeMenu,
                        clearQuery: u.clearQuery,
                        getItems: d,
                        columns: i,
                        gridSuggestionMenuComponent: o || W_,
                        onItemClick: c
                    })
            }) : null
    }
    function Z_(e) {
        const t = gN()
            , n = bN()
            , { items: o, loadingState: i, selectedIndex: s, onItemClick: a } = e
            , l = "loading-initial" === i || "loading" === i ? (0,
                Lx.jsx)(t.SuggestionMenu.Loader, {
                    className: "bn-suggestion-menu-loader",
                    children: n.suggestion_menu.loading
                }) : null
            , c = (0,
                r.useMemo)((() => {
                    let e;
                    const n = [];
                    for (let r = 0; r < o.length; r++) {
                        const i = o[r];
                        i.group !== e && (e = i.group,
                            n.push((0,
                                Lx.jsx)(t.SuggestionMenu.Label, {
                                    className: "bn-suggestion-menu-label",
                                    children: e
                                }, e))),
                            n.push((0,
                                Lx.jsx)(t.SuggestionMenu.Item, {
                                    className: "bn-suggestion-menu-item",
                                    item: i,
                                    id: `bn-suggestion-menu-item-${r}`,
                                    isSelected: r === s,
                                    onClick: () => null == a ? void 0 : a(i)
                                }, i.title))
                    }
                    return n
                }
                ), [t, o, a, s]);
        return (0,
            Lx.jsxs)(t.SuggestionMenu.Root, {
                id: "bn-suggestion-menu",
                className: "bn-suggestion-menu",
                children: [c, 0 === c.length && ("loading" === e.loadingState || "loaded" === e.loadingState) && (0,
                    Lx.jsx)(t.SuggestionMenu.EmptyItem, {
                        className: "bn-suggestion-menu-item",
                        children: n.suggestion_menu.no_items_title
                    }), l]
            })
    }
    function X_(e) {
        const t = uN().setContentEditableProps
            , n = hN()
            , { getItems: o, suggestionMenuComponent: i, query: s, clearQuery: a, closeMenu: l, onItemClick: c } = e
            , d = (0,
                r.useCallback)((e => {
                    l(),
                        a(),
                        null == c || c(e)
                }
                ), [c, l, a])
            , { items: u, usedQuery: h, loadingState: p } = G_(s, o);
        q_(u, h, l);
        const { selectedIndex: f } = function (e, t, n, o) {
            const [i, s] = (0,
                r.useState)(0);
            return (0,
                r.useEffect)((() => {
                    const t = e => "ArrowUp" === e.key ? (e.preventDefault(),
                        n.length && s((i - 1 + n.length) % n.length),
                        !0) : "ArrowDown" === e.key ? (e.preventDefault(),
                            n.length && s((i + 1) % n.length),
                            !0) : "Enter" === e.key && !e.isComposing && (e.preventDefault(),
                                n.length && (null == o || o(n[i])),
                                !0);
                    return e.domElement.addEventListener("keydown", t, !0),
                        () => {
                            e.domElement.removeEventListener("keydown", t, !0)
                        }
                }
                ), [e.domElement, n, i, o]),
                (0,
                    r.useEffect)((() => {
                        s(0)
                    }
                    ), [t]),
            {
                selectedIndex: 0 === n.length ? void 0 : i
            }
        }(n, s, u, d);
        return (0,
            r.useEffect)((() => (t((e => ({
                ...e,
                "aria-expanded": !0,
                "aria-controls": "bn-suggestion-menu"
            }))),
                () => {
                    t((e => ({
                        ...e,
                        "aria-expanded": !1,
                        "aria-controls": void 0
                    })))
                }
            )), [t]),
            (0,
                r.useEffect)((() => (t((e => ({
                    ...e,
                    "aria-activedescendant": f ? "bn-suggestion-menu-item-" + f : void 0
                }))),
                    () => {
                        t((e => ({
                            ...e,
                            "aria-activedescendant": void 0
                        })))
                    }
                )), [t, f]),
            (0,
                Lx.jsx)(i, {
                    items: u,
                    onItemClick: d,
                    loadingState: p,
                    selectedIndex: f
                })
    }
    const Q_ = {
        heading: HN,
        heading_2: zN,
        heading_3: $N,
        numbered_list: GN,
        bullet_list: KN,
        check_list: qN,
        paragraph: JN,
        table: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z"
                    },
                    child: []
                }]
            })(e)
        },
        image: ZN,
        video: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"
                    },
                    child: []
                }]
            })(e)
        },
        audio: e_,
        file: IN,
        emoji: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM8 13C8 15.2091 9.79086 17 12 17C14.2091 17 16 15.2091 16 13H8ZM8 11C8.82843 11 9.5 10.3284 9.5 9.5C9.5 8.67157 8.82843 8 8 8C7.17157 8 6.5 8.67157 6.5 9.5C6.5 10.3284 7.17157 11 8 11ZM16 11C16.8284 11 17.5 10.3284 17.5 9.5C17.5 8.67157 16.8284 8 16 8C15.1716 8 14.5 8.67157 14.5 9.5C14.5 10.3284 15.1716 11 16 11Z"
                    },
                    child: []
                }]
            })(e)
        },
        code_block: function (e) {
            return RN({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M3.41436 5.99995L5.70726 3.70706L4.29304 2.29285L0.585938 5.99995L4.29304 9.70706L5.70726 8.29285L3.41436 5.99995ZM9.58594 5.99995L7.29304 3.70706L8.70726 2.29285L12.4144 5.99995L8.70726 9.70706L7.29304 8.29285L9.58594 5.99995ZM14.0002 2.99995H21.0002C21.5524 2.99995 22.0002 3.44767 22.0002 3.99995V20C22.0002 20.5522 21.5524 21 21.0002 21H3.00015C2.44787 21 2.00015 20.5522 2.00015 20V12H4.00015V19H20.0002V4.99995H14.0002V2.99995Z"
                    },
                    child: []
                }]
            })(e)
        }
    };
    function Y_(e) {
        return function (e) {
            const t = [];
            return eS("heading", e) && t.push({
                onItemClick: () => {
                    Ax(e, {
                        type: "heading",
                        props: {
                            level: 1
                        }
                    })
                }
                ,
                badge: Ck("Mod-Alt-1"),
                key: "heading",
                ...e.dictionary.slash_menu.heading
            }, {
                onItemClick: () => {
                    Ax(e, {
                        type: "heading",
                        props: {
                            level: 2
                        }
                    })
                }
                ,
                badge: Ck("Mod-Alt-2"),
                key: "heading_2",
                ...e.dictionary.slash_menu.heading_2
            }, {
                onItemClick: () => {
                    Ax(e, {
                        type: "heading",
                        props: {
                            level: 3
                        }
                    })
                }
                ,
                badge: Ck("Mod-Alt-3"),
                key: "heading_3",
                ...e.dictionary.slash_menu.heading_3
            }),
                eS("numberedListItem", e) && t.push({
                    onItemClick: () => {
                        Ax(e, {
                            type: "numberedListItem"
                        })
                    }
                    ,
                    badge: Ck("Mod-Shift-7"),
                    key: "numbered_list",
                    ...e.dictionary.slash_menu.numbered_list
                }),
                eS("bulletListItem", e) && t.push({
                    onItemClick: () => {
                        Ax(e, {
                            type: "bulletListItem"
                        })
                    }
                    ,
                    badge: Ck("Mod-Shift-8"),
                    key: "bullet_list",
                    ...e.dictionary.slash_menu.bullet_list
                }),
                eS("checkListItem", e) && t.push({
                    onItemClick: () => {
                        Ax(e, {
                            type: "checkListItem"
                        })
                    }
                    ,
                    badge: Ck("Mod-Shift-9"),
                    key: "check_list",
                    ...e.dictionary.slash_menu.check_list
                }),
                eS("paragraph", e) && t.push({
                    onItemClick: () => {
                        Ax(e, {
                            type: "paragraph"
                        })
                    }
                    ,
                    badge: Ck("Mod-Alt-0"),
                    key: "paragraph",
                    ...e.dictionary.slash_menu.paragraph
                }),
                eS("codeBlock", e) && t.push({
                    onItemClick: () => {
                        const t = e._tiptapEditor.state.selection.from;
                        Ax(e, {
                            type: "codeBlock"
                        }),
                            e._tiptapEditor.commands.setTextSelection(t)
                    }
                    ,
                    badge: Ck("Mod-Alt-c"),
                    key: "code_block",
                    ...e.dictionary.slash_menu.code_block
                }),
                eS("table", e) && t.push({
                    onItemClick: () => {
                        Ax(e, {
                            type: "table",
                            content: {
                                type: "tableContent",
                                rows: [{
                                    cells: ["", "", ""]
                                }, {
                                    cells: ["", "", ""]
                                }]
                            }
                        })
                    }
                    ,
                    badge: void 0,
                    key: "table",
                    ...e.dictionary.slash_menu.table
                }),
                eS("image", e) && t.push({
                    onItemClick: () => {
                        const t = Ax(e, {
                            type: "image"
                        });
                        e.dispatch(e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {
                            block: t
                        }))
                    }
                    ,
                    key: "image",
                    ...e.dictionary.slash_menu.image
                }),
                eS("video", e) && t.push({
                    onItemClick: () => {
                        const t = Ax(e, {
                            type: "video"
                        });
                        e.dispatch(e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {
                            block: t
                        }))
                    }
                    ,
                    key: "video",
                    ...e.dictionary.slash_menu.video
                }),
                eS("audio", e) && t.push({
                    onItemClick: () => {
                        const t = Ax(e, {
                            type: "audio"
                        });
                        e.dispatch(e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {
                            block: t
                        }))
                    }
                    ,
                    key: "audio",
                    ...e.dictionary.slash_menu.audio
                }),
                eS("file", e) && t.push({
                    onItemClick: () => {
                        const t = Ax(e, {
                            type: "file"
                        });
                        e.dispatch(e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {
                            block: t
                        }))
                    }
                    ,
                    key: "file",
                    ...e.dictionary.slash_menu.file
                }),
                t.push({
                    onItemClick: () => {
                        e.openSuggestionMenu(":", {
                            deleteTriggerCharacter: !0,
                            ignoreQueryLength: !0
                        })
                    }
                    ,
                    key: "emoji",
                    ...e.dictionary.slash_menu.emoji
                }),
                t
        }(e).map((e => {
            const t = Q_[e.key];
            return {
                ...e,
                icon: (0,
                    Lx.jsx)(t, {
                        size: 18
                    })
            }
        }
        ))
    }
    function eO(e) {
        const t = hN()
            , { triggerCharacter: n, suggestionMenuComponent: o, minQueryLength: i, onItemClick: s, getItems: a } = e
            , l = (0,
                r.useMemo)((() => s || (e => {
                    e.onItemClick(t)
                }
                )), [t, s])
            , c = (0,
                r.useMemo)((() => a || (async e => Px(Y_(t), e))), [t, a])
            , d = {
                closeMenu: t.suggestionMenus.closeMenu,
                clearQuery: t.suggestionMenus.clearQuery
            }
            , u = fN((0,
                r.useCallback)((e => t.suggestionMenus.onUpdate(n, e)), [t.suggestionMenus, n]))
            , { isMounted: h, ref: p, style: f, getFloatingProps: m } = pN((null == u ? void 0 : u.show) || !1, (null == u ? void 0 : u.referencePos) || null, 2e3, {
                placement: "bottom-start",
                middleware: [AM(10), RM({
                    mainAxis: !0,
                    crossAxis: !1
                }), PM(), DM({
                    apply(e) {
                        let { availableHeight: t, elements: n } = e;
                        Object.assign(n.floating.style, {
                            maxHeight: t - 10 + "px"
                        })
                    }
                })],
                onOpenChange(e) {
                    e || t.suggestionMenus.closeMenu()
                }
            });
        return h && u && (null != u && u.ignoreQueryLength || !i || !(u.query.startsWith(" ") || u.query.length < i)) ? (0,
            Lx.jsx)("div", {
                ref: p,
                style: f,
                ...m(),
                children: (0,
                    Lx.jsx)(X_, {
                        query: u.query,
                        closeMenu: d.closeMenu,
                        clearQuery: d.clearQuery,
                        getItems: c,
                        suggestionMenuComponent: o || Z_,
                        onItemClick: l
                    })
            }) : null
    }
    function tO(e, t) {
        let n = 0;
        if ("columns" === t)
            for (let o = e.rows[0].cells.length - 1; o >= 0 && e.rows.every((e => 0 === e.cells[o].length)); o--)
                n++;
        const r = [];
        for (let o = e.rows.length - 1; o >= 0; o--)
            "rows" === t && 0 === r.length && e.rows[o].cells.every((e => 0 === e.length)) || r.unshift({
                cells: e.rows[o].cells.slice(0, e.rows[0].cells.length - n)
            });
        return {
            ...e,
            rows: r
        }
    }
    const nO = (e, t, n) => {
        const r = {
            cells: Array(n).fill([])
        }
            , o = [];
        for (let i = 0; i < t; i++)
            o.push(r);
        return {
            type: "tableContent",
            columnWidths: e.columnWidths,
            rows: [...e.rows, ...o]
        }
    }
        , rO = (e, t) => {
            const n = []
                , r = [];
            for (let o = 0; o < t; o++)
                r.push(n);
            return {
                type: "tableContent",
                columnWidths: e.columnWidths ? [...e.columnWidths, ...r.map((() => { }
                ))] : void 0,
                rows: e.rows.map((e => ({
                    cells: [...e.cells, ...r]
                })))
            }
        }
        , oO = e => {
            const t = gN()
                , n = (0,
                    r.useRef)(!1)
                , [o, i] = (0,
                    r.useState)()
                , s = (0,
                    r.useCallback)((t => {
                        e.onMouseDown(),
                            i({
                                originalContent: e.block.content,
                                originalCroppedContent: tO(e.block.content, "addOrRemoveColumns" === e.orientation ? "columns" : "rows"),
                                startPos: "addOrRemoveColumns" === e.orientation ? t.clientX : t.clientY
                            }),
                            n.current = !1,
                            t.preventDefault()
                    }
                    ), [e])
                , a = (0,
                    r.useCallback)((() => {
                        n.current || e.editor.updateBlock(e.block, {
                            type: "table",
                            content: "addOrRemoveColumns" === e.orientation ? rO(e.block.content, 1) : nO(e.block.content, 1, e.block.content.rows[0].cells.length)
                        })
                    }
                    ), [e.block, e.orientation, e.editor]);
            return (0,
                r.useEffect)((() => {
                    const t = t => {
                        var r, i;
                        if (!o)
                            throw new Error("editingState is undefined");
                        n.current = !0;
                        const s = ("addOrRemoveColumns" === e.orientation ? t.clientX : t.clientY) - o.startPos
                            , a = "addOrRemoveColumns" === e.orientation ? (null == (r = o.originalCroppedContent.rows[0]) ? void 0 : r.cells.length) ?? 0 : o.originalCroppedContent.rows.length
                            , l = "addOrRemoveColumns" === e.orientation ? (null == (i = o.originalContent.rows[0]) ? void 0 : i.cells.length) ?? 0 : o.originalContent.rows.length
                            , c = "addOrRemoveColumns" === e.orientation ? e.block.content.rows[0].cells.length : e.block.content.rows.length
                            , d = l + function (e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3;
                                const n = Math.floor(e) + t
                                    , r = Math.ceil(e) - t;
                                return e >= n && e <= r ? Math.round(e) : e < n ? Math.floor(e) : Math.ceil(e)
                            }(s / ("addOrRemoveColumns" === e.orientation ? 120 : 31), .3);
                        d >= a && d > 0 && d !== c && (e.editor.updateBlock(e.block, {
                            type: "table",
                            content: "addOrRemoveColumns" === e.orientation ? rO(o.originalCroppedContent, d - a) : nO(o.originalCroppedContent, d - a, o.originalContent.rows[0].cells.length)
                        }),
                            e.block.content && e.editor.setTextCursorPosition(e.block))
                    }
                        ;
                    return o && window.addEventListener("mousemove", t),
                        () => {
                            window.removeEventListener("mousemove", t)
                        }
                }
                ), [o, e.block, e.editor, e.orientation]),
                (0,
                    r.useEffect)((() => {
                        const t = e.onMouseUp
                            , n = () => {
                                i(void 0),
                                    t()
                            }
                            ;
                        return o && window.addEventListener("mouseup", n),
                            () => {
                                window.removeEventListener("mouseup", n)
                            }
                    }
                    ), [o, e.onMouseUp]),
                (0,
                    Lx.jsx)(t.TableHandle.ExtendButton, {
                        className: Sk("bn-extend-button", "addOrRemoveColumns" === e.orientation ? "bn-extend-button-add-remove-columns" : "bn-extend-button-add-remove-rows", null !== o ? "bn-extend-button-editing" : ""),
                        onClick: a,
                        onMouseDown: s,
                        children: e.children || (0,
                            Lx.jsx)(t_, {
                                size: 18,
                                "data-test": "extendButton"
                            })
                    })
        }
        , iO = e => {
            const t = gN()
                , n = bN()
                , r = hN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Item, {
                    onClick: () => {
                        const t = e.block.content.rows[e.index].cells.map((() => []))
                            , n = [...e.block.content.rows];
                        n.splice(e.index + ("below" === e.side ? 1 : 0), 0, {
                            cells: t
                        }),
                            r.updateBlock(e.block, {
                                type: "table",
                                content: {
                                    type: "tableContent",
                                    columnWidths: e.block.content.columnWidths,
                                    rows: n
                                }
                            }),
                            r.setTextCursorPosition(e.block)
                    }
                    ,
                    children: n.table_handle[`add_${e.side}_menuitem`]
                })
        }
        , sO = e => {
            const t = gN()
                , n = bN()
                , r = hN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Item, {
                    onClick: () => {
                        const t = [...e.block.content.columnWidths];
                        t.splice(e.index + ("right" === e.side ? 1 : 0), 0, void 0);
                        const n = {
                            type: "tableContent",
                            columnWidths: t,
                            rows: e.block.content.rows.map((t => {
                                const n = [...t.cells];
                                return n.splice(e.index + ("right" === e.side ? 1 : 0), 0, []),
                                {
                                    cells: n
                                }
                            }
                            ))
                        };
                        r.updateBlock(e.block, {
                            type: "table",
                            content: n
                        }),
                            r.setTextCursorPosition(e.block)
                    }
                    ,
                    children: n.table_handle[`add_${e.side}_menuitem`]
                })
        }
        , aO = e => "row" === e.orientation ? (0,
            Lx.jsx)(iO, {
                ...e,
                side: e.side
            }) : (0,
                Lx.jsx)(sO, {
                    ...e,
                    side: e.side
                })
        , lO = e => {
            const t = gN()
                , n = bN()
                , r = hN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Item, {
                    onClick: () => {
                        const t = {
                            type: "tableContent",
                            columnWidths: e.block.content.columnWidths,
                            rows: e.block.content.rows.filter(((t, n) => n !== e.index))
                        };
                        r.updateBlock(e.block, {
                            type: "table",
                            content: t
                        }),
                            r.setTextCursorPosition(e.block)
                    }
                    ,
                    children: n.table_handle.delete_row_menuitem
                })
        }
        , cO = e => {
            const t = gN()
                , n = bN()
                , r = hN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Item, {
                    onClick: () => {
                        const t = {
                            type: "tableContent",
                            columnWidths: e.block.content.columnWidths.filter(((t, n) => n !== e.index)),
                            rows: e.block.content.rows.map((t => ({
                                cells: t.cells.filter(((t, n) => n !== e.index))
                            })))
                        };
                        r.updateBlock(e.block, {
                            type: "table",
                            content: t
                        }),
                            r.setTextCursorPosition(e.block)
                    }
                    ,
                    children: n.table_handle.delete_column_menuitem
                })
        }
        , dO = e => "row" === e.orientation ? (0,
            Lx.jsx)(lO, {
                ...e
            }) : (0,
                Lx.jsx)(cO, {
                    ...e
                })
        , uO = e => {
            const t = gN();
            return (0,
                Lx.jsx)(t.Generic.Menu.Dropdown, {
                    className: "bn-table-handle-menu",
                    children: e.children || (0,
                        Lx.jsxs)(Lx.Fragment, {
                            children: [(0,
                                Lx.jsx)(dO, {
                                    orientation: e.orientation,
                                    block: e.block,
                                    index: e.index
                                }), (0,
                                    Lx.jsx)(aO, {
                                        orientation: e.orientation,
                                        block: e.block,
                                        index: e.index,
                                        side: "row" === e.orientation ? "above" : "left"
                                    }), (0,
                                        Lx.jsx)(aO, {
                                            orientation: e.orientation,
                                            block: e.block,
                                            index: e.index,
                                            side: "row" === e.orientation ? "below" : "right"
                                        })]
                        })
                })
        }
        , hO = e => {
            const t = gN()
                , [n, o] = (0,
                    r.useState)(!1)
                , i = e.tableHandleMenu || uO;
            return (0,
                Lx.jsxs)(t.Generic.Menu.Root, {
                    onOpenChange: t => {
                        t ? (e.freezeHandles(),
                            e.hideOtherSide()) : (e.unfreezeHandles(),
                                e.showOtherSide(),
                                e.editor.focus())
                    }
                    ,
                    position: "right",
                    children: [(0,
                        Lx.jsx)(t.Generic.Menu.Trigger, {
                            children: (0,
                                Lx.jsx)(t.TableHandle.Root, {
                                    className: Sk("bn-table-handle", n ? "bn-table-handle-dragging" : ""),
                                    draggable: !0,
                                    onDragStart: t => {
                                        o(!0),
                                            e.dragStart(t)
                                    }
                                    ,
                                    onDragEnd: () => {
                                        e.dragEnd(),
                                            o(!1)
                                    }
                                    ,
                                    style: "column" === e.orientation ? {
                                        transform: "rotate(0.25turn)"
                                    } : void 0,
                                    children: e.children || (0,
                                        Lx.jsx)(H_, {
                                            size: 24,
                                            "data-test": "tableHandle"
                                        })
                                })
                        }), (0,
                            PE.createPortal)((0,
                                Lx.jsx)(i, {
                                    orientation: e.orientation,
                                    block: e.block,
                                    index: e.index
                                }), e.menuContainer)]
                })
        }
        ;
    function pO(e, t, n) {
        const { refs: o, update: i, context: s, floatingStyles: a } = RT({
            open: t,
            placement: "addOrRemoveColumns" === e ? "right" : "bottom",
            middleware: [DM({
                apply(t) {
                    let { rects: n, elements: r } = t;
                    Object.assign(r.floating.style, "addOrRemoveColumns" === e ? {
                        height: `${n.reference.height}px`
                    } : {
                        width: `${n.reference.width}px`
                    })
                }
            })]
        })
            , { isMounted: l, styles: c } = WT(s);
        return (0,
            r.useEffect)((() => {
                i()
            }
            ), [n, i]),
            (0,
                r.useEffect)((() => {
                    null !== n && o.setReference({
                        getBoundingClientRect: () => n
                    })
                }
                ), [e, n, o]),
            (0,
                r.useMemo)((() => ({
                    isMounted: l,
                    ref: o.setFloating,
                    style: {
                        display: "flex",
                        ...c,
                        ...a
                    }
                })), [a, l, o.setFloating, c])
    }
    function fO(e, t, n) {
        return n && "row" === n.draggedCellOrientation ? new DOMRect(t.x, n.mousePos, t.width, 0) : new DOMRect(t.x, e.y, t.width, e.height)
    }
    function mO(e, t, n) {
        return n && "col" === n.draggedCellOrientation ? new DOMRect(n.mousePos, t.y, 0, t.height) : new DOMRect(e.x, t.y, e.width, t.height)
    }
    function gO(e, t, n, o, i) {
        const { refs: s, update: a, context: l, floatingStyles: c } = RT({
            open: t,
            placement: "row" === e ? "left" : "top",
            middleware: [AM("row" === e ? -10 : -12)]
        })
            , { isMounted: d, styles: u } = WT(l);
        return (0,
            r.useEffect)((() => {
                a()
            }
            ), [n, o, a]),
            (0,
                r.useEffect)((() => {
                    null === n || null === o || s.setReference({
                        getBoundingClientRect: () => ("row" === e ? fO : mO)(n, o, i)
                    })
                }
                ), [i, e, n, o, s]),
            (0,
                r.useMemo)((() => ({
                    isMounted: d,
                    ref: s.setFloating,
                    style: {
                        display: "flex",
                        ...u,
                        ...c
                    }
                })), [c, d, s.setFloating, u])
    }
    const bO = e => {
        var t, n;
        const o = hN()
            , [i, s] = (0,
                r.useState)(null);
        if (!o.tableHandles)
            throw new Error("TableHandlesController can only be used when BlockNote editor schema contains table block");
        const a = {
            rowDragStart: o.tableHandles.rowDragStart,
            colDragStart: o.tableHandles.colDragStart,
            dragEnd: o.tableHandles.dragEnd,
            freezeHandles: o.tableHandles.freezeHandles,
            unfreezeHandles: o.tableHandles.unfreezeHandles
        }
            , { freezeHandles: l, unfreezeHandles: c } = a
            , d = (0,
                r.useCallback)((() => {
                    l(),
                        k(!0),
                        v(!0)
                }
                ), [l])
            , u = (0,
                r.useCallback)((() => {
                    c(),
                        k(!1),
                        v(!1)
                }
                ), [c])
            , h = fN(o.tableHandles.onUpdate.bind(o.tableHandles))
            , p = (0,
                r.useMemo)((() => {
                    var e, t;
                    return null != h && h.draggingState ? {
                        draggedCellOrientation: null == (e = null == h ? void 0 : h.draggingState) ? void 0 : e.draggedCellOrientation,
                        mousePos: null == (t = null == h ? void 0 : h.draggingState) ? void 0 : t.mousePos
                    } : void 0
                }
                ), [null == h ? void 0 : h.draggingState, null == (t = null == h ? void 0 : h.draggingState) ? void 0 : t.draggedCellOrientation, null == (n = null == h ? void 0 : h.draggingState) ? void 0 : n.mousePos])
            , { rowHandle: f, colHandle: m } = function (e, t, n, o) {
                const i = gO("row", e, t, n, o)
                    , s = gO("col", e, t, n, o);
                return (0,
                    r.useMemo)((() => ({
                        rowHandle: i,
                        colHandle: s
                    })), [s, i])
            }((null == h ? void 0 : h.show) || !1, (null == h ? void 0 : h.referencePosCell) || null, (null == h ? void 0 : h.referencePosTable) || null, p)
            , { addOrRemoveColumnsButton: g, addOrRemoveRowsButton: b } = function (e, t, n) {
                const o = pO("addOrRemoveRows", t, n)
                    , i = pO("addOrRemoveColumns", e, n);
                return (0,
                    r.useMemo)((() => ({
                        addOrRemoveRowsButton: o,
                        addOrRemoveColumnsButton: i
                    })), [i, o])
            }((null == h ? void 0 : h.showAddOrRemoveColumnsButton) || !1, (null == h ? void 0 : h.showAddOrRemoveRowsButton) || !1, (null == h ? void 0 : h.referencePosTable) || null)
            , [y, v] = (0,
                r.useState)(!1)
            , [w, k] = (0,
                r.useState)(!1);
        if (!h)
            return null;
        const C = e.tableHandle || hO
            , S = e.extendButton || oO;
        return (0,
            Lx.jsxs)(Lx.Fragment, {
                children: [(0,
                    Lx.jsx)("div", {
                        ref: s
                    }), (0,
                        Lx.jsxs)(TT, {
                            root: h.widgetContainer,
                            children: [!y && i && f.isMounted && void 0 !== h.rowIndex && (0,
                                Lx.jsx)("div", {
                                    ref: f.ref,
                                    style: f.style,
                                    children: (0,
                                        Lx.jsx)(C, {
                                            editor: o,
                                            orientation: "row",
                                            showOtherSide: () => k(!1),
                                            hideOtherSide: () => k(!0),
                                            index: h.rowIndex,
                                            block: h.block,
                                            dragStart: a.rowDragStart,
                                            dragEnd: a.dragEnd,
                                            freezeHandles: a.freezeHandles,
                                            unfreezeHandles: a.unfreezeHandles,
                                            menuContainer: i
                                        })
                                }), !w && i && m.isMounted && void 0 !== h.colIndex && (0,
                                    Lx.jsx)("div", {
                                        ref: m.ref,
                                        style: m.style,
                                        children: (0,
                                            Lx.jsx)(C, {
                                                editor: o,
                                                orientation: "column",
                                                showOtherSide: () => v(!1),
                                                hideOtherSide: () => v(!0),
                                                index: h.colIndex,
                                                block: h.block,
                                                dragStart: a.colDragStart,
                                                dragEnd: a.dragEnd,
                                                freezeHandles: a.freezeHandles,
                                                unfreezeHandles: a.unfreezeHandles,
                                                menuContainer: i
                                            })
                                    }), (0,
                                        Lx.jsx)("div", {
                                            ref: b.ref,
                                            style: b.style,
                                            children: (0,
                                                Lx.jsx)(S, {
                                                    editor: o,
                                                    orientation: "addOrRemoveRows",
                                                    block: h.block,
                                                    onMouseDown: d,
                                                    onMouseUp: u
                                                })
                                        }), (0,
                                            Lx.jsx)("div", {
                                                ref: g.ref,
                                                style: g.style,
                                                children: (0,
                                                    Lx.jsx)(S, {
                                                        editor: o,
                                                        orientation: "addOrRemoveColumns",
                                                        block: h.block,
                                                        onMouseDown: d,
                                                        onMouseUp: u
                                                    })
                                            })]
                        })]
            })
    }
        ;
    function yO(e) {
        const t = hN();
        if (!t)
            throw new Error("BlockNoteDefaultUI must be used within a BlockNoteContext.Provider");
        return (0,
            Lx.jsxs)(Lx.Fragment, {
                children: [!1 !== e.formattingToolbar && (0,
                    Lx.jsx)(O_, {}), !1 !== e.linkToolbar && (0,
                        Lx.jsx)(D_, {}), !1 !== e.slashMenu && (0,
                            Lx.jsx)(eO, {
                                triggerCharacter: "/"
                            }), !1 !== e.emojiPicker && (0,
                                Lx.jsx)(J_, {
                                    triggerCharacter: ":",
                                    columns: 10,
                                    minQueryLength: 2
                                }), !1 !== e.sideMenu && (0,
                                    Lx.jsx)(U_, {}), t.filePanel && !1 !== e.filePanel && (0,
                                        Lx.jsx)(kN, {}), t.tableHandles && !1 !== e.tableHandles && (0,
                                            Lx.jsx)(bO, {})]
            })
    }
    const vO = () => {
        const e = (0,
            r.useMemo)((() => {
                var e;
                return null == (e = window.matchMedia) ? void 0 : e.call(window, "(prefers-color-scheme: dark)")
            }
            ), [])
            , t = (0,
                r.useMemo)((() => {
                    var e;
                    return null == (e = window.matchMedia) ? void 0 : e.call(window, "(prefers-color-scheme: light)")
                }
                ), [])
            , n = null == e ? void 0 : e.matches
            , o = null == t ? void 0 : t.matches
            , [i, s] = (0,
                r.useState)(n ? "dark" : o ? "light" : "no-preference");
        return (0,
            r.useEffect)((() => {
                s(n ? "dark" : o ? "light" : "no-preference")
            }
            ), [n, o]),
            (0,
                r.useEffect)((() => {
                    if ("function" == typeof (null == e ? void 0 : e.addEventListener)) {
                        const n = e => {
                            let { matches: t } = e;
                            return t && s("dark")
                        }
                            , r = e => {
                                let { matches: t } = e;
                                return t && s("light")
                            }
                            ;
                        return null == e || e.addEventListener("change", n),
                            null == t || t.addEventListener("change", r),
                            () => {
                                null == e || e.removeEventListener("change", n),
                                    null == t || t.removeEventListener("change", r)
                            }
                    }
                    {
                        const n = () => s(e.matches ? "dark" : t.matches ? "light" : "no-preference");
                        return null == e || e.addEventListener("change", n),
                            null == t || t.addEventListener("change", n),
                            () => {
                                null == e || e.removeEventListener("change", n),
                                    null == t || t.removeEventListener("change", n)
                            }
                    }
                }
                ), [e, t]),
            window.matchMedia,
            i
    }
        , wO = e => {
            let { renderers: t } = e;
            return (0,
                Lx.jsx)(Lx.Fragment, {
                    children: Object.entries(t).map((e => {
                        let [t, n] = e;
                        return (0,
                            PE.createPortal)(n.reactElement, n.element, t)
                    }
                    ))
                })
        }
        ;
    function kO(e) {
        const [t, n] = (0,
            r.useState)({});
        return (0,
            r.useEffect)((() => (e.editor._tiptapEditor.contentComponent = {
                setRenderer(e, t) {
                    n((n => ({
                        ...n,
                        [e]: t
                    })))
                },
                removeRenderer(e) {
                    n((t => {
                        const n = {
                            ...t
                        };
                        return delete n[e],
                            n
                    }
                    ))
                }
            },
                queueMicrotask((() => {
                    e.editor._tiptapEditor.createNodeViews()
                }
                )),
                () => {
                    e.editor._tiptapEditor.contentComponent = null
                }
            )), [e.editor._tiptapEditor]),
            (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [(0,
                        Lx.jsx)(wO, {
                            renderers: t
                        }), e.children]
                })
    }
    const CO = (0,
        r.forwardRef)(((e, t) => {
            const [n, o] = (0,
                r.useState)();
            return (0,
                r.useImperativeHandle)(t, (() => (e, t) => {
                    (0,
                        PE.flushSync)((() => {
                            o({
                                node: e,
                                container: t
                            })
                        }
                        )),
                        o(void 0)
                }
                ), []),
                (0,
                    Lx.jsx)(Lx.Fragment, {
                        children: n && (0,
                            PE.createPortal)(n.node, n.container)
                    })
        }
        ))
        , SO = () => { }
        ;
    const xO = r.forwardRef((function (e, t) {
        const { editor: n, className: o, theme: i, children: s, editable: a, onSelectionChange: l, onChange: c, formattingToolbar: d, linkToolbar: u, slashMenu: h, emojiPicker: p, sideMenu: f, filePanel: m, tableHandles: g, ...b } = e
            , [y, v] = (0,
                r.useState)()
            , w = uN()
            , k = vO()
            , C = (null == w ? void 0 : w.colorSchemePreference) || k
            , S = i || ("dark" === C ? "dark" : "light");
        CN(c || SO, n),
            SN(l || SO, n),
            (0,
                r.useEffect)((() => {
                    n.isEditable = !1 !== a
                }
                ), [a, n]);
        const x = (0,
            r.useMemo)((() => (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [s, (0,
                        Lx.jsx)(yO, {
                            formattingToolbar: d,
                            linkToolbar: u,
                            slashMenu: h,
                            emojiPicker: p,
                            sideMenu: f,
                            filePanel: m,
                            tableHandles: g
                        })]
                })), [s, d, u, h, p, f, m, g])
            , E = (0,
                r.useMemo)((() => ({
                    ...w,
                    editor: n,
                    setContentEditableProps: v
                })), [w, n])
            , M = (0,
                r.useCallback)((e => {
                    n.elementRenderer = e
                }
                ), [n]);
        return (0,
            Lx.jsxs)(dN.Provider, {
                value: E,
                children: [(0,
                    Lx.jsx)(CO, {
                        ref: M
                    }), !n.headless && (0,
                        Lx.jsx)(kO, {
                            editor: n,
                            children: (0,
                                Lx.jsxs)("div", {
                                    className: Sk("bn-container", S || "", o || ""),
                                    "data-color-scheme": S,
                                    ...b,
                                    ref: t,
                                    children: [(0,
                                        Lx.jsx)("div", {
                                            "aria-autocomplete": "list",
                                            "aria-haspopup": "listbox",
                                            ref: n.mount,
                                            ...y
                                        }), x]
                                })
                        })]
            })
    }
    ));
    var EO, MO = PE;
    function TO(e, t) {
        let n;
        const r = document.createElement("div");
        let o;
        if (null != t && t.elementRenderer ? t.elementRenderer(e((e => n = e || void 0)), r) : (o = EO(r),
            (0,
                PE.flushSync)((() => {
                    o.render(e((e => n = e || void 0)))
                }
                ))),
            !r.childElementCount)
            return console.warn("ReactInlineContentSpec: renderHTML() failed"),
            {
                dom: document.createElement("span")
            };
        null == n || n.setAttribute("data-tmp-find", "true");
        const i = r.cloneNode(!0)
            , s = i.firstElementChild
            , a = i.querySelector("[data-tmp-find]");
        return null == a || a.removeAttribute("data-tmp-find"),
            null == o || o.unmount(),
        {
            dom: s,
            contentDOM: a || void 0
        }
    }
    function NO(e) {
        var t;
        return (0,
            Lx.jsx)(aN, {
                ...Object.fromEntries(Object.entries(e.domAttributes || {}).filter((e => {
                    let [t] = e;
                    return "class" !== t
                }
                ))),
                className: Sk("bn-block-content", (null == (t = e.domAttributes) ? void 0 : t.class) || ""),
                "data-content-type": e.blockType,
                ...Object.fromEntries(Object.entries(e.blockProps).filter((t => {
                    let [n, r] = t;
                    return !Nk.includes(n) && r !== e.propSchema[n].default
                }
                )).map((e => {
                    let [t, n] = e;
                    return [_k(t), n]
                }
                ))),
                "data-file-block": !0 === e.isFileBlock || void 0,
                children: e.children
            })
    }
    function _O(e, t) {
        const n = Rk({
            name: e.type,
            content: "inline" === e.content ? "inline*" : "",
            group: "blockContent",
            selectable: e.isSelectable ?? !0,
            addAttributes: () => Ak(e.propSchema),
            parseHTML: () => zk(e, t.parse),
            renderHTML(t) {
                let { HTMLAttributes: n } = t;
                const r = document.createElement("div");
                return Lk({
                    dom: r,
                    contentDOM: "inline" === e.content ? r : void 0
                }, e.type, {}, e.propSchema, e.isFileBlock, n)
            },
            addNodeView() {
                return n => {
                    const o = function (e, t) {
                        return n => n.editor.contentComponent ? new cN(e, n, t) : {}
                    }((n => {
                        var o;
                        const i = this.options.editor
                            , s = Pk(n.getPos, i, this.editor, e.type)
                            , a = (null == (o = this.options.domAttributes) ? void 0 : o.blockContent) || {}
                            , l = (e => {
                                const t = e.as || "div"
                                    , { nodeViewContentRef: n } = sN();
                                return r.createElement(t, {
                                    ...e,
                                    ref: n,
                                    "data-node-view-content": "",
                                    style: {
                                        whiteSpace: "pre-wrap",
                                        ...e.style
                                    }
                                })
                            }
                            )({}).ref
                            , c = t.render;
                        return (0,
                            Lx.jsx)(NO, {
                                blockType: s.type,
                                blockProps: s.props,
                                propSchema: e.propSchema,
                                isFileBlock: e.isFileBlock,
                                domAttributes: a,
                                children: (0,
                                    Lx.jsx)(c, {
                                        block: s,
                                        editor: i,
                                        contentRef: l
                                    })
                            })
                    }
                    ), {
                        className: "bn-react-node-view-renderer"
                    })(n);
                    return !1 === e.isSelectable && Hk(o, this.editor),
                        o
                }
            }
        });
        return Dk(e, {
            node: n,
            toInternalHTML: (r, o) => {
                var i, s;
                const a = (null == (i = n.options.domAttributes) ? void 0 : i.blockContent) || {}
                    , l = t.render
                    , c = TO((t => (0,
                        Lx.jsx)(NO, {
                            blockType: r.type,
                            blockProps: r.props,
                            propSchema: e.propSchema,
                            domAttributes: a,
                            children: (0,
                                Lx.jsx)(l, {
                                    block: r,
                                    editor: o,
                                    contentRef: t
                                })
                        })), o);
                return null == (s = c.contentDOM) || s.setAttribute("data-editable", ""),
                    c
            }
            ,
            toExternalHTML: (r, o) => {
                var i, s;
                const a = (null == (i = n.options.domAttributes) ? void 0 : i.blockContent) || {}
                    , l = t.toExternalHTML || t.render
                    , c = TO((t => (0,
                        Lx.jsx)(NO, {
                            blockType: r.type,
                            blockProps: r.props,
                            propSchema: e.propSchema,
                            domAttributes: a,
                            children: (0,
                                Lx.jsx)(l, {
                                    block: r,
                                    editor: o,
                                    contentRef: t
                                })
                        })), o);
                return null == (s = c.contentDOM) || s.setAttribute("data-editable", ""),
                    c
            }
        })
    }
    function OO(e) {
        const [t, n] = (0,
            r.useState)(!1);
        return function (e) {
            const t = hN();
            (0,
                r.useEffect)((() => t.onUploadStart(e)), [e, t])
        }((t => {
            t === e && n(!0)
        }
        )),
            function (e) {
                const t = hN();
                (0,
                    r.useEffect)((() => t.onUploadEnd(e)), [e, t])
            }((t => {
                t === e && n(!1)
            }
            )),
            t
    }
    EO = MO.createRoot,
        MO.hydrateRoot;
    const AO = e => OO(e.block.id) ? (0,
        Lx.jsx)("div", {
            className: "bn-file-loading-preview",
            children: "Loading..."
        }) : (0,
            Lx.jsx)("div", {
                className: "bn-file-block-content-wrapper",
                children: "" === e.block.props.url ? (0,
                    Lx.jsx)(RO, {
                        ...e
                    }) : !1 === e.block.props.showPreview ? (0,
                        Lx.jsx)(LO, {
                            block: e.block,
                            editor: e.editor,
                            children: (0,
                                Lx.jsx)(PO, {
                                    block: e.block,
                                    editor: e.editor
                                })
                        }) : (0,
                            Lx.jsx)(LO, {
                                block: e.block,
                                editor: e.editor,
                                children: e.children
                            })
            })
        , PO = e => (0,
            Lx.jsxs)("div", {
                className: "bn-file-default-preview",
                contentEditable: !1,
                draggable: !1,
                children: [(0,
                    Lx.jsx)("div", {
                        className: "bn-file-default-preview-icon",
                        children: (0,
                            Lx.jsx)(IN, {
                                size: 24
                            })
                    }), (0,
                        Lx.jsx)("p", {
                            className: "bn-file-default-preview-name",
                            children: e.block.props.name
                        })]
            })
        , LO = e => (0,
            Lx.jsxs)("div", {
                className: "bn-file-and-caption-wrapper",
                children: [e.children, e.block.props.caption && (0,
                    Lx.jsx)("p", {
                        className: "bn-file-caption",
                        children: e.block.props.caption
                    })]
            })
        , RO = e => {
            const t = bN()
                , n = (0,
                    r.useCallback)((e => {
                        e.preventDefault()
                    }
                    ), [])
                , o = (0,
                    r.useCallback)((() => {
                        e.editor.dispatch(e.editor._tiptapEditor.state.tr.setMeta(e.editor.filePanel.plugin, {
                            block: e.block
                        }))
                    }
                    ), [e.block, e.editor]);
            return (0,
                Lx.jsxs)("div", {
                    className: "bn-add-file-button",
                    onMouseDown: n,
                    onClick: o,
                    children: [(0,
                        Lx.jsx)("div", {
                            className: "bn-add-file-button-icon",
                            children: e.buttonIcon || (0,
                                Lx.jsx)(IN, {
                                    size: 24
                                })
                        }), (0,
                            Lx.jsx)("div", {
                                className: "bn-add-file-button-text",
                                children: e.buttonText || t.file_blocks.file.add_button_text
                            })]
                })
        }
        , DO = e => (0,
            Lx.jsxs)("div", {
                children: [e.children, (0,
                    Lx.jsx)("p", {
                        children: e.caption
                    })]
            })
        , IO = e => (0,
            Lx.jsxs)("figure", {
                children: [e.children, (0,
                    Lx.jsx)("figcaption", {
                        children: e.caption
                    })]
            })
        , jO = e => {
            const [t, n] = (0,
                r.useState)(!1)
                , [o, i] = (0,
                    r.useState)(void 0);
            (0,
                r.useEffect)((() => {
                    const t = t => {
                        let n;
                        n = "center" === e.block.props.textAlignment ? "left" === o.handleUsed ? o.initialWidth + 2 * (o.initialClientX - t.clientX) : o.initialWidth + 2 * (t.clientX - o.initialClientX) : "left" === o.handleUsed ? o.initialWidth + o.initialClientX - t.clientX : o.initialWidth + t.clientX - o.initialClientX;
                        n < 64 ? e.setWidth(64) : n > e.editor.domElement.firstElementChild.clientWidth ? e.setWidth(e.editor.domElement.firstElementChild.clientWidth) : e.setWidth(n)
                    }
                        , n = () => {
                            i(void 0),
                                e.editor.updateBlock(e.block, {
                                    props: {
                                        previewWidth: e.width
                                    }
                                })
                        }
                        ;
                    return o && (window.addEventListener("mousemove", t),
                        window.addEventListener("mouseup", n)),
                        () => {
                            window.removeEventListener("mousemove", t),
                                window.removeEventListener("mouseup", n)
                        }
                }
                ), [e, o]);
            const s = (0,
                r.useCallback)((() => {
                    e.editor.isEditable && n(!0)
                }
                ), [e.editor.isEditable])
                , a = (0,
                    r.useCallback)((() => {
                        n(!1)
                    }
                    ), [])
                , l = (0,
                    r.useCallback)((t => {
                        t.preventDefault(),
                            i({
                                handleUsed: "left",
                                initialWidth: e.width,
                                initialClientX: t.clientX
                            })
                    }
                    ), [e.width])
                , c = (0,
                    r.useCallback)((t => {
                        t.preventDefault(),
                            i({
                                handleUsed: "right",
                                initialWidth: e.width,
                                initialClientX: t.clientX
                            })
                    }
                    ), [e.width]);
            return (0,
                Lx.jsxs)("div", {
                    className: "bn-visual-media-wrapper",
                    onMouseEnter: s,
                    onMouseLeave: a,
                    children: [e.children, (t || o) && (0,
                        Lx.jsxs)(Lx.Fragment, {
                            children: [(0,
                                Lx.jsx)("div", {
                                    className: "bn-visual-media-resize-handle",
                                    style: {
                                        left: "4px"
                                    },
                                    onMouseDown: l
                                }), (0,
                                    Lx.jsx)("div", {
                                        className: "bn-visual-media-resize-handle",
                                        style: {
                                            right: "4px"
                                        },
                                        onMouseDown: c
                                    })]
                        })]
                })
        }
        ;
    function HO(e) {
        const t = hN()
            , [n, o] = (0,
                r.useState)("loading")
            , [i, s] = (0,
                r.useState)();
        if ((0,
            r.useEffect)((() => {
                let n = !0;
                return (async () => {
                    let r = "";
                    o("loading");
                    try {
                        r = await t.resolveFileUrl(e)
                    } catch {
                        return void o("error")
                    }
                    n && (o("loaded"),
                        s(r))
                }
                )(),
                    () => {
                        n = !1
                    }
            }
            ), [t, e]),
            "loaded" !== n)
            return {
                loadingState: n
            };
        if (!i)
            throw new Error("Finished fetching file but did not get download URL.");
        return {
            loadingState: n,
            downloadUrl: i
        }
    }
    const zO = e => {
        const t = HO(e.block.props.url);
        return "loading" === t.loadingState ? null : (0,
            Lx.jsx)("audio", {
                className: "bn-audio",
                src: t.downloadUrl,
                controls: !0,
                contentEditable: !1,
                draggable: !1
            })
    }
        , $O = (_O(iC, {
            render: e => (0,
                Lx.jsx)(AO, {
                    ...e,
                    buttonText: e.editor.dictionary.file_blocks.audio.add_button_text,
                    buttonIcon: (0,
                        Lx.jsx)(e_, {
                            size: 24
                        }),
                    children: (0,
                        Lx.jsx)(zO, {
                            block: e.block,
                            editor: e.editor
                        })
                }),
            parse: sC,
            toExternalHTML: e => {
                if (!e.block.props.url)
                    return (0,
                        Lx.jsx)("p", {
                            children: "Add audio"
                        });
                const t = e.block.props.showPreview ? (0,
                    Lx.jsx)("audio", {
                        src: e.block.props.url
                    }) : (0,
                        Lx.jsx)("a", {
                            href: e.block.props.url,
                            children: e.block.props.name || e.block.props.url
                        });
                return e.block.props.caption ? e.block.props.showPreview ? (0,
                    Lx.jsx)(IO, {
                        caption: e.block.props.caption,
                        children: t
                    }) : (0,
                        Lx.jsx)(DO, {
                            caption: e.block.props.caption,
                            children: t
                        }) : t
            }
        }),
            _O(mC, {
                render: e => (0,
                    Lx.jsx)(AO, {
                        ...e,
                        children: (0,
                            Lx.jsx)(PO, {
                                block: e.block,
                                editor: e.editor
                            })
                    }),
                parse: gC,
                toExternalHTML: e => {
                    if (!e.block.props.url)
                        return (0,
                            Lx.jsx)("p", {
                                children: "Add file"
                            });
                    const t = (0,
                        Lx.jsx)("a", {
                            href: e.block.props.url,
                            children: e.block.props.name || e.block.props.url
                        });
                    return e.block.props.caption ? (0,
                        Lx.jsx)(DO, {
                            caption: e.block.props.caption,
                            children: t
                        }) : t
                }
            }),
            e => {
                const [t, n] = (0,
                    r.useState)(Math.min(e.block.props.previewWidth, e.editor.domElement.firstElementChild.clientWidth))
                    , o = HO(e.block.props.url);
                return "loading" === o.loadingState ? null : (0,
                    Lx.jsx)(jO, {
                        ...e,
                        width: t,
                        setWidth: n,
                        children: (0,
                            Lx.jsx)("img", {
                                className: "bn-visual-media",
                                src: o.downloadUrl,
                                alt: e.block.props.caption || "BlockNote image",
                                contentEditable: !1,
                                draggable: !1,
                                width: t
                            })
                    })
            }
        )
        , BO = (_O(xC, {
            render: e => (0,
                Lx.jsx)(AO, {
                    ...e,
                    buttonText: e.editor.dictionary.file_blocks.image.add_button_text,
                    buttonIcon: (0,
                        Lx.jsx)(ZN, {
                            size: 24
                        }),
                    children: (0,
                        Lx.jsx)($O, {
                            block: e.block,
                            editor: e.editor
                        })
                }),
            parse: EC,
            toExternalHTML: e => {
                if (!e.block.props.url)
                    return (0,
                        Lx.jsx)("p", {
                            children: "Add image"
                        });
                const t = e.block.props.showPreview ? (0,
                    Lx.jsx)("img", {
                        src: e.block.props.url,
                        alt: e.block.props.name || e.block.props.caption || "BlockNote image",
                        width: e.block.props.previewWidth
                    }) : (0,
                        Lx.jsx)("a", {
                            href: e.block.props.url,
                            children: e.block.props.name || e.block.props.url
                        });
                return e.block.props.caption ? e.block.props.showPreview ? (0,
                    Lx.jsx)(IO, {
                        caption: e.block.props.caption,
                        children: t
                    }) : (0,
                        Lx.jsx)(DO, {
                            caption: e.block.props.caption,
                            children: t
                        }) : t
            }
        }),
            e => {
                const [t, n] = (0,
                    r.useState)(Math.min(e.block.props.previewWidth, e.editor.domElement.firstElementChild.clientWidth))
                    , o = HO(e.block.props.url);
                return "loading" === o.loadingState ? null : (0,
                    Lx.jsx)(jO, {
                        ...e,
                        width: t,
                        setWidth: n,
                        children: (0,
                            Lx.jsx)("video", {
                                className: "bn-visual-media",
                                src: o.downloadUrl,
                                controls: !0,
                                contentEditable: !1,
                                draggable: !1,
                                width: t
                            })
                    })
            }
        );
    _O(qC, {
        render: e => (0,
            Lx.jsx)(AO, {
                ...e,
                buttonText: e.editor.dictionary.file_blocks.video.add_button_text,
                buttonIcon: (0,
                    Lx.jsx)(YN, {
                        size: 24
                    }),
                children: (0,
                    Lx.jsx)(BO, {
                        block: e.block,
                        editor: e.editor
                    })
            }),
        parse: GC,
        toExternalHTML: e => {
            if (!e.block.props.url)
                return (0,
                    Lx.jsx)("p", {
                        children: "Add video"
                    });
            const t = e.block.props.showPreview ? (0,
                Lx.jsx)("video", {
                    src: e.block.props.url
                }) : (0,
                    Lx.jsx)("a", {
                        href: e.block.props.url,
                        children: e.block.props.name || e.block.props.url
                    });
            return e.block.props.caption ? e.block.props.showPreview ? (0,
                Lx.jsx)(IO, {
                    caption: e.block.props.caption,
                    children: t
                }) : (0,
                    Lx.jsx)(DO, {
                        caption: e.block.props.caption,
                        children: t
                    }) : t
        }
    });
    const VO = function () {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        return (0,
            r.useMemo)((() => {
                const t = Tx.create(e);
                return window && (window.ProseMirror = t._tiptapEditor),
                    t
            }
            ), t)
    };
    function FO(e, t) {
        const n = e.getBoundingClientRect()
            , r = t.getBoundingClientRect()
            , o = n.top < r.top
            , i = n.bottom > r.bottom;
        return o && i ? "both" : o ? "top" : i ? "bottom" : "none"
    }
    function UO(e) {
        return Object.keys(e).reduce(((t, n) => (void 0 !== e[n] && (t[n] = e[n]),
            t)), {})
    }
    function WO(e) {
        return "0rem" === e ? "0rem" : `calc(${e} * var(--mantine-scale))`
    }
    function qO(e) {
        let { shouldScale: t = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return function n(r) {
            if (0 === r || "0" === r)
                return `0${e}`;
            if ("number" === typeof r) {
                const n = `${r / 16}${e}`;
                return t ? WO(n) : n
            }
            if ("string" === typeof r) {
                if ("" === r)
                    return r;
                if (r.startsWith("calc(") || r.startsWith("clamp(") || r.includes("rgba("))
                    return r;
                if (r.includes(","))
                    return r.split(",").map((e => n(e))).join(",");
                if (r.includes(" "))
                    return r.split(" ").map((e => n(e))).join(" ");
                if (r.includes(e))
                    return t ? WO(r) : r;
                const o = r.replace("px", "");
                if (!Number.isNaN(Number(o))) {
                    const n = `${Number(o) / 16}${e}`;
                    return t ? WO(n) : n
                }
            }
            return r
        }
    }
    const GO = qO("rem", {
        shouldScale: !0
    })
        , KO = qO("em");
    function JO(e) {
        return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(e) ? function (e) {
            let t = e.replace("#", "");
            if (3 === t.length) {
                const e = t.split("");
                t = [e[0], e[0], e[1], e[1], e[2], e[2]].join("")
            }
            if (8 === t.length) {
                const e = parseInt(t.slice(6, 8), 16) / 255;
                return {
                    r: parseInt(t.slice(0, 2), 16),
                    g: parseInt(t.slice(2, 4), 16),
                    b: parseInt(t.slice(4, 6), 16),
                    a: e
                }
            }
            const n = parseInt(t, 16);
            return {
                r: n >> 16 & 255,
                g: n >> 8 & 255,
                b: 255 & n,
                a: 1
            }
        }(e) : e.startsWith("rgb") ? function (e) {
            const [t, n, r, o] = e.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
            return {
                r: t,
                g: n,
                b: r,
                a: o || 1
            }
        }(e) : e.startsWith("hsl") ? function (e) {
            const t = e.match(/^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i);
            if (!t)
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                };
            const n = parseInt(t[1], 10)
                , r = parseInt(t[2], 10) / 100
                , o = parseInt(t[3], 10) / 100
                , i = t[5] ? parseFloat(t[5]) : void 0
                , s = (1 - Math.abs(2 * o - 1)) * r
                , a = n / 60
                , l = s * (1 - Math.abs(a % 2 - 1))
                , c = o - s / 2;
            let d, u, h;
            return a >= 0 && a < 1 ? (d = s,
                u = l,
                h = 0) : a >= 1 && a < 2 ? (d = l,
                    u = s,
                    h = 0) : a >= 2 && a < 3 ? (d = 0,
                        u = s,
                        h = l) : a >= 3 && a < 4 ? (d = 0,
                            u = l,
                            h = s) : a >= 4 && a < 5 ? (d = l,
                                u = 0,
                                h = s) : (d = s,
                                    u = 0,
                                    h = l),
            {
                r: Math.round(255 * (d + c)),
                g: Math.round(255 * (u + c)),
                b: Math.round(255 * (h + c)),
                a: i || 1
            }
        }(e) : {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        }
    }
    function ZO(e, t) {
        if (e.startsWith("var("))
            return `color-mix(in srgb, ${e}, black ${100 * t}%)`;
        const { r: n, g: r, b: o, a: i } = JO(e)
            , s = 1 - t
            , a = e => Math.round(e * s);
        return `rgba(${a(n)}, ${a(r)}, ${a(o)}, ${i})`
    }
    function XO(e, t) {
        return "number" === typeof e.primaryShade ? e.primaryShade : "dark" === t ? e.primaryShade.dark : e.primaryShade.light
    }
    function QO(e) {
        return e <= .03928 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4
    }
    function YO(e) {
        if (e.startsWith("oklch("))
            return (function (e) {
                const t = e.match(/oklch\((.*?)%\s/);
                return t ? parseFloat(t[1]) : null
            }(e) || 0) / 100;
        const { r: t, g: n, b: r } = JO(e)
            , o = n / 255
            , i = r / 255;
        return .2126 * QO(t / 255) + .7152 * QO(o) + .0722 * QO(i)
    }
    function eA(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .179;
        return !e.startsWith("var(") && YO(e) > t
    }
    function tA(e) {
        let { color: t, theme: n, colorScheme: r } = e;
        if ("string" !== typeof t)
            throw new Error("[@mantine/core] Failed to parse color. Expected color to be a string, instead got " + typeof t);
        if ("bright" === t)
            return {
                color: t,
                value: "dark" === r ? n.white : n.black,
                shade: void 0,
                isThemeColor: !1,
                isLight: eA("dark" === r ? n.white : n.black, n.luminanceThreshold),
                variable: "--mantine-color-bright"
            };
        if ("dimmed" === t)
            return {
                color: t,
                value: "dark" === r ? n.colors.dark[2] : n.colors.gray[7],
                shade: void 0,
                isThemeColor: !1,
                isLight: eA("dark" === r ? n.colors.dark[2] : n.colors.gray[6], n.luminanceThreshold),
                variable: "--mantine-color-dimmed"
            };
        if ("white" === t || "black" === t)
            return {
                color: t,
                value: "white" === t ? n.white : n.black,
                shade: void 0,
                isThemeColor: !1,
                isLight: eA("white" === t ? n.white : n.black, n.luminanceThreshold),
                variable: `--mantine-color-${t}`
            };
        const [o, i] = t.split(".")
            , s = i ? Number(i) : void 0
            , a = o in n.colors;
        if (a) {
            const e = void 0 !== s ? n.colors[o][s] : n.colors[o][XO(n, r || "light")];
            return {
                color: o,
                value: e,
                shade: s,
                isThemeColor: a,
                isLight: eA(e, n.luminanceThreshold),
                variable: i ? `--mantine-color-${o}-${s}` : `--mantine-color-${o}-filled`
            }
        }
        return {
            color: t,
            value: t,
            isThemeColor: a,
            isLight: eA(t, n.luminanceThreshold),
            shade: s,
            variable: void 0
        }
    }
    function nA(e, t) {
        const n = tA({
            color: e || t.primaryColor,
            theme: t
        });
        return n.variable ? `var(${n.variable})` : e
    }
    function rA(e, t) {
        const n = {
            from: e?.from || t.defaultGradient.from,
            to: e?.to || t.defaultGradient.to,
            deg: e?.deg || t.defaultGradient.deg || 0
        }
            , r = nA(n.from, t)
            , o = nA(n.to, t);
        return `linear-gradient(${n.deg}deg, ${r} 0%, ${o} 100%)`
    }
    function oA(e, t) {
        if ("string" !== typeof e || t > 1 || t < 0)
            return "rgba(0, 0, 0, 1)";
        if (e.startsWith("var(")) {
            return `color-mix(in srgb, ${e}, transparent ${100 * (1 - t)}%)`
        }
        if (e.startsWith("oklch"))
            return e.includes("/") ? e.replace(/\/\s*[\d.]+\s*\)/, `/ ${t})`) : e.replace(")", ` / ${t})`);
        const { r: n, g: r, b: o } = JO(e);
        return `rgba(${n}, ${r}, ${o}, ${t})`
    }
    const iA = oA
        , sA = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji"
        , aA = {
            scale: 1,
            fontSmoothing: !0,
            focusRing: "auto",
            white: "#fff",
            black: "#000",
            colors: {
                dark: ["#C9C9C9", "#b8b8b8", "#828282", "#696969", "#424242", "#3b3b3b", "#2e2e2e", "#242424", "#1f1f1f", "#141414"],
                gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"],
                red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"],
                pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"],
                grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"],
                violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"],
                indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"],
                blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"],
                cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"],
                teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"],
                green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"],
                lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"],
                yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"],
                orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"]
            },
            primaryShade: {
                light: 6,
                dark: 8
            },
            primaryColor: "blue",
            variantColorResolver: e => {
                let { color: t, theme: n, variant: r, gradient: o, autoContrast: i } = e;
                const s = tA({
                    color: t,
                    theme: n
                })
                    , a = "boolean" === typeof i ? i : n.autoContrast;
                if ("filled" === r) {
                    const e = a && s.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
                    return s.isThemeColor ? void 0 === s.shade ? {
                        background: `var(--mantine-color-${t}-filled)`,
                        hover: `var(--mantine-color-${t}-filled-hover)`,
                        color: e,
                        border: `${GO(1)} solid transparent`
                    } : {
                        background: `var(--mantine-color-${s.color}-${s.shade})`,
                        hover: `var(--mantine-color-${s.color}-${9 === s.shade ? 8 : s.shade + 1})`,
                        color: e,
                        border: `${GO(1)} solid transparent`
                    } : {
                        background: t,
                        hover: ZO(t, .1),
                        color: e,
                        border: `${GO(1)} solid transparent`
                    }
                }
                if ("light" === r) {
                    if (s.isThemeColor) {
                        if (void 0 === s.shade)
                            return {
                                background: `var(--mantine-color-${t}-light)`,
                                hover: `var(--mantine-color-${t}-light-hover)`,
                                color: `var(--mantine-color-${t}-light-color)`,
                                border: `${GO(1)} solid transparent`
                            };
                        const e = n.colors[s.color][s.shade];
                        return {
                            background: oA(e, .1),
                            hover: oA(e, .12),
                            color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
                            border: `${GO(1)} solid transparent`
                        }
                    }
                    return {
                        background: oA(t, .1),
                        hover: oA(t, .12),
                        color: t,
                        border: `${GO(1)} solid transparent`
                    }
                }
                if ("outline" === r)
                    return s.isThemeColor ? void 0 === s.shade ? {
                        background: "transparent",
                        hover: `var(--mantine-color-${t}-outline-hover)`,
                        color: `var(--mantine-color-${t}-outline)`,
                        border: `${GO(1)} solid var(--mantine-color-${t}-outline)`
                    } : {
                        background: "transparent",
                        hover: oA(n.colors[s.color][s.shade], .05),
                        color: `var(--mantine-color-${s.color}-${s.shade})`,
                        border: `${GO(1)} solid var(--mantine-color-${s.color}-${s.shade})`
                    } : {
                        background: "transparent",
                        hover: oA(t, .05),
                        color: t,
                        border: `${GO(1)} solid ${t}`
                    };
                if ("subtle" === r) {
                    if (s.isThemeColor) {
                        if (void 0 === s.shade)
                            return {
                                background: "transparent",
                                hover: `var(--mantine-color-${t}-light-hover)`,
                                color: `var(--mantine-color-${t}-light-color)`,
                                border: `${GO(1)} solid transparent`
                            };
                        return {
                            background: "transparent",
                            hover: oA(n.colors[s.color][s.shade], .12),
                            color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
                            border: `${GO(1)} solid transparent`
                        }
                    }
                    return {
                        background: "transparent",
                        hover: oA(t, .12),
                        color: t,
                        border: `${GO(1)} solid transparent`
                    }
                }
                return "transparent" === r ? s.isThemeColor ? void 0 === s.shade ? {
                    background: "transparent",
                    hover: "transparent",
                    color: `var(--mantine-color-${t}-light-color)`,
                    border: `${GO(1)} solid transparent`
                } : {
                    background: "transparent",
                    hover: "transparent",
                    color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
                    border: `${GO(1)} solid transparent`
                } : {
                    background: "transparent",
                    hover: "transparent",
                    color: t,
                    border: `${GO(1)} solid transparent`
                } : "white" === r ? s.isThemeColor ? void 0 === s.shade ? {
                    background: "var(--mantine-color-white)",
                    hover: ZO(n.white, .01),
                    color: `var(--mantine-color-${t}-filled)`,
                    border: `${GO(1)} solid transparent`
                } : {
                    background: "var(--mantine-color-white)",
                    hover: ZO(n.white, .01),
                    color: `var(--mantine-color-${s.color}-${s.shade})`,
                    border: `${GO(1)} solid transparent`
                } : {
                    background: "var(--mantine-color-white)",
                    hover: ZO(n.white, .01),
                    color: t,
                    border: `${GO(1)} solid transparent`
                } : "gradient" === r ? {
                    background: rA(o, n),
                    hover: rA(o, n),
                    color: "var(--mantine-color-white)",
                    border: "none"
                } : "default" === r ? {
                    background: "var(--mantine-color-default)",
                    hover: "var(--mantine-color-default-hover)",
                    color: "var(--mantine-color-default-color)",
                    border: `${GO(1)} solid var(--mantine-color-default-border)`
                } : {}
            }
            ,
            autoContrast: !1,
            luminanceThreshold: .3,
            fontFamily: sA,
            fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
            respectReducedMotion: !1,
            cursorType: "default",
            defaultGradient: {
                from: "blue",
                to: "cyan",
                deg: 45
            },
            defaultRadius: "sm",
            activeClassName: "mantine-active",
            focusClassName: "",
            headings: {
                fontFamily: sA,
                fontWeight: "700",
                textWrap: "wrap",
                sizes: {
                    h1: {
                        fontSize: GO(34),
                        lineHeight: "1.3"
                    },
                    h2: {
                        fontSize: GO(26),
                        lineHeight: "1.35"
                    },
                    h3: {
                        fontSize: GO(22),
                        lineHeight: "1.4"
                    },
                    h4: {
                        fontSize: GO(18),
                        lineHeight: "1.45"
                    },
                    h5: {
                        fontSize: GO(16),
                        lineHeight: "1.5"
                    },
                    h6: {
                        fontSize: GO(14),
                        lineHeight: "1.5"
                    }
                }
            },
            fontSizes: {
                xs: GO(12),
                sm: GO(14),
                md: GO(16),
                lg: GO(18),
                xl: GO(20)
            },
            lineHeights: {
                xs: "1.4",
                sm: "1.45",
                md: "1.55",
                lg: "1.6",
                xl: "1.65"
            },
            radius: {
                xs: GO(2),
                sm: GO(4),
                md: GO(8),
                lg: GO(16),
                xl: GO(32)
            },
            spacing: {
                xs: GO(10),
                sm: GO(12),
                md: GO(16),
                lg: GO(20),
                xl: GO(32)
            },
            breakpoints: {
                xs: "36em",
                sm: "48em",
                md: "62em",
                lg: "75em",
                xl: "88em"
            },
            shadows: {
                xs: `0 ${GO(1)} ${GO(3)} rgba(0, 0, 0, 0.05), 0 ${GO(1)} ${GO(2)} rgba(0, 0, 0, 0.1)`,
                sm: `0 ${GO(1)} ${GO(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${GO(10)} ${GO(15)} ${GO(-5)}, rgba(0, 0, 0, 0.04) 0 ${GO(7)} ${GO(7)} ${GO(-5)}`,
                md: `0 ${GO(1)} ${GO(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${GO(20)} ${GO(25)} ${GO(-5)}, rgba(0, 0, 0, 0.04) 0 ${GO(10)} ${GO(10)} ${GO(-5)}`,
                lg: `0 ${GO(1)} ${GO(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${GO(28)} ${GO(23)} ${GO(-7)}, rgba(0, 0, 0, 0.04) 0 ${GO(12)} ${GO(12)} ${GO(-7)}`,
                xl: `0 ${GO(1)} ${GO(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${GO(36)} ${GO(28)} ${GO(-7)}, rgba(0, 0, 0, 0.04) 0 ${GO(17)} ${GO(17)} ${GO(-7)}`
            },
            other: {},
            components: {}
        };
    function lA(e) {
        return e && "object" === typeof e && !Array.isArray(e)
    }
    function cA(e, t) {
        const n = {
            ...e
        }
            , r = t;
        return lA(e) && lA(t) && Object.keys(t).forEach((t => {
            lA(r[t]) ? n[t] = t in e ? cA(n[t], r[t]) : r[t] : n[t] = r[t]
        }
        )),
            n
    }
    const dA = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
    function uA(e) {
        return !(e < 0 || e > 9) && parseInt(e.toString(), 10) === e
    }
    function hA(e) {
        if (!(e.primaryColor in e.colors))
            throw new Error("[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more \u2013 https://mantine.dev/theming/colors/#primary-color");
        if ("object" === typeof e.primaryShade && (!uA(e.primaryShade.dark) || !uA(e.primaryShade.light)))
            throw new Error(dA);
        if ("number" === typeof e.primaryShade && !uA(e.primaryShade))
            throw new Error(dA)
    }
    const pA = (0,
        r.createContext)(null);
    function fA() {
        const e = (0,
            r.useContext)(pA);
        if (!e)
            throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app");
        return e
    }
    function mA(e) {
        let { theme: t, children: n, inherit: o = !0 } = e;
        const i = (0,
            r.useContext)(pA) || aA
            , s = (0,
                r.useMemo)((() => function (e, t) {
                    if (!t)
                        return hA(e),
                            e;
                    const n = cA(e, t);
                    return t.fontFamily && !t.headings?.fontFamily && (n.headings.fontFamily = t.fontFamily),
                        hA(n),
                        n
                }(o ? i : aA, t)), [t, i, o]);
        return (0,
            Lx.jsx)(pA.Provider, {
                value: s,
                children: n
            })
    }
    function gA(e, t, n) {
        const r = fA()
            , o = r.components[e]?.defaultProps;
        return {
            ...t,
            ..."function" === typeof o ? o(r) : o,
            ...UO(n)
        }
    }
    function bA(e) {
        return e
    }
    function yA(e) {
        const t = (0,
            r.forwardRef)(e);
        return t.extend = bA,
            t.withProps = e => {
                const n = (0,
                    r.forwardRef)(((n, r) => (0,
                        Lx.jsx)(t, {
                            ...e,
                            ...n,
                            ref: r
                        })));
                return n.extend = t.extend,
                    n.displayName = `WithProps(${t.displayName})`,
                    n
            }
            ,
            t
    }
    function vA(e) {
        const t = (0,
            r.forwardRef)(e);
        return t.withProps = e => {
            const n = (0,
                r.forwardRef)(((n, r) => (0,
                    Lx.jsx)(t, {
                        ...e,
                        ...n,
                        ref: r
                    })));
            return n.extend = t.extend,
                n.displayName = `WithProps(${t.displayName})`,
                n
        }
            ,
            t.extend = bA,
            t
    }
    function wA(e) {
        if ("number" === typeof e)
            return !0;
        if ("string" === typeof e) {
            if (e.startsWith("calc(") || e.startsWith("var(") || e.includes(" ") && "" !== e.trim())
                return !0;
            const t = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
            return e.trim().split(/\s+/).every((e => t.test(e)))
        }
        return !1
    }
    function kA(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "size"
            , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        if (void 0 !== e)
            return wA(e) ? n ? GO(e) : e : `var(--${t}-${e})`
    }
    function CA(e) {
        return kA(e, "mantine-spacing")
    }
    function SA(e) {
        return void 0 === e ? "var(--mantine-radius-default)" : kA(e, "mantine-radius")
    }
    function xA(e) {
        return kA(e, "mantine-font-size")
    }
    function EA(e) {
        return kA(e, "mantine-line-height", !1)
    }
    function MA(e) {
        if (e)
            return kA(e, "mantine-shadow", !1)
    }
    mA.displayName = "@mantine/core/MantineThemeProvider";
    const TA = (0,
        r.createContext)(null);
    function NA() {
        const e = (0,
            r.useContext)(TA);
        if (!e)
            throw new Error("[@mantine/core] MantineProvider was not found in tree");
        return e
    }
    function _A() {
        return NA().getStyleNonce
    }
    function OA(e) {
        var t, n, r = "";
        if ("string" == typeof e || "number" == typeof e)
            r += e;
        else if ("object" == typeof e)
            if (Array.isArray(e)) {
                var o = e.length;
                for (t = 0; t < o; t++)
                    e[t] && (n = OA(e[t])) && (r && (r += " "),
                        r += n)
            } else
                for (n in e)
                    e[n] && (r && (r += " "),
                        r += n);
        return r
    }
    const AA = function () {
        for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++)
            (e = arguments[n]) && (t = OA(e)) && (r && (r += " "),
                r += t);
        return r
    }
        , PA = {
            always: "mantine-focus-always",
            auto: "mantine-focus-auto",
            never: "mantine-focus-never"
        };
    const LA = {};
    function RA(e) {
        let { theme: t, classNames: n, props: r, stylesCtx: o } = e;
        return function (e) {
            const t = {};
            return e.forEach((e => {
                Object.entries(e).forEach((e => {
                    let [n, r] = e;
                    t[n] ? t[n] = AA(t[n], r) : t[n] = r
                }
                ))
            }
            )),
                t
        }((Array.isArray(n) ? n : [n]).map((e => "function" === typeof e ? e(t, r, o) : e || LA)))
    }
    function DA(e) {
        let { selector: t, stylesCtx: n, theme: r, classNames: o, props: i } = e;
        return RA({
            theme: r,
            classNames: o,
            props: i,
            stylesCtx: n
        })[t]
    }
    function IA(e) {
        let { theme: t, options: n, themeName: r, selector: o, classNamesPrefix: i, classNames: s, classes: a, unstyled: l, className: c, rootSelector: d, props: u, stylesCtx: h, withStaticClasses: p, headless: f, transformedStyles: m } = e;
        return AA(function (e) {
            let { theme: t, options: n, unstyled: r } = e;
            return AA(n?.focusable && !r && (t.focusClassName || PA[t.focusRing]), n?.active && !r && t.activeClassName)
        }({
            theme: t,
            options: n,
            unstyled: l || f
        }), function (e) {
            let { themeName: t, theme: n, selector: r, props: o, stylesCtx: i } = e;
            return t.map((e => RA({
                theme: n,
                classNames: n.components[e]?.classNames,
                props: o,
                stylesCtx: i
            })?.[r]))
        }({
            theme: t,
            themeName: r,
            selector: o,
            props: u,
            stylesCtx: h
        }), function (e) {
            let { options: t, classes: n, selector: r, unstyled: o } = e;
            return t?.variant && !o ? n[`${r}--${t.variant}`] : void 0
        }({
            options: n,
            classes: a,
            selector: o,
            unstyled: l
        }), DA({
            selector: o,
            stylesCtx: h,
            theme: t,
            classNames: s,
            props: u
        }), DA({
            selector: o,
            stylesCtx: h,
            theme: t,
            classNames: m,
            props: u
        }), function (e) {
            let { selector: t, stylesCtx: n, options: r, props: o, theme: i } = e;
            return RA({
                theme: i,
                classNames: r?.classNames,
                props: r?.props || o,
                stylesCtx: n
            })[t]
        }({
            selector: o,
            stylesCtx: h,
            options: n,
            props: u,
            theme: t
        }), function (e) {
            let { rootSelector: t, selector: n, className: r } = e;
            return t === n ? r : void 0
        }({
            rootSelector: d,
            selector: o,
            className: c
        }), function (e) {
            let { selector: t, classes: n, unstyled: r } = e;
            return r ? void 0 : n[t]
        }({
            selector: o,
            classes: a,
            unstyled: l || f
        }), p && !f && function (e) {
            let { themeName: t, classNamesPrefix: n, selector: r, withStaticClass: o } = e;
            return !1 === o ? [] : t.map((e => `${n}-${e}-${r}`))
        }({
            themeName: r,
            classNamesPrefix: i,
            selector: o,
            withStaticClass: n?.withStaticClass
        }), n?.className)
    }
    function jA(e) {
        let { theme: t, styles: n, props: r, stylesCtx: o } = e;
        return (Array.isArray(n) ? n : [n]).reduce(((e, n) => "function" === typeof n ? {
            ...e,
            ...n(t, r, o)
        } : {
            ...e,
            ...n
        }), {})
    }
    function HA(e) {
        let { theme: t, themeName: n, props: r, stylesCtx: o, selector: i } = e;
        return n.map((e => jA({
            theme: t,
            styles: t.components[e]?.styles,
            props: r,
            stylesCtx: o
        })[i])).reduce(((e, t) => ({
            ...e,
            ...t
        })), {})
    }
    function zA(e) {
        let { style: t, theme: n } = e;
        return Array.isArray(t) ? [...t].reduce(((e, t) => ({
            ...e,
            ...zA({
                style: t,
                theme: n
            })
        })), {}) : "function" === typeof t ? t(n) : null == t ? {} : t
    }
    function $A(e) {
        let { vars: t, varsResolver: n, theme: r, props: o, stylesCtx: i, selector: s, themeName: a, headless: l } = e;
        return function (e) {
            return e.reduce(((e, t) => (t && Object.keys(t).forEach((n => {
                e[n] = {
                    ...e[n],
                    ...UO(t[n])
                }
            }
            )),
                e)), {})
        }([l ? {} : n?.(r, o, i), ...a.map((e => r.components?.[e]?.vars?.(r, o, i))), t?.(r, o, i)])?.[s]
    }
    function BA(e) {
        let { theme: t, themeName: n, selector: r, options: o, props: i, stylesCtx: s, rootSelector: a, styles: l, style: c, vars: d, varsResolver: u, headless: h, withStylesTransform: p } = e;
        return {
            ...!p && HA({
                theme: t,
                themeName: n,
                props: i,
                stylesCtx: s,
                selector: r
            }),
            ...!p && jA({
                theme: t,
                styles: l,
                props: i,
                stylesCtx: s
            })[r],
            ...!p && jA({
                theme: t,
                styles: o?.styles,
                props: o?.props || i,
                stylesCtx: s
            })[r],
            ...$A({
                theme: t,
                props: i,
                stylesCtx: s,
                vars: d,
                varsResolver: u,
                selector: r,
                themeName: n,
                headless: h
            }),
            ...a === r ? zA({
                style: c,
                theme: t
            }) : null,
            ...zA({
                style: o?.style,
                theme: t
            })
        }
    }
    function VA(e) {
        let { props: t, stylesCtx: n, themeName: r } = e;
        const o = fA()
            , i = (NA().stylesTransform?.styles)?.();
        return {
            getTransformedStyles: e => {
                if (!i)
                    return [];
                const s = e.map((e => i(e, {
                    props: t,
                    theme: o,
                    ctx: n
                })));
                return [...s, ...r.map((e => i(o.components[e]?.styles, {
                    props: t,
                    theme: o,
                    ctx: n
                })))].filter(Boolean)
            }
            ,
            withStylesTransform: !!i
        }
    }
    function FA(e) {
        let { name: t, classes: n, props: r, stylesCtx: o, className: i, style: s, rootSelector: a = "root", unstyled: l, classNames: c, styles: d, vars: u, varsResolver: h } = e;
        const p = fA()
            , f = NA().classNamesPrefix
            , m = NA().withStaticClasses
            , g = NA().headless
            , b = (Array.isArray(t) ? t : [t]).filter((e => e))
            , { withStylesTransform: y, getTransformedStyles: v } = VA({
                props: r,
                stylesCtx: o,
                themeName: b
            });
        return (e, t) => ({
            className: IA({
                theme: p,
                options: t,
                themeName: b,
                selector: e,
                classNamesPrefix: f,
                classNames: c,
                classes: n,
                unstyled: l,
                className: i,
                rootSelector: a,
                props: r,
                stylesCtx: o,
                withStaticClasses: m,
                headless: g,
                transformedStyles: v([t?.styles, d])
            }),
            style: BA({
                theme: p,
                themeName: b,
                selector: e,
                options: t,
                props: r,
                stylesCtx: o,
                rootSelector: a,
                styles: d,
                style: s,
                vars: u,
                varsResolver: h,
                headless: g,
                withStylesTransform: y
            })
        })
    }
    function UA(e) {
        const { m: t, mx: n, my: r, mt: o, mb: i, ml: s, mr: a, me: l, ms: c, p: d, px: u, py: h, pt: p, pb: f, pl: m, pr: g, pe: b, ps: y, bd: v, bg: w, c: k, opacity: C, ff: S, fz: x, fw: E, lts: M, ta: T, lh: N, fs: _, tt: O, td: A, w: P, miw: L, maw: R, h: D, mih: I, mah: j, bgsz: H, bgp: z, bgr: $, bga: B, pos: V, top: F, left: U, bottom: W, right: q, inset: G, display: K, flex: J, hiddenFrom: Z, visibleFrom: X, lightHidden: Q, darkHidden: Y, sx: ee, ...te } = e;
        return {
            styleProps: UO({
                m: t,
                mx: n,
                my: r,
                mt: o,
                mb: i,
                ml: s,
                mr: a,
                me: l,
                ms: c,
                p: d,
                px: u,
                py: h,
                pt: p,
                pb: f,
                pl: m,
                pr: g,
                pe: b,
                ps: y,
                bd: v,
                bg: w,
                c: k,
                opacity: C,
                ff: S,
                fz: x,
                fw: E,
                lts: M,
                ta: T,
                lh: N,
                fs: _,
                tt: O,
                td: A,
                w: P,
                miw: L,
                maw: R,
                h: D,
                mih: I,
                mah: j,
                bgsz: H,
                bgp: z,
                bgr: $,
                bga: B,
                pos: V,
                top: F,
                left: U,
                bottom: W,
                right: q,
                inset: G,
                display: K,
                flex: J,
                hiddenFrom: Z,
                visibleFrom: X,
                lightHidden: Q,
                darkHidden: Y,
                sx: ee
            }),
            rest: te
        }
    }
    function WA(e) {
        return Object.keys(e)
    }
    function qA(e) {
        return WA(e).reduce(((t, n) => {
            return void 0 !== e[n] ? `${t}${r = n,
                r.replace(/[A-Z]/g, (e => `-${e.toLowerCase()}`))}:${e[n]};` : t;
            var r
        }
        ), "").trim()
    }
    function GA(e) {
        let { selector: t, styles: n, media: r, container: o } = e;
        const i = n ? qA(n) : ""
            , s = Array.isArray(r) ? r.map((e => `@media${e.query}{${t}{${qA(e.styles)}}}`)) : []
            , a = Array.isArray(o) ? o.map((e => `@container ${e.query}{${t}{${qA(e.styles)}}}`)) : [];
        return `${i ? `${t}{${i}}` : ""}${s.join("")}${a.join("")}`.trim()
    }
    function KA(e) {
        const t = _A();
        return (0,
            Lx.jsx)("style", {
                "data-mantine-styles": "inline",
                nonce: t?.(),
                dangerouslySetInnerHTML: {
                    __html: GA(e)
                }
            })
    }
    function JA(e) {
        return e.startsWith("data-") ? e : `data-${e}`
    }
    function ZA(e) {
        return e ? "string" === typeof e ? {
            [JA(e)]: !0
        } : Array.isArray(e) ? [...e].reduce(((e, t) => ({
            ...e,
            ...ZA(t)
        })), {}) : (t = e,
            Object.keys(t).reduce(((e, n) => {
                const r = t[n];
                return void 0 === r || "" === r || !1 === r || null === r || (e[JA(n)] = t[n]),
                    e
            }
            ), {})) : null;
        var t
    }
    function XA(e, t) {
        return Array.isArray(e) ? [...e].reduce(((e, n) => ({
            ...e,
            ...XA(n, t)
        })), {}) : "function" === typeof e ? e(t) : null == e ? {} : e
    }
    function QA(e) {
        let { theme: t, style: n, vars: r, styleProps: o } = e;
        return {
            ...XA(n, t),
            ...XA(r, t),
            ...o
        }
    }
    const YA = {
        m: {
            type: "spacing",
            property: "margin"
        },
        mt: {
            type: "spacing",
            property: "marginTop"
        },
        mb: {
            type: "spacing",
            property: "marginBottom"
        },
        ml: {
            type: "spacing",
            property: "marginLeft"
        },
        mr: {
            type: "spacing",
            property: "marginRight"
        },
        ms: {
            type: "spacing",
            property: "marginInlineStart"
        },
        me: {
            type: "spacing",
            property: "marginInlineEnd"
        },
        mx: {
            type: "spacing",
            property: "marginInline"
        },
        my: {
            type: "spacing",
            property: "marginBlock"
        },
        p: {
            type: "spacing",
            property: "padding"
        },
        pt: {
            type: "spacing",
            property: "paddingTop"
        },
        pb: {
            type: "spacing",
            property: "paddingBottom"
        },
        pl: {
            type: "spacing",
            property: "paddingLeft"
        },
        pr: {
            type: "spacing",
            property: "paddingRight"
        },
        ps: {
            type: "spacing",
            property: "paddingInlineStart"
        },
        pe: {
            type: "spacing",
            property: "paddingInlineEnd"
        },
        px: {
            type: "spacing",
            property: "paddingInline"
        },
        py: {
            type: "spacing",
            property: "paddingBlock"
        },
        bd: {
            type: "border",
            property: "border"
        },
        bg: {
            type: "color",
            property: "background"
        },
        c: {
            type: "textColor",
            property: "color"
        },
        opacity: {
            type: "identity",
            property: "opacity"
        },
        ff: {
            type: "fontFamily",
            property: "fontFamily"
        },
        fz: {
            type: "fontSize",
            property: "fontSize"
        },
        fw: {
            type: "identity",
            property: "fontWeight"
        },
        lts: {
            type: "size",
            property: "letterSpacing"
        },
        ta: {
            type: "identity",
            property: "textAlign"
        },
        lh: {
            type: "lineHeight",
            property: "lineHeight"
        },
        fs: {
            type: "identity",
            property: "fontStyle"
        },
        tt: {
            type: "identity",
            property: "textTransform"
        },
        td: {
            type: "identity",
            property: "textDecoration"
        },
        w: {
            type: "spacing",
            property: "width"
        },
        miw: {
            type: "spacing",
            property: "minWidth"
        },
        maw: {
            type: "spacing",
            property: "maxWidth"
        },
        h: {
            type: "spacing",
            property: "height"
        },
        mih: {
            type: "spacing",
            property: "minHeight"
        },
        mah: {
            type: "spacing",
            property: "maxHeight"
        },
        bgsz: {
            type: "size",
            property: "backgroundSize"
        },
        bgp: {
            type: "identity",
            property: "backgroundPosition"
        },
        bgr: {
            type: "identity",
            property: "backgroundRepeat"
        },
        bga: {
            type: "identity",
            property: "backgroundAttachment"
        },
        pos: {
            type: "identity",
            property: "position"
        },
        top: {
            type: "identity",
            property: "top"
        },
        left: {
            type: "size",
            property: "left"
        },
        bottom: {
            type: "size",
            property: "bottom"
        },
        right: {
            type: "size",
            property: "right"
        },
        inset: {
            type: "size",
            property: "inset"
        },
        display: {
            type: "identity",
            property: "display"
        },
        flex: {
            type: "identity",
            property: "flex"
        }
    };
    function eP(e, t) {
        const n = tA({
            color: e,
            theme: t
        });
        return "dimmed" === n.color ? "var(--mantine-color-dimmed)" : "bright" === n.color ? "var(--mantine-color-bright)" : n.variable ? `var(${n.variable})` : n.color
    }
    const tP = {
        text: "var(--mantine-font-family)",
        mono: "var(--mantine-font-family-monospace)",
        monospace: "var(--mantine-font-family-monospace)",
        heading: "var(--mantine-font-family-headings)",
        headings: "var(--mantine-font-family-headings)"
    };
    const nP = ["h1", "h2", "h3", "h4", "h5", "h6"];
    const rP = ["h1", "h2", "h3", "h4", "h5", "h6"];
    const oP = {
        color: eP,
        textColor: function (e, t) {
            const n = tA({
                color: e,
                theme: t
            });
            return n.isThemeColor && void 0 === n.shade ? `var(--mantine-color-${n.color}-text)` : eP(e, t)
        },
        fontSize: function (e, t) {
            return "string" === typeof e && e in t.fontSizes ? `var(--mantine-font-size-${e})` : "string" === typeof e && nP.includes(e) ? `var(--mantine-${e}-font-size)` : "number" === typeof e || "string" === typeof e ? GO(e) : e
        },
        spacing: function (e, t) {
            if ("number" === typeof e)
                return GO(e);
            if ("string" === typeof e) {
                const n = e.replace("-", "");
                if (!(n in t.spacing))
                    return GO(e);
                const r = `--mantine-spacing-${n}`;
                return e.startsWith("-") ? `calc(var(${r}) * -1)` : `var(${r})`
            }
            return e
        },
        identity: function (e) {
            return e
        },
        size: function (e) {
            return "number" === typeof e ? GO(e) : e
        },
        lineHeight: function (e, t) {
            return "string" === typeof e && e in t.lineHeights ? `var(--mantine-line-height-${e})` : "string" === typeof e && rP.includes(e) ? `var(--mantine-${e}-line-height)` : e
        },
        fontFamily: function (e) {
            return "string" === typeof e && e in tP ? tP[e] : e
        },
        border: function (e, t) {
            if ("number" === typeof e)
                return GO(e);
            if ("string" === typeof e) {
                const [n, r, ...o] = e.split(" ").filter((e => "" !== e.trim()));
                let i = `${GO(n)}`;
                return r && (i += ` ${r}`),
                    o.length > 0 && (i += ` ${eP(o.join(" "), t)}`),
                    i.trim()
            }
            return e
        }
    };
    function iP(e) {
        return e.replace("(min-width: ", "").replace("em)", "")
    }
    function sP(e, t) {
        return "object" === typeof e && null !== e && t in e ? e[t] : e
    }
    function aP(e) {
        let { styleProps: t, data: n, theme: r } = e;
        return function (e) {
            let { media: t, ...n } = e;
            const r = Object.keys(t).sort(((e, t) => Number(iP(e)) - Number(iP(t)))).map((e => ({
                query: e,
                styles: t[e]
            })));
            return {
                ...n,
                media: r
            }
        }(WA(t).reduce(((e, o) => {
            if ("hiddenFrom" === o || "visibleFrom" === o || "sx" === o)
                return e;
            const i = n[o]
                , s = Array.isArray(i.property) ? i.property : [i.property]
                , a = "object" === typeof (l = t[o]) && null !== l ? "base" in l ? l.base : void 0 : l;
            var l;
            if (!function (e) {
                if ("object" !== typeof e || null === e)
                    return !1;
                const t = Object.keys(e);
                return 1 !== t.length || "base" !== t[0]
            }(t[o]))
                return s.forEach((t => {
                    e.inlineStyles[t] = oP[i.type](a, r)
                }
                )),
                    e;
            e.hasResponsiveStyles = !0;
            const c = function (e) {
                return "object" === typeof e && null !== e ? WA(e).filter((e => "base" !== e)) : []
            }(t[o]);
            return s.forEach((n => {
                a && (e.styles[n] = oP[i.type](a, r)),
                    c.forEach((s => {
                        const a = `(min-width: ${r.breakpoints[s]})`;
                        e.media[a] = {
                            ...e.media[a],
                            [n]: oP[i.type](sP(t[o], s), r)
                        }
                    }
                    ))
            }
            )),
                e
        }
        ), {
            hasResponsiveStyles: !1,
            styles: {},
            inlineStyles: {},
            media: {}
        }))
    }
    const lP = (0,
        r.forwardRef)(((e, t) => {
            let { component: n, style: o, __vars: i, className: s, variant: a, mod: l, size: c, hiddenFrom: d, visibleFrom: u, lightHidden: h, darkHidden: p, renderRoot: f, __size: m, ...g } = e;
            const b = fA()
                , y = n || "div"
                , { styleProps: v, rest: w } = UA(g)
                , k = NA().stylesTransform?.sx
                , C = k?.()?.(v.sx)
                , S = `__m__-${(0,
                    r.useId)().replace(/:/g, "")}`
                , x = aP({
                    styleProps: v,
                    theme: b,
                    data: YA
                })
                , E = {
                    ref: t,
                    style: QA({
                        theme: b,
                        style: o,
                        vars: i,
                        styleProps: x.inlineStyles
                    }),
                    className: AA(s, C, {
                        [S]: x.hasResponsiveStyles,
                        "mantine-light-hidden": h,
                        "mantine-dark-hidden": p,
                        [`mantine-hidden-from-${d}`]: d,
                        [`mantine-visible-from-${u}`]: u
                    }),
                    "data-variant": a,
                    "data-size": wA(c) ? void 0 : c || void 0,
                    size: m,
                    ...ZA(l),
                    ...w
                };
            return (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [x.hasResponsiveStyles && (0,
                        Lx.jsx)(KA, {
                            selector: `.${S}`,
                            styles: x.styles,
                            media: x.media
                        }), "function" === typeof f ? f(E) : (0,
                            Lx.jsx)(y, {
                                ...E
                            })]
                })
        }
        ));
    lP.displayName = "@mantine/core/Box";
    const cP = lP;
    const [dP, uP] = function () {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        const t = (0,
            r.createContext)(e);
        return [e => {
            let { children: n, value: r } = e;
            return (0,
                Lx.jsx)(t.Provider, {
                    value: r,
                    children: n
                })
        }
            , () => (0,
                r.useContext)(t)]
    }({
        offsetBottom: !1,
        offsetTop: !1,
        describedBy: void 0,
        getStyles: null,
        inputId: void 0,
        labelId: void 0
    });
    var hP = {
        wrapper: "m_6c018570",
        input: "m_8fb7ebe7",
        section: "m_82577fc2",
        placeholder: "m_88bacfd0",
        root: "m_46b77525",
        label: "m_8fdc1311",
        required: "m_78a94662",
        error: "m_8f816625",
        description: "m_fe47ce59"
    };
    const pP = {}
        , fP = (e, t) => {
            let { size: n } = t;
            return {
                description: {
                    "--input-description-size": void 0 === n ? void 0 : `calc(${xA(n)} - ${GO(2)})`
                }
            }
        }
        , mP = yA(((e, t) => {
            const n = gA("InputDescription", pP, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, size: c, __staticSelector: d, __inheritStyles: u = !0, variant: h, ...p } = gA("InputDescription", pP, n)
                , f = uP()
                , m = FA({
                    name: ["InputWrapper", d],
                    props: n,
                    classes: hP,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    rootSelector: "description",
                    vars: l,
                    varsResolver: fP
                })
                , g = u && f?.getStyles || m;
            return (0,
                Lx.jsx)(cP, {
                    component: "p",
                    ref: t,
                    variant: h,
                    size: c,
                    ...g("description", f?.getStyles ? {
                        className: o,
                        style: i
                    } : void 0),
                    ...p
                })
        }
        ));
    mP.classes = hP,
        mP.displayName = "@mantine/core/InputDescription";
    const gP = {}
        , bP = (e, t) => {
            let { size: n } = t;
            return {
                error: {
                    "--input-error-size": void 0 === n ? void 0 : `calc(${xA(n)} - ${GO(2)})`
                }
            }
        }
        , yP = yA(((e, t) => {
            const n = gA("InputError", gP, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, size: c, __staticSelector: d, __inheritStyles: u = !0, variant: h, ...p } = n
                , f = FA({
                    name: ["InputWrapper", d],
                    props: n,
                    classes: hP,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    rootSelector: "error",
                    vars: l,
                    varsResolver: bP
                })
                , m = uP()
                , g = u && m?.getStyles || f;
            return (0,
                Lx.jsx)(cP, {
                    component: "p",
                    ref: t,
                    variant: h,
                    size: c,
                    ...g("error", m?.getStyles ? {
                        className: o,
                        style: i
                    } : void 0),
                    ...p
                })
        }
        ));
    yP.classes = hP,
        yP.displayName = "@mantine/core/InputError";
    const vP = {
        labelElement: "label"
    }
        , wP = (e, t) => {
            let { size: n } = t;
            return {
                label: {
                    "--input-label-size": xA(n),
                    "--input-asterisk-color": void 0
                }
            }
        }
        , kP = yA(((e, t) => {
            const n = gA("InputLabel", vP, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, labelElement: c, size: d, required: u, htmlFor: h, onMouseDown: p, children: f, __staticSelector: m, variant: g, mod: b, ...y } = gA("InputLabel", vP, n)
                , v = FA({
                    name: ["InputWrapper", m],
                    props: n,
                    classes: hP,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    rootSelector: "label",
                    vars: l,
                    varsResolver: wP
                })
                , w = uP()
                , k = w?.getStyles || v;
            return (0,
                Lx.jsxs)(cP, {
                    ...k("label", w?.getStyles ? {
                        className: o,
                        style: i
                    } : void 0),
                    component: c,
                    variant: g,
                    size: d,
                    ref: t,
                    htmlFor: "label" === c ? h : void 0,
                    mod: [{
                        required: u
                    }, b],
                    onMouseDown: e => {
                        p?.(e),
                            !e.defaultPrevented && e.detail > 1 && e.preventDefault()
                    }
                    ,
                    ...y,
                    children: [f, u && (0,
                        Lx.jsx)("span", {
                            ...k("required"),
                            "aria-hidden": !0,
                            children: " *"
                        })]
                })
        }
        ));
    kP.classes = hP,
        kP.displayName = "@mantine/core/InputLabel";
    const CP = {}
        , SP = yA(((e, t) => {
            const n = gA("InputPlaceholder", CP, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, __staticSelector: c, variant: d, error: u, mod: h, ...p } = gA("InputPlaceholder", CP, n)
                , f = FA({
                    name: ["InputPlaceholder", c],
                    props: n,
                    classes: hP,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    rootSelector: "placeholder"
                });
            return (0,
                Lx.jsx)(cP, {
                    ...f("placeholder"),
                    mod: [{
                        error: !!u
                    }, h],
                    component: "span",
                    variant: d,
                    ref: t,
                    ...p
                })
        }
        ));
    SP.classes = hP,
        SP.displayName = "@mantine/core/InputPlaceholder";
    const xP = "undefined" !== typeof document ? r.useLayoutEffect : r.useEffect;
    function EP() {
        return `mantine-${Math.random().toString(36).slice(2, 11)}`
    }
    const MP = r["useId".toString()] || (() => { }
    );
    function TP(e) {
        const t = function () {
            const e = MP();
            return e ? `mantine-${e.replace(/:/g, "")}` : ""
        }()
            , [n, o] = (0,
                r.useState)(t);
        return xP((() => {
            o(EP())
        }
        ), []),
            "string" === typeof e ? e : "undefined" === typeof window ? t : n
    }
    function NP(e, t) {
        let { hasDescription: n, hasError: r } = t;
        const o = e.findIndex((e => "input" === e))
            , i = e.slice(0, o)
            , s = e.slice(o + 1)
            , a = n && i.includes("description") || r && i.includes("error");
        return {
            offsetBottom: n && s.includes("description") || r && s.includes("error"),
            offsetTop: a
        }
    }
    const _P = {
        labelElement: "label",
        inputContainer: e => e,
        inputWrapperOrder: ["label", "description", "input", "error"]
    }
        , OP = (e, t) => {
            let { size: n } = t;
            return {
                label: {
                    "--input-label-size": xA(n),
                    "--input-asterisk-color": void 0
                },
                error: {
                    "--input-error-size": void 0 === n ? void 0 : `calc(${xA(n)} - ${GO(2)})`
                },
                description: {
                    "--input-description-size": void 0 === n ? void 0 : `calc(${xA(n)} - ${GO(2)})`
                }
            }
        }
        , AP = yA(((e, t) => {
            const n = gA("InputWrapper", _P, e)
                , { classNames: o, className: i, style: s, styles: a, unstyled: l, vars: c, size: d, variant: u, __staticSelector: h, inputContainer: p, inputWrapperOrder: f, label: m, error: g, description: b, labelProps: y, descriptionProps: v, errorProps: w, labelElement: k, children: C, withAsterisk: S, id: x, required: E, __stylesApiProps: M, mod: T, ...N } = n
                , _ = FA({
                    name: ["InputWrapper", h],
                    props: M || n,
                    classes: hP,
                    className: i,
                    style: s,
                    classNames: o,
                    styles: a,
                    unstyled: l,
                    vars: c,
                    varsResolver: OP
                })
                , O = {
                    size: d,
                    variant: u,
                    __staticSelector: h
                }
                , A = TP(x)
                , P = "boolean" === typeof S ? S : E
                , L = w?.id || `${A}-error`
                , R = v?.id || `${A}-description`
                , D = A
                , I = !!g && "boolean" !== typeof g
                , j = !!b
                , H = `${I ? L : ""} ${j ? R : ""}`
                , z = H.trim().length > 0 ? H.trim() : void 0
                , $ = y?.id || `${A}-label`
                , B = m && (0,
                    Lx.jsx)(kP, {
                        labelElement: k,
                        id: $,
                        htmlFor: D,
                        required: P,
                        ...O,
                        ...y,
                        children: m
                    }, "label")
                , V = j && (0,
                    Lx.jsx)(mP, {
                        ...v,
                        ...O,
                        size: v?.size || O.size,
                        id: v?.id || R,
                        children: b
                    }, "description")
                , F = (0,
                    Lx.jsx)(r.Fragment, {
                        children: p(C)
                    }, "input")
                , U = I && (0,
                    r.createElement)(yP, {
                        ...w,
                        ...O,
                        size: w?.size || O.size,
                        key: "error",
                        id: w?.id || L
                    }, g)
                , W = f.map((e => {
                    switch (e) {
                        case "label":
                            return B;
                        case "input":
                            return F;
                        case "description":
                            return V;
                        case "error":
                            return U;
                        default:
                            return null
                    }
                }
                ));
            return (0,
                Lx.jsx)(dP, {
                    value: {
                        getStyles: _,
                        describedBy: z,
                        inputId: D,
                        labelId: $,
                        ...NP(f, {
                            hasDescription: j,
                            hasError: I
                        })
                    },
                    children: (0,
                        Lx.jsx)(cP, {
                            ref: t,
                            variant: u,
                            size: d,
                            mod: [{
                                error: !!g
                            }, T],
                            ..._("root"),
                            ...N,
                            children: W
                        })
                })
        }
        ));
    AP.classes = hP,
        AP.displayName = "@mantine/core/InputWrapper";
    const PP = {
        variant: "default",
        leftSectionPointerEvents: "none",
        rightSectionPointerEvents: "none",
        withAria: !0,
        withErrorStyles: !0
    }
        , LP = (e, t, n) => ({
            wrapper: {
                "--input-margin-top": n.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
                "--input-margin-bottom": n.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
                "--input-height": kA(t.size, "input-height"),
                "--input-fz": xA(t.size),
                "--input-radius": void 0 === t.radius ? void 0 : SA(t.radius),
                "--input-left-section-width": void 0 !== t.leftSectionWidth ? GO(t.leftSectionWidth) : void 0,
                "--input-right-section-width": void 0 !== t.rightSectionWidth ? GO(t.rightSectionWidth) : void 0,
                "--input-padding-y": t.multiline ? kA(t.size, "input-padding-y") : void 0,
                "--input-left-section-pointer-events": t.leftSectionPointerEvents,
                "--input-right-section-pointer-events": t.rightSectionPointerEvents
            }
        })
        , RP = vA(((e, t) => {
            const n = gA("Input", PP, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, required: l, __staticSelector: c, __stylesApiProps: d, size: u, wrapperProps: h, error: p, disabled: f, leftSection: m, leftSectionProps: g, leftSectionWidth: b, rightSection: y, rightSectionProps: v, rightSectionWidth: w, rightSectionPointerEvents: k, leftSectionPointerEvents: C, variant: S, vars: x, pointer: E, multiline: M, radius: T, id: N, withAria: _, withErrorStyles: O, mod: A, inputSize: P, ...L } = n
                , { styleProps: R, rest: D } = UA(L)
                , I = uP()
                , j = FA({
                    name: ["Input", c],
                    props: d || n,
                    classes: hP,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    stylesCtx: {
                        offsetBottom: I?.offsetBottom,
                        offsetTop: I?.offsetTop
                    },
                    rootSelector: "wrapper",
                    vars: x,
                    varsResolver: LP
                })
                , H = _ ? {
                    required: l,
                    disabled: f,
                    "aria-invalid": !!p,
                    "aria-describedby": I?.describedBy,
                    id: I?.inputId || N
                } : {};
            return (0,
                Lx.jsxs)(cP, {
                    ...j("wrapper"),
                    ...R,
                    ...h,
                    mod: [{
                        error: !!p && O,
                        pointer: E,
                        disabled: f,
                        multiline: M,
                        "data-with-right-section": !!y,
                        "data-with-left-section": !!m
                    }, A],
                    variant: S,
                    size: u,
                    children: [m && (0,
                        Lx.jsx)("div", {
                            ...g,
                            "data-position": "left",
                            ...j("section", {
                                className: g?.className,
                                style: g?.style
                            }),
                            children: m
                        }), (0,
                            Lx.jsx)(cP, {
                                component: "input",
                                ...D,
                                ...H,
                                ref: t,
                                required: l,
                                mod: {
                                    disabled: f,
                                    error: !!p && O
                                },
                                variant: S,
                                __size: P,
                                ...j("input")
                            }), y && (0,
                                Lx.jsx)("div", {
                                    ...v,
                                    "data-position": "right",
                                    ...j("section", {
                                        className: v?.className,
                                        style: v?.style
                                    }),
                                    children: y
                                })]
                })
        }
        ));
    RP.classes = hP,
        RP.Wrapper = AP,
        RP.Label = kP,
        RP.Error = yP,
        RP.Description = mP,
        RP.Placeholder = SP,
        RP.displayName = "@mantine/core/Input";
    const DP = {
        __staticSelector: "InputBase",
        withAria: !0
    }
        , IP = vA(((e, t) => {
            const { inputProps: n, wrapperProps: r, ...o } = function (e, t, n) {
                const r = gA(e, t, n)
                    , { label: o, description: i, error: s, required: a, classNames: l, styles: c, className: d, unstyled: u, __staticSelector: h, __stylesApiProps: p, errorProps: f, labelProps: m, descriptionProps: g, wrapperProps: b, id: y, size: v, style: w, inputContainer: k, inputWrapperOrder: C, withAsterisk: S, variant: x, vars: E, mod: M, ...T } = r
                    , { styleProps: N, rest: _ } = UA(T);
                return {
                    ..._,
                    classNames: l,
                    styles: c,
                    unstyled: u,
                    wrapperProps: {
                        ...{
                            label: o,
                            description: i,
                            error: s,
                            required: a,
                            classNames: l,
                            className: d,
                            __staticSelector: h,
                            __stylesApiProps: p || r,
                            errorProps: f,
                            labelProps: m,
                            descriptionProps: g,
                            unstyled: u,
                            styles: c,
                            size: v,
                            style: w,
                            inputContainer: k,
                            inputWrapperOrder: C,
                            withAsterisk: S,
                            variant: x,
                            id: y,
                            mod: M,
                            ...b
                        },
                        ...N
                    },
                    inputProps: {
                        required: a,
                        classNames: l,
                        styles: c,
                        unstyled: u,
                        size: v,
                        __staticSelector: h,
                        __stylesApiProps: p || r,
                        error: s,
                        variant: x,
                        id: y
                    }
                }
            }("InputBase", DP, e);
            return (0,
                Lx.jsx)(RP.Wrapper, {
                    ...r,
                    children: (0,
                        Lx.jsx)(RP, {
                            ...n,
                            ...o,
                            ref: t
                        })
                })
        }
        ));
    IP.classes = {
        ...RP.classes,
        ...RP.Wrapper.classes
    },
        IP.displayName = "@mantine/core/InputBase";
    const jP = {}
        , HP = yA(((e, t) => {
            const n = gA("TextInput", jP, e);
            return (0,
                Lx.jsx)(IP, {
                    component: "input",
                    ref: t,
                    ...n,
                    __staticSelector: "TextInput"
                })
        }
        ));
    function zP(e) {
        let { value: t, defaultValue: n, finalValue: o, onChange: i = () => { }
        } = e;
        const [s, a] = (0,
            r.useState)(void 0 !== n ? n : o);
        return void 0 !== t ? [t, i, !0] : [s, function (e) {
            a(e);
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                n[r - 1] = arguments[r];
            i?.(e, ...n)
        }
            , !1]
    }
    function $P(e, t) {
        const n = (0,
            r.useRef)(!1);
        (0,
            r.useEffect)((() => () => {
                n.current = !1
            }
            ), []),
            (0,
                r.useEffect)((() => {
                    if (n.current)
                        return e();
                    n.current = !0
                }
                ), t)
    }
    function BP(e, t) {
        let n = e;
        for (; (n = n.parentElement) && !n.matches(t);)
            ;
        return n
    }
    HP.classes = IP.classes,
        HP.displayName = "@mantine/core/TextInput";
    const VP = ["mousedown", "touchstart"];
    const FP = {
        app: 100,
        modal: 200,
        popover: 300,
        overlay: 400,
        max: 9999
    };
    function UP(e) {
        return FP[e]
    }
    const WP = (0,
        r.createContext)({
            dir: "ltr",
            toggleDirection: () => { }
            ,
            setDirection: () => { }
        });
    function qP() {
        return (0,
            r.useContext)(WP)
    }
    function GP(e, t) {
        if ("rtl" === e && (t.includes("right") || t.includes("left"))) {
            const [e, n] = t.split("-")
                , r = "right" === e ? "left" : "right";
            return void 0 === n ? r : `${r}-${n}`
        }
        return t
    }
    function KP(e) {
        const t = (0,
            r.createContext)(null);
        return [e => {
            let { children: n, value: r } = e;
            return (0,
                Lx.jsx)(t.Provider, {
                    value: r,
                    children: n
                })
        }
            , () => {
                const n = (0,
                    r.useContext)(t);
                if (null === n)
                    throw new Error(e);
                return n
            }
        ]
    }
    const [JP, ZP] = KP("Popover component was not found in the tree");
    function XP(e, t) {
        "function" === typeof e ? e(t) : "object" === typeof e && null !== e && "current" in e && (e.current = t)
    }
    function QP() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return e => {
            t.forEach((t => XP(t, e)))
        }
    }
    function YP() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return (0,
            r.useCallback)(QP(...t), t)
    }
    const eL = () => { }
        ;
    function tL(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
            active: !0
        };
        return "function" === typeof e && t.active ? n => {
            "Escape" === n.key && (e(n),
                t.onTrigger?.())
        }
            : t.onKeyDown || eL
    }
    function nL(e, t, n, r) {
        return "center" === e || "center" === r ? {
            top: t
        } : "end" === e ? {
            bottom: n
        } : "start" === e ? {
            top: n
        } : {}
    }
    function rL(e, t, n, r, o) {
        return "center" === e || "center" === r ? {
            left: t
        } : "end" === e ? {
            ["ltr" === o ? "right" : "left"]: n
        } : "start" === e ? {
            ["ltr" === o ? "left" : "right"]: n
        } : {}
    }
    const oL = {
        bottom: "borderTopLeftRadius",
        left: "borderTopRightRadius",
        right: "borderBottomLeftRadius",
        top: "borderBottomRightRadius"
    };
    function iL(e) {
        let { position: t, arrowSize: n, arrowOffset: r, arrowRadius: o, arrowPosition: i, arrowX: s, arrowY: a, dir: l } = e;
        const [c, d = "center"] = t.split("-")
            , u = {
                width: n,
                height: n,
                transform: "rotate(45deg)",
                position: "absolute",
                [oL[c]]: o
            }
            , h = -n / 2;
        return "left" === c ? {
            ...u,
            ...nL(d, a, r, i),
            right: h,
            borderLeftColor: "transparent",
            borderBottomColor: "transparent"
        } : "right" === c ? {
            ...u,
            ...nL(d, a, r, i),
            left: h,
            borderRightColor: "transparent",
            borderTopColor: "transparent"
        } : "top" === c ? {
            ...u,
            ...rL(d, s, r, i, l),
            bottom: h,
            borderTopColor: "transparent",
            borderLeftColor: "transparent"
        } : "bottom" === c ? {
            ...u,
            ...rL(d, s, r, i, l),
            top: h,
            borderBottomColor: "transparent",
            borderRightColor: "transparent"
        } : {}
    }
    const sL = (0,
        r.forwardRef)(((e, t) => {
            let { position: n, arrowSize: r, arrowOffset: o, arrowRadius: i, arrowPosition: s, visible: a, arrowX: l, arrowY: c, style: d, ...u } = e;
            const { dir: h } = qP();
            return a ? (0,
                Lx.jsx)("div", {
                    ...u,
                    ref: t,
                    style: {
                        ...d,
                        ...iL({
                            position: n,
                            arrowSize: r,
                            arrowOffset: o,
                            arrowRadius: i,
                            arrowPosition: s,
                            dir: h,
                            arrowX: l,
                            arrowY: c
                        })
                    }
                }) : null
        }
        ));
    sL.displayName = "@mantine/core/FloatingArrow";
    const aL = /input|select|textarea|button|object/
        , lL = "a, input, select, textarea, button, object, [tabindex]";
    function cL(e) {
        return "none" === e.style.display
    }
    function dL(e) {
        let t = e.getAttribute("tabindex");
        return null === t && (t = void 0),
            parseInt(t, 10)
    }
    function uL(e) {
        const t = e.nodeName.toLowerCase()
            , n = !Number.isNaN(dL(e));
        return (aL.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || n) && function (e) {
            if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || "hidden" === e.getAttribute("type"))
                return !1;
            let t = e;
            for (; t && t !== document.body && 11 !== t.nodeType;) {
                if (cL(t))
                    return !1;
                t = t.parentNode
            }
            return !0
        }(e)
    }
    function hL(e) {
        const t = dL(e);
        return (Number.isNaN(t) || t >= 0) && uL(e)
    }
    function pL(e, t) {
        const n = (r = e,
            Array.from(r.querySelectorAll(lL)).filter(hL));
        var r;
        if (!n.length)
            return void t.preventDefault();
        const o = n[t.shiftKey ? 0 : n.length - 1]
            , i = e.getRootNode();
        let s = o === i.activeElement || e === i.activeElement;
        const a = i.activeElement;
        if ("INPUT" === a.tagName && "radio" === a.getAttribute("type")) {
            const e = n.filter((e => "radio" === e.getAttribute("type") && e.getAttribute("name") === a.getAttribute("name")));
            s = e.includes(o)
        }
        if (!s)
            return;
        t.preventDefault();
        const l = n[t.shiftKey ? n.length - 1 : 0];
        l && l.focus()
    }
    function fL() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        const t = (0,
            r.useRef)()
            , n = (0,
                r.useRef)(null)
            , o = e => {
                let t = e.querySelector("[data-autofocus]");
                if (!t) {
                    const n = Array.from(e.querySelectorAll(lL));
                    t = n.find(hL) || n.find(uL) || null,
                        !t && uL(e) && (t = e)
                }
                t && t.focus({
                    preventScroll: !0
                })
            }
            , i = (0,
                r.useCallback)((r => {
                    e && (null !== r ? (n.current = function (e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body > :not(script)";
                        const n = EP()
                            , r = Array.from(document.querySelectorAll(t)).map((t => {
                                if (t?.shadowRoot?.contains(e) || t.contains(e))
                                    return;
                                const r = t.getAttribute("aria-hidden")
                                    , o = t.getAttribute("data-hidden")
                                    , i = t.getAttribute("data-focus-id");
                                return t.setAttribute("data-focus-id", n),
                                    null === r || "false" === r ? t.setAttribute("aria-hidden", "true") : o || i || t.setAttribute("data-hidden", r),
                                {
                                    node: t,
                                    ariaHidden: o || null
                                }
                            }
                            ));
                        return () => {
                            r.forEach((e => {
                                e && n === e.node.getAttribute("data-focus-id") && (null === e.ariaHidden ? e.node.removeAttribute("aria-hidden") : e.node.setAttribute("aria-hidden", e.ariaHidden),
                                    e.node.removeAttribute("data-focus-id"),
                                    e.node.removeAttribute("data-hidden"))
                            }
                            ))
                        }
                    }(r),
                        t.current !== r && (r ? (setTimeout((() => {
                            r.getRootNode() && o(r)
                        }
                        )),
                            t.current = r) : t.current = null)) : n.current && (n.current(),
                                n.current = null))
                }
                ), [e]);
        return (0,
            r.useEffect)((() => {
                if (!e)
                    return;
                t.current && setTimeout((() => o(t.current)));
                const r = e => {
                    "Tab" === e.key && t.current && pL(t.current, e)
                }
                    ;
                return document.addEventListener("keydown", r),
                    () => {
                        document.removeEventListener("keydown", r),
                            n.current && n.current()
                    }
            }
            ), [e]),
            i
    }
    function mL(e) {
        return !Array.isArray(e) && null !== e && ("object" === typeof e && e.type !== r.Fragment)
    }
    var gL = {
        root: "m_515a97f8"
    };
    const bL = {}
        , yL = yA(((e, t) => {
            const n = gA("VisuallyHidden", bL, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, ...c } = n
                , d = FA({
                    name: "VisuallyHidden",
                    classes: gL,
                    props: n,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a
                });
            return (0,
                Lx.jsx)(cP, {
                    component: "span",
                    ref: t,
                    ...d("root"),
                    ...c
                })
        }
        ));
    function vL(e) {
        let { children: t, active: n = !0, refProp: o = "ref", innerRef: i } = e;
        const s = YP(fL(n), i);
        return mL(t) ? (0,
            r.cloneElement)(t, {
                [o]: s
            }) : t
    }
    function wL(e) {
        return (0,
            Lx.jsx)(yL, {
                tabIndex: -1,
                "data-autofocus": !0,
                ...e
            })
    }
    yL.classes = gL,
        yL.displayName = "@mantine/core/VisuallyHidden",
        vL.displayName = "@mantine/core/FocusTrap",
        wL.displayName = "@mantine/core/FocusTrapInitialFocus",
        vL.InitialFocus = wL;
    const kL = {}
        , CL = (0,
            r.forwardRef)(((e, t) => {
                const { children: n, target: o, ...i } = gA("Portal", kL, e)
                    , [s, a] = (0,
                        r.useState)(!1)
                    , l = (0,
                        r.useRef)(null);
                return xP((() => (a(!0),
                    l.current = o ? "string" === typeof o ? document.querySelector(o) : o : function (e) {
                        const t = document.createElement("div");
                        return t.setAttribute("data-portal", "true"),
                            "string" === typeof e.className && t.classList.add(...e.className.split(" ").filter(Boolean)),
                            "object" === typeof e.style && Object.assign(t.style, e.style),
                            "string" === typeof e.id && t.setAttribute("id", e.id),
                            t
                    }(i),
                    XP(t, l.current),
                    !o && l.current && document.body.appendChild(l.current),
                    () => {
                        !o && l.current && document.body.removeChild(l.current)
                    }
                )), [o]),
                    s && l.current ? (0,
                        PE.createPortal)((0,
                            Lx.jsx)(Lx.Fragment, {
                                children: n
                            }), l.current) : null
            }
            ));
    function SL(e) {
        let { withinPortal: t = !0, children: n, ...r } = e;
        return t ? (0,
            Lx.jsx)(CL, {
                ...r,
                children: n
            }) : (0,
                Lx.jsx)(Lx.Fragment, {
                    children: n
                })
    }
    CL.displayName = "@mantine/core/Portal",
        SL.displayName = "@mantine/core/OptionalPortal";
    const xL = e => ({
        in: {
            opacity: 1,
            transform: "scale(1)"
        },
        out: {
            opacity: 0,
            transform: `scale(.9) translateY(${GO("bottom" === e ? 10 : -10)})`
        },
        transitionProperty: "transform, opacity"
    })
        , EL = {
            fade: {
                in: {
                    opacity: 1
                },
                out: {
                    opacity: 0
                },
                transitionProperty: "opacity"
            },
            "fade-up": {
                in: {
                    opacity: 1,
                    transform: "translateY(0)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(30)}`
                },
                transitionProperty: "opacity, transform"
            },
            "fade-down": {
                in: {
                    opacity: 1,
                    transform: "translateY(0)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(-30)}`
                },
                transitionProperty: "opacity, transform"
            },
            "fade-left": {
                in: {
                    opacity: 1,
                    transform: "translateX(0)"
                },
                out: {
                    opacity: 0,
                    transform: `translateX(${GO(30)}`
                },
                transitionProperty: "opacity, transform"
            },
            "fade-right": {
                in: {
                    opacity: 1,
                    transform: "translateX(0)"
                },
                out: {
                    opacity: 0,
                    transform: `translateX(${GO(-30)}`
                },
                transitionProperty: "opacity, transform"
            },
            scale: {
                in: {
                    opacity: 1,
                    transform: "scale(1)"
                },
                out: {
                    opacity: 0,
                    transform: "scale(0)"
                },
                common: {
                    transformOrigin: "top"
                },
                transitionProperty: "transform, opacity"
            },
            "scale-y": {
                in: {
                    opacity: 1,
                    transform: "scaleY(1)"
                },
                out: {
                    opacity: 0,
                    transform: "scaleY(0)"
                },
                common: {
                    transformOrigin: "top"
                },
                transitionProperty: "transform, opacity"
            },
            "scale-x": {
                in: {
                    opacity: 1,
                    transform: "scaleX(1)"
                },
                out: {
                    opacity: 0,
                    transform: "scaleX(0)"
                },
                common: {
                    transformOrigin: "left"
                },
                transitionProperty: "transform, opacity"
            },
            "skew-up": {
                in: {
                    opacity: 1,
                    transform: "translateY(0) skew(0deg, 0deg)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(-20)}) skew(-10deg, -5deg)`
                },
                common: {
                    transformOrigin: "top"
                },
                transitionProperty: "transform, opacity"
            },
            "skew-down": {
                in: {
                    opacity: 1,
                    transform: "translateY(0) skew(0deg, 0deg)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(20)}) skew(-10deg, -5deg)`
                },
                common: {
                    transformOrigin: "bottom"
                },
                transitionProperty: "transform, opacity"
            },
            "rotate-left": {
                in: {
                    opacity: 1,
                    transform: "translateY(0) rotate(0deg)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(20)}) rotate(-5deg)`
                },
                common: {
                    transformOrigin: "bottom"
                },
                transitionProperty: "transform, opacity"
            },
            "rotate-right": {
                in: {
                    opacity: 1,
                    transform: "translateY(0) rotate(0deg)"
                },
                out: {
                    opacity: 0,
                    transform: `translateY(${GO(20)}) rotate(5deg)`
                },
                common: {
                    transformOrigin: "top"
                },
                transitionProperty: "transform, opacity"
            },
            "slide-down": {
                in: {
                    opacity: 1,
                    transform: "translateY(0)"
                },
                out: {
                    opacity: 0,
                    transform: "translateY(-100%)"
                },
                common: {
                    transformOrigin: "top"
                },
                transitionProperty: "transform, opacity"
            },
            "slide-up": {
                in: {
                    opacity: 1,
                    transform: "translateY(0)"
                },
                out: {
                    opacity: 0,
                    transform: "translateY(100%)"
                },
                common: {
                    transformOrigin: "bottom"
                },
                transitionProperty: "transform, opacity"
            },
            "slide-left": {
                in: {
                    opacity: 1,
                    transform: "translateX(0)"
                },
                out: {
                    opacity: 0,
                    transform: "translateX(100%)"
                },
                common: {
                    transformOrigin: "left"
                },
                transitionProperty: "transform, opacity"
            },
            "slide-right": {
                in: {
                    opacity: 1,
                    transform: "translateX(0)"
                },
                out: {
                    opacity: 0,
                    transform: "translateX(-100%)"
                },
                common: {
                    transformOrigin: "right"
                },
                transitionProperty: "transform, opacity"
            },
            pop: {
                ...xL("bottom"),
                common: {
                    transformOrigin: "center center"
                }
            },
            "pop-bottom-left": {
                ...xL("bottom"),
                common: {
                    transformOrigin: "bottom left"
                }
            },
            "pop-bottom-right": {
                ...xL("bottom"),
                common: {
                    transformOrigin: "bottom right"
                }
            },
            "pop-top-left": {
                ...xL("top"),
                common: {
                    transformOrigin: "top left"
                }
            },
            "pop-top-right": {
                ...xL("top"),
                common: {
                    transformOrigin: "top right"
                }
            }
        }
        , ML = {
            entering: "in",
            entered: "in",
            exiting: "out",
            exited: "out",
            "pre-exiting": "out",
            "pre-entering": "out"
        };
    function TL(e) {
        let { transition: t, state: n, duration: r, timingFunction: o } = e;
        const i = {
            transitionDuration: `${r}ms`,
            transitionTimingFunction: o
        };
        return "string" === typeof t ? t in EL ? {
            transitionProperty: EL[t].transitionProperty,
            ...i,
            ...EL[t].common,
            ...EL[t][ML[n]]
        } : {} : {
            transitionProperty: t.transitionProperty,
            ...i,
            ...t.common,
            ...t[ML[n]]
        }
    }
    function NL(e, t) {
        let { getInitialValueInEffect: n } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
            getInitialValueInEffect: !0
        };
        const [o, i] = (0,
            r.useState)(n ? t : function (e, t) {
                return "boolean" === typeof t ? t : "undefined" !== typeof window && "matchMedia" in window && window.matchMedia(e).matches
            }(e))
            , s = (0,
                r.useRef)();
        return (0,
            r.useEffect)((() => {
                if ("matchMedia" in window)
                    return s.current = window.matchMedia(e),
                        i(s.current.matches),
                        function (e, t) {
                            try {
                                return e.addEventListener("change", t),
                                    () => e.removeEventListener("change", t)
                            } catch (pj) {
                                return e.addListener(t),
                                    () => e.removeListener(t)
                            }
                        }(s.current, (e => i(e.matches)))
            }
            ), [e]),
            o
    }
    function _L(e) {
        let { duration: t, exitDuration: n, timingFunction: o, mounted: i, onEnter: s, onExit: a, onEntered: l, onExited: c, enterDelay: d, exitDelay: u } = e;
        const h = fA()
            , p = function (e, t) {
                return NL("(prefers-reduced-motion: reduce)", e, t)
            }()
            , f = !!h.respectReducedMotion && p
            , [m, g] = (0,
                r.useState)(f ? 0 : t)
            , [b, y] = (0,
                r.useState)(i ? "entered" : "exited")
            , v = (0,
                r.useRef)(-1)
            , w = (0,
                r.useRef)(-1)
            , k = (0,
                r.useRef)(-1)
            , C = e => {
                const r = e ? s : a
                    , o = e ? l : c;
                window.clearTimeout(v.current);
                const i = f ? 0 : e ? t : n;
                g(i),
                    0 === i ? ("function" === typeof r && r(),
                        "function" === typeof o && o(),
                        y(e ? "entered" : "exited")) : k.current = requestAnimationFrame((() => {
                            PE.flushSync((() => {
                                y(e ? "pre-entering" : "pre-exiting")
                            }
                            )),
                                k.current = requestAnimationFrame((() => {
                                    "function" === typeof r && r(),
                                        y(e ? "entering" : "exiting"),
                                        v.current = window.setTimeout((() => {
                                            "function" === typeof o && o(),
                                                y(e ? "entered" : "exited")
                                        }
                                        ), i)
                                }
                                ))
                        }
                        ))
            }
            ;
        return $P((() => {
            var e;
            e = i,
                window.clearTimeout(w.current),
                "number" === typeof (e ? d : u) ? w.current = window.setTimeout((() => {
                    C(e)
                }
                ), e ? d : u) : C(e)
        }
        ), [i]),
            (0,
                r.useEffect)((() => () => {
                    window.clearTimeout(v.current),
                        cancelAnimationFrame(k.current)
                }
                ), []),
        {
            transitionDuration: m,
            transitionStatus: b,
            transitionTimingFunction: o || "ease"
        }
    }
    function OL(e) {
        let { keepMounted: t, transition: n = "fade", duration: r = 250, exitDuration: o = r, mounted: i, children: s, timingFunction: a = "ease", onExit: l, onEntered: c, onEnter: d, onExited: u, enterDelay: h, exitDelay: p } = e;
        const { transitionDuration: f, transitionStatus: m, transitionTimingFunction: g } = _L({
            mounted: i,
            exitDuration: o,
            duration: r,
            timingFunction: a,
            onExit: l,
            onEntered: c,
            onEnter: d,
            onExited: u,
            enterDelay: h,
            exitDelay: p
        });
        return 0 === f ? i ? (0,
            Lx.jsx)(Lx.Fragment, {
                children: s({})
            }) : t ? s({
                display: "none"
            }) : null : "exited" === m ? t ? s({
                display: "none"
            }) : null : (0,
                Lx.jsx)(Lx.Fragment, {
                    children: s(TL({
                        transition: n,
                        duration: f,
                        state: m,
                        timingFunction: g
                    }))
                })
    }
    OL.displayName = "@mantine/core/Transition";
    var AL = {
        dropdown: "m_38a85659",
        arrow: "m_a31dc6c1"
    };
    const PL = {}
        , LL = yA(((e, t) => {
            const n = gA("PopoverDropdown", PL, e)
                , { className: o, style: i, vars: s, children: a, onKeyDownCapture: l, variant: c, classNames: d, styles: u, ...h } = n
                , p = ZP()
                , f = function (e) {
                    let { opened: t, shouldReturnFocus: n = !0 } = e;
                    const o = (0,
                        r.useRef)()
                        , i = () => {
                            o.current && "focus" in o.current && "function" === typeof o.current.focus && o.current?.focus({
                                preventScroll: !0
                            })
                        }
                        ;
                    return $P((() => {
                        let e = -1;
                        const r = t => {
                            "Tab" === t.key && window.clearTimeout(e)
                        }
                            ;
                        return document.addEventListener("keydown", r),
                            t ? o.current = document.activeElement : n && (e = window.setTimeout(i, 10)),
                            () => {
                                window.clearTimeout(e),
                                    document.removeEventListener("keydown", r)
                            }
                    }
                    ), [t, n]),
                        i
                }({
                    opened: p.opened,
                    shouldReturnFocus: p.returnFocus
                })
                , m = p.withRoles ? {
                    "aria-labelledby": p.getTargetId(),
                    id: p.getDropdownId(),
                    role: "dialog",
                    tabIndex: -1
                } : {}
                , g = YP(t, p.floating);
            return p.disabled ? null : (0,
                Lx.jsx)(SL, {
                    ...p.portalProps,
                    withinPortal: p.withinPortal,
                    children: (0,
                        Lx.jsx)(OL, {
                            mounted: p.opened,
                            ...p.transitionProps,
                            transition: p.transitionProps?.transition || "fade",
                            duration: p.transitionProps?.duration ?? 150,
                            keepMounted: p.keepMounted,
                            exitDuration: "number" === typeof p.transitionProps?.exitDuration ? p.transitionProps.exitDuration : p.transitionProps?.duration,
                            children: e => (0,
                                Lx.jsx)(vL, {
                                    active: p.trapFocus && p.opened,
                                    innerRef: g,
                                    children: (0,
                                        Lx.jsxs)(cP, {
                                            ...m,
                                            ...h,
                                            variant: c,
                                            onKeyDownCapture: tL(p.onClose, {
                                                active: p.closeOnEscape,
                                                onTrigger: f,
                                                onKeyDown: l
                                            }),
                                            "data-position": p.placement,
                                            "data-fixed": "fixed" === p.floatingStrategy || void 0,
                                            ...p.getStyles("dropdown", {
                                                className: o,
                                                props: n,
                                                classNames: d,
                                                styles: u,
                                                style: [{
                                                    ...e,
                                                    zIndex: p.zIndex,
                                                    top: p.y ?? 0,
                                                    left: p.x ?? 0,
                                                    width: "target" === p.width ? void 0 : GO(p.width)
                                                }, i]
                                            }),
                                            children: [a, (0,
                                                Lx.jsx)(sL, {
                                                    ref: p.arrowRef,
                                                    arrowX: p.arrowX,
                                                    arrowY: p.arrowY,
                                                    visible: p.withArrow,
                                                    position: p.placement,
                                                    arrowSize: p.arrowSize,
                                                    arrowRadius: p.arrowRadius,
                                                    arrowOffset: p.arrowOffset,
                                                    arrowPosition: p.arrowPosition,
                                                    ...p.getStyles("arrow", {
                                                        props: n,
                                                        classNames: d,
                                                        styles: u
                                                    })
                                                })]
                                        })
                                })
                        })
                })
        }
        ));
    LL.classes = AL,
        LL.displayName = "@mantine/core/PopoverDropdown";
    const RL = {
        refProp: "ref",
        popupType: "dialog"
    }
        , DL = yA(((e, t) => {
            const { children: n, refProp: o, popupType: i, ...s } = gA("PopoverTarget", RL, e);
            if (!mL(n))
                throw new Error("Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
            const a = s
                , l = ZP()
                , c = YP(l.reference, n.ref, t)
                , d = l.withRoles ? {
                    "aria-haspopup": i,
                    "aria-expanded": l.opened,
                    "aria-controls": l.getDropdownId(),
                    id: l.getTargetId()
                } : {};
            return (0,
                r.cloneElement)(n, {
                    ...a,
                    ...d,
                    ...l.targetProps,
                    className: AA(l.targetProps.className, a.className, n.props.className),
                    [o]: c,
                    ...l.controlled ? null : {
                        onClick: l.onToggle
                    }
                })
        }
        ));
    function IL(e) {
        let { opened: t, floating: n, position: o, positionDependencies: i } = e;
        const [s, a] = (0,
            r.useState)(0);
        (0,
            r.useEffect)((() => {
                if (n.refs.reference.current && n.refs.floating.current && t)
                    return gM(n.refs.reference.current, n.refs.floating.current, n.update)
            }
            ), [n.refs.reference.current, n.refs.floating.current, t, s, o]),
            $P((() => {
                n.update()
            }
            ), i),
            $P((() => {
                a((e => e + 1))
            }
            ), [t])
    }
    function jL(e, t) {
        const n = function (e) {
            if (void 0 === e)
                return {
                    shift: !0,
                    flip: !0
                };
            const t = {
                ...e
            };
            return void 0 === e.shift && (t.shift = !0),
                void 0 === e.flip && (t.flip = !0),
                t
        }(e.middlewares)
            , r = [AM(e.offset)];
        return n.shift && r.push(PM("boolean" === typeof n.shift ? {
            limiter: LM(),
            padding: 5
        } : {
            limiter: LM(),
            padding: 5,
            ...n.shift
        })),
            n.flip && r.push("boolean" === typeof n.flip ? RM() : RM(n.flip)),
            n.inline && r.push("boolean" === typeof n.inline ? IM() : IM(n.inline)),
            r.push(jM({
                element: e.arrowRef,
                padding: e.arrowOffset
            })),
            (n.size || "target" === e.width) && r.push(DM({
                ..."boolean" === typeof n.size ? {} : n.size,
                apply(r) {
                    let { rects: o, availableWidth: i, availableHeight: s, ...a } = r;
                    const l = t()
                        , c = l.refs.floating.current?.style ?? {};
                    n.size && ("object" === typeof n.size && n.size.apply ? n.size.apply({
                        rects: o,
                        availableWidth: i,
                        availableHeight: s,
                        ...a
                    }) : Object.assign(c, {
                        maxWidth: `${i}px`,
                        maxHeight: `${s}px`
                    })),
                        "target" === e.width && Object.assign(c, {
                            width: `${o.reference.width}px`
                        })
                }
            })),
            r
    }
    DL.displayName = "@mantine/core/PopoverTarget";
    const HL = {
        position: "bottom",
        offset: 8,
        positionDependencies: [],
        transitionProps: {
            transition: "fade",
            duration: 150
        },
        middlewares: {
            flip: !0,
            shift: !0,
            inline: !1
        },
        arrowSize: 7,
        arrowOffset: 5,
        arrowRadius: 0,
        arrowPosition: "side",
        closeOnClickOutside: !0,
        withinPortal: !0,
        closeOnEscape: !0,
        trapFocus: !1,
        withRoles: !0,
        returnFocus: !1,
        clickOutsideEvents: ["mousedown", "touchstart"],
        zIndex: UP("popover"),
        __staticSelector: "Popover",
        width: "max-content"
    }
        , zL = (e, t) => {
            let { radius: n, shadow: r } = t;
            return {
                dropdown: {
                    "--popover-radius": void 0 === n ? void 0 : SA(n),
                    "--popover-shadow": MA(r)
                }
            }
        }
        ;
    function $L(e) {
        const t = gA("Popover", HL, e)
            , { children: n, position: o, offset: i, onPositionChange: s, positionDependencies: a, opened: l, transitionProps: c, width: d, middlewares: u, withArrow: h, arrowSize: p, arrowOffset: f, arrowRadius: m, arrowPosition: g, unstyled: b, classNames: y, styles: v, closeOnClickOutside: w, withinPortal: k, portalProps: C, closeOnEscape: S, clickOutsideEvents: x, trapFocus: E, onClose: M, onOpen: T, onChange: N, zIndex: _, radius: O, shadow: A, id: P, defaultOpened: L, __staticSelector: R, withRoles: D, disabled: I, returnFocus: j, variant: H, keepMounted: z, vars: $, floatingStrategy: B, ...V } = t
            , F = FA({
                name: R,
                props: t,
                classes: AL,
                classNames: y,
                styles: v,
                unstyled: b,
                rootSelector: "dropdown",
                vars: $,
                varsResolver: zL
            })
            , U = (0,
                r.useRef)(null)
            , [W, q] = (0,
                r.useState)(null)
            , [G, K] = (0,
                r.useState)(null)
            , { dir: J } = qP()
            , Z = TP(P)
            , X = function (e) {
                const [t, n] = zP({
                    value: e.opened,
                    defaultValue: e.defaultOpened,
                    finalValue: !1,
                    onChange: e.onChange
                })
                    , r = RT({
                        strategy: e.strategy,
                        placement: e.position,
                        middleware: jL(e, (() => r))
                    });
                return IL({
                    opened: t,
                    position: e.position,
                    positionDependencies: e.positionDependencies || [],
                    floating: r
                }),
                    $P((() => {
                        e.onPositionChange?.(r.placement)
                    }
                    ), [r.placement]),
                    $P((() => {
                        t ? e.onOpen?.() : e.onClose?.()
                    }
                    ), [t, e.onClose, e.onOpen]),
                {
                    floating: r,
                    controlled: "boolean" === typeof e.opened,
                    opened: t,
                    onClose: () => {
                        t && n(!1)
                    }
                    ,
                    onToggle: () => n(!t)
                }
            }({
                middlewares: u,
                width: d,
                position: GP(J, o),
                offset: "number" === typeof i ? i + (h ? p / 2 : 0) : i,
                arrowRef: U,
                arrowOffset: f,
                onPositionChange: s,
                positionDependencies: a,
                opened: l,
                defaultOpened: L,
                onChange: N,
                onOpen: T,
                onClose: M,
                strategy: B
            });
        !function (e, t, n) {
            const o = (0,
                r.useRef)();
            (0,
                r.useEffect)((() => {
                    const r = t => {
                        const { target: r } = t ?? {};
                        if (Array.isArray(n)) {
                            const o = r?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(r) && "HTML" !== r.tagName;
                            n.every((e => !!e && !t.composedPath().includes(e))) && !o && e()
                        } else
                            o.current && !o.current.contains(r) && e()
                    }
                        ;
                    return (t || VP).forEach((e => document.addEventListener(e, r))),
                        () => {
                            (t || VP).forEach((e => document.removeEventListener(e, r)))
                        }
                }
                ), [o, e, n])
        }((() => w && X.onClose()), x, [W, G]);
        const Q = (0,
            r.useCallback)((e => {
                q(e),
                    X.floating.refs.setReference(e)
            }
            ), [X.floating.refs.setReference])
            , Y = (0,
                r.useCallback)((e => {
                    K(e),
                        X.floating.refs.setFloating(e)
                }
                ), [X.floating.refs.setFloating]);
        return (0,
            Lx.jsx)(JP, {
                value: {
                    returnFocus: j,
                    disabled: I,
                    controlled: X.controlled,
                    reference: Q,
                    floating: Y,
                    x: X.floating.x,
                    y: X.floating.y,
                    arrowX: X.floating?.middlewareData?.arrow?.x,
                    arrowY: X.floating?.middlewareData?.arrow?.y,
                    opened: X.opened,
                    arrowRef: U,
                    transitionProps: c,
                    width: d,
                    withArrow: h,
                    arrowSize: p,
                    arrowOffset: f,
                    arrowRadius: m,
                    arrowPosition: g,
                    placement: X.floating.placement,
                    trapFocus: E,
                    withinPortal: k,
                    portalProps: C,
                    zIndex: _,
                    radius: O,
                    shadow: A,
                    closeOnEscape: S,
                    onClose: X.onClose,
                    onToggle: X.onToggle,
                    getTargetId: () => `${Z}-target`,
                    getDropdownId: () => `${Z}-dropdown`,
                    withRoles: D,
                    targetProps: V,
                    __staticSelector: R,
                    classNames: y,
                    styles: v,
                    unstyled: b,
                    variant: H,
                    keepMounted: z,
                    getStyles: F,
                    floatingStrategy: B
                },
                children: n
            })
    }
    $L.Target = DL,
        $L.Dropdown = LL,
        $L.displayName = "@mantine/core/Popover",
        $L.extend = e => e;
    const [BL, VL] = KP("Menu component was not found in the tree");
    var FL = {
        dropdown: "m_dc9b7c9f",
        label: "m_9bfac126",
        divider: "m_efdf90cb",
        item: "m_99ac2aa1",
        itemLabel: "m_5476e0d3",
        itemSection: "m_8b75e504"
    };
    const UL = {}
        , WL = yA(((e, t) => {
            const { classNames: n, className: r, style: o, styles: i, vars: s, ...a } = gA("MenuDivider", UL, e)
                , l = VL();
            return (0,
                Lx.jsx)(cP, {
                    ref: t,
                    ...l.getStyles("divider", {
                        className: r,
                        style: o,
                        styles: i,
                        classNames: n
                    }),
                    ...a
                })
        }
        ));
    function qL(e, t) {
        return n => {
            e?.(n),
                t?.(n)
        }
    }
    WL.classes = FL,
        WL.displayName = "@mantine/core/MenuDivider";
    const GL = {}
        , KL = yA(((e, t) => {
            const { classNames: n, className: o, style: i, styles: s, vars: a, onMouseEnter: l, onMouseLeave: c, onKeyDown: d, children: u, ...h } = gA("MenuDropdown", GL, e)
                , p = (0,
                    r.useRef)(null)
                , f = VL()
                , m = qL(d, (e => {
                    "ArrowUp" !== e.key && "ArrowDown" !== e.key || (e.preventDefault(),
                        p.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus())
                }
                ))
                , g = qL(l, (() => ("hover" === f.trigger || "click-hover" === f.trigger) && f.openDropdown()))
                , b = qL(c, (() => ("hover" === f.trigger || "click-hover" === f.trigger) && f.closeDropdown()));
            return (0,
                Lx.jsxs)($L.Dropdown, {
                    ...h,
                    onMouseEnter: g,
                    onMouseLeave: b,
                    role: "menu",
                    "aria-orientation": "vertical",
                    ref: YP(t, p),
                    ...f.getStyles("dropdown", {
                        className: o,
                        style: i,
                        styles: s,
                        classNames: n,
                        withStaticClass: !1
                    }),
                    tabIndex: -1,
                    "data-menu-dropdown": !0,
                    onKeyDown: m,
                    children: [(0,
                        Lx.jsx)("div", {
                            tabIndex: -1,
                            "data-autofocus": !0,
                            "data-mantine-stop-propagation": !0,
                            style: {
                                outline: 0
                            }
                        }), u]
                })
        }
        ));
    function JL(e) {
        let { parentSelector: t, siblingSelector: n, onKeyDown: r, loop: o = !0, activateOnFocus: i = !1, dir: s = "rtl", orientation: a } = e;
        return e => {
            r?.(e);
            const l = Array.from(BP(e.currentTarget, t)?.querySelectorAll(n) || []).filter((n => function (e, t, n) {
                return BP(e, n) === BP(t, n)
            }(e.currentTarget, n, t)))
                , c = l.findIndex((t => e.currentTarget === t))
                , d = function (e, t, n) {
                    for (let r = e + 1; r < t.length; r += 1)
                        if (!t[r].disabled)
                            return r;
                    if (n)
                        for (let r = 0; r < t.length; r += 1)
                            if (!t[r].disabled)
                                return r;
                    return e
                }(c, l, o)
                , u = function (e, t, n) {
                    for (let r = e - 1; r >= 0; r -= 1)
                        if (!t[r].disabled)
                            return r;
                    if (n)
                        for (let r = t.length - 1; r > -1; r -= 1)
                            if (!t[r].disabled)
                                return r;
                    return e
                }(c, l, o)
                , h = "rtl" === s ? u : d
                , p = "rtl" === s ? d : u;
            switch (e.key) {
                case "ArrowRight":
                    "horizontal" === a && (e.stopPropagation(),
                        e.preventDefault(),
                        l[h].focus(),
                        i && l[h].click());
                    break;
                case "ArrowLeft":
                    "horizontal" === a && (e.stopPropagation(),
                        e.preventDefault(),
                        l[p].focus(),
                        i && l[p].click());
                    break;
                case "ArrowUp":
                    "vertical" === a && (e.stopPropagation(),
                        e.preventDefault(),
                        l[u].focus(),
                        i && l[u].click());
                    break;
                case "ArrowDown":
                    "vertical" === a && (e.stopPropagation(),
                        e.preventDefault(),
                        l[d].focus(),
                        i && l[d].click());
                    break;
                case "Home":
                    e.stopPropagation(),
                        e.preventDefault(),
                        !l[0].disabled && l[0].focus();
                    break;
                case "End":
                    {
                        e.stopPropagation(),
                            e.preventDefault();
                        const t = l.length - 1;
                        !l[t].disabled && l[t].focus();
                        break
                    }
            }
        }
    }
    KL.classes = FL,
        KL.displayName = "@mantine/core/MenuDropdown";
    var ZL = {
        root: "m_87cf2631"
    };
    const XL = {
        __staticSelector: "UnstyledButton"
    }
        , QL = vA(((e, t) => {
            const n = gA("UnstyledButton", XL, e)
                , { className: r, component: o = "button", __staticSelector: i, unstyled: s, classNames: a, styles: l, style: c, ...d } = n
                , u = FA({
                    name: i,
                    props: n,
                    classes: ZL,
                    className: r,
                    style: c,
                    classNames: a,
                    styles: l,
                    unstyled: s
                });
            return (0,
                Lx.jsx)(cP, {
                    ...u("root", {
                        focusable: !0
                    }),
                    component: o,
                    ref: t,
                    type: "button" === o ? "button" : void 0,
                    ...d
                })
        }
        ));
    QL.classes = ZL,
        QL.displayName = "@mantine/core/UnstyledButton";
    const YL = {}
        , eR = vA(((e, t) => {
            const { classNames: n, className: o, style: i, styles: s, vars: a, color: l, closeMenuOnClick: c, leftSection: d, rightSection: u, children: h, disabled: p, ...f } = gA("MenuItem", YL, e)
                , m = VL()
                , g = fA()
                , { dir: b } = qP()
                , y = (0,
                    r.useRef)()
                , v = m.getItemIndex(y.current)
                , w = f
                , k = qL(w.onMouseLeave, (() => m.setHovered(-1)))
                , C = qL(w.onMouseEnter, (() => m.setHovered(m.getItemIndex(y.current))))
                , S = qL(w.onClick, (() => {
                    "boolean" === typeof c ? c && m.closeDropdownImmediately() : m.closeOnItemClick && m.closeDropdownImmediately()
                }
                ))
                , x = qL(w.onFocus, (() => m.setHovered(m.getItemIndex(y.current))))
                , E = l ? g.variantColorResolver({
                    color: l,
                    theme: g,
                    variant: "light"
                }) : void 0
                , M = l ? tA({
                    color: l,
                    theme: g
                }) : null;
            return (0,
                Lx.jsxs)(QL, {
                    ...f,
                    unstyled: m.unstyled,
                    tabIndex: m.menuItemTabIndex,
                    onFocus: x,
                    ...m.getStyles("item", {
                        className: o,
                        style: i,
                        styles: s,
                        classNames: n
                    }),
                    ref: YP(y, t),
                    role: "menuitem",
                    disabled: p,
                    "data-menu-item": !0,
                    "data-disabled": p || void 0,
                    "data-hovered": m.hovered === v || void 0,
                    "data-mantine-stop-propagation": !0,
                    onMouseEnter: C,
                    onMouseLeave: k,
                    onClick: S,
                    onKeyDown: JL({
                        siblingSelector: "[data-menu-item]",
                        parentSelector: "[data-menu-dropdown]",
                        activateOnFocus: !1,
                        loop: m.loop,
                        dir: b,
                        orientation: "vertical",
                        onKeyDown: w.onKeyDown
                    }),
                    __vars: {
                        "--menu-item-color": M?.isThemeColor && void 0 === M?.shade ? `var(--mantine-color-${M.color}-6)` : E?.color,
                        "--menu-item-hover": E?.hover
                    },
                    children: [d && (0,
                        Lx.jsx)("div", {
                            ...m.getStyles("itemSection", {
                                styles: s,
                                classNames: n
                            }),
                            "data-position": "left",
                            children: d
                        }), h && (0,
                            Lx.jsx)("div", {
                                ...m.getStyles("itemLabel", {
                                    styles: s,
                                    classNames: n
                                }),
                                children: h
                            }), u && (0,
                                Lx.jsx)("div", {
                                    ...m.getStyles("itemSection", {
                                        styles: s,
                                        classNames: n
                                    }),
                                    "data-position": "right",
                                    children: u
                                })]
                })
        }
        ));
    eR.classes = FL,
        eR.displayName = "@mantine/core/MenuItem";
    const tR = {}
        , nR = yA(((e, t) => {
            const { classNames: n, className: r, style: o, styles: i, vars: s, ...a } = gA("MenuLabel", tR, e)
                , l = VL();
            return (0,
                Lx.jsx)(cP, {
                    ref: t,
                    ...l.getStyles("label", {
                        className: r,
                        style: o,
                        styles: i,
                        classNames: n
                    }),
                    ...a
                })
        }
        ));
    nR.classes = FL,
        nR.displayName = "@mantine/core/MenuLabel";
    const rR = {
        refProp: "ref"
    }
        , oR = (0,
            r.forwardRef)(((e, t) => {
                const { children: n, refProp: o, ...i } = gA("MenuTarget", rR, e);
                if (!mL(n))
                    throw new Error("Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
                const s = VL()
                    , a = qL(n.props.onClick, (() => {
                        "click" === s.trigger ? s.toggleDropdown() : "click-hover" === s.trigger && (s.setOpenedViaClick(!0),
                            s.opened || s.openDropdown())
                    }
                    ))
                    , l = qL(n.props.onMouseEnter, (() => ("hover" === s.trigger || "click-hover" === s.trigger) && s.openDropdown()))
                    , c = qL(n.props.onMouseLeave, (() => {
                        "hover" === s.trigger ? s.closeDropdown() : "click-hover" !== s.trigger || s.openedViaClick || s.closeDropdown()
                    }
                    ));
                return (0,
                    Lx.jsx)($L.Target, {
                        refProp: o,
                        popupType: "menu",
                        ref: t,
                        ...i,
                        children: (0,
                            r.cloneElement)(n, {
                                onClick: a,
                                onMouseEnter: l,
                                onMouseLeave: c,
                                "data-expanded": !!s.opened || void 0
                            })
                    })
            }
            ));
    oR.displayName = "@mantine/core/MenuTarget";
    const iR = {
        trapFocus: !0,
        closeOnItemClick: !0,
        clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
        loop: !0,
        trigger: "click",
        openDelay: 0,
        closeDelay: 100,
        menuItemTabIndex: -1
    };
    function sR(e) {
        const t = gA("Menu", iR, e)
            , { children: n, onOpen: o, onClose: i, opened: s, defaultOpened: a, trapFocus: l, onChange: c, closeOnItemClick: d, loop: u, closeOnEscape: h, trigger: p, openDelay: f, closeDelay: m, classNames: g, styles: b, unstyled: y, variant: v, vars: w, menuItemTabIndex: k, keepMounted: C, ...S } = t
            , x = FA({
                name: "Menu",
                classes: FL,
                props: t,
                classNames: g,
                styles: b,
                unstyled: y
            })
            , [E, { setHovered: M, resetHovered: T }] = function () {
                const [e, t] = (0,
                    r.useState)(-1);
                return [e, {
                    setHovered: t,
                    resetHovered: () => t(-1)
                }]
            }()
            , [N, _] = zP({
                value: s,
                defaultValue: a,
                finalValue: !1,
                onChange: c
            })
            , [O, A] = (0,
                r.useState)(!1)
            , P = () => {
                _(!1),
                    A(!1),
                    N && i?.()
            }
            , L = () => {
                _(!0),
                    !N && o?.()
            }
            , R = () => {
                N ? P() : L()
            }
            , { openDropdown: D, closeDropdown: I } = function (e) {
                let { open: t, close: n, openDelay: o, closeDelay: i } = e;
                const s = (0,
                    r.useRef)(-1)
                    , a = (0,
                        r.useRef)(-1)
                    , l = () => {
                        window.clearTimeout(s.current),
                            window.clearTimeout(a.current)
                    }
                    ;
                return (0,
                    r.useEffect)((() => l), []),
                {
                    openDropdown: () => {
                        l(),
                            0 === o || void 0 === o ? t() : s.current = window.setTimeout(t, o)
                    }
                    ,
                    closeDropdown: () => {
                        l(),
                            0 === i || void 0 === i ? n() : a.current = window.setTimeout(n, i)
                    }
                }
            }({
                open: L,
                close: P,
                closeDelay: m,
                openDelay: f
            })
            , { resolvedClassNames: j, resolvedStyles: H } = function (e) {
                let { classNames: t, styles: n, props: r, stylesCtx: o } = e;
                const i = fA();
                return {
                    resolvedClassNames: RA({
                        theme: i,
                        classNames: t,
                        props: r,
                        stylesCtx: o || void 0
                    }),
                    resolvedStyles: jA({
                        theme: i,
                        styles: n,
                        props: r,
                        stylesCtx: o || void 0
                    })
                }
            }({
                classNames: g,
                styles: b,
                props: t
            });
        return $P((() => {
            T()
        }
        ), [N]),
            (0,
                Lx.jsx)(BL, {
                    value: {
                        getStyles: x,
                        opened: N,
                        toggleDropdown: R,
                        getItemIndex: e => function (e, t, n) {
                            return n ? Array.from(BP(n, t)?.querySelectorAll(e) || []).findIndex((e => e === n)) : null
                        }("[data-menu-item]", "[data-menu-dropdown]", e),
                        hovered: E,
                        setHovered: M,
                        openedViaClick: O,
                        setOpenedViaClick: A,
                        closeOnItemClick: d,
                        closeDropdown: "click" === p ? P : I,
                        openDropdown: "click" === p ? L : D,
                        closeDropdownImmediately: P,
                        loop: u,
                        trigger: p,
                        unstyled: y,
                        menuItemTabIndex: k
                    },
                    children: (0,
                        Lx.jsx)($L, {
                            ...S,
                            opened: N,
                            onChange: R,
                            defaultOpened: a,
                            trapFocus: !C && l,
                            closeOnEscape: h,
                            __staticSelector: "Menu",
                            classNames: j,
                            styles: H,
                            unstyled: y,
                            variant: v,
                            keepMounted: C,
                            children: n
                        })
                })
    }
    function aR(e) {
        let { size: t, style: n, ...r } = e;
        const o = void 0 !== t ? {
            width: GO(t),
            height: GO(t),
            ...n
        } : n;
        return (0,
            Lx.jsx)("svg", {
                viewBox: "0 0 10 7",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                style: o,
                "aria-hidden": !0,
                ...r,
                children: (0,
                    Lx.jsx)("path", {
                        d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
                        fill: "currentColor",
                        fillRule: "evenodd",
                        clipRule: "evenodd"
                    })
            })
    }
    sR.extend = e => e,
        sR.classes = FL,
        sR.displayName = "@mantine/core/Menu",
        sR.Item = eR,
        sR.Label = nR,
        sR.Dropdown = KL,
        sR.Target = oR,
        sR.Divider = WL;
    var lR = {
        root: "m_4081bf90"
    };
    const cR = {
        preventGrowOverflow: !0,
        gap: "md",
        align: "center",
        justify: "flex-start",
        wrap: "wrap"
    }
        , dR = (e, t, n) => {
            let { grow: r, preventGrowOverflow: o, gap: i, align: s, justify: a, wrap: l } = t
                , { childWidth: c } = n;
            return {
                root: {
                    "--group-child-width": r && o ? c : void 0,
                    "--group-gap": CA(i),
                    "--group-align": s,
                    "--group-justify": a,
                    "--group-wrap": l
                }
            }
        }
        , uR = yA(((e, t) => {
            const n = gA("Group", cR, e)
                , { classNames: o, className: i, style: s, styles: a, unstyled: l, children: c, gap: d, align: u, justify: h, wrap: p, grow: f, preventGrowOverflow: m, vars: g, variant: b, __size: y, mod: v, ...w } = n
                , k = function (e) {
                    return r.Children.toArray(e).filter(Boolean)
                }(c)
                , C = k.length
                , S = CA(d ?? "md")
                , x = FA({
                    name: "Group",
                    props: n,
                    stylesCtx: {
                        childWidth: `calc(${100 / C}% - (${S} - ${S} / ${C}))`
                    },
                    className: i,
                    style: s,
                    classes: lR,
                    classNames: o,
                    styles: a,
                    unstyled: l,
                    vars: g,
                    varsResolver: dR
                });
            return (0,
                Lx.jsx)(cP, {
                    ...x("root"),
                    ref: t,
                    variant: b,
                    mod: [{
                        grow: f
                    }, v],
                    size: y,
                    ...w,
                    children: k
                })
        }
        ));
    function hR(e, t) {
        return n => {
            if ("string" !== typeof n || 0 === n.trim().length)
                throw new Error(t);
            return `${e}-${n}`
        }
    }
    function pR(e) {
        let { color: t, theme: n, autoContrast: r } = e;
        if (!("boolean" === typeof r ? r : n.autoContrast))
            return "var(--mantine-color-white)";
        return tA({
            color: t || n.primaryColor,
            theme: n
        }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)"
    }
    function fR(e, t) {
        return pR({
            color: e.colors[e.primaryColor][XO(e, t)],
            theme: e,
            autoContrast: null
        })
    }
    function mR(e, t) {
        return "boolean" === typeof e ? e : t.autoContrast
    }
    uR.classes = lR,
        uR.displayName = "@mantine/core/Group";
    const [gR, bR] = KP("Tabs component was not found in the tree");
    var yR = {
        root: "m_89d60db1",
        "list--default": "m_576c9d4",
        list: "m_89d33d6d",
        panel: "m_b0c91715",
        tab: "m_4ec4dce6",
        tabSection: "m_fc420b1f",
        "tab--default": "m_539e827b",
        "list--outline": "m_6772fbd5",
        "tab--outline": "m_b59ab47c",
        "tab--pills": "m_c3381914"
    };
    const vR = {}
        , wR = yA(((e, t) => {
            const n = gA("TabsList", vR, e)
                , { children: r, className: o, grow: i, justify: s, classNames: a, styles: l, style: c, mod: d, ...u } = n
                , h = bR();
            return (0,
                Lx.jsx)(cP, {
                    ...u,
                    ...h.getStyles("list", {
                        className: o,
                        style: c,
                        classNames: a,
                        styles: l,
                        props: n,
                        variant: h.variant
                    }),
                    ref: t,
                    role: "tablist",
                    variant: h.variant,
                    mod: [{
                        grow: i,
                        orientation: h.orientation,
                        placement: "vertical" === h.orientation && h.placement,
                        inverted: h.inverted
                    }, d],
                    "aria-orientation": h.orientation,
                    __vars: {
                        "--tabs-justify": s
                    },
                    children: r
                })
        }
        ));
    wR.classes = yR,
        wR.displayName = "@mantine/core/TabsList";
    const kR = {}
        , CR = yA(((e, t) => {
            const n = gA("TabsPanel", kR, e)
                , { children: r, className: o, value: i, classNames: s, styles: a, style: l, mod: c, keepMounted: d, ...u } = n
                , h = bR()
                , p = h.value === i
                , f = h.keepMounted || d || p ? r : null;
            return (0,
                Lx.jsx)(cP, {
                    ...u,
                    ...h.getStyles("panel", {
                        className: o,
                        classNames: s,
                        styles: a,
                        style: [l, p ? void 0 : {
                            display: "none"
                        }],
                        props: n
                    }),
                    ref: t,
                    mod: [{
                        orientation: h.orientation
                    }, c],
                    role: "tabpanel",
                    id: h.getPanelId(i),
                    "aria-labelledby": h.getTabId(i),
                    children: f
                })
        }
        ));
    CR.classes = yR,
        CR.displayName = "@mantine/core/TabsPanel";
    const SR = {}
        , xR = yA(((e, t) => {
            const n = gA("TabsTab", SR, e)
                , { className: r, children: o, rightSection: i, leftSection: s, value: a, onClick: l, onKeyDown: c, disabled: d, color: u, style: h, classNames: p, styles: f, vars: m, mod: g, ...b } = n
                , y = fA()
                , { dir: v } = qP()
                , w = bR()
                , k = a === w.value
                , C = {
                    classNames: p,
                    styles: f,
                    props: n
                };
            return (0,
                Lx.jsxs)(QL, {
                    ...b,
                    ...w.getStyles("tab", {
                        className: r,
                        style: h,
                        variant: w.variant,
                        ...C
                    }),
                    disabled: d,
                    unstyled: w.unstyled,
                    variant: w.variant,
                    mod: [{
                        active: k,
                        disabled: d,
                        orientation: w.orientation,
                        inverted: w.inverted,
                        placement: "vertical" === w.orientation && w.placement
                    }, g],
                    ref: t,
                    role: "tab",
                    id: w.getTabId(a),
                    "aria-selected": k,
                    tabIndex: k || null === w.value ? 0 : -1,
                    "aria-controls": w.getPanelId(a),
                    onClick: e => {
                        w.onChange(w.allowTabDeactivation && a === w.value ? null : a),
                            l?.(e)
                    }
                    ,
                    __vars: {
                        "--tabs-color": u ? nA(u, y) : void 0
                    },
                    onKeyDown: JL({
                        siblingSelector: '[role="tab"]',
                        parentSelector: '[role="tablist"]',
                        activateOnFocus: w.activateTabWithKeyboard,
                        loop: w.loop,
                        orientation: w.orientation || "horizontal",
                        dir: v,
                        onKeyDown: c
                    }),
                    children: [s && (0,
                        Lx.jsx)("span", {
                            ...w.getStyles("tabSection", C),
                            "data-position": "left",
                            children: s
                        }), o && (0,
                            Lx.jsx)("span", {
                                ...w.getStyles("tabLabel", C),
                                children: o
                            }), i && (0,
                                Lx.jsx)("span", {
                                    ...w.getStyles("tabSection", C),
                                    "data-position": "right",
                                    children: i
                                })]
                })
        }
        ));
    xR.classes = yR,
        xR.displayName = "@mantine/core/TabsTab";
    const ER = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value"
        , MR = {
            keepMounted: !0,
            orientation: "horizontal",
            loop: !0,
            activateTabWithKeyboard: !0,
            allowTabDeactivation: !1,
            unstyled: !1,
            inverted: !1,
            variant: "default",
            placement: "left"
        }
        , TR = (e, t) => {
            let { radius: n, color: r, autoContrast: o } = t;
            return {
                root: {
                    "--tabs-radius": SA(n),
                    "--tabs-color": nA(r, e),
                    "--tabs-text-color": mR(o, e) ? pR({
                        color: r,
                        theme: e,
                        autoContrast: o
                    }) : void 0
                }
            }
        }
        , NR = yA(((e, t) => {
            const n = gA("Tabs", MR, e)
                , { defaultValue: r, value: o, onChange: i, orientation: s, children: a, loop: l, id: c, activateTabWithKeyboard: d, allowTabDeactivation: u, variant: h, color: p, radius: f, inverted: m, placement: g, keepMounted: b, classNames: y, styles: v, unstyled: w, className: k, style: C, vars: S, autoContrast: x, mod: E, ...M } = n
                , T = TP(c)
                , [N, _] = zP({
                    value: o,
                    defaultValue: r,
                    finalValue: null,
                    onChange: i
                })
                , O = FA({
                    name: "Tabs",
                    props: n,
                    classes: yR,
                    className: k,
                    style: C,
                    classNames: y,
                    styles: v,
                    unstyled: w,
                    vars: S,
                    varsResolver: TR
                });
            return (0,
                Lx.jsx)(gR, {
                    value: {
                        placement: g,
                        value: N,
                        orientation: s,
                        id: T,
                        loop: l,
                        activateTabWithKeyboard: d,
                        getTabId: hR(`${T}-tab`, ER),
                        getPanelId: hR(`${T}-panel`, ER),
                        onChange: _,
                        allowTabDeactivation: u,
                        variant: h,
                        color: p,
                        radius: f,
                        inverted: m,
                        keepMounted: b,
                        unstyled: w,
                        getStyles: O
                    },
                    children: (0,
                        Lx.jsx)(cP, {
                            ref: t,
                            id: T,
                            variant: h,
                            mod: [{
                                orientation: s,
                                inverted: "horizontal" === s && m,
                                placement: "vertical" === s && g
                            }, E],
                            ...O("root"),
                            ...M,
                            children: a
                        })
                })
        }
        ));
    NR.classes = yR,
        NR.displayName = "@mantine/core/Tabs",
        NR.Tab = xR,
        NR.Panel = CR,
        NR.List = wR;
    var _R = {
        root: "m_5ae2e3c",
        barsLoader: "m_7a2bd4cd",
        bar: "m_870bb79",
        "bars-loader-animation": "m_5d2b3b9d",
        dotsLoader: "m_4e3f22d7",
        dot: "m_870c4af",
        "loader-dots-animation": "m_aac34a1",
        ovalLoader: "m_b34414df",
        "oval-loader-animation": "m_f8e89c4b"
    };
    const OR = (0,
        r.forwardRef)(((e, t) => {
            let { className: n, ...r } = e;
            return (0,
                Lx.jsxs)(cP, {
                    component: "span",
                    className: AA(_R.barsLoader, n),
                    ...r,
                    ref: t,
                    children: [(0,
                        Lx.jsx)("span", {
                            className: _R.bar
                        }), (0,
                            Lx.jsx)("span", {
                                className: _R.bar
                            }), (0,
                                Lx.jsx)("span", {
                                    className: _R.bar
                                })]
                })
        }
        ));
    OR.displayName = "@mantine/core/Bars";
    const AR = (0,
        r.forwardRef)(((e, t) => {
            let { className: n, ...r } = e;
            return (0,
                Lx.jsxs)(cP, {
                    component: "span",
                    className: AA(_R.dotsLoader, n),
                    ...r,
                    ref: t,
                    children: [(0,
                        Lx.jsx)("span", {
                            className: _R.dot
                        }), (0,
                            Lx.jsx)("span", {
                                className: _R.dot
                            }), (0,
                                Lx.jsx)("span", {
                                    className: _R.dot
                                })]
                })
        }
        ));
    AR.displayName = "@mantine/core/Dots";
    const PR = (0,
        r.forwardRef)(((e, t) => {
            let { className: n, ...r } = e;
            return (0,
                Lx.jsx)(cP, {
                    component: "span",
                    className: AA(_R.ovalLoader, n),
                    ...r,
                    ref: t
                })
        }
        ));
    PR.displayName = "@mantine/core/Oval";
    const LR = {
        bars: OR,
        oval: PR,
        dots: AR
    }
        , RR = {
            loaders: LR,
            type: "oval"
        }
        , DR = (e, t) => {
            let { size: n, color: r } = t;
            return {
                root: {
                    "--loader-size": kA(n, "loader-size"),
                    "--loader-color": r ? nA(r, e) : void 0
                }
            }
        }
        , IR = yA(((e, t) => {
            const n = gA("Loader", RR, e)
                , { size: r, color: o, type: i, vars: s, className: a, style: l, classNames: c, styles: d, unstyled: u, loaders: h, variant: p, children: f, ...m } = n
                , g = FA({
                    name: "Loader",
                    props: n,
                    classes: _R,
                    className: a,
                    style: l,
                    classNames: c,
                    styles: d,
                    unstyled: u,
                    vars: s,
                    varsResolver: DR
                });
            return f ? (0,
                Lx.jsx)(cP, {
                    ...g("root"),
                    ref: t,
                    ...m,
                    children: f
                }) : (0,
                    Lx.jsx)(cP, {
                        ...g("root"),
                        ref: t,
                        component: h[i],
                        variant: p,
                        size: r,
                        ...m
                    })
        }
        ));
    IR.defaultLoaders = LR,
        IR.classes = _R,
        IR.displayName = "@mantine/core/Loader";
    var jR = {
        root: "m_9814e45f"
    };
    const HR = {
        zIndex: UP("modal")
    }
        , zR = (e, t) => {
            let { gradient: n, color: r, backgroundOpacity: o, blur: i, radius: s, zIndex: a } = t;
            return {
                root: {
                    "--overlay-bg": n || (void 0 !== r || void 0 !== o) && oA(r || "#000", o ?? .6) || void 0,
                    "--overlay-filter": i ? `blur(${GO(i)})` : void 0,
                    "--overlay-radius": void 0 === s ? void 0 : SA(s),
                    "--overlay-z-index": a?.toString()
                }
            }
        }
        , $R = vA(((e, t) => {
            const n = gA("Overlay", HR, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, fixed: c, center: d, children: u, radius: h, zIndex: p, gradient: f, blur: m, color: g, backgroundOpacity: b, mod: y, ...v } = n
                , w = FA({
                    name: "Overlay",
                    props: n,
                    classes: jR,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    vars: l,
                    varsResolver: zR
                });
            return (0,
                Lx.jsx)(cP, {
                    ref: t,
                    ...w("root"),
                    mod: [{
                        center: d,
                        fixed: c
                    }, y],
                    ...v,
                    children: u
                })
        }
        ));
    $R.classes = jR,
        $R.displayName = "@mantine/core/Overlay";
    var BR = {
        root: "m_6e45937b",
        loader: "m_e8eb006c",
        overlay: "m_df587f17"
    };
    const VR = {
        transitionProps: {
            transition: "fade",
            duration: 0
        },
        overlayProps: {
            backgroundOpacity: .75
        },
        zIndex: UP("overlay")
    }
        , FR = (e, t) => {
            let { zIndex: n } = t;
            return {
                root: {
                    "--lo-z-index": n?.toString()
                }
            }
        }
        , UR = yA(((e, t) => {
            const n = gA("LoadingOverlay", VR, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, transitionProps: c, loaderProps: d, overlayProps: u, visible: h, zIndex: p, ...f } = n
                , m = fA()
                , g = FA({
                    name: "LoadingOverlay",
                    classes: BR,
                    props: n,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    vars: l,
                    varsResolver: FR
                })
                , b = {
                    ...VR.overlayProps,
                    ...u
                };
            return (0,
                Lx.jsx)(OL, {
                    transition: "fade",
                    ...c,
                    mounted: !!h,
                    children: e => (0,
                        Lx.jsxs)(cP, {
                            ...g("root", {
                                style: e
                            }),
                            ref: t,
                            ...f,
                            children: [(0,
                                Lx.jsx)(IR, {
                                    ...g("loader"),
                                    unstyled: a,
                                    ...d
                                }), (0,
                                    Lx.jsx)($R, {
                                        ...b,
                                        ...g("overlay"),
                                        darkHidden: !0,
                                        unstyled: a,
                                        color: u?.color || m.white
                                    }), (0,
                                        Lx.jsx)($R, {
                                            ...b,
                                            ...g("overlay"),
                                            lightHidden: !0,
                                            unstyled: a,
                                            color: u?.color || m.colors.dark[5]
                                        })]
                        })
                })
        }
        ));
    UR.classes = BR,
        UR.displayName = "@mantine/core/LoadingOverlay";
    var WR = {
        root: "m_77c9d27d",
        inner: "m_80f1301b",
        label: "m_811560b9",
        section: "m_a74036a",
        loader: "m_a25b86ee",
        group: "m_80d6d844"
    };
    const qR = {
        orientation: "horizontal"
    }
        , GR = (e, t) => {
            let { borderWidth: n } = t;
            return {
                group: {
                    "--button-border-width": GO(n)
                }
            }
        }
        , KR = yA(((e, t) => {
            const n = gA("ButtonGroup", qR, e)
                , { className: r, style: o, classNames: i, styles: s, unstyled: a, orientation: l, vars: c, borderWidth: d, variant: u, mod: h, ...p } = gA("ButtonGroup", qR, e)
                , f = FA({
                    name: "ButtonGroup",
                    props: n,
                    classes: WR,
                    className: r,
                    style: o,
                    classNames: i,
                    styles: s,
                    unstyled: a,
                    vars: c,
                    varsResolver: GR,
                    rootSelector: "group"
                });
            return (0,
                Lx.jsx)(cP, {
                    ...f("group"),
                    ref: t,
                    variant: u,
                    mod: [{
                        "data-orientation": l
                    }, h],
                    role: "group",
                    ...p
                })
        }
        ));
    KR.classes = WR,
        KR.displayName = "@mantine/core/ButtonGroup";
    const JR = {
        in: {
            opacity: 1,
            transform: `translate(-50%, calc(-50% + ${GO(1)}))`
        },
        out: {
            opacity: 0,
            transform: "translate(-50%, -200%)"
        },
        common: {
            transformOrigin: "center"
        },
        transitionProperty: "transform, opacity"
    }
        , ZR = {}
        , XR = (e, t) => {
            let { radius: n, color: r, gradient: o, variant: i, size: s, justify: a, autoContrast: l } = t;
            const c = e.variantColorResolver({
                color: r || e.primaryColor,
                theme: e,
                gradient: o,
                variant: i || "filled",
                autoContrast: l
            });
            return {
                root: {
                    "--button-justify": a,
                    "--button-height": kA(s, "button-height"),
                    "--button-padding-x": kA(s, "button-padding-x"),
                    "--button-fz": s?.includes("compact") ? xA(s.replace("compact-", "")) : xA(s),
                    "--button-radius": void 0 === n ? void 0 : SA(n),
                    "--button-bg": r || i ? c.background : void 0,
                    "--button-hover": r || i ? c.hover : void 0,
                    "--button-color": c.color,
                    "--button-bd": r || i ? c.border : void 0,
                    "--button-hover-color": r || i ? c.hoverColor : void 0
                }
            }
        }
        , QR = vA(((e, t) => {
            const n = gA("Button", ZR, e)
                , { style: r, vars: o, className: i, color: s, disabled: a, children: l, leftSection: c, rightSection: d, fullWidth: u, variant: h, radius: p, loading: f, loaderProps: m, gradient: g, classNames: b, styles: y, unstyled: v, "data-disabled": w, autoContrast: k, mod: C, ...S } = n
                , x = FA({
                    name: "Button",
                    props: n,
                    classes: WR,
                    className: i,
                    style: r,
                    classNames: b,
                    styles: y,
                    unstyled: v,
                    vars: o,
                    varsResolver: XR
                })
                , E = !!c
                , M = !!d;
            return (0,
                Lx.jsxs)(QL, {
                    ref: t,
                    ...x("root", {
                        active: !a && !f && !w
                    }),
                    unstyled: v,
                    variant: h,
                    disabled: a || f,
                    mod: [{
                        disabled: a || w,
                        loading: f,
                        block: u,
                        "with-left-section": E,
                        "with-right-section": M
                    }, C],
                    ...S,
                    children: [(0,
                        Lx.jsx)(OL, {
                            mounted: !!f,
                            transition: JR,
                            duration: 150,
                            children: e => (0,
                                Lx.jsx)(cP, {
                                    component: "span",
                                    ...x("loader", {
                                        style: e
                                    }),
                                    "aria-hidden": !0,
                                    children: (0,
                                        Lx.jsx)(IR, {
                                            color: "var(--button-color)",
                                            size: "calc(var(--button-height) / 1.8)",
                                            ...m
                                        })
                                })
                        }), (0,
                            Lx.jsxs)("span", {
                                ...x("inner"),
                                children: [c && (0,
                                    Lx.jsx)(cP, {
                                        component: "span",
                                        ...x("section"),
                                        mod: {
                                            position: "left"
                                        },
                                        children: c
                                    }), (0,
                                        Lx.jsx)(cP, {
                                            component: "span",
                                            mod: {
                                                loading: f
                                            },
                                            ...x("label"),
                                            children: l
                                        }), d && (0,
                                            Lx.jsx)(cP, {
                                                component: "span",
                                                ...x("section"),
                                                mod: {
                                                    position: "right"
                                                },
                                                children: d
                                            })]
                            })]
                })
        }
        ));
    QR.classes = WR,
        QR.displayName = "@mantine/core/Button",
        QR.Group = KR;
    const YR = (0,
        r.forwardRef)(((e, t) => {
            let { size: n = "var(--cb-icon-size, 70%)", style: r, ...o } = e;
            return (0,
                Lx.jsx)("svg", {
                    viewBox: "0 0 15 15",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    style: {
                        ...r,
                        width: n,
                        height: n
                    },
                    ref: t,
                    ...o,
                    children: (0,
                        Lx.jsx)("path", {
                            d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
                            fill: "currentColor",
                            fillRule: "evenodd",
                            clipRule: "evenodd"
                        })
                })
        }
        ));
    YR.displayName = "@mantine/core/CloseIcon";
    var eD = {
        root: "m_86a44da5",
        "root--subtle": "m_220c80f2"
    };
    const tD = {
        variant: "subtle"
    }
        , nD = (e, t) => {
            let { size: n, radius: r, iconSize: o } = t;
            return {
                root: {
                    "--cb-size": kA(n, "cb-size"),
                    "--cb-radius": void 0 === r ? void 0 : SA(r),
                    "--cb-icon-size": GO(o)
                }
            }
        }
        , rD = vA(((e, t) => {
            const n = gA("CloseButton", tD, e)
                , { iconSize: r, children: o, vars: i, radius: s, className: a, classNames: l, style: c, styles: d, unstyled: u, "data-disabled": h, disabled: p, variant: f, icon: m, mod: g, ...b } = n
                , y = FA({
                    name: "CloseButton",
                    props: n,
                    className: a,
                    style: c,
                    classes: eD,
                    classNames: l,
                    styles: d,
                    unstyled: u,
                    vars: i,
                    varsResolver: nD
                });
            return (0,
                Lx.jsxs)(QL, {
                    ref: t,
                    ...b,
                    unstyled: u,
                    variant: f,
                    disabled: p,
                    mod: [{
                        disabled: p || h
                    }, g],
                    ...y("root", {
                        variant: f,
                        active: !p && !h
                    }),
                    children: [m || (0,
                        Lx.jsx)(YR, {}), o]
                })
        }
        ));
    rD.classes = eD,
        rD.displayName = "@mantine/core/CloseButton";
    const oD = {
        multiple: !1
    }
        , iD = (0,
            r.forwardRef)(((e, t) => {
                const { onChange: n, children: o, multiple: i, accept: s, name: a, form: l, resetRef: c, disabled: d, capture: u, inputProps: h, ...p } = gA("FileButton", oD, e)
                    , f = (0,
                        r.useRef)();
                return XP(c, (() => {
                    f.current.value = ""
                }
                )),
                    (0,
                        Lx.jsxs)(Lx.Fragment, {
                            children: [o({
                                onClick: () => {
                                    !d && f.current?.click()
                                }
                                ,
                                ...p
                            }), (0,
                                Lx.jsx)("input", {
                                    style: {
                                        display: "none"
                                    },
                                    type: "file",
                                    accept: s,
                                    multiple: i,
                                    onChange: e => {
                                        n(i ? Array.from(e.currentTarget.files) : e.currentTarget.files[0] || null)
                                    }
                                    ,
                                    ref: YP(t, f),
                                    name: a,
                                    form: l,
                                    capture: u,
                                    ...h
                                })]
                        })
            }
            ));
    iD.displayName = "@mantine/core/FileButton";
    const sD = {
        valueComponent: e => {
            let { value: t } = e;
            return (0,
                Lx.jsx)("div", {
                    style: {
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap"
                    },
                    children: Array.isArray(t) ? t.map((e => e.name)).join(", ") : t?.name
                })
        }
    }
        , aD = yA(((e, t) => {
            const n = gA("FileInput", sD, e)
                , { unstyled: o, vars: i, onChange: s, value: a, defaultValue: l, multiple: c, accept: d, name: u, form: h, valueComponent: p, clearable: f, clearButtonProps: m, readOnly: g, capture: b, fileInputProps: y, rightSection: v, size: w, placeholder: k, resetRef: C, ...S } = n
                , x = (0,
                    r.useRef)(null)
                , [E, M] = zP({
                    value: a,
                    defaultValue: l,
                    onChange: s,
                    finalValue: c ? [] : null
                })
                , T = Array.isArray(E) ? 0 !== E.length : null !== E
                , N = v || (f && T && !g ? (0,
                    Lx.jsx)(rD, {
                        ...m,
                        variant: "subtle",
                        onClick: () => M(c ? [] : null),
                        size: w,
                        unstyled: o
                    }) : null);
            (0,
                r.useEffect)((() => {
                    (Array.isArray(E) && 0 === E.length || null === E) && x.current?.()
                }
                ), [E]);
            const _ = p;
            return (0,
                Lx.jsx)(iD, {
                    onChange: M,
                    multiple: c,
                    accept: d,
                    name: u,
                    form: h,
                    resetRef: YP(x, C),
                    disabled: g,
                    capture: b,
                    inputProps: y,
                    children: e => (0,
                        Lx.jsx)(IP, {
                            component: "button",
                            ref: t,
                            rightSection: N,
                            ...e,
                            ...S,
                            __staticSelector: "FileInput",
                            multiline: !0,
                            type: "button",
                            pointer: !0,
                            __stylesApiProps: n,
                            unstyled: o,
                            size: w,
                            children: T ? (0,
                                Lx.jsx)(_, {
                                    value: E
                                }) : (0,
                                    Lx.jsx)(RP.Placeholder, {
                                        children: k
                                    })
                        })
                })
        }
        ));
    aD.classes = IP.classes,
        aD.displayName = "@mantine/core/FileInput";
    const lD = aD;
    var cD = {
        root: "m_8d3f4000",
        icon: "m_8d3afb97",
        loader: "m_302b9fb1",
        group: "m_1a0f1b21"
    };
    const dD = {
        orientation: "horizontal"
    }
        , uD = (e, t) => {
            let { borderWidth: n } = t;
            return {
                group: {
                    "--ai-border-width": GO(n)
                }
            }
        }
        , hD = yA(((e, t) => {
            const n = gA("ActionIconGroup", dD, e)
                , { className: r, style: o, classNames: i, styles: s, unstyled: a, orientation: l, vars: c, borderWidth: d, variant: u, mod: h, ...p } = gA("ActionIconGroup", dD, e)
                , f = FA({
                    name: "ActionIconGroup",
                    props: n,
                    classes: cD,
                    className: r,
                    style: o,
                    classNames: i,
                    styles: s,
                    unstyled: a,
                    vars: c,
                    varsResolver: uD,
                    rootSelector: "group"
                });
            return (0,
                Lx.jsx)(cP, {
                    ...f("group"),
                    ref: t,
                    variant: u,
                    mod: [{
                        "data-orientation": l
                    }, h],
                    role: "group",
                    ...p
                })
        }
        ));
    hD.classes = cD,
        hD.displayName = "@mantine/core/ActionIconGroup";
    const pD = {}
        , fD = (e, t) => {
            let { size: n, radius: r, variant: o, gradient: i, color: s, autoContrast: a } = t;
            const l = e.variantColorResolver({
                color: s || e.primaryColor,
                theme: e,
                gradient: i,
                variant: o || "filled",
                autoContrast: a
            });
            return {
                root: {
                    "--ai-size": kA(n, "ai-size"),
                    "--ai-radius": void 0 === r ? void 0 : SA(r),
                    "--ai-bg": s || o ? l.background : void 0,
                    "--ai-hover": s || o ? l.hover : void 0,
                    "--ai-hover-color": s || o ? l.hoverColor : void 0,
                    "--ai-color": l.color,
                    "--ai-bd": s || o ? l.border : void 0
                }
            }
        }
        , mD = vA(((e, t) => {
            const n = gA("ActionIcon", pD, e)
                , { className: r, unstyled: o, variant: i, classNames: s, styles: a, style: l, loading: c, loaderProps: d, size: u, color: h, radius: p, __staticSelector: f, gradient: m, vars: g, children: b, disabled: y, "data-disabled": v, autoContrast: w, mod: k, ...C } = n
                , S = FA({
                    name: ["ActionIcon", f],
                    props: n,
                    className: r,
                    style: l,
                    classes: cD,
                    classNames: s,
                    styles: a,
                    unstyled: o,
                    vars: g,
                    varsResolver: fD
                });
            return (0,
                Lx.jsxs)(QL, {
                    ...S("root", {
                        active: !y && !c && !v
                    }),
                    ...C,
                    unstyled: o,
                    variant: i,
                    size: u,
                    disabled: y || c,
                    ref: t,
                    mod: [{
                        loading: c,
                        disabled: y || v
                    }, k],
                    children: [(0,
                        Lx.jsx)(OL, {
                            mounted: !!c,
                            transition: "slide-down",
                            duration: 150,
                            children: e => (0,
                                Lx.jsx)(cP, {
                                    component: "span",
                                    ...S("loader", {
                                        style: e
                                    }),
                                    "aria-hidden": !0,
                                    children: (0,
                                        Lx.jsx)(IR, {
                                            color: "var(--ai-color)",
                                            size: "calc(var(--ai-size) * 0.55)",
                                            ...d
                                        })
                                })
                        }), (0,
                            Lx.jsx)(cP, {
                                component: "span",
                                mod: {
                                    loading: c
                                },
                                ...S("icon"),
                                children: b
                            })]
                })
        }
        ));
    mD.classes = cD,
        mD.displayName = "@mantine/core/ActionIcon",
        mD.Group = hD;
    var gD = {
        root: "m_6d731127"
    };
    const bD = {
        gap: "md",
        align: "stretch",
        justify: "flex-start"
    }
        , yD = (e, t) => {
            let { gap: n, align: r, justify: o } = t;
            return {
                root: {
                    "--stack-gap": CA(n),
                    "--stack-align": r,
                    "--stack-justify": o
                }
            }
        }
        , vD = yA(((e, t) => {
            const n = gA("Stack", bD, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, align: c, justify: d, gap: u, variant: h, ...p } = n
                , f = FA({
                    name: "Stack",
                    props: n,
                    classes: gD,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    vars: l,
                    varsResolver: yD
                });
            return (0,
                Lx.jsx)(cP, {
                    ref: t,
                    ...f("root"),
                    variant: h,
                    ...p
                })
        }
        ));
    vD.classes = gD,
        vD.displayName = "@mantine/core/Stack";
    var wD = {
        root: "m_b6d8b162"
    };
    function kD(e) {
        return "start" === e ? "start" : "end" === e || e ? "end" : void 0
    }
    const CD = {
        inherit: !1
    }
        , SD = (e, t) => {
            let { variant: n, lineClamp: r, gradient: o, size: i, color: s } = t;
            return {
                root: {
                    "--text-fz": xA(i),
                    "--text-lh": EA(i),
                    "--text-gradient": "gradient" === n ? rA(o, e) : void 0,
                    "--text-line-clamp": "number" === typeof r ? r.toString() : void 0,
                    "--text-color": s ? nA(s, e) : void 0
                }
            }
        }
        , xD = vA(((e, t) => {
            const n = gA("Text", CD, e)
                , { lineClamp: r, truncate: o, inline: i, inherit: s, gradient: a, span: l, __staticSelector: c, vars: d, className: u, style: h, classNames: p, styles: f, unstyled: m, variant: g, mod: b, size: y, ...v } = n
                , w = FA({
                    name: ["Text", c],
                    props: n,
                    classes: wD,
                    className: u,
                    style: h,
                    classNames: p,
                    styles: f,
                    unstyled: m,
                    vars: d,
                    varsResolver: SD
                });
            return (0,
                Lx.jsx)(cP, {
                    ...w("root", {
                        focusable: !0
                    }),
                    ref: t,
                    component: l ? "span" : "p",
                    variant: g,
                    mod: [{
                        "data-truncate": kD(o),
                        "data-line-clamp": "number" === typeof r,
                        "data-inline": i,
                        "data-inherit": s
                    }, b],
                    size: y,
                    ...v
                })
        }
        ));
    xD.classes = wD,
        xD.displayName = "@mantine/core/Text";
    var ED = {
        root: "m_347db0ec",
        "root--dot": "m_fbd81e3d",
        label: "m_5add502a",
        section: "m_91fdda9b"
    };
    const MD = {}
        , TD = (e, t) => {
            let { radius: n, color: r, gradient: o, variant: i, size: s, autoContrast: a } = t;
            const l = e.variantColorResolver({
                color: r || e.primaryColor,
                theme: e,
                gradient: o,
                variant: i || "filled",
                autoContrast: a
            });
            return {
                root: {
                    "--badge-height": kA(s, "badge-height"),
                    "--badge-padding-x": kA(s, "badge-padding-x"),
                    "--badge-fz": kA(s, "badge-fz"),
                    "--badge-radius": void 0 === n ? void 0 : SA(n),
                    "--badge-bg": r || i ? l.background : void 0,
                    "--badge-color": r || i ? l.color : void 0,
                    "--badge-bd": r || i ? l.border : void 0,
                    "--badge-dot-color": "dot" === i ? nA(r, e) : void 0
                }
            }
        }
        , ND = vA(((e, t) => {
            const n = gA("Badge", MD, e)
                , { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, radius: c, color: d, gradient: u, leftSection: h, rightSection: p, children: f, variant: m, fullWidth: g, autoContrast: b, circle: y, mod: v, ...w } = n
                , k = FA({
                    name: "Badge",
                    props: n,
                    classes: ED,
                    className: o,
                    style: i,
                    classNames: r,
                    styles: s,
                    unstyled: a,
                    vars: l,
                    varsResolver: TD
                });
            return (0,
                Lx.jsxs)(cP, {
                    variant: m,
                    mod: [{
                        block: g,
                        circle: y,
                        "with-right-section": !!p,
                        "with-left-section": !!h
                    }, v],
                    ...k("root", {
                        variant: m
                    }),
                    ref: t,
                    ...w,
                    children: [h && (0,
                        Lx.jsx)("span", {
                            ...k("section"),
                            "data-position": "left",
                            children: h
                        }), (0,
                            Lx.jsx)("span", {
                                ...k("label"),
                                children: f
                            }), p && (0,
                                Lx.jsx)("span", {
                                    ...k("section"),
                                    "data-position": "right",
                                    children: p
                                })]
                })
        }
        ));
    ND.classes = ED,
        ND.displayName = "@mantine/core/Badge";
    const _D = {
        duration: 100,
        transition: "fade"
    };
    function OD(e, t) {
        return Array.isArray(e) ? [...e].reduce(((e, n) => ({
            ...e,
            ...OD(n, t)
        })), {}) : "function" === typeof e ? e(t) : null == e ? {} : e
    }
    var AD = {
        tooltip: "m_1b3c8819",
        arrow: "m_f898399f"
    };
    const PD = {
        refProp: "ref",
        withinPortal: !0,
        offset: 10,
        defaultOpened: !1,
        position: "right",
        zIndex: UP("popover")
    }
        , LD = (e, t) => {
            let { radius: n, color: r } = t;
            return {
                tooltip: {
                    "--tooltip-radius": void 0 === n ? void 0 : SA(n),
                    "--tooltip-bg": r ? nA(r, e) : void 0,
                    "--tooltip-color": r ? "var(--mantine-color-white)" : void 0
                }
            }
        }
        , RD = yA(((e, t) => {
            const n = gA("TooltipFloating", PD, e)
                , { children: o, refProp: i, withinPortal: s, style: a, className: l, classNames: c, styles: d, unstyled: u, radius: h, color: p, label: f, offset: m, position: g, multiline: b, zIndex: y, disabled: v, defaultOpened: w, variant: k, vars: C, portalProps: S, ...x } = n
                , E = fA()
                , M = FA({
                    name: "TooltipFloating",
                    props: n,
                    classes: AD,
                    className: l,
                    style: a,
                    classNames: c,
                    styles: d,
                    unstyled: u,
                    rootSelector: "tooltip",
                    vars: C,
                    varsResolver: LD
                })
                , { handleMouseMove: T, x: N, y: _, opened: O, boundaryRef: A, floating: P, setOpened: L } = function (e) {
                    let { offset: t, position: n, defaultOpened: o } = e;
                    const [i, s] = (0,
                        r.useState)(o)
                        , a = (0,
                            r.useRef)()
                        , { x: l, y: c, elements: d, refs: u, update: h, placement: p } = RT({
                            placement: n,
                            middleware: [PM({
                                crossAxis: !0,
                                padding: 5,
                                rootBoundary: "document"
                            })]
                        })
                        , f = p.includes("right") ? t : n.includes("left") ? -1 * t : 0
                        , m = p.includes("bottom") ? t : n.includes("top") ? -1 * t : 0
                        , g = (0,
                            r.useCallback)((e => {
                                let { clientX: t, clientY: n } = e;
                                u.setPositionReference({
                                    getBoundingClientRect: () => ({
                                        width: 0,
                                        height: 0,
                                        x: t,
                                        y: n,
                                        left: t + f,
                                        top: n + m,
                                        right: t,
                                        bottom: n
                                    })
                                })
                            }
                            ), [d.reference]);
                    return (0,
                        r.useEffect)((() => {
                            if (u.floating.current) {
                                const e = a.current;
                                e.addEventListener("mousemove", g);
                                const t = Qx(u.floating.current);
                                return t.forEach((e => {
                                    e.addEventListener("scroll", h)
                                }
                                )),
                                    () => {
                                        e.removeEventListener("mousemove", g),
                                            t.forEach((e => {
                                                e.removeEventListener("scroll", h)
                                            }
                                            ))
                                    }
                            }
                        }
                        ), [d.reference, u.floating.current, h, g, i]),
                    {
                        handleMouseMove: g,
                        x: l,
                        y: c,
                        opened: i,
                        setOpened: s,
                        boundaryRef: a,
                        floating: u.setFloating
                    }
                }({
                    offset: m,
                    position: g,
                    defaultOpened: w
                });
            if (!mL(o))
                throw new Error("[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
            const R = YP(A, o.ref, t);
            return (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [(0,
                        Lx.jsx)(SL, {
                            ...S,
                            withinPortal: s,
                            children: (0,
                                Lx.jsx)(cP, {
                                    ...x,
                                    ...M("tooltip", {
                                        style: {
                                            ...OD(a, E),
                                            zIndex: y,
                                            display: !v && O ? "block" : "none",
                                            top: (_ && Math.round(_)) ?? "",
                                            left: (N && Math.round(N)) ?? ""
                                        }
                                    }),
                                    variant: k,
                                    ref: P,
                                    mod: {
                                        multiline: b
                                    },
                                    children: f
                                })
                        }), (0,
                            r.cloneElement)(o, {
                                ...o.props,
                                [i]: R,
                                onMouseEnter: e => {
                                    o.props.onMouseEnter?.(e),
                                        T(e),
                                        L(!0)
                                }
                                ,
                                onMouseLeave: e => {
                                    o.props.onMouseLeave?.(e),
                                        L(!1)
                                }
                            })]
                })
        }
        ));
    RD.classes = AD,
        RD.displayName = "@mantine/core/TooltipFloating";
    const DD = (0,
        r.createContext)(!1)
        , ID = DD.Provider
        , jD = {
            openDelay: 0,
            closeDelay: 0
        };
    function HD(e) {
        const { openDelay: t, closeDelay: n, children: r } = gA("TooltipGroup", jD, e);
        return (0,
            Lx.jsx)(ID, {
                value: !0,
                children: (0,
                    Lx.jsx)(hT, {
                        delay: {
                            open: t,
                            close: n
                        },
                        children: r
                    })
            })
    }
    function zD(e) {
        const [t, n] = (0,
            r.useState)(e.defaultOpened)
            , o = "boolean" === typeof e.opened ? e.opened : t
            , i = (0,
                r.useContext)(DD)
            , s = TP()
            , { delay: a, currentId: l, setCurrentId: c } = uT()
            , d = (0,
                r.useCallback)((e => {
                    n(e),
                        e && c(s)
                }
                ), [c, s])
            , { x: u, y: h, context: p, refs: f, update: m, placement: g, middlewareData: { arrow: { x: b, y: y } = {} } } = RT({
                strategy: e.strategy,
                placement: e.position,
                open: o,
                onOpenChange: d,
                middleware: [AM(e.offset), PM({
                    padding: 8
                }), RM(), jM({
                    element: e.arrowRef,
                    padding: e.arrowOffset
                }), ...e.inline ? [IM()] : []]
            })
            , { getReferenceProps: v, getFloatingProps: w } = zT([lT(p, {
                enabled: e.events?.hover,
                delay: i ? a : {
                    open: e.openDelay,
                    close: e.closeDelay
                },
                mouseOnly: !e.events?.touch
            }), DT(p, {
                enabled: e.events?.focus,
                visibleOnly: !0
            }), BT(p, {
                role: "tooltip"
            }), LT(p, {
                enabled: "undefined" === typeof e.opened
            }), pT(p, {
                id: s
            })]);
        IL({
            opened: o,
            position: e.position,
            positionDependencies: e.positionDependencies,
            floating: {
                refs: f,
                update: m
            }
        }),
            $P((() => {
                e.onPositionChange?.(g)
            }
            ), [g]);
        const k = o && l && l !== s;
        return {
            x: u,
            y: h,
            arrowX: b,
            arrowY: y,
            reference: f.setReference,
            floating: f.setFloating,
            getFloatingProps: w,
            getReferenceProps: v,
            isGroupPhase: k,
            opened: o,
            placement: g
        }
    }
    HD.displayName = "@mantine/core/TooltipGroup",
        HD.extend = e => e;
    const $D = {
        position: "top",
        refProp: "ref",
        withinPortal: !0,
        inline: !1,
        defaultOpened: !1,
        arrowSize: 4,
        arrowOffset: 5,
        arrowRadius: 0,
        arrowPosition: "side",
        offset: 5,
        transitionProps: {
            duration: 100,
            transition: "fade"
        },
        events: {
            hover: !0,
            focus: !1,
            touch: !1
        },
        zIndex: UP("popover"),
        positionDependencies: []
    }
        , BD = (e, t) => {
            let { radius: n, color: r } = t;
            return {
                tooltip: {
                    "--tooltip-radius": void 0 === n ? void 0 : SA(n),
                    "--tooltip-bg": r ? nA(r, e) : void 0,
                    "--tooltip-color": r ? "var(--mantine-color-white)" : void 0
                }
            }
        }
        , VD = yA(((e, t) => {
            const n = gA("Tooltip", $D, e)
                , { children: o, position: i, refProp: s, label: a, openDelay: l, closeDelay: c, onPositionChange: d, opened: u, defaultOpened: h, withinPortal: p, radius: f, color: m, classNames: g, styles: b, unstyled: y, style: v, className: w, withArrow: k, arrowSize: C, arrowOffset: S, arrowRadius: x, arrowPosition: E, offset: M, transitionProps: T, multiline: N, events: _, zIndex: O, disabled: A, positionDependencies: P, onClick: L, onMouseEnter: R, onMouseLeave: D, inline: I, variant: j, keepMounted: H, vars: z, portalProps: $, mod: B, floatingStrategy: V, ...F } = gA("Tooltip", $D, n)
                , { dir: U } = qP()
                , W = (0,
                    r.useRef)(null)
                , q = zD({
                    position: GP(U, i),
                    closeDelay: c,
                    openDelay: l,
                    onPositionChange: d,
                    opened: u,
                    defaultOpened: h,
                    events: _,
                    arrowRef: W,
                    arrowOffset: S,
                    offset: "number" === typeof M ? M + (k ? C / 2 : 0) : M,
                    positionDependencies: [...P, o],
                    inline: I,
                    strategy: V
                })
                , G = FA({
                    name: "Tooltip",
                    props: n,
                    classes: AD,
                    className: w,
                    style: v,
                    classNames: g,
                    styles: b,
                    unstyled: y,
                    rootSelector: "tooltip",
                    vars: z,
                    varsResolver: BD
                });
            if (!mL(o))
                throw new Error("[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
            const K = YP(q.reference, o.ref, t)
                , J = function (e, t) {
                    return {
                        ..._D,
                        ...t,
                        ...e
                    }
                }(T, {
                    duration: 100,
                    transition: "fade"
                });
            return (0,
                Lx.jsxs)(Lx.Fragment, {
                    children: [(0,
                        Lx.jsx)(SL, {
                            ...$,
                            withinPortal: p,
                            children: (0,
                                Lx.jsx)(OL, {
                                    ...J,
                                    keepMounted: H,
                                    mounted: !A && !!q.opened,
                                    duration: q.isGroupPhase ? 10 : J.duration,
                                    children: e => (0,
                                        Lx.jsxs)(cP, {
                                            ...F,
                                            "data-fixed": "fixed" === V || void 0,
                                            variant: j,
                                            mod: [{
                                                multiline: N
                                            }, B],
                                            ...q.getFloatingProps({
                                                ref: q.floating,
                                                className: G("tooltip").className,
                                                style: {
                                                    ...G("tooltip").style,
                                                    ...e,
                                                    zIndex: O,
                                                    top: q.y ?? 0,
                                                    left: q.x ?? 0
                                                }
                                            }),
                                            children: [a, (0,
                                                Lx.jsx)(sL, {
                                                    ref: W,
                                                    arrowX: q.arrowX,
                                                    arrowY: q.arrowY,
                                                    visible: k,
                                                    position: q.placement,
                                                    arrowSize: C,
                                                    arrowOffset: S,
                                                    arrowRadius: x,
                                                    arrowPosition: E,
                                                    ...G("arrow")
                                                })]
                                        })
                                })
                        }), (0,
                            r.cloneElement)(o, q.getReferenceProps({
                                onClick: L,
                                onMouseEnter: R,
                                onMouseLeave: D,
                                onMouseMove: n.onMouseMove,
                                onPointerDown: n.onPointerDown,
                                onPointerEnter: n.onPointerEnter,
                                [s]: K,
                                className: AA(w, o.props.className),
                                ...o.props
                            }))]
                })
        }
        ));
    function FD(e) {
        return "auto" === e || "dark" === e || "light" === e
    }
    function UD() {
        let e, { key: t = "mantine-color-scheme-value" } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return {
            get: e => {
                if ("undefined" === typeof window)
                    return e;
                try {
                    const n = window.localStorage.getItem(t);
                    return FD(n) ? n : e
                } catch {
                    return e
                }
            }
            ,
            set: e => {
                try {
                    window.localStorage.setItem(t, e)
                } catch (n) {
                    console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", n)
                }
            }
            ,
            subscribe: n => {
                e = e => {
                    e.storageArea === window.localStorage && e.key === t && FD(e.newValue) && n(e.newValue)
                }
                    ,
                    window.addEventListener("storage", e)
            }
            ,
            unsubscribe: () => {
                window.removeEventListener("storage", e)
            }
            ,
            clear: () => {
                window.localStorage.removeItem(t)
            }
        }
    }
    function WD() {
        const e = fA()
            , t = _A()
            , n = WA(e.breakpoints).reduce(((t, n) => {
                const r = e.breakpoints[n].includes("px")
                    , o = function (e) {
                        const t = function (e) {
                            return "string" === typeof e && e.includes("var(--mantine-scale)") ? e.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim() : e
                        }(e);
                        return "number" === typeof t ? t : "string" === typeof t ? t.includes("calc") || t.includes("var") ? t : t.includes("px") ? Number(t.replace("px", "")) : t.includes("rem") ? 16 * Number(t.replace("rem", "")) : t.includes("em") ? 16 * Number(t.replace("em", "")) : Number(t) : NaN
                    }(e.breakpoints[n]);
                return `${t}@media (max-width: ${r ? o - .1 + "px" : KO(o - .1)}) {.mantine-visible-from-${n} {display: none !important;}}@media (min-width: ${r ? `${o}px` : KO(o)}) {.mantine-hidden-from-${n} {display: none !important;}}`
            }
            ), "");
        return (0,
            Lx.jsx)("style", {
                "data-mantine-styles": "classes",
                nonce: t?.(),
                dangerouslySetInnerHTML: {
                    __html: n
                }
            })
    }
    function qD(e) {
        return Object.entries(e).map((e => {
            let [t, n] = e;
            return `${t}: ${n};`
        }
        )).join("")
    }
    function GD(e, t) {
        return (Array.isArray(e) ? e : [e]).reduce(((e, t) => `${t}{${e}}`), t)
    }
    function KD(e) {
        let { theme: t, color: n, colorScheme: r, name: o = n, withColorValues: i = !0 } = e;
        if (!t.colors[n])
            return {};
        if ("light" === r) {
            const e = XO(t, "light")
                , r = {
                    [`--mantine-color-${o}-text`]: `var(--mantine-color-${o}-filled)`,
                    [`--mantine-color-${o}-filled`]: `var(--mantine-color-${o}-${e})`,
                    [`--mantine-color-${o}-filled-hover`]: `var(--mantine-color-${o}-${9 === e ? 8 : e + 1})`,
                    [`--mantine-color-${o}-light`]: iA(t.colors[n][e], .1),
                    [`--mantine-color-${o}-light-hover`]: iA(t.colors[n][e], .12),
                    [`--mantine-color-${o}-light-color`]: `var(--mantine-color-${o}-${e})`,
                    [`--mantine-color-${o}-outline`]: `var(--mantine-color-${o}-${e})`,
                    [`--mantine-color-${o}-outline-hover`]: iA(t.colors[n][e], .05)
                };
            return i ? {
                [`--mantine-color-${o}-0`]: t.colors[n][0],
                [`--mantine-color-${o}-1`]: t.colors[n][1],
                [`--mantine-color-${o}-2`]: t.colors[n][2],
                [`--mantine-color-${o}-3`]: t.colors[n][3],
                [`--mantine-color-${o}-4`]: t.colors[n][4],
                [`--mantine-color-${o}-5`]: t.colors[n][5],
                [`--mantine-color-${o}-6`]: t.colors[n][6],
                [`--mantine-color-${o}-7`]: t.colors[n][7],
                [`--mantine-color-${o}-8`]: t.colors[n][8],
                [`--mantine-color-${o}-9`]: t.colors[n][9],
                ...r
            } : r
        }
        const s = XO(t, "dark")
            , a = {
                [`--mantine-color-${o}-text`]: `var(--mantine-color-${o}-4)`,
                [`--mantine-color-${o}-filled`]: `var(--mantine-color-${o}-${s})`,
                [`--mantine-color-${o}-filled-hover`]: `var(--mantine-color-${o}-${9 === s ? 8 : s + 1})`,
                [`--mantine-color-${o}-light`]: iA(t.colors[n][Math.max(0, s - 2)], .15),
                [`--mantine-color-${o}-light-hover`]: iA(t.colors[n][Math.max(0, s - 2)], .2),
                [`--mantine-color-${o}-light-color`]: `var(--mantine-color-${o}-${Math.max(s - 5, 0)})`,
                [`--mantine-color-${o}-outline`]: `var(--mantine-color-${o}-${Math.max(s - 4, 0)})`,
                [`--mantine-color-${o}-outline-hover`]: iA(t.colors[n][Math.max(s - 4, 0)], .05)
            };
        return i ? {
            [`--mantine-color-${o}-0`]: t.colors[n][0],
            [`--mantine-color-${o}-1`]: t.colors[n][1],
            [`--mantine-color-${o}-2`]: t.colors[n][2],
            [`--mantine-color-${o}-3`]: t.colors[n][3],
            [`--mantine-color-${o}-4`]: t.colors[n][4],
            [`--mantine-color-${o}-5`]: t.colors[n][5],
            [`--mantine-color-${o}-6`]: t.colors[n][6],
            [`--mantine-color-${o}-7`]: t.colors[n][7],
            [`--mantine-color-${o}-8`]: t.colors[n][8],
            [`--mantine-color-${o}-9`]: t.colors[n][9],
            ...a
        } : a
    }
    function JD(e, t, n) {
        WA(t).forEach((r => Object.assign(e, {
            [`--mantine-${n}-${r}`]: t[r]
        })))
    }
    VD.classes = AD,
        VD.displayName = "@mantine/core/Tooltip",
        VD.Floating = RD,
        VD.Group = HD;
    const ZD = e => {
        const t = XO(e, "light")
            , n = e.defaultRadius in e.radius ? e.radius[e.defaultRadius] : GO(e.defaultRadius)
            , r = {
                variables: {
                    "--mantine-scale": e.scale.toString(),
                    "--mantine-cursor-type": e.cursorType,
                    "--mantine-color-scheme": "light dark",
                    "--mantine-webkit-font-smoothing": e.fontSmoothing ? "antialiased" : "unset",
                    "--mantine-moz-font-smoothing": e.fontSmoothing ? "grayscale" : "unset",
                    "--mantine-color-white": e.white,
                    "--mantine-color-black": e.black,
                    "--mantine-line-height": e.lineHeights.md,
                    "--mantine-font-family": e.fontFamily,
                    "--mantine-font-family-monospace": e.fontFamilyMonospace,
                    "--mantine-font-family-headings": e.headings.fontFamily,
                    "--mantine-heading-font-weight": e.headings.fontWeight,
                    "--mantine-heading-text-wrap": e.headings.textWrap,
                    "--mantine-radius-default": n,
                    "--mantine-primary-color-filled": `var(--mantine-color-${e.primaryColor}-filled)`,
                    "--mantine-primary-color-filled-hover": `var(--mantine-color-${e.primaryColor}-filled-hover)`,
                    "--mantine-primary-color-light": `var(--mantine-color-${e.primaryColor}-light)`,
                    "--mantine-primary-color-light-hover": `var(--mantine-color-${e.primaryColor}-light-hover)`,
                    "--mantine-primary-color-light-color": `var(--mantine-color-${e.primaryColor}-light-color)`
                },
                light: {
                    "--mantine-primary-color-contrast": fR(e, "light"),
                    "--mantine-color-bright": "var(--mantine-color-black)",
                    "--mantine-color-text": e.black,
                    "--mantine-color-body": e.white,
                    "--mantine-color-error": "var(--mantine-color-red-6)",
                    "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
                    "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-${t})`,
                    "--mantine-color-default": "var(--mantine-color-white)",
                    "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
                    "--mantine-color-default-color": "var(--mantine-color-black)",
                    "--mantine-color-default-border": "var(--mantine-color-gray-4)",
                    "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
                },
                dark: {
                    "--mantine-primary-color-contrast": fR(e, "dark"),
                    "--mantine-color-bright": "var(--mantine-color-white)",
                    "--mantine-color-text": "var(--mantine-color-dark-0)",
                    "--mantine-color-body": "var(--mantine-color-dark-7)",
                    "--mantine-color-error": "var(--mantine-color-red-8)",
                    "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
                    "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-4)`,
                    "--mantine-color-default": "var(--mantine-color-dark-6)",
                    "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
                    "--mantine-color-default-color": "var(--mantine-color-white)",
                    "--mantine-color-default-border": "var(--mantine-color-dark-4)",
                    "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
                }
            };
        JD(r.variables, e.breakpoints, "breakpoint"),
            JD(r.variables, e.spacing, "spacing"),
            JD(r.variables, e.fontSizes, "font-size"),
            JD(r.variables, e.lineHeights, "line-height"),
            JD(r.variables, e.shadows, "shadow"),
            JD(r.variables, e.radius, "radius"),
            e.colors[e.primaryColor].forEach(((t, n) => {
                r.variables[`--mantine-primary-color-${n}`] = `var(--mantine-color-${e.primaryColor}-${n})`
            }
            )),
            WA(e.colors).forEach((t => {
                const n = e.colors[t];
                if (function (e) {
                    return !!e && "object" === typeof e && "mantine-virtual-color" in e
                }(n))
                    return Object.assign(r.light, KD({
                        theme: e,
                        name: n.name,
                        color: n.light,
                        colorScheme: "light",
                        withColorValues: !0
                    })),
                        void Object.assign(r.dark, KD({
                            theme: e,
                            name: n.name,
                            color: n.dark,
                            colorScheme: "dark",
                            withColorValues: !0
                        }));
                n.forEach(((e, n) => {
                    r.variables[`--mantine-color-${t}-${n}`] = e
                }
                )),
                    Object.assign(r.light, KD({
                        theme: e,
                        color: t,
                        colorScheme: "light",
                        withColorValues: !1
                    })),
                    Object.assign(r.dark, KD({
                        theme: e,
                        color: t,
                        colorScheme: "dark",
                        withColorValues: !1
                    }))
            }
            ));
        const o = e.headings.sizes;
        return WA(o).forEach((t => {
            r.variables[`--mantine-${t}-font-size`] = o[t].fontSize,
                r.variables[`--mantine-${t}-line-height`] = o[t].lineHeight,
                r.variables[`--mantine-${t}-font-weight`] = o[t].fontWeight || e.headings.fontWeight
        }
        )),
            r
    }
        ;
    const XD = ZD(aA);
    function QD(e) {
        let { cssVariablesSelector: t, deduplicateCssVariables: n } = e;
        const r = fA()
            , o = _A()
            , i = function (e) {
                let { theme: t, generator: n } = e;
                const r = ZD(t)
                    , o = n?.(t);
                return o ? cA(r, o) : r
            }({
                theme: r,
                generator: NA().cssVariablesResolver
            })
            , s = ":root" === t && n
            , a = function (e, t) {
                const n = qD(e.variables)
                    , r = n ? GD(t, n) : ""
                    , o = qD(e.dark)
                    , i = qD(e.light);
                return `${r}${o ? GD(":host" === t ? `${t}([data-mantine-color-scheme="dark"])` : `${t}[data-mantine-color-scheme="dark"]`, o) : ""}${i ? GD(":host" === t ? `${t}([data-mantine-color-scheme="light"])` : `${t}[data-mantine-color-scheme="light"]`, i) : ""}`
            }(s ? function (e) {
                const t = {
                    variables: {},
                    light: {},
                    dark: {}
                };
                return WA(e.variables).forEach((n => {
                    XD.variables[n] !== e.variables[n] && (t.variables[n] = e.variables[n])
                }
                )),
                    WA(e.light).forEach((n => {
                        XD.light[n] !== e.light[n] && (t.light[n] = e.light[n])
                    }
                    )),
                    WA(e.dark).forEach((n => {
                        XD.dark[n] !== e.dark[n] && (t.dark[n] = e.dark[n])
                    }
                    )),
                    t
            }(i) : i, t);
        return a ? (0,
            Lx.jsx)("style", {
                "data-mantine-styles": !0,
                nonce: o?.(),
                dangerouslySetInnerHTML: {
                    __html: `${a}${s ? "" : (l = t,
                        `\n  ${l}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }\n  ${l}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }\n`)}`
                }
            }) : null;
        var l
    }
    function YD(e, t) {
        const n = "auto" !== e ? e : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        t()?.setAttribute("data-mantine-color-scheme", n)
    }
    function eI(e) {
        let { theme: t, children: n, getStyleNonce: o, withStaticClasses: i = !0, withGlobalClasses: s = !0, deduplicateCssVariables: a = !0, withCssVariables: l = !0, cssVariablesSelector: c = ":root", classNamesPrefix: d = "mantine", colorSchemeManager: u = UD(), defaultColorScheme: h = "light", getRootElement: p = () => document.documentElement, cssVariablesResolver: f, forceColorScheme: m, stylesTransform: g } = e;
        const { colorScheme: b, setColorScheme: y, clearColorScheme: v } = function (e) {
            let { manager: t, defaultColorScheme: n, getRootElement: o, forceColorScheme: i } = e;
            const s = (0,
                r.useRef)()
                , [a, l] = (0,
                    r.useState)((() => t.get(n)))
                , c = i || a
                , d = (0,
                    r.useCallback)((e => {
                        i || (YD(e, o),
                            l(e),
                            t.set(e))
                    }
                    ), [t.set, c, i])
                , u = (0,
                    r.useCallback)((() => {
                        l(n),
                            YD(n, o),
                            t.clear()
                    }
                    ), [t.clear, n]);
            return (0,
                r.useEffect)((() => (t.subscribe(d),
                    t.unsubscribe)), [t.subscribe, t.unsubscribe]),
                xP((() => {
                    YD(t.get(n), o)
                }
                ), []),
                (0,
                    r.useEffect)((() => {
                        if (i)
                            return YD(i, o),
                                () => { }
                                ;
                        void 0 === i && YD(a, o),
                            s.current = window.matchMedia("(prefers-color-scheme: dark)");
                        const e = e => {
                            "auto" === a && YD(e.matches ? "dark" : "light", o)
                        }
                            ;
                        return s.current?.addEventListener("change", e),
                            () => s.current?.removeEventListener("change", e)
                    }
                    ), [a, i]),
            {
                colorScheme: c,
                setColorScheme: d,
                clearColorScheme: u
            }
        }({
            defaultColorScheme: h,
            forceColorScheme: m,
            manager: u,
            getRootElement: p
        });
        return function (e) {
            let { respectReducedMotion: t, getRootElement: n } = e;
            xP((() => {
                t && n()?.setAttribute("data-respect-reduced-motion", "true")
            }
            ), [t])
        }({
            respectReducedMotion: t?.respectReducedMotion || !1,
            getRootElement: p
        }),
            (0,
                Lx.jsx)(TA.Provider, {
                    value: {
                        colorScheme: b,
                        setColorScheme: y,
                        clearColorScheme: v,
                        getRootElement: p,
                        classNamesPrefix: d,
                        getStyleNonce: o,
                        cssVariablesResolver: f,
                        cssVariablesSelector: c,
                        withStaticClasses: i,
                        stylesTransform: g
                    },
                    children: (0,
                        Lx.jsxs)(mA, {
                            theme: t,
                            children: [l && (0,
                                Lx.jsx)(QD, {
                                    cssVariablesSelector: c,
                                    deduplicateCssVariables: a
                                }), s && (0,
                                    Lx.jsx)(WD, {}), n]
                        })
                })
    }
    function tI() {
        let { onBlur: e, onFocus: t } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const n = (0,
            r.useRef)()
            , [o, i] = (0,
                r.useState)(!1)
            , s = (0,
                r.useRef)(!1)
            , a = e => {
                i(e),
                    s.current = e
            }
            , l = e => {
                s.current || (a(!0),
                    t?.(e))
            }
            , c = t => {
                s.current && !function (e) {
                    return e.currentTarget instanceof HTMLElement && e.relatedTarget instanceof HTMLElement && e.currentTarget.contains(e.relatedTarget)
                }(t) && (a(!1),
                    e?.(t))
            }
            ;
        return (0,
            r.useEffect)((() => {
                if (n.current)
                    return n.current.addEventListener("focusin", l),
                        n.current.addEventListener("focusout", c),
                        () => {
                            n.current?.removeEventListener("focusin", l),
                                n.current?.removeEventListener("focusout", c)
                        }
            }
            ), [l, c]),
        {
            ref: n,
            focused: o
        }
    }
    QD.displayName = "@mantine/CssVariables",
        function () {
            const e = console.error;
            console.error = function () {
                for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
                    n[r] = arguments[r];
                n.length > 1 && "string" === typeof n[0] && n[0].toLowerCase().includes("extra attributes from the server") && "string" === typeof n[1] && n[1].toLowerCase().includes("data-mantine-color-scheme") || e(...n)
            }
        }(),
        eI.displayName = "@mantine/core/MantineProvider";
    const nI = function (e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return function e(r) {
            let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "--bn";
            for (const i in r) {
                const s = `${o}-${i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}`;
                "object" != typeof r[i] ? ("number" == typeof r[i] && (r[i] = `${r[i]}px`),
                    n ? t.style.removeProperty(s) : t.style.setProperty(s, r[i].toString())) : e(r[i], s)
            }
        }(e),
            []
    }
        , rI = (e, t) => nI(e, t)
        , oI = {
            colors: {
                editor: {
                    text: void 0,
                    background: void 0
                },
                menu: {
                    text: void 0,
                    background: void 0
                },
                tooltip: {
                    text: void 0,
                    background: void 0
                },
                hovered: {
                    text: void 0,
                    background: void 0
                },
                selected: {
                    text: void 0,
                    background: void 0
                },
                disabled: {
                    text: void 0,
                    background: void 0
                },
                shadow: void 0,
                border: void 0,
                sideMenu: void 0,
                highlights: {
                    gray: {
                        text: void 0,
                        background: void 0
                    },
                    brown: {
                        text: void 0,
                        background: void 0
                    },
                    red: {
                        text: void 0,
                        background: void 0
                    },
                    orange: {
                        text: void 0,
                        background: void 0
                    },
                    yellow: {
                        text: void 0,
                        background: void 0
                    },
                    green: {
                        text: void 0,
                        background: void 0
                    },
                    blue: {
                        text: void 0,
                        background: void 0
                    },
                    purple: {
                        text: void 0,
                        background: void 0
                    },
                    pink: {
                        text: void 0,
                        background: void 0
                    }
                }
            },
            borderRadius: void 0,
            fontFamily: void 0
        }
        , iI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, name: r, label: o, icon: i, value: s, autoFocus: a, placeholder: l, onKeyDown: c, onChange: d, onSubmit: u, ...h } = e;
                return Xw(h),
                    (0,
                        Lx.jsx)(HP, {
                            size: "xs",
                            className: n,
                            ref: t,
                            name: r,
                            label: o,
                            leftSection: i,
                            value: s,
                            autoFocus: a,
                            "data-autofocus": a ? "true" : void 0,
                            placeholder: l,
                            onKeyDown: c,
                            onChange: d,
                            onSubmit: u
                        })
            }
            ));
    var sI = {
        color: void 0,
        size: void 0,
        className: void 0,
        style: void 0,
        attr: void 0
    }
        , aI = r.createContext && r.createContext(sI)
        , lI = ["attr", "size", "title"];
    function cI(e, t) {
        if (null == e)
            return {};
        var n, r, o = function (e, t) {
            if (null == e)
                return {};
            var n = {};
            for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                    if (t.indexOf(r) >= 0)
                        continue;
                    n[r] = e[r]
                }
            return n
        }(e, t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            for (r = 0; r < i.length; r++)
                n = i[r],
                    !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n])
        }
        return o
    }
    function dI() {
        return dI = Object.assign ? Object.assign.bind() : function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
            ,
            dI.apply(this, arguments)
    }
    function uI(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
                n.push.apply(n, r)
        }
        return n
    }
    function hI(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? uI(Object(n), !0).forEach((function (t) {
                pI(e, t, n[t])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uI(Object(n)).forEach((function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            ))
        }
        return e
    }
    function pI(e, t, n) {
        return t = function (e) {
            var t = function (e, t) {
                if ("object" != typeof e || !e)
                    return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(e, t || "default");
                    if ("object" != typeof r)
                        return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === t ? String : Number)(e)
            }(e, "string");
            return "symbol" == typeof t ? t : t + ""
        }(t),
            t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n,
            e
    }
    function fI(e) {
        return e && e.map(((e, t) => r.createElement(e.tag, hI({
            key: t
        }, e.attr), fI(e.child))))
    }
    function mI(e) {
        return t => r.createElement(gI, dI({
            attr: hI({}, e.attr)
        }, t), fI(e.child))
    }
    function gI(e) {
        var t = t => {
            var n, { attr: o, size: i, title: s } = e, a = cI(e, lI), l = i || t.size || "1em";
            return t.className && (n = t.className),
                e.className && (n = (n ? n + " " : "") + e.className),
                r.createElement("svg", dI({
                    stroke: "currentColor",
                    fill: "currentColor",
                    strokeWidth: "0"
                }, t.attr, o, a, {
                    className: n,
                    style: hI(hI({
                        color: e.color || t.color
                    }, t.style), e.style),
                    height: l,
                    width: l,
                    xmlns: "http://www.w3.org/2000/svg"
                }), s && r.createElement("title", null, s), e.children)
        }
            ;
        return void 0 !== aI ? r.createElement(aI.Consumer, null, (e => t(e))) : t(sI)
    }
    function bI(e) {
        return mI({
            tag: "svg",
            attr: {
                viewBox: "0 0 20 20",
                fill: "currentColor",
                "aria-hidden": "true"
            },
            child: [{
                tag: "path",
                attr: {
                    fillRule: "evenodd",
                    d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                    clipRule: "evenodd"
                },
                child: []
            }]
        })(e)
    }
    function yI(e) {
        return mI({
            tag: "svg",
            attr: {
                viewBox: "0 0 20 20",
                fill: "currentColor",
                "aria-hidden": "true"
            },
            child: [{
                tag: "path",
                attr: {
                    fillRule: "evenodd",
                    d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                    clipRule: "evenodd"
                },
                child: []
            }]
        })(e)
    }
    const vI = (0,
        r.createContext)(void 0)
        , wI = (0,
            r.forwardRef)(((e, t) => {
                const { children: n, onOpenChange: o, position: i, sub: s, ...a } = e;
                Xw(a);
                const [l, c] = (0,
                    r.useState)(!1)
                    , d = (0,
                        r.useRef)(null)
                    , u = (0,
                        r.useRef)()
                    , h = (0,
                        r.useCallback)((() => {
                            u.current && clearTimeout(u.current),
                                u.current = setTimeout((() => {
                                    c(!1)
                                }
                                ), 250)
                        }
                        ), [])
                    , p = (0,
                        r.useCallback)((() => {
                            u.current && clearTimeout(u.current),
                                c(!0)
                        }
                        ), []);
                return (0,
                    Lx.jsx)(vI.Provider, {
                        value: {
                            onMenuMouseOver: p,
                            onMenuMouseLeave: h
                        },
                        children: (0,
                            Lx.jsx)(sR.Item, {
                                className: "bn-menu-item bn-mt-sub-menu-item",
                                ref: QP(t, d),
                                onMouseOver: p,
                                onMouseLeave: h,
                                children: (0,
                                    Lx.jsx)(sR, {
                                        portalProps: {
                                            target: d.current ? d.current.parentElement : void 0
                                        },
                                        middlewares: {
                                            flip: !0,
                                            shift: !0,
                                            inline: !1,
                                            size: !0
                                        },
                                        trigger: "hover",
                                        opened: l,
                                        onClose: () => null == o ? void 0 : o(!1),
                                        onOpen: () => null == o ? void 0 : o(!0),
                                        position: i,
                                        children: n
                                    })
                            })
                    })
            }
            ))
        , kI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, icon: o, checked: i, subTrigger: s, onClick: a, ...l } = e;
                return Xw(l, !1),
                    s ? (0,
                        Lx.jsxs)("div", {
                            ref: t,
                            ...l,
                            children: [r, (0,
                                Lx.jsx)(yI, {
                                    size: 15
                                })]
                        }) : (0,
                            Lx.jsx)(sR.Item, {
                                className: n,
                                ref: t,
                                leftSection: o,
                                rightSection: i ? (0,
                                    Lx.jsx)(aR, {
                                        size: 10
                                    }) : !1 === i ? (0,
                                        Lx.jsx)("div", {
                                            className: "bn-tick-space"
                                        }) : null,
                                onClick: a,
                                ...l,
                                children: r
                            })
            }
            ))
        , CI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: o, sub: i, ...s } = e;
                Xw(s);
                const a = (0,
                    r.useContext)(vI);
                return (0,
                    Lx.jsx)(sR.Dropdown, {
                        className: n,
                        ref: t,
                        onMouseOver: null == a ? void 0 : a.onMenuMouseOver,
                        onMouseLeave: null == a ? void 0 : a.onMenuMouseLeave,
                        children: o
                    })
            }
            ))
        , SI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, ...r } = e;
                return Xw(r),
                    (0,
                        Lx.jsx)(sR.Divider, {
                            className: n,
                            ref: t
                        })
            }
            ))
        , xI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o),
                    (0,
                        Lx.jsx)(sR.Label, {
                            className: n,
                            ref: t,
                            children: r
                        })
            }
            ))
        , EI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, tabs: r, defaultOpenTab: o, openTab: i, setOpenTab: s, loading: a, ...l } = e;
                return Xw(l),
                    (0,
                        Lx.jsx)(uR, {
                            className: n,
                            ref: t,
                            children: (0,
                                Lx.jsxs)(NR, {
                                    value: i,
                                    defaultValue: o,
                                    onChange: s,
                                    children: [a && (0,
                                        Lx.jsx)(UR, {
                                            visible: a
                                        }), (0,
                                            Lx.jsx)(NR.List, {
                                                children: r.map((e => (0,
                                                    Lx.jsx)(NR.Tab, {
                                                        "data-test": `${e.name.toLowerCase()}-tab`,
                                                        value: e.name,
                                                        children: e.name
                                                    }, e.name)))
                                            }), r.map((e => (0,
                                                Lx.jsx)(NR.Panel, {
                                                    value: e.name,
                                                    children: e.tabPanel
                                                }, e.name)))]
                                })
                        })
            }
            ))
        , MI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, onClick: o, label: i, ...s } = e;
                return Xw(s),
                    (0,
                        Lx.jsx)(QR, {
                            size: "xs",
                            "aria-label": i,
                            className: n,
                            ref: t,
                            onClick: o,
                            ...s,
                            children: r
                        })
            }
            ))
        , TI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, accept: r, value: o, placeholder: i, onChange: s, ...a } = e;
                return Xw(a),
                    (0,
                        Lx.jsx)(lD, {
                            size: "xs",
                            className: n,
                            ref: t,
                            accept: r,
                            value: o,
                            placeholder: i,
                            onChange: s,
                            ...a
                        })
            }
            ))
        , NI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o),
                    (0,
                        Lx.jsx)("div", {
                            className: n,
                            ref: t,
                            children: r
                        })
            }
            ))
        , _I = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, value: r, placeholder: o, onKeyDown: i, onChange: s, ...a } = e;
                return Xw(a),
                    (0,
                        Lx.jsx)(HP, {
                            size: "xs",
                            "data-test": "embed-input",
                            className: n,
                            ref: t,
                            value: r,
                            placeholder: o,
                            onKeyDown: i,
                            onChange: s
                        })
            }
            ))
        , OI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, variant: o, ...i } = e;
                return Xw(i),
                    (0,
                        Lx.jsx)(LL, {
                            className: n,
                            ref: t,
                            children: r
                        })
            }
            ))
        , AI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o, !1),
                    (0,
                        Lx.jsx)(uR, {
                            align: "center",
                            gap: 0,
                            className: n,
                            ref: t,
                            ...o,
                            children: r
                        })
            }
            ))
        , PI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, icon: o, onClick: i, onDragEnd: s, onDragStart: a, draggable: l, label: c, ...d } = e;
                return Xw(d, !1),
                    o ? (0,
                        Lx.jsx)(mD, {
                            size: 24,
                            className: n,
                            ref: t,
                            onClick: i,
                            onDragEnd: s,
                            onDragStart: a,
                            draggable: l,
                            "aria-label": c,
                            ...d,
                            children: o
                        }) : (0,
                            Lx.jsx)(QR, {
                                className: n,
                                ref: t,
                                onClick: i,
                                onDragEnd: s,
                                onDragStart: a,
                                draggable: l,
                                "aria-label": c,
                                ...d,
                                children: r
                            })
            }
            ))
        , LI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, id: o, columns: i, ...s } = e;
                return Xw(s),
                    (0,
                        Lx.jsx)("div", {
                            className: n,
                            style: {
                                gridTemplateColumns: `repeat(${i}, 1fr)`
                            },
                            ref: t,
                            id: o,
                            role: "grid",
                            children: r
                        })
            }
            ))
        , RI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, columns: o, ...i } = e;
                return Xw(i),
                    (0,
                        Lx.jsx)(uR, {
                            className: n,
                            style: {
                                gridColumn: `1 / ${o + 1}`
                            },
                            ref: t,
                            children: (0,
                                Lx.jsx)(uR, {
                                    className: "bn-mt-suggestion-menu-item-title",
                                    children: r
                                })
                        })
            }
            ))
        , DI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, isSelected: o, onClick: i, item: s, id: a, ...l } = e;
                Xw(l);
                const c = (0,
                    r.useRef)(null);
                return (0,
                    r.useEffect)((() => {
                        if (!c.current || !o)
                            return;
                        const e = FO(c.current, document.querySelector(".bn-grid-suggestion-menu"));
                        "top" === e ? c.current.scrollIntoView(!0) : "bottom" === e && c.current.scrollIntoView(!1)
                    }
                    ), [o]),
                    (0,
                        Lx.jsx)("div", {
                            className: n,
                            ref: QP(t, c),
                            id: a,
                            role: "option",
                            onClick: i,
                            "aria-selected": o || void 0,
                            children: s.icon
                        })
            }
            ))
        , II = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, columns: o, ...i } = e;
                return Xw(i),
                    (0,
                        Lx.jsx)(IR, {
                            className: n,
                            style: {
                                gridColumn: `1 / ${o + 1}`
                            },
                            type: "dots",
                            ref: t
                        })
            }
            ))
        , jI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, id: o, ...i } = e;
                return Xw(i),
                    (0,
                        Lx.jsx)(vD, {
                            gap: 0,
                            className: n,
                            ref: t,
                            id: o,
                            role: "listbox",
                            children: r
                        })
            }
            ))
        , HI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o),
                    (0,
                        Lx.jsx)(uR, {
                            className: n,
                            ref: t,
                            children: (0,
                                Lx.jsx)(uR, {
                                    className: "bn-mt-suggestion-menu-item-title",
                                    children: r
                                })
                        })
            }
            ))
        , zI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, isSelected: o, onClick: i, item: s, id: a, ...l } = e;
                Xw(l);
                const c = (0,
                    r.useRef)(null);
                return (0,
                    r.useEffect)((() => {
                        if (!c.current || !o)
                            return;
                        const e = FO(c.current, document.querySelector(".bn-suggestion-menu"));
                        "top" === e ? c.current.scrollIntoView(!0) : "bottom" === e && c.current.scrollIntoView(!1)
                    }
                    ), [o]),
                    (0,
                        Lx.jsxs)(uR, {
                            gap: 0,
                            className: n,
                            ref: QP(t, c),
                            id: a,
                            role: "option",
                            onClick: i,
                            "aria-selected": o || void 0,
                            children: [s.icon && (0,
                                Lx.jsx)(uR, {
                                    className: "bn-mt-suggestion-menu-item-section",
                                    "data-position": "left",
                                    children: s.icon
                                }), (0,
                                    Lx.jsxs)(vD, {
                                        gap: 0,
                                        className: "bn-mt-suggestion-menu-item-body",
                                        children: [(0,
                                            Lx.jsx)(xD, {
                                                className: "bn-mt-suggestion-menu-item-title",
                                                children: s.title
                                            }), (0,
                                                Lx.jsx)(xD, {
                                                    className: "bn-mt-suggestion-menu-item-subtitle",
                                                    children: s.subtext
                                                })]
                                    }), s.badge && (0,
                                        Lx.jsx)(uR, {
                                            "data-position": "right",
                                            className: "bn-mt-suggestion-menu-item-section",
                                            children: (0,
                                                Lx.jsx)(ND, {
                                                    size: "xs",
                                                    children: s.badge
                                                })
                                        })]
                        })
            }
            ))
        , $I = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o),
                    (0,
                        Lx.jsx)(uR, {
                            className: n,
                            ref: t,
                            children: r
                        })
            }
            ))
        , BI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, ...o } = e;
                return Xw(o),
                    (0,
                        Lx.jsx)(IR, {
                            className: n,
                            type: "dots",
                            ref: t
                        })
            }
            ))
        , VI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, draggable: o, onDragStart: i, onDragEnd: s, style: a, label: l, ...c } = e;
                return Xw(c, !1),
                    (0,
                        Lx.jsx)(QR, {
                            className: n,
                            ref: t,
                            "aria-label": l,
                            draggable: o,
                            onDragStart: i,
                            onDragEnd: s,
                            style: a,
                            ...c,
                            children: r
                        })
            }
            ))
        , FI = (0,
            r.forwardRef)(((e, t) => {
                const { children: n, className: r, onMouseDown: o, onClick: i, ...s } = e;
                return Xw(s, !1),
                    (0,
                        Lx.jsx)(QR, {
                            className: r,
                            ref: t,
                            onMouseDown: o,
                            onClick: i,
                            ...s,
                            children: n
                        })
            }
            ))
        , UI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, onMouseEnter: o, onMouseLeave: i, ...s } = e;
                Xw(s);
                const { ref: a, focused: l } = tI()
                    , c = QP(t, a, fL(l));
                return (0,
                    Lx.jsx)(uR, {
                        className: n,
                        ref: c,
                        role: "toolbar",
                        onMouseEnter: o,
                        onMouseLeave: i,
                        children: r
                    })
            }
            ))
        , WI = e => (0,
            Lx.jsxs)(vD, {
                gap: 0,
                className: "bn-tooltip",
                children: [(0,
                    Lx.jsx)(xD, {
                        size: "sm",
                        children: e.mainTooltip
                    }), e.secondaryTooltip && (0,
                        Lx.jsx)(xD, {
                            size: "xs",
                            children: e.secondaryTooltip
                        })]
            })
        , qI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, children: r, mainTooltip: o, secondaryTooltip: i, icon: s, isSelected: a, isDisabled: l, onClick: c, label: d, ...u } = e;
                return Xw(u, !1),
                    (0,
                        Lx.jsx)(VD, {
                            withinPortal: !1,
                            label: (0,
                                Lx.jsx)(WI, {
                                    mainTooltip: o,
                                    secondaryTooltip: i
                                }),
                            children: r ? (0,
                                Lx.jsx)(QR, {
                                    "aria-label": d,
                                    className: n,
                                    onMouseDown: e => {
                                        xk() && e.currentTarget.focus()
                                    }
                                    ,
                                    onClick: c,
                                    "aria-pressed": a,
                                    "data-selected": a || void 0,
                                    "data-test": o.slice(0, 1).toLowerCase() + o.replace(/\s+/g, "").slice(1),
                                    size: "xs",
                                    disabled: l || !1,
                                    ref: t,
                                    ...u,
                                    children: r
                                }) : (0,
                                    Lx.jsx)(mD, {
                                        className: n,
                                        "aria-label": d,
                                        onMouseDown: e => {
                                            xk() && e.currentTarget.focus()
                                        }
                                        ,
                                        onClick: c,
                                        "aria-pressed": a,
                                        "data-selected": a || void 0,
                                        "data-test": o.slice(0, 1).toLowerCase() + o.replace(/\s+/g, "").slice(1),
                                        size: 30,
                                        disabled: l || !1,
                                        ref: t,
                                        ...u,
                                        children: s
                                    })
                        })
            }
            ))
        , GI = (0,
            r.forwardRef)(((e, t) => {
                const { className: n, items: r, isDisabled: o, ...i } = e;
                Xw(i);
                const s = r.filter((e => e.isSelected))[0];
                return s ? (0,
                    Lx.jsxs)(sR, {
                        withinPortal: !1,
                        transitionProps: {
                            exitDuration: 0
                        },
                        disabled: o,
                        middlewares: {
                            flip: !0,
                            shift: !0,
                            inline: !1,
                            size: !0
                        },
                        children: [(0,
                            Lx.jsx)(sR.Target, {
                                children: (0,
                                    Lx.jsx)(QR, {
                                        onMouseDown: e => {
                                            xk() && e.currentTarget.focus()
                                        }
                                        ,
                                        leftSection: s.icon,
                                        rightSection: (0,
                                            Lx.jsx)(bI, {}),
                                        size: "xs",
                                        variant: "subtle",
                                        disabled: o,
                                        children: s.text
                                    })
                            }), (0,
                                Lx.jsx)(sR.Dropdown, {
                                    className: n,
                                    ref: t,
                                    children: r.map((e => (0,
                                        Lx.jsx)(sR.Item, {
                                            onClick: e.onClick,
                                            leftSection: e.icon,
                                            rightSection: e.isSelected ? (0,
                                                Lx.jsx)(aR, {
                                                    size: 10,
                                                    className: "bn-tick-icon"
                                                }) : (0,
                                                    Lx.jsx)("div", {
                                                        className: "bn-tick-space"
                                                    }),
                                            disabled: e.isDisabled,
                                            children: e.text
                                        }, e.text)))
                                })]
                    }) : null
            }
            ))
        , KI = {
            FormattingToolbar: {
                Root: UI,
                Button: qI,
                Select: GI
            },
            FilePanel: {
                Root: EI,
                Button: MI,
                FileInput: TI,
                TabPanel: NI,
                TextInput: _I
            },
            GridSuggestionMenu: {
                Root: LI,
                Item: DI,
                EmptyItem: RI,
                Loader: II
            },
            LinkToolbar: {
                Root: UI,
                Button: qI
            },
            SideMenu: {
                Root: AI,
                Button: PI
            },
            SuggestionMenu: {
                Root: jI,
                Item: zI,
                EmptyItem: HI,
                Label: $I,
                Loader: BI
            },
            TableHandle: {
                Root: VI,
                ExtendButton: FI
            },
            Generic: {
                Form: {
                    Root: e => (0,
                        Lx.jsx)("div", {
                            children: e.children
                        }),
                    TextInput: iI
                },
                Menu: {
                    Root: e => {
                        const { children: t, onOpenChange: n, position: r, sub: o, ...i } = e;
                        return Xw(i),
                            o ? (0,
                                Lx.jsx)(wI, {
                                    ...e
                                }) : (0,
                                    Lx.jsx)(sR, {
                                        withinPortal: !1,
                                        middlewares: {
                                            flip: !0,
                                            shift: !0,
                                            inline: !1,
                                            size: !0
                                        },
                                        onClose: () => null == n ? void 0 : n(!1),
                                        onOpen: () => null == n ? void 0 : n(!0),
                                        position: r,
                                        children: t
                                    })
                    }
                    ,
                    Trigger: e => {
                        const { children: t, sub: n, ...r } = e;
                        return Xw(r),
                            (0,
                                Lx.jsx)(sR.Target, {
                                    children: t
                                })
                    }
                    ,
                    Dropdown: CI,
                    Divider: SI,
                    Label: xI,
                    Item: kI
                },
                Popover: {
                    Root: e => {
                        const { children: t, opened: n, position: r, ...o } = e;
                        return Xw(o),
                            (0,
                                Lx.jsx)($L, {
                                    withinPortal: !1,
                                    zIndex: 1e4,
                                    opened: n,
                                    position: r,
                                    children: t
                                })
                    }
                    ,
                    Trigger: e => {
                        const { children: t, ...n } = e;
                        return Xw(n),
                            (0,
                                Lx.jsx)(DL, {
                                    children: t
                                })
                    }
                    ,
                    Content: OI
                }
            }
        }
        , JI = {
            activeClassName: ""
        }
        , ZI = e => {
            const { className: t, theme: n, ...o } = e
                , i = uN()
                , s = vO()
                , a = (null == i ? void 0 : i.colorSchemePreference) || s
                , l = (0,
                    r.useCallback)((e => {
                        if (e && ((e => {
                            nI(oI, e, !0)
                        }
                        )(e),
                            "object" == typeof n))
                            return "light" in n && "dark" in n ? void rI(n["dark" === a ? "dark" : "light"], e) : void rI(n, e)
                    }
                    ), [a, n]);
            return (0,
                Lx.jsx)(mN.Provider, {
                    value: KI,
                    children: (0,
                        Lx.jsx)(eI, {
                            theme: JI,
                            cssVariablesSelector: ".bn-mantine",
                            getRootElement: () => { }
                            ,
                            children: (0,
                                Lx.jsx)(xO, {
                                    className: Sk("bn-mantine", t || ""),
                                    theme: "object" == typeof n ? void 0 : n,
                                    ...o,
                                    ref: l
                                })
                        })
                })
        }

    return {
        createRoot: i.createRoot, 
        react: r,
        blockSpec: _O,
        textOption: Tk, 
        slashMenu: Ax, 
        jsx: Lx.jsx, 
        blcokSpecCreate: bx.create, 
        defaultSpec: JC, 
        schemaConfig: VO, 
        blocknoteMain: ZI, 
        slashMenuChild: eO, 
        slashMenuSetting: Px, 
        defaultMenuItem: Y_
    }
}